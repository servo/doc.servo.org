<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A compiler uses a builder configuration and builds up the NFA formulation of an Aho-Corasick automaton. This roughly corresponds to the standard formulation described in textbooks, with some tweaks to support leftmost searching."><title>Compiler in aho_corasick::nfa::noncontiguous - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="aho_corasick" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../aho_corasick/index.html">aho_corasick</a><span class="version">1.1.3</span></h2></div><h2 class="location"><a href="#">Compiler</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.builder">builder</a></li><li><a href="#structfield.byteset">byteset</a></li><li><a href="#structfield.nfa">nfa</a></li><li><a href="#structfield.prefilter">prefilter</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add_dead_state_loop">add_dead_state_loop</a></li><li><a href="#method.add_unanchored_start_state_loop">add_unanchored_start_state_loop</a></li><li><a href="#method.build_trie">build_trie</a></li><li><a href="#method.close_start_state_loop_for_leftmost">close_start_state_loop_for_leftmost</a></li><li><a href="#method.compile">compile</a></li><li><a href="#method.densify">densify</a></li><li><a href="#method.fill_failure_transitions">fill_failure_transitions</a></li><li><a href="#method.init_unanchored_start_state">init_unanchored_start_state</a></li><li><a href="#method.new">new</a></li><li><a href="#method.queued_set">queued_set</a></li><li><a href="#method.set_anchored_start_state">set_anchored_start_state</a></li><li><a href="#method.shuffle">shuffle</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-Compiler%3C'a%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Compiler%3C'a%3E">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Compiler%3C'a%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Compiler%3C'a%3E">Send</a></li><li><a href="#impl-Sync-for-Compiler%3C'a%3E">Sync</a></li><li><a href="#impl-Unpin-for-Compiler%3C'a%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Compiler%3C'a%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In aho_corasick::nfa::noncontiguous</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">aho_corasick</a>::<wbr><a href="../index.html">nfa</a>::<wbr><a href="index.html">noncontiguous</a>::<wbr><a class="struct" href="#">Compiler</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#932-937">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>struct Compiler&lt;'a&gt; {
    builder: &amp;'a <a class="struct" href="struct.Builder.html" title="struct aho_corasick::nfa::noncontiguous::Builder">Builder</a>,
    prefilter: <a class="struct" href="../../util/prefilter/struct.Builder.html" title="struct aho_corasick::util::prefilter::Builder">Builder</a>,
    nfa: <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a>,
    byteset: <a class="struct" href="../../util/alphabet/struct.ByteClassSet.html" title="struct aho_corasick::util::alphabet::ByteClassSet">ByteClassSet</a>,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A compiler uses a builder configuration and builds up the NFA formulation
of an Aho-Corasick automaton. This roughly corresponds to the standard
formulation described in textbooks, with some tweaks to support leftmost
searching.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.builder" class="structfield section-header"><a href="#structfield.builder" class="anchor field">§</a><code>builder: &amp;'a <a class="struct" href="struct.Builder.html" title="struct aho_corasick::nfa::noncontiguous::Builder">Builder</a></code></span><span id="structfield.prefilter" class="structfield section-header"><a href="#structfield.prefilter" class="anchor field">§</a><code>prefilter: <a class="struct" href="../../util/prefilter/struct.Builder.html" title="struct aho_corasick::util::prefilter::Builder">Builder</a></code></span><span id="structfield.nfa" class="structfield section-header"><a href="#structfield.nfa" class="anchor field">§</a><code>nfa: <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></code></span><span id="structfield.byteset" class="structfield section-header"><a href="#structfield.byteset" class="anchor field">§</a><code>byteset: <a class="struct" href="../../util/alphabet/struct.ByteClassSet.html" title="struct aho_corasick::util::alphabet::ByteClassSet">ByteClassSet</a></code></span><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Compiler%3C'a%3E" class="impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#939-1647">source</a><a href="#impl-Compiler%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.Compiler.html" title="struct aho_corasick::nfa::noncontiguous::Compiler">Compiler</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><section id="method.new" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#940-961">source</a><h4 class="code-header">fn <a href="#method.new" class="fn">new</a>(builder: &amp;'a <a class="struct" href="struct.Builder.html" title="struct aho_corasick::nfa::noncontiguous::Builder">Builder</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Compiler.html" title="struct aho_corasick::nfa::noncontiguous::Compiler">Compiler</a>&lt;'a&gt;, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.compile" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#963-1051">source</a><h4 class="code-header">fn <a href="#method.compile" class="fn">compile</a>&lt;I, P&gt;(self, patterns: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = P&gt;,
    P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>]&gt;,</div></h4></section><details class="toggle method-toggle" open><summary><section id="method.build_trie" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1057-1150">source</a><h4 class="code-header">fn <a href="#method.build_trie" class="fn">build_trie</a>&lt;I, P&gt;(&amp;mut self, patterns: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = P&gt;,
    P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>]&gt;,</div></h4></section></summary><div class="docblock"><p>This sets up the initial prefix trie that makes up the Aho-Corasick
automaton. Effectively, it creates the basic structure of the
automaton, where every pattern given has a path from the start state to
the end of the pattern.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fill_failure_transitions" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1275-1374">source</a><h4 class="code-header">fn <a href="#method.fill_failure_transitions" class="fn">fill_failure_transitions</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>This routine creates failure transitions according to the standard
textbook formulation of the Aho-Corasick algorithm, with a couple small
tweaks to support “leftmost” semantics.</p>
<p>Building failure transitions is the most interesting part of building
the Aho-Corasick automaton, because they are what allow searches to
be performed in linear time. Specifically, a failure transition is
a single transition associated with each state that points back to
the longest proper suffix of the pattern being searched. The failure
transition is followed whenever there exists no transition on the
current state for the current input byte. If there is no other proper
suffix, then the failure transition points back to the starting state.</p>
<p>For example, let’s say we built an Aho-Corasick automaton with the
following patterns: ‘abcd’ and ‘cef’. The trie looks like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>         a - S1 - b - S2 - c - S3 - d - S4*
        /
    S0 - c - S5 - e - S6 - f - S7<span class="kw-2">*</span></code></pre></div>
<p>At this point, it should be fairly straight-forward to see how this
trie can be used in a simplistic way. At any given position in the
text we’re searching (called the “subject” string), all we need to do
is follow the transitions in the trie by consuming one transition for
each byte in the subject string. If we reach a match state, then we can
report that location as a match.</p>
<p>The trick comes when searching a subject string like ‘abcef’. We’ll
initially follow the transition from S0 to S1 and wind up in S3 after
observng the ‘c’ byte. At this point, the next byte is ‘e’ but state
S3 has no transition for ‘e’, so the search fails. We then would need
to restart the search at the next position in ‘abcef’, which
corresponds to ‘b’. The match would fail, but the next search starting
at ‘c’ would finally succeed. The problem with this approach is that
we wind up searching the subject string potentially many times. In
effect, this makes the algorithm have worst case <code>O(n * m)</code> complexity,
where <code>n ~ len(subject)</code> and <code>m ~ len(all patterns)</code>. We would instead
like to achieve a <code>O(n + m)</code> worst case complexity.</p>
<p>This is where failure transitions come in. Instead of dying at S3 in
the first search, the automaton can instruct the search to move to
another part of the automaton that corresponds to a suffix of what
we’ve seen so far. Recall that we’ve seen ‘abc’ in the subject string,
and the automaton does indeed have a non-empty suffix, ‘c’, that could
potentially lead to another match. Thus, the actual Aho-Corasick
automaton for our patterns in this case looks like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>         a - S1 - b - S2 - c - S3 - d - S4*
        /                      /
       /       ----------------
      /       /
    S0 - c - S5 - e - S6 - f - S7<span class="kw-2">*</span></code></pre></div>
<p>That is, we have a failure transition from S3 to S5, which is followed
exactly in cases when we are in state S3 but see any byte other than
‘d’ (that is, we’ve “failed” to find a match in this portion of our
trie). We know we can transition back to S5 because we’ve already seen
a ‘c’ byte, so we don’t need to re-scan it. We can then pick back up
with the search starting at S5 and complete our match.</p>
<p>Adding failure transitions to a trie is fairly simple, but subtle. The
key issue is that you might have multiple failure transition that you
need to follow. For example, look at the trie for the patterns
‘abcd’, ‘b’, ‘bcd’ and ‘cd’:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>         - a - S1 - b - S2* - c - S3 - d - S4*
        /               /         /
       /         -------   -------
      /         /         /
    S0 --- b - S5* - c - S6 - d - S7*
      \                  /
       \         --------
        \       /
         - c - S8 - d - S9<span class="kw-2">*</span></code></pre></div>
<p>The failure transitions for this trie are defined from S2 to S5,
S3 to S6 and S6 to S8. Moreover, state S2 needs to track that it
corresponds to a match, since its failure transition to S5 is itself
a match state.</p>
<p>Perhaps simplest way to think about adding these failure transitions
is recursively. That is, if you know the failure transitions for every
possible previous state that could be visited (e.g., when computing the
failure transition for S3, you already know the failure transitions
for S0, S1 and S2), then you can simply follow the failure transition
of the previous state and check whether the incoming transition is
defined after following the failure transition.</p>
<p>For example, when determining the failure state for S3, by our
assumptions, we already know that there is a failure transition from
S2 (the previous state) to S5. So we follow that transition and check
whether the transition connecting S2 to S3 is defined. Indeed, it is,
as there is a transition from S5 to S6 for the byte ‘c’. If no such
transition existed, we could keep following the failure transitions
until we reach the start state, which is the failure transition for
every state that has no corresponding proper suffix.</p>
<p>We don’t actually use recursion to implement this, but instead, use a
breadth first search of the automaton. Our base case is the start
state, whose failure transition is just a transition to itself.</p>
<p>When building a leftmost automaton, we proceed as above, but only
include a subset of failure transitions. Namely, we omit any failure
transitions that appear after a match state in the trie. This is
because failure transitions always point back to a proper suffix of
what has been seen so far. Thus, following a failure transition after
a match implies looking for a match that starts after the one that has
already been seen, which is of course therefore not the leftmost match.</p>
<p>N.B. I came up with this algorithm on my own, and after scouring all of
the other AC implementations I know of (Perl, Snort, many on GitHub).
I couldn’t find any that implement leftmost semantics like this.
Perl of course needs leftmost-first semantics, but they implement it
with a seeming hack at <em>search</em> time instead of encoding it into the
automaton. There are also a couple Java libraries that support leftmost
longest semantics, but they do it by building a queue of matches at
search time, which is even worse than what Perl is doing. —AG</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shuffle" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1399-1481">source</a><h4 class="code-header">fn <a href="#method.shuffle" class="fn">shuffle</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Shuffle the states so that they appear in this sequence:</p>
<p>DEAD, FAIL, MATCH…, START, START, NON-MATCH…</p>
<p>The idea here is that if we know how special states are laid out in our
transition table, then we can determine what “kind” of state we’re in
just by comparing our current state ID with a particular value. In this
way, we avoid doing extra memory lookups.</p>
<p>Before shuffling begins, our states look something like this:</p>
<p>DEAD, FAIL, START, START, (MATCH | NON-MATCH)…</p>
<p>So all we need to do is move all of the MATCH states so that they
all appear before any NON-MATCH state, like so:</p>
<p>DEAD, FAIL, START, START, MATCH… NON-MATCH…</p>
<p>Then it’s just a simple matter of swapping the two START states with
the last two MATCH states.</p>
<p>(This is the same technique used for fully compiled DFAs in
regex-automata.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.densify" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1500-1526">source</a><h4 class="code-header">fn <a href="#method.densify" class="fn">densify</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Attempts to convert the transition representation of a subset of states
in this NFA from sparse to dense. This can greatly improve search
performance since states with a higher number of transitions tend to
correlate with very active states.</p>
<p>We generally only densify states that are close to the start state.
These tend to be the most active states and thus benefit from a dense
representation more than other states.</p>
<p>This tends to best balance between memory usage and performance. In
particular, the <em>vast majority</em> of all states in a typical Aho-Corasick
automaton have only 1 transition and are usually farther from the start
state and thus don’t get densified.</p>
<p>Note that this doesn’t remove the sparse representation of transitions
for states that are densified. It could be done, but actually removing
entries from <code>NFA::sparse</code> is likely more expensive than it’s worth.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.queued_set" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1534-1540">source</a><h4 class="code-header">fn <a href="#method.queued_set" class="fn">queued_set</a>(&amp;self) -&gt; <a class="struct" href="struct.QueuedSet.html" title="struct aho_corasick::nfa::noncontiguous::QueuedSet">QueuedSet</a></h4></section></summary><div class="docblock"><p>Returns a set that tracked queued states.</p>
<p>This is only necessary when ASCII case insensitivity is enabled, since
it is the only way to visit the same state twice. Otherwise, this
returns an inert set that nevers adds anything and always reports
<code>false</code> for every member test.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.init_unanchored_start_state" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1549-1555">source</a><h4 class="code-header">fn <a href="#method.init_unanchored_start_state" class="fn">init_unanchored_start_state</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Initializes the unanchored start state by making it dense. This is
achieved by explicitly setting every transition to the FAIL state.
This isn’t necessary for correctness, since any missing transition is
automatically assumed to be mapped to the FAIL state. We do this to
make the unanchored starting state dense, and thus in turn make
transition lookups on it faster. (Which is worth doing because it’s
the most active state.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_anchored_start_state" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1561-1586">source</a><h4 class="code-header">fn <a href="#method.set_anchored_start_state" class="fn">set_anchored_start_state</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Setup the anchored start state by copying all of the transitions and
matches from the unanchored starting state with one change: the failure
transition is changed to the DEAD state, so that for any undefined
transitions, the search will stop.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_unanchored_start_state_loop" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1597-1606">source</a><h4 class="code-header">fn <a href="#method.add_unanchored_start_state_loop" class="fn">add_unanchored_start_state_loop</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Set the failure transitions on the start state to loop back to the
start state. This effectively permits the Aho-Corasick automaton to
match at any position. This is also required for finding the next
state to terminate, namely, finding the next state should never return
a fail_id.</p>
<p>This must be done after building the initial trie, since trie
construction depends on transitions to <code>fail_id</code> to determine whether a
state already exists or not.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.close_start_state_loop_for_leftmost" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1620-1638">source</a><h4 class="code-header">fn <a href="#method.close_start_state_loop_for_leftmost" class="fn">close_start_state_loop_for_leftmost</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Remove the start state loop by rewriting any transitions on the start
state back to the start state with transitions to the dead state.</p>
<p>The loop is only closed when two conditions are met: the start state
is a match state and the match kind is leftmost-first or
leftmost-longest.</p>
<p>The reason for this is that under leftmost semantics, a start state
that is also a match implies that we should never restart the search
process. We allow normal transitions out of the start state, but if
none exist, we transition to the dead state, which signals that
searching should stop.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_dead_state_loop" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1643-1646">source</a><h4 class="code-header">fn <a href="#method.add_dead_state_loop" class="fn">add_dead_state_loop</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Sets all transitions on the dead state to point back to the dead state.
Normally, missing transitions map back to the failure state, but the
point of the dead state is to act as a sink that can never be escaped.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Compiler%3C'a%3E" class="impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#931">source</a><a href="#impl-Debug-for-Compiler%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Compiler.html" title="struct aho_corasick::nfa::noncontiguous::Compiler">Compiler</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#931">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Compiler%3C'a%3E" class="impl"><a href="#impl-Freeze-for-Compiler%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Compiler.html" title="struct aho_corasick::nfa::noncontiguous::Compiler">Compiler</a>&lt;'a&gt;</h3></section><section id="impl-RefUnwindSafe-for-Compiler%3C'a%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Compiler%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Compiler.html" title="struct aho_corasick::nfa::noncontiguous::Compiler">Compiler</a>&lt;'a&gt;</h3></section><section id="impl-Send-for-Compiler%3C'a%3E" class="impl"><a href="#impl-Send-for-Compiler%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Compiler.html" title="struct aho_corasick::nfa::noncontiguous::Compiler">Compiler</a>&lt;'a&gt;</h3></section><section id="impl-Sync-for-Compiler%3C'a%3E" class="impl"><a href="#impl-Sync-for-Compiler%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Compiler.html" title="struct aho_corasick::nfa::noncontiguous::Compiler">Compiler</a>&lt;'a&gt;</h3></section><section id="impl-Unpin-for-Compiler%3C'a%3E" class="impl"><a href="#impl-Unpin-for-Compiler%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Compiler.html" title="struct aho_corasick::nfa::noncontiguous::Compiler">Compiler</a>&lt;'a&gt;</h3></section><section id="impl-UnwindSafe-for-Compiler%3C'a%3E" class="impl"><a href="#impl-UnwindSafe-for-Compiler%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Compiler.html" title="struct aho_corasick::nfa::noncontiguous::Compiler">Compiler</a>&lt;'a&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>