<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A noncontiguous NFA implementation of Aho-Corasick."><title>NFA in aho_corasick::nfa::noncontiguous - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="aho_corasick" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../aho_corasick/index.html">aho_corasick</a><span class="version">1.1.3</span></h2></div><h2 class="location"><a href="#">NFA</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.byte_classes">byte_classes</a></li><li><a href="#structfield.dense">dense</a></li><li><a href="#structfield.match_kind">match_kind</a></li><li><a href="#structfield.matches">matches</a></li><li><a href="#structfield.max_pattern_len">max_pattern_len</a></li><li><a href="#structfield.min_pattern_len">min_pattern_len</a></li><li><a href="#structfield.pattern_lens">pattern_lens</a></li><li><a href="#structfield.prefilter">prefilter</a></li><li><a href="#structfield.sparse">sparse</a></li><li><a href="#structfield.special">special</a></li><li><a href="#structfield.states">states</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.DEAD">DEAD</a></li><li><a href="#associatedconstant.FAIL">FAIL</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add_match">add_match</a></li><li><a href="#method.add_transition">add_transition</a></li><li><a href="#method.alloc_dense_state">alloc_dense_state</a></li><li><a href="#method.alloc_match">alloc_match</a></li><li><a href="#method.alloc_state">alloc_state</a></li><li><a href="#method.alloc_transition">alloc_transition</a></li><li><a href="#method.builder">builder</a></li><li><a href="#method.byte_classes">byte_classes</a></li><li><a href="#method.copy_matches">copy_matches</a></li><li><a href="#method.follow_transition">follow_transition</a></li><li><a href="#method.follow_transition_sparse">follow_transition_sparse</a></li><li><a href="#method.init_full_state">init_full_state</a></li><li><a href="#method.iter_matches">iter_matches</a></li><li><a href="#method.iter_trans">iter_trans</a></li><li><a href="#method.new">new</a></li><li><a href="#method.next_link">next_link</a></li><li><a href="#method.pattern_lens_raw">pattern_lens_raw</a></li><li><a href="#method.remap">remap</a></li><li><a href="#method.special">special</a></li><li><a href="#method.states">states</a></li><li><a href="#method.swap_states">swap_states</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Automaton-for-NFA">Automaton</a></li><li><a href="#impl-Clone-for-NFA">Clone</a></li><li><a href="#impl-Debug-for-NFA">Debug</a></li><li><a href="#impl-Remappable-for-NFA">Remappable</a></li><li><a href="#impl-Sealed-for-NFA">Sealed</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-NFA">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-NFA">RefUnwindSafe</a></li><li><a href="#impl-Send-for-NFA">Send</a></li><li><a href="#impl-Sync-for-NFA">Sync</a></li><li><a href="#impl-Unpin-for-NFA">Unpin</a></li><li><a href="#impl-UnwindSafe-for-NFA">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In aho_corasick::nfa::noncontiguous</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">aho_corasick</a>::<wbr><a href="../index.html">nfa</a>::<wbr><a href="index.html">noncontiguous</a>::<wbr><a class="struct" href="#">NFA</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#82-175">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct NFA {
    match_kind: <a class="enum" href="../../util/search/enum.MatchKind.html" title="enum aho_corasick::util::search::MatchKind">MatchKind</a>,
    states: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.State.html" title="struct aho_corasick::nfa::noncontiguous::State">State</a>&gt;,
    sparse: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.Transition.html" title="struct aho_corasick::nfa::noncontiguous::Transition">Transition</a>&gt;,
    dense: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>&gt;,
    matches: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.Match.html" title="struct aho_corasick::nfa::noncontiguous::Match">Match</a>&gt;,
    pattern_lens: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../util/primitives/struct.SmallIndex.html" title="struct aho_corasick::util::primitives::SmallIndex">SmallIndex</a>&gt;,
    prefilter: <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../automaton/struct.Prefilter.html" title="struct aho_corasick::automaton::Prefilter">Prefilter</a>&gt;,
    byte_classes: <a class="struct" href="../../util/alphabet/struct.ByteClasses.html" title="struct aho_corasick::util::alphabet::ByteClasses">ByteClasses</a>,
    min_pattern_len: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>,
    max_pattern_len: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>,
    special: <a class="struct" href="../../util/special/struct.Special.html" title="struct aho_corasick::util::special::Special">Special</a>,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A noncontiguous NFA implementation of Aho-Corasick.</p>
<p>When possible, prefer using <a href="../../ahocorasick/struct.AhoCorasick.html" title="struct aho_corasick::ahocorasick::AhoCorasick"><code>AhoCorasick</code></a> instead of
this type directly. Using an <code>NFA</code> directly is typically only necessary
when one needs access to the <a href="../../automaton/trait.Automaton.html" title="trait aho_corasick::automaton::Automaton"><code>Automaton</code></a> trait implementation.</p>
<p>This NFA represents the “core” implementation of Aho-Corasick in this
crate. Namely, constructing this NFA involving building a trie and then
filling in the failure transitions between states, similar to what is
described in any standard textbook description of Aho-Corasick.</p>
<p>In order to minimize heap usage and to avoid additional construction costs,
this implementation represents the transitions of all states as distinct
sparse memory allocations. This is where it gets its name from. That is,
this NFA has no contiguous memory allocation for its transition table. Each
state gets its own allocation.</p>
<p>While the sparse representation keeps memory usage to somewhat reasonable
levels, it is still quite large and also results in somewhat mediocre
search performance. For this reason, it is almost always a good idea to
use a <a href="../contiguous/struct.NFA.html" title="struct aho_corasick::nfa::contiguous::NFA"><code>contiguous::NFA</code></a> instead. It is
marginally slower to build, but has higher throughput and can sometimes use
an order of magnitude less memory. The main reason to use a noncontiguous
NFA is when you need the fastest possible construction time, or when a
contiguous NFA does not have the desired capacity. (The total number of NFA
states it can have is fewer than a noncontiguous NFA.)</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>This example shows how to build an <code>NFA</code> directly and use it to execute
<a href="../../automaton/trait.Automaton.html#method.try_find" title="method aho_corasick::automaton::Automaton::try_find"><code>Automaton::try_find</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>aho_corasick::{
    automaton::Automaton,
    nfa::noncontiguous::NFA,
    Input, Match,
};

<span class="kw">let </span>patterns = <span class="kw-2">&amp;</span>[<span class="string">"b"</span>, <span class="string">"abc"</span>, <span class="string">"abcd"</span>];
<span class="kw">let </span>haystack = <span class="string">"abcd"</span>;

<span class="kw">let </span>nfa = NFA::new(patterns).unwrap();
<span class="macro">assert_eq!</span>(
    <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">1</span>..<span class="number">2</span>)),
    nfa.try_find(<span class="kw-2">&amp;</span>Input::new(haystack))<span class="question-mark">?</span>,
);</code></pre></div>
<p>It is also possible to implement your own version of <code>try_find</code>. See the
<a href="../../automaton/trait.Automaton.html" title="trait aho_corasick::automaton::Automaton"><code>Automaton</code></a> documentation for an example.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.match_kind" class="structfield section-header"><a href="#structfield.match_kind" class="anchor field">§</a><code>match_kind: <a class="enum" href="../../util/search/enum.MatchKind.html" title="enum aho_corasick::util::search::MatchKind">MatchKind</a></code></span><div class="docblock"><p>The match semantics built into this NFA.</p>
</div><span id="structfield.states" class="structfield section-header"><a href="#structfield.states" class="anchor field">§</a><code>states: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.State.html" title="struct aho_corasick::nfa::noncontiguous::State">State</a>&gt;</code></span><div class="docblock"><p>A set of states. Each state defines its own transitions, a fail
transition and a set of indices corresponding to matches.</p>
<p>The first state is always the fail state, which is used only as a
sentinel. Namely, in the final NFA, no transition into the fail state
exists. (Well, they do, but they aren’t followed. Instead, the state’s
failure transition is followed.)</p>
<p>The second state (index 1) is always the dead state. Dead states are
in every automaton, but only used when leftmost-{first,longest} match
semantics are enabled. Specifically, they instruct search to stop
at specific points in order to report the correct match location. In
the standard Aho-Corasick construction, there are no transitions to
the dead state.</p>
<p>The third state (index 2) is generally intended to be the starting or
“root” state.</p>
</div><span id="structfield.sparse" class="structfield section-header"><a href="#structfield.sparse" class="anchor field">§</a><code>sparse: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.Transition.html" title="struct aho_corasick::nfa::noncontiguous::Transition">Transition</a>&gt;</code></span><div class="docblock"><p>Transitions stored in a sparse representation via a linked list.</p>
<p>Each transition contains three pieces of information: the byte it
is defined for, the state it transitions to and a link to the next
transition in the same state (or <code>StateID::ZERO</code> if it is the last
transition).</p>
<p>The first transition for each state is determined by <code>State::sparse</code>.</p>
<p>Note that this contains a complete set of all transitions in this NFA,
including states that have a dense representation for transitions.
(Adding dense transitions for a state doesn’t remove its sparse
transitions, since deleting transitions from this particular sparse
representation would be fairly expensive.)</p>
</div><span id="structfield.dense" class="structfield section-header"><a href="#structfield.dense" class="anchor field">§</a><code>dense: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>&gt;</code></span><div class="docblock"><p>Transitions stored in a dense representation.</p>
<p>A state has a row in this table if and only if <code>State::dense</code> is
not equal to <code>StateID::ZERO</code>. When not zero, there are precisely
<code>NFA::byte_classes::alphabet_len()</code> entries beginning at <code>State::dense</code>
in this table.</p>
<p>Generally a very small minority of states have a dense representation
since it uses so much memory.</p>
</div><span id="structfield.matches" class="structfield section-header"><a href="#structfield.matches" class="anchor field">§</a><code>matches: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="struct.Match.html" title="struct aho_corasick::nfa::noncontiguous::Match">Match</a>&gt;</code></span><div class="docblock"><p>Matches stored in linked list for each state.</p>
<p>Like sparse transitions, each match has a link to the next match in the
state.</p>
<p>The first match for each state is determined by <code>State::matches</code>.</p>
</div><span id="structfield.pattern_lens" class="structfield section-header"><a href="#structfield.pattern_lens" class="anchor field">§</a><code>pattern_lens: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../util/primitives/struct.SmallIndex.html" title="struct aho_corasick::util::primitives::SmallIndex">SmallIndex</a>&gt;</code></span><div class="docblock"><p>The length, in bytes, of each pattern in this NFA. This slice is
indexed by <code>PatternID</code>.</p>
<p>The number of entries in this vector corresponds to the total number of
patterns in this automaton.</p>
</div><span id="structfield.prefilter" class="structfield section-header"><a href="#structfield.prefilter" class="anchor field">§</a><code>prefilter: <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../automaton/struct.Prefilter.html" title="struct aho_corasick::automaton::Prefilter">Prefilter</a>&gt;</code></span><div class="docblock"><p>A prefilter for quickly skipping to candidate matches, if pertinent.</p>
</div><span id="structfield.byte_classes" class="structfield section-header"><a href="#structfield.byte_classes" class="anchor field">§</a><code>byte_classes: <a class="struct" href="../../util/alphabet/struct.ByteClasses.html" title="struct aho_corasick::util::alphabet::ByteClasses">ByteClasses</a></code></span><div class="docblock"><p>A set of equivalence classes in terms of bytes. We compute this while
building the NFA, but don’t use it in the NFA’s states. Instead, we
use this for building the DFA. We store it on the NFA since it’s easy
to compute while visiting the patterns.</p>
</div><span id="structfield.min_pattern_len" class="structfield section-header"><a href="#structfield.min_pattern_len" class="anchor field">§</a><code>min_pattern_len: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></code></span><div class="docblock"><p>The length, in bytes, of the shortest pattern in this automaton. This
information is useful for detecting whether an automaton matches the
empty string or not.</p>
</div><span id="structfield.max_pattern_len" class="structfield section-header"><a href="#structfield.max_pattern_len" class="anchor field">§</a><code>max_pattern_len: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></code></span><div class="docblock"><p>The length, in bytes, of the longest pattern in this automaton. This
information is useful for keeping correct buffer sizes when searching
on streams.</p>
</div><span id="structfield.special" class="structfield section-header"><a href="#structfield.special" class="anchor field">§</a><code>special: <a class="struct" href="../../util/special/struct.Special.html" title="struct aho_corasick::util::special::Special">Special</a></code></span><div class="docblock"><p>The information required to deduce which states are “special” in this
NFA.</p>
<p>Since the DEAD and FAIL states are always the first two states and
there are only ever two start states (which follow all of the match
states), it follows that we can determine whether a state is a fail,
dead, match or start with just a few comparisons on the ID itself:</p>
<p>is_dead(sid): sid == NFA::DEAD
is_fail(sid): sid == NFA::FAIL
is_match(sid): NFA::FAIL &lt; sid &amp;&amp; sid &lt;= max_match_id
is_start(sid): sid == start_unanchored_id || sid == start_anchored_id</p>
<p>Note that this only applies to the NFA after it has been constructed.
During construction, the start states are the first ones added and the
match states are inter-leaved with non-match states. Once all of the
states have been added, the states are shuffled such that the above
predicates hold.</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-NFA" class="impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#177-197">source</a><a href="#impl-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#182-188">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>&lt;I, P&gt;(patterns: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = P&gt;,
    P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>]&gt;,</div></h4></section></summary><div class="docblock"><p>Create a new Aho-Corasick noncontiguous NFA using the default
configuration.</p>
<p>Use a <a href="struct.Builder.html" title="struct aho_corasick::nfa::noncontiguous::Builder"><code>Builder</code></a> if you want to change the configuration.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.builder" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#194-196">source</a><h4 class="code-header">pub fn <a href="#method.builder" class="fn">builder</a>() -&gt; <a class="struct" href="struct.Builder.html" title="struct aho_corasick::nfa::noncontiguous::Builder">Builder</a></h4></section></summary><div class="docblock"><p>A convenience method for returning a new Aho-Corasick noncontiguous NFA
builder.</p>
<p>This usually permits one to just import the <code>NFA</code> type.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-NFA-1" class="impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#199-586">source</a><a href="#impl-NFA-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.DEAD" class="associatedconstant"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#214">source</a><h4 class="code-header">pub(crate) const <a href="#associatedconstant.DEAD" class="constant">DEAD</a>: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a> = _</h4></section></summary><div class="docblock"><p>The DEAD state is a sentinel state like the FAIL state. The DEAD state
instructs any search to stop and return any currently recorded match,
or no match otherwise. Generally speaking, it is impossible for an
unanchored standard search to enter a DEAD state. But an anchored
search can, and so to can a leftmost search.</p>
<p>We put DEAD before FAIL so that DEAD is always 0. We repeat this
decision across the other Aho-Corasicm automata, so that DEAD
states there are always 0 too. It’s not that we need all of the
implementations to agree, but rather, the contiguous NFA and the DFA
use a sort of “premultiplied” state identifier where the only state
whose ID is always known and constant is the first state. Subsequent
state IDs depend on how much space has already been used in the
transition table.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.FAIL" class="associatedconstant"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#221">source</a><h4 class="code-header">pub(crate) const <a href="#associatedconstant.FAIL" class="constant">FAIL</a>: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a> = _</h4></section></summary><div class="docblock"><p>The FAIL state mostly just corresponds to the ID of any transition on a
state that isn’t explicitly defined. When one transitions into the FAIL
state, one must follow the previous state’s failure transition before
doing the next state lookup. In this way, FAIL is more of a sentinel
than a state that one actually transitions into. In particular, it is
never exposed in the <code>Automaton</code> interface.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_classes" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#228-230">source</a><h4 class="code-header">pub(crate) fn <a href="#method.byte_classes" class="fn">byte_classes</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../util/alphabet/struct.ByteClasses.html" title="struct aho_corasick::util::alphabet::ByteClasses">ByteClasses</a></h4></section></summary><div class="docblock"><p>Returns the equivalence classes of bytes found while constructing
this NFA.</p>
<p>Note that the NFA doesn’t actually make use of these equivalence
classes. Instead, these are useful for building the DFA when desired.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_lens_raw" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#237-239">source</a><h4 class="code-header">pub(crate) fn <a href="#method.pattern_lens_raw" class="fn">pattern_lens_raw</a>(&amp;self) -&gt; &amp;[<a class="struct" href="../../util/primitives/struct.SmallIndex.html" title="struct aho_corasick::util::primitives::SmallIndex">SmallIndex</a>]</h4></section></summary><div class="docblock"><p>Returns a slice containing the length of each pattern in this searcher.
It is indexed by <code>PatternID</code> and has length <code>NFA::patterns_len</code>.</p>
<p>This is exposed for convenience when building a contiguous NFA. But it
can be reconstructed from the <code>Automaton</code> API if necessary.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.states" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#242-244">source</a><h4 class="code-header">pub(crate) fn <a href="#method.states" class="fn">states</a>(&amp;self) -&gt; &amp;[<a class="struct" href="struct.State.html" title="struct aho_corasick::nfa::noncontiguous::State">State</a>]</h4></section></summary><div class="docblock"><p>Returns a slice of all states in this non-contiguous NFA.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.special" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#247-249">source</a><h4 class="code-header">pub(crate) fn <a href="#method.special" class="fn">special</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../util/special/struct.Special.html" title="struct aho_corasick::util::special::Special">Special</a></h4></section></summary><div class="docblock"><p>Returns the underlying “special” state information for this NFA.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.swap_states" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#255-257">source</a><h4 class="code-header">pub(crate) fn <a href="#method.swap_states" class="fn">swap_states</a>(&amp;mut self, id1: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, id2: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>)</h4></section></summary><div class="docblock"><p>Swaps the states at <code>id1</code> and <code>id2</code>.</p>
<p>This does not update the transitions of any state to account for the
state swap.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remap" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#261-278">source</a><h4 class="code-header">pub(crate) fn <a href="#method.remap" class="fn">remap</a>(&amp;mut self, map: impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>) -&gt; <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>)</h4></section></summary><div class="docblock"><p>Re-maps all state IDs in this NFA according to the <code>map</code> function
given.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter_trans" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#281-294">source</a><h4 class="code-header">pub(crate) fn <a href="#method.iter_trans" class="fn">iter_trans</a>(
    &amp;self,
    sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>,
) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="struct" href="struct.Transition.html" title="struct aho_corasick::nfa::noncontiguous::Transition">Transition</a>&gt; + '_</h4></section></summary><div class="docblock"><p>Iterate over all of the transitions for the given state ID.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter_matches" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#297-310">source</a><h4 class="code-header">pub(crate) fn <a href="#method.iter_matches" class="fn">iter_matches</a>(
    &amp;self,
    sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>,
) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="struct" href="../../util/primitives/struct.PatternID.html" title="struct aho_corasick::util::primitives::PatternID">PatternID</a>&gt; + '_</h4></section></summary><div class="docblock"><p>Iterate over all of the matches for the given state ID.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_link" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#322-334">source</a><h4 class="code-header">fn <a href="#method.next_link" class="fn">next_link</a>(&amp;self, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, prev: <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>&gt;</h4></section></summary><div class="docblock"><p>Return the link following the one given. If the one given is the last
link for the given state, then return <code>None</code>.</p>
<p>If no previous link is given, then this returns the first link in the
state, if one exists.</p>
<p>This is useful for manually iterating over the transitions in a single
state without borrowing the NFA. This permits mutating other parts of
the NFA during iteration. Namely, one can access the transition pointed
to by the link via <code>self.sparse[link]</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.follow_transition" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#339-360">source</a><h4 class="code-header">fn <a href="#method.follow_transition" class="fn">follow_transition</a>(&amp;self, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, byte: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a></h4></section></summary><div class="docblock"><p>Follow the transition for the given byte in the given state. If no such
transition exists, then the FAIL state ID is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.follow_transition_sparse" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#364-374">source</a><h4 class="code-header">fn <a href="#method.follow_transition_sparse" class="fn">follow_transition_sparse</a>(&amp;self, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, byte: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a></h4></section></summary><div class="docblock"><p>Like <code>follow_transition</code>, but always uses the sparse representation.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_transition" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#381-423">source</a><h4 class="code-header">fn <a href="#method.add_transition" class="fn">add_transition</a>(
    &amp;mut self,
    prev: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>,
    byte: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>,
    next: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Set the transition for the given byte to the state ID given.</p>
<p>Note that one should not set transitions to the FAIL state. It is not
technically incorrect, but it wastes space. If a transition is not
defined, then it is automatically assumed to lead to the FAIL state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.init_full_state" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#435-463">source</a><h4 class="code-header">fn <a href="#method.init_full_state" class="fn">init_full_state</a>(
    &amp;mut self,
    prev: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>,
    next: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>This sets every possible transition (all 255 of them) for the given
state to the name <code>next</code> value.</p>
<p>This is useful for efficiently initializing start/dead states.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This requires that the state has no transitions added to it already.
If it has any transitions, then this panics. It will also panic if
the state has been densified prior to calling this.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_match" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#466-484">source</a><h4 class="code-header">fn <a href="#method.add_match" class="fn">add_match</a>(&amp;mut self, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, pid: <a class="struct" href="../../util/primitives/struct.PatternID.html" title="struct aho_corasick::util::primitives::PatternID">PatternID</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a match for the given pattern ID to the state for the given ID.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.copy_matches" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#490-523">source</a><h4 class="code-header">fn <a href="#method.copy_matches" class="fn">copy_matches</a>(&amp;mut self, src: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, dst: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Copy matches from the <code>src</code> state to the <code>dst</code> state. This is useful
when a match state can be reached via a failure transition. In which
case, you’ll want to copy the matches (if any) from the state reached
by the failure transition to the original state you were at.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.alloc_transition" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#527-533">source</a><h4 class="code-header">fn <a href="#method.alloc_transition" class="fn">alloc_transition</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new entry in <code>NFA::trans</code>, if there’s room, and return that
entry’s ID. If there’s no room, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.alloc_match" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#537-543">source</a><h4 class="code-header">fn <a href="#method.alloc_match" class="fn">alloc_match</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new entry in <code>NFA::matches</code>, if there’s room, and return that
entry’s ID. If there’s no room, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.alloc_dense_state" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#551-563">source</a><h4 class="code-header">fn <a href="#method.alloc_dense_state" class="fn">alloc_dense_state</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new set of <code>N</code> transitions in this NFA’s dense transition
table. The ID return corresponds to the index at which the <code>N</code>
transitions begin. So <code>id+0</code> is the first transition and <code>id+(N-1)</code> is
the last.</p>
<p><code>N</code> is determined via <code>NFA::byte_classes::alphabet_len</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.alloc_state" class="method"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#568-585">source</a><h4 class="code-header">fn <a href="#method.alloc_state" class="fn">alloc_state</a>(&amp;mut self, depth: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, <a class="struct" href="../../util/error/struct.BuildError.html" title="struct aho_corasick::util::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Allocate and add a fresh state to the underlying NFA and return its
ID (guaranteed to be one more than the ID of the previously allocated
state). If the ID would overflow <code>StateID</code>, then this returns an error.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Automaton-for-NFA" class="impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#591-702">source</a><a href="#impl-Automaton-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../automaton/trait.Automaton.html" title="trait aho_corasick::automaton::Automaton">Automaton</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.start_state" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#593-598">source</a><a href="#method.start_state" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.start_state" class="fn">start_state</a>(&amp;self, anchored: <a class="enum" href="../../util/search/enum.Anchored.html" title="enum aho_corasick::util::search::Anchored">Anchored</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, <a class="struct" href="../../util/error/struct.MatchError.html" title="struct aho_corasick::util::error::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Returns the starting state for the given anchor mode. <a href="../../automaton/trait.Automaton.html#tymethod.start_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.next_state" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#601-626">source</a><a href="#method.next_state" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.next_state" class="fn">next_state</a>(&amp;self, anchored: <a class="enum" href="../../util/search/enum.Anchored.html" title="enum aho_corasick::util::search::Anchored">Anchored</a>, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, byte: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>) -&gt; <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a></h4></section></summary><div class='docblock'>Performs a state transition from <code>sid</code> for <code>byte</code> and returns the next
state. <a href="../../automaton/trait.Automaton.html#tymethod.next_state">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_special" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#629-631">source</a><a href="#method.is_special" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.is_special" class="fn">is_special</a>(&amp;self, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if the given ID represents a “special” state. A special
state is a dead, match or start state. <a href="../../automaton/trait.Automaton.html#tymethod.is_special">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_dead" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#634-636">source</a><a href="#method.is_dead" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.is_dead" class="fn">is_dead</a>(&amp;self, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if the given ID represents a dead state. <a href="../../automaton/trait.Automaton.html#tymethod.is_dead">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_match" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#639-645">source</a><a href="#method.is_match" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.is_match" class="fn">is_match</a>(&amp;self, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if the given ID represents a match state. <a href="../../automaton/trait.Automaton.html#tymethod.is_match">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.is_start" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#648-651">source</a><a href="#method.is_start" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.is_start" class="fn">is_start</a>(&amp;self, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns true if the given ID represents a start state. <a href="../../automaton/trait.Automaton.html#tymethod.is_start">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.match_kind" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#654-656">source</a><a href="#method.match_kind" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.match_kind" class="fn">match_kind</a>(&amp;self) -&gt; <a class="enum" href="../../util/search/enum.MatchKind.html" title="enum aho_corasick::util::search::MatchKind">MatchKind</a></h4></section></summary><div class='docblock'>Returns the match semantics that this automaton was built with.</div></details><details class="toggle method-toggle" open><summary><section id="method.patterns_len" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#659-661">source</a><a href="#method.patterns_len" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.patterns_len" class="fn">patterns_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the total number of patterns compiled into this automaton.</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern_len" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#664-666">source</a><a href="#method.pattern_len" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.pattern_len" class="fn">pattern_len</a>(&amp;self, pid: <a class="struct" href="../../util/primitives/struct.PatternID.html" title="struct aho_corasick::util::primitives::PatternID">PatternID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the length of the pattern for the given ID. <a href="../../automaton/trait.Automaton.html#tymethod.pattern_len">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min_pattern_len" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#669-671">source</a><a href="#method.min_pattern_len" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.min_pattern_len" class="fn">min_pattern_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the length, in bytes, of the shortest pattern in this
automaton.</div></details><details class="toggle method-toggle" open><summary><section id="method.max_pattern_len" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#674-676">source</a><a href="#method.max_pattern_len" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.max_pattern_len" class="fn">max_pattern_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the length, in bytes, of the longest pattern in this automaton.</div></details><details class="toggle method-toggle" open><summary><section id="method.match_len" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#679-681">source</a><a href="#method.match_len" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.match_len" class="fn">match_len</a>(&amp;self, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the total number of matches for the given state ID. <a href="../../automaton/trait.Automaton.html#tymethod.match_len">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.match_pattern" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#684-686">source</a><a href="#method.match_pattern" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.match_pattern" class="fn">match_pattern</a>(&amp;self, sid: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, index: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../util/primitives/struct.PatternID.html" title="struct aho_corasick::util::primitives::PatternID">PatternID</a></h4></section></summary><div class='docblock'>Returns the pattern ID for the match state given by <code>sid</code> at the
<code>index</code> given. <a href="../../automaton/trait.Automaton.html#tymethod.match_pattern">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.memory_usage" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#689-696">source</a><a href="#method.memory_usage" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.memory_usage" class="fn">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the heap memory usage, in bytes, used by this automaton.</div></details><details class="toggle method-toggle" open><summary><section id="method.prefilter" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#699-701">source</a><a href="#method.prefilter" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#tymethod.prefilter" class="fn">prefilter</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="../../automaton/struct.Prefilter.html" title="struct aho_corasick::automaton::Prefilter">Prefilter</a>&gt;</h4></section></summary><div class='docblock'>Returns a prefilter, if available, that can be used to accelerate
searches for this automaton. <a href="../../automaton/trait.Automaton.html#tymethod.prefilter">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_find" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#354-359">source</a><a href="#method.try_find" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_find" class="fn">try_find</a>(&amp;self, input: &amp;<a class="struct" href="../../util/search/struct.Input.html" title="struct aho_corasick::util::search::Input">Input</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../util/search/struct.Match.html" title="struct aho_corasick::util::search::Match">Match</a>&gt;, <a class="struct" href="../../util/error/struct.MatchError.html" title="struct aho_corasick::util::error::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a non-overlapping search with this automaton using the given
configuration. <a href="../../automaton/trait.Automaton.html#method.try_find">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_overlapping" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#367-373">source</a><a href="#method.try_find_overlapping" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_find_overlapping" class="fn">try_find_overlapping</a>(
    &amp;self,
    input: &amp;<a class="struct" href="../../util/search/struct.Input.html" title="struct aho_corasick::util::search::Input">Input</a>&lt;'_&gt;,
    state: &amp;mut <a class="struct" href="../../automaton/struct.OverlappingState.html" title="struct aho_corasick::automaton::OverlappingState">OverlappingState</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.MatchError.html" title="struct aho_corasick::util::error::MatchError">MatchError</a>&gt;</h4></section></summary><div class='docblock'>Executes a overlapping search with this automaton using the given
configuration. <a href="../../automaton/trait.Automaton.html#method.try_find_overlapping">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_iter" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#381-389">source</a><a href="#method.try_find_iter" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_find_iter" class="fn">try_find_iter</a>&lt;'a, 'h&gt;(
    &amp;'a self,
    input: <a class="struct" href="../../util/search/struct.Input.html" title="struct aho_corasick::util::search::Input">Input</a>&lt;'h&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../automaton/struct.FindIter.html" title="struct aho_corasick::automaton::FindIter">FindIter</a>&lt;'a, 'h, Self&gt;, <a class="struct" href="../../util/error/struct.MatchError.html" title="struct aho_corasick::util::error::MatchError">MatchError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Returns an iterator of non-overlapping matches with this automaton
using the given configuration. <a href="../../automaton/trait.Automaton.html#method.try_find_iter">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_find_overlapping_iter" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#397-423">source</a><a href="#method.try_find_overlapping_iter" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_find_overlapping_iter" class="fn">try_find_overlapping_iter</a>&lt;'a, 'h&gt;(
    &amp;'a self,
    input: <a class="struct" href="../../util/search/struct.Input.html" title="struct aho_corasick::util::search::Input">Input</a>&lt;'h&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../automaton/struct.FindOverlappingIter.html" title="struct aho_corasick::automaton::FindOverlappingIter">FindOverlappingIter</a>&lt;'a, 'h, Self&gt;, <a class="struct" href="../../util/error/struct.MatchError.html" title="struct aho_corasick::util::error::MatchError">MatchError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Returns an iterator of overlapping matches with this automaton
using the given configuration. <a href="../../automaton/trait.Automaton.html#method.try_find_overlapping_iter">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_replace_all" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#433-454">source</a><a href="#method.try_replace_all" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_replace_all" class="fn">try_replace_all</a>&lt;B&gt;(
    &amp;self,
    haystack: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>,
    replace_with: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.slice.html">[B]</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <a class="struct" href="../../util/error/struct.MatchError.html" title="struct aho_corasick::util::error::MatchError">MatchError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    B: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class='docblock'>Replaces all non-overlapping matches in <code>haystack</code> with
strings from <code>replace_with</code> depending on the pattern that
matched. The <code>replace_with</code> slice must have length equal to
<code>Automaton::patterns_len</code>. <a href="../../automaton/trait.Automaton.html#method.try_replace_all">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_replace_all_bytes" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#464-485">source</a><a href="#method.try_replace_all_bytes" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_replace_all_bytes" class="fn">try_replace_all_bytes</a>&lt;B&gt;(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>],
    replace_with: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.slice.html">[B]</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>&gt;, <a class="struct" href="../../util/error/struct.MatchError.html" title="struct aho_corasick::util::error::MatchError">MatchError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    B: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>]&gt;,</div></h4></section></summary><div class='docblock'>Replaces all non-overlapping matches in <code>haystack</code> with
strings from <code>replace_with</code> depending on the pattern that
matched. The <code>replace_with</code> slice must have length equal to
<code>Automaton::patterns_len</code>. <a href="../../automaton/trait.Automaton.html#method.try_replace_all_bytes">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_replace_all_with" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#493-522">source</a><a href="#method.try_replace_all_with" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_replace_all_with" class="fn">try_replace_all_with</a>&lt;F&gt;(
    &amp;self,
    haystack: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>,
    dst: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,
    replace_with: F,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.MatchError.html" title="struct aho_corasick::util::error::MatchError">MatchError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../../util/search/struct.Match.html" title="struct aho_corasick::util::search::Match">Match</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>, &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Replaces all non-overlapping matches in <code>haystack</code> by calling the
<code>replace_with</code> closure given. <a href="../../automaton/trait.Automaton.html#method.try_replace_all_with">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_replace_all_with_bytes" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#530-550">source</a><a href="#method.try_replace_all_with_bytes" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_replace_all_with_bytes" class="fn">try_replace_all_with_bytes</a>&lt;F&gt;(
    &amp;self,
    haystack: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>],
    dst: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>&gt;,
    replace_with: F,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../../util/error/struct.MatchError.html" title="struct aho_corasick::util::error::MatchError">MatchError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../../util/search/struct.Match.html" title="struct aho_corasick::util::search::Match">Match</a>, &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>], &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Replaces all non-overlapping matches in <code>haystack</code> by calling the
<code>replace_with</code> closure given. <a href="../../automaton/trait.Automaton.html#method.try_replace_all_with_bytes">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_stream_find_iter" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#559-567">source</a><a href="#method.try_stream_find_iter" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_stream_find_iter" class="fn">try_stream_find_iter</a>&lt;'a, R: <a class="trait" href="https://doc.rust-lang.org/1.80.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a>&gt;(
    &amp;'a self,
    rdr: R,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../automaton/struct.StreamFindIter.html" title="struct aho_corasick::automaton::StreamFindIter">StreamFindIter</a>&lt;'a, Self, R&gt;, <a class="struct" href="../../util/error/struct.MatchError.html" title="struct aho_corasick::util::error::MatchError">MatchError</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Returns an iterator of non-overlapping matches with this automaton
from the stream given. <a href="../../automaton/trait.Automaton.html#method.try_stream_find_iter">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_stream_replace_all" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#578-599">source</a><a href="#method.try_stream_replace_all" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_stream_replace_all" class="fn">try_stream_replace_all</a>&lt;R, W, B&gt;(
    &amp;self,
    rdr: R,
    wtr: W,
    replace_with: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.slice.html">[B]</a>,
) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: <a class="trait" href="https://doc.rust-lang.org/1.80.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a>,
    W: <a class="trait" href="https://doc.rust-lang.org/1.80.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a>,
    B: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>]&gt;,</div></h4></section></summary><div class='docblock'>Replaces all non-overlapping matches in <code>rdr</code> with strings from
<code>replace_with</code> depending on the pattern that matched, and writes the
result to <code>wtr</code>. The <code>replace_with</code> slice must have length equal to
<code>Automaton::patterns_len</code>. <a href="../../automaton/trait.Automaton.html#method.try_stream_replace_all">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.try_stream_replace_all_with" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#608-636">source</a><a href="#method.try_stream_replace_all_with" class="anchor">§</a><h4 class="code-header">fn <a href="../../automaton/trait.Automaton.html#method.try_stream_replace_all_with" class="fn">try_stream_replace_all_with</a>&lt;R, W, F&gt;(
    &amp;self,
    rdr: R,
    wtr: W,
    replace_with: F,
) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>&gt;<div class="where">where
    Self: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,
    R: <a class="trait" href="https://doc.rust-lang.org/1.80.1/std/io/trait.Read.html" title="trait std::io::Read">Read</a>,
    W: <a class="trait" href="https://doc.rust-lang.org/1.80.1/std/io/trait.Write.html" title="trait std::io::Write">Write</a>,
    F: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../../util/search/struct.Match.html" title="struct aho_corasick::util::search::Match">Match</a>, &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>], <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut W</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/std/io/error/type.Result.html" title="type std::io::error::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>&gt;,</div></h4></section></summary><div class='docblock'>Replaces all non-overlapping matches in <code>rdr</code> by calling the
<code>replace_with</code> closure given and writing the result to <code>wtr</code>. <a href="../../automaton/trait.Automaton.html#method.try_stream_replace_all_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-NFA" class="impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#81">source</a><a href="#impl-Clone-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#81">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-NFA" class="impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1691-1762">source</a><a href="#impl-Debug-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/nfa/noncontiguous.rs.html#1692-1761">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Remappable-for-NFA" class="impl"><a class="src rightside" href="../../../src/aho_corasick/util/remapper.rs.html#202-214">source</a><a href="#impl-Remappable-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../util/remapper/trait.Remappable.html" title="trait aho_corasick::util::remapper::Remappable">Remappable</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.state_len" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/util/remapper.rs.html#203-205">source</a><a href="#method.state_len" class="anchor">§</a><h4 class="code-header">fn <a href="../../util/remapper/trait.Remappable.html#tymethod.state_len" class="fn">state_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Return the total number of states.</div></details><details class="toggle method-toggle" open><summary><section id="method.swap_states-1" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/util/remapper.rs.html#207-209">source</a><a href="#method.swap_states-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../util/remapper/trait.Remappable.html#tymethod.swap_states" class="fn">swap_states</a>(&amp;mut self, id1: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>, id2: <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>)</h4></section></summary><div class='docblock'>Swap the states pointed to by the given IDs. The underlying finite
state machine should be mutated such that all of the transitions in
<code>id1</code> are now in the memory region where the transitions for <code>id2</code>
were, and all of the transitions in <code>id2</code> are now in the memory region
where the transitions for <code>id1</code> were. <a href="../../util/remapper/trait.Remappable.html#tymethod.swap_states">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.remap-1" class="method trait-impl"><a class="src rightside" href="../../../src/aho_corasick/util/remapper.rs.html#211-213">source</a><a href="#method.remap-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../util/remapper/trait.Remappable.html#tymethod.remap" class="fn">remap</a>(&amp;mut self, map: impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>) -&gt; <a class="struct" href="../../automaton/struct.StateID.html" title="struct aho_corasick::automaton::StateID">StateID</a>)</h4></section></summary><div class='docblock'>This must remap every single state ID in the underlying value according
to the function given. For example, in a DFA, this should remap every
transition and every starting state ID.</div></details></div></details><section id="impl-Sealed-for-NFA" class="impl"><a class="src rightside" href="../../../src/aho_corasick/automaton.rs.html#31">source</a><a href="#impl-Sealed-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../automaton/private/trait.Sealed.html" title="trait aho_corasick::automaton::private::Sealed">Sealed</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-NFA" class="impl"><a href="#impl-Freeze-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section><section id="impl-RefUnwindSafe-for-NFA" class="impl"><a href="#impl-RefUnwindSafe-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section><section id="impl-Send-for-NFA" class="impl"><a href="#impl-Send-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section><section id="impl-Sync-for-NFA" class="impl"><a href="#impl-Sync-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section><section id="impl-Unpin-for-NFA" class="impl"><a href="#impl-Unpin-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section><section id="impl-UnwindSafe-for-NFA" class="impl"><a href="#impl-UnwindSafe-for-NFA" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.NFA.html" title="struct aho_corasick::nfa::noncontiguous::NFA">NFA</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>