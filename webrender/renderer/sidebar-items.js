initSidebarItems({"constant":[["BLOCKS_PER_UV_RECT","Number of GPU blocks per UV rectangle provided for an image."],["DEFAULT_BATCH_LOOKBACK_COUNT",""],["GPU_CACHE_RESIZE_TEST","Enabling this toggle would force the GPU cache scattered texture to be resized every frame, which enables GPU debuggers to see if this is performed correctly."],["GPU_SAMPLER_TAG_ALPHA",""],["GPU_SAMPLER_TAG_OPAQUE",""],["GPU_SAMPLER_TAG_TRANSPARENT",""],["GPU_TAG_BLIT",""],["GPU_TAG_BLUR",""],["GPU_TAG_BRUSH_BLEND",""],["GPU_TAG_BRUSH_CONIC_GRADIENT",""],["GPU_TAG_BRUSH_IMAGE",""],["GPU_TAG_BRUSH_LINEAR_GRADIENT",""],["GPU_TAG_BRUSH_MIXBLEND",""],["GPU_TAG_BRUSH_OPACITY",""],["GPU_TAG_BRUSH_RADIAL_GRADIENT",""],["GPU_TAG_BRUSH_SOLID",""],["GPU_TAG_BRUSH_YUV_IMAGE",""],["GPU_TAG_CACHE_BORDER",""],["GPU_TAG_CACHE_CLIP",""],["GPU_TAG_CACHE_GRADIENT",""],["GPU_TAG_CACHE_LINE_DECORATION",""],["GPU_TAG_CLEAR",""],["GPU_TAG_COMPOSITE",""],["GPU_TAG_PRIM_SPLIT_COMPOSITE",""],["GPU_TAG_PRIM_TEXT_RUN",""],["GPU_TAG_SCALE",""],["GPU_TAG_SETUP_DATA",""],["GPU_TAG_SETUP_TARGET",""],["GPU_TAG_SVG_FILTER",""],["MAX_VERTEX_TEXTURE_WIDTH",""],["TEXTURE_CACHE_DBG_CLEAR_COLOR","The clear color used for the texture cache when the debug display is enabled. We use a shade of blue so that we can still identify completely blue items in the texture cache."],["VERTEX_DATA_TEXTURE_COUNT","The size of the array of each type of vertex data texture that is round-robin-ed each frame during bind_frame_data. Doing this helps avoid driver stalls while updating the texture in some drivers. The size of these textures are typically very small (e.g. < 16 kB) so it’s not a huge waste of memory. Despite that, this is a short-term solution - we want to find a better way to provide this frame data, which will likely involve some combination of UBO/SSBO usage. Although this only affects some platforms, it’s enabled on all platforms to reduce testing differences between platforms."],["VERTEX_TEXTURE_EXTRA_ROWS",""]],"enum":[["BlendMode",""],["FramebufferKind",""],["GpuCacheBus","The bus over which CPU and GPU versions of the GPU cache get synchronized."],["GraphicsApi",""],["ImageBufferKind",""],["PartialPresentMode","The selected partial present mode for a given frame."],["RendererError",""],["ShaderColorMode",""],["TextureSampler","Enumeration of the texture samplers used across the various WebRender shaders."],["VertexArrayKind",""]],"fn":[["flag_changed",""],["get_vao",""],["new_debug_server",""],["should_skip_batch",""],["wr_has_been_initialized","Returns true if a WR instance has ever been initialized in this process."]],"mod":[["desc",""]],"static":[["HAS_BEEN_INITIALIZED","Is only false if no WR instances have ever been created."]],"struct":[["ActiveTexture","A Texture that has been initialized by the `device` module and is ready to be used."],["CacheRow","Tracks the state of each row in the GPU cache texture."],["CpuProfile",""],["DebugFlags","Flags to enable/disable various builtin debugging tools."],["DebugOverlayState","Information about the state of the debugging / profiler overlay in native compositing mode."],["FrameOutput",""],["GpuCacheTexture","The device-specific representation of the cache texture in gpu_cache.rs"],["GpuProfile",""],["GraphicsApiInfo",""],["LazyInitializedDebugRenderer",""],["NoopDebugServer",""],["PackedVertex",""],["PipelineInfo",""],["PlainExternalResources",""],["PlainRenderer",""],["PlainTexture",""],["RenderResults","Return type from render(), which contains some repr(C) statistics as well as some non-repr(C) data."],["Renderer","The renderer is responsible for submitting to the GPU the work prepared by the RenderBackend."],["RendererOptions",""],["RendererStats","Some basic statistics about the rendered scene, used in Gecko, as well as in wrench reftests to ensure that tests are batching and/or allocating on render targets as we expect them to."],["RendererVAOs",""],["ShaderPrecacheFlags","Flags that control how shaders are pre-cached, if at all."],["TargetSelector",""],["TextureResolver","Helper struct for resolving device Textures for use during rendering passes."],["VertexDataTexture",""],["VertexDataTextures",""]],"trait":[["AsyncPropertySampler","Allows callers to hook into the main render_backend loop and provide additional frame ops for generate_frame transactions. These functions are all called from the render backend thread."],["DebugServer",""],["SceneBuilderHooks","Allows callers to hook in at certain points of the async scene build. These functions are all called from the scene builder thread."],["ThreadListener",""]]});