initSidebarItems({"enum":[["AttributeFlags","An attribute selector can have ‘s’ or ‘i’ as flags, or no flags at all."],["Combinator",""],["Component","A CSS simple selector or combinator. We store both in the same enum for optimal packing and cache performance, see [1]."],["OptionalQName",""],["ParseErrorRecovery","How to treat invalid selectors in a selector list."],["QNamePrefix",""],["SelectorParseErrorKind",""],["SimpleSelectorParseResult",""]],"fn":[["collect_ancestor_hashes",""],["is_css2_pseudo_element","Returns whether the name corresponds to a CSS2 pseudo-element that can be specified with the single colon syntax (in addition to the double-colon syntax, which can be used for all pseudo-elements)."],["namespace_empty_string",""],["parse_attribute_flags",""],["parse_attribute_selector",""],["parse_compound_selector","simple_selector_sequence : [ type_selector | universal ] [ HASH | class | attrib | pseudo | negation ]* | [ HASH | class | attrib | pseudo | negation ]+"],["parse_functional_pseudo_class",""],["parse_inner_compound_selector","Parses one compound selector suitable for nested stuff like :-moz-any, etc."],["parse_is_or_where",""],["parse_negation","Level 3: Parse one simple_selector.  (Though we might insert a second implied “|*” type selector.)"],["parse_nth_pseudo_class",""],["parse_one_simple_selector","Parse a simple selector other than a type selector."],["parse_qualified_name","`Err(())`: Invalid selector, abort`Ok(None(token))`: Not a simple selector, could be something else. `input` was not consumed, but the token is still returned.`Ok(Some(namespace, local_name))`: `None` for the local name means a `*` universal selector"],["parse_selector","Build up a Selector. selector : simple_selector_sequence [ combinator simple_selector_sequence ]* ;"],["parse_simple_pseudo_class",""],["parse_type_selector","`Err(())`: Invalid selector, abort`Ok(false)`: Not a type selector, could be something else. `input` was not consumed.`Ok(true)`: Length 0 (`*|*`), 1 (`*|E` or `ns|*`) or 2 (`|E` or `ns|E`)"],["serialize_selector_list",""],["to_ascii_lowercase","Returns a Cow::Borrowed if `s` is already ASCII lowercase, and a Cow::Owned if `s` had to be converted into ASCII lowercase."]],"macro":[["with_all_bounds",""],["with_bounds",""]],"struct":[["AncestorHashes","Ancestor hashes for the bloom filter. We precompute these and store them inline with selectors to optimize cache performance during matching. This matters a lot."],["AncestorIter","An iterator over all simple selectors belonging to ancestors."],["LocalName",""],["Selector","A Selector stores a sequence of simple selectors and combinators. The iterator classes allow callers to iterate at either the raw sequence level or at the level of sequences of simple selectors separated by combinators. Most callers want the higher-level iterator."],["SelectorIter",""],["SelectorList",""],["SelectorParsingState","Flags that indicate at which point of parsing a selector are we."]],"trait":[["NonTSPseudoClass","A trait that represents a pseudo-class."],["Parser",""],["PseudoElement","A trait that represents a pseudo-element."],["SelectorImpl","This trait allows to define the parser implementation in regards of pseudo-classes/elements"]],"type":[["SelectorParseError",""]]});