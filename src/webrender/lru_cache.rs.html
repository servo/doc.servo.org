<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `&#x2F;home&#x2F;runner&#x2F;.cargo&#x2F;git&#x2F;checkouts&#x2F;webrender-479e138e1c1b9e8b&#x2F;920168a&#x2F;webrender&#x2F;src&#x2F;lru_cache.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>lru_cache.rs - source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../webrender/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
</pre><pre class="rust">
<span class="comment">/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>

<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::freelist</span>::{<span class="ident">FreeList</span>, <span class="ident">FreeListHandle</span>, <span class="ident">WeakFreeListHandle</span>};
<span class="kw">use</span> <span class="ident">std</span>::{<span class="ident">mem</span>, <span class="ident">num</span>};

<span class="comment">/*
  This module implements a least recently used cache structure, which is
  used by the texture cache to manage the lifetime of items inside the
  texture cache. It has a few special pieces of functionality that the
  texture cache requires, but should be usable as a general LRU cache
  type if useful in other areas.

  The cache is implemented with two backing freelists. These allow
  random access to the underlying data, while being efficient in both
  memory access and allocation patterns.

  The first freelist stores the elements being cached (for example, the
  CacheEntry structure for the texture cache). These elements are stored
  in arbitrary order, reusing empty slots in the freelist where possible.

  The second freelist stores the LRU tracking information. Although the
  tracking elements are stored in arbitrary order inside a freelist for
  efficiency, they use next/prev links to represent a doubly-linked list,
  kept sorted in order of recent use. The next link is also used to store
  the current freelist within the array when the element is not occupied.
 */</span>

<span class="doccomment">/// Stores the data supplied by the user to be cached, and an index</span>
<span class="doccomment">/// into the LRU tracking freelist for this element.</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;capture&quot;</span>, <span class="ident">derive</span>(<span class="ident">Serialize</span>))]</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;replay&quot;</span>, <span class="ident">derive</span>(<span class="ident">Deserialize</span>))]</span>
<span class="kw">struct</span> <span class="ident">LRUCacheEntry</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
    <span class="doccomment">/// The location of the LRU tracking element for this cache entry.</span>
    <span class="doccomment">/// This is None if the entry has manual eviction policy enabled.</span>
    <span class="ident">lru_index</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ItemIndex</span><span class="op">&gt;</span>,
    <span class="doccomment">/// The cached data provided by the caller for this element.</span>
    <span class="ident">value</span>: <span class="ident">T</span>,
}

<span class="doccomment">/// The main public interface to the LRU cache</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;capture&quot;</span>, <span class="ident">derive</span>(<span class="ident">Serialize</span>))]</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;replay&quot;</span>, <span class="ident">derive</span>(<span class="ident">Deserialize</span>))]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">LRUCache</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">M</span><span class="op">&gt;</span> {
    <span class="doccomment">/// A free list of cache entries, and indices into the LRU tracking list</span>
    <span class="ident">entries</span>: <span class="ident">FreeList</span><span class="op">&lt;</span><span class="ident">LRUCacheEntry</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="ident">M</span><span class="op">&gt;</span>,
    <span class="doccomment">/// The LRU tracking list, allowing O(1) access to the oldest element</span>
    <span class="ident">lru</span>: <span class="ident">LRUTracker</span><span class="op">&lt;</span><span class="ident">FreeListHandle</span><span class="op">&lt;</span><span class="ident">M</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">M</span><span class="op">&gt;</span> <span class="ident">LRUCache</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">M</span><span class="op">&gt;</span> {
    <span class="doccomment">/// Construct a new LRU cache</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
        <span class="ident">LRUCache</span> {
            <span class="ident">entries</span>: <span class="ident">FreeList::new</span>(),
            <span class="ident">lru</span>: <span class="ident">LRUTracker::new</span>(),
        }
    }

    <span class="doccomment">/// Insert a new element into the cache. Returns a weak handle for callers to</span>
    <span class="doccomment">/// access the data, since the lifetime is managed by the LRU algorithm and it</span>
    <span class="doccomment">/// may be evicted at any time.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">push_new</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">value</span>: <span class="ident">T</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">WeakFreeListHandle</span><span class="op">&lt;</span><span class="ident">M</span><span class="op">&gt;</span> {
        <span class="comment">// It&#39;s a slightly awkward process to insert an element, since we don&#39;t know</span>
        <span class="comment">// the index of the LRU tracking element until we&#39;ve got a handle for the</span>
        <span class="comment">// underlying cached data.</span>

        <span class="comment">// Insert the data provided by the caller</span>
        <span class="kw">let</span> <span class="ident">handle</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">entries</span>.<span class="ident">insert</span>(<span class="ident">LRUCacheEntry</span> {
            <span class="ident">lru_index</span>: <span class="prelude-val">None</span>,
            <span class="ident">value</span>,
        });

        <span class="comment">// Get a weak handle to return to the caller</span>
        <span class="kw">let</span> <span class="ident">weak_handle</span> <span class="op">=</span> <span class="ident">handle</span>.<span class="ident">weak</span>();

        <span class="comment">// Add an LRU tracking node that owns the strong handle, and store the location</span>
        <span class="comment">// of this inside the cache entry.</span>
        <span class="kw">let</span> <span class="ident">entry</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">entries</span>.<span class="ident">get_mut</span>(<span class="kw-2">&amp;</span><span class="ident">handle</span>);
        <span class="ident">entry</span>.<span class="ident">lru_index</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="self">self</span>.<span class="ident">lru</span>.<span class="ident">push_new</span>(<span class="ident">handle</span>));

        <span class="ident">weak_handle</span>
    }

    <span class="doccomment">/// Get immutable access to the data at a given slot. Since this takes a strong</span>
    <span class="doccomment">/// handle, it&#39;s guaranteed to be valid.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get</span>(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        <span class="ident">handle</span>: <span class="kw-2">&amp;</span><span class="ident">FreeListHandle</span><span class="op">&lt;</span><span class="ident">M</span><span class="op">&gt;</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="ident">T</span> {
        <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">entries</span>
            .<span class="ident">get</span>(<span class="ident">handle</span>)
            .<span class="ident">value</span>
    }

    <span class="doccomment">/// Get immutable access to the data at a given slot. Since this takes a weak</span>
    <span class="doccomment">/// handle, it may have been evicted, so returns an Option.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_opt</span>(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        <span class="ident">handle</span>: <span class="kw-2">&amp;</span><span class="ident">WeakFreeListHandle</span><span class="op">&lt;</span><span class="ident">M</span><span class="op">&gt;</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">T</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">entries</span>
            .<span class="ident">get_opt</span>(<span class="ident">handle</span>)
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">entry</span><span class="op">|</span> {
                <span class="kw-2">&amp;</span><span class="ident">entry</span>.<span class="ident">value</span>
            })
    }

    <span class="doccomment">/// Get mutable access to the data at a given slot. Since this takes a weak</span>
    <span class="doccomment">/// handle, it may have been evicted, so returns an Option.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_opt_mut</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">handle</span>: <span class="kw-2">&amp;</span><span class="ident">WeakFreeListHandle</span><span class="op">&lt;</span><span class="ident">M</span><span class="op">&gt;</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">T</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">entries</span>
            .<span class="ident">get_opt_mut</span>(<span class="ident">handle</span>)
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">entry</span><span class="op">|</span> {
                <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">entry</span>.<span class="ident">value</span>
            })
    }

    <span class="doccomment">/// Remove the oldest item from the cache. This is used to select elements to</span>
    <span class="doccomment">/// be evicted. If the cache is empty, or all elements in the cache have manual</span>
    <span class="doccomment">/// eviction enabled, this will return None</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">pop_oldest</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">lru</span>
            .<span class="ident">pop_front</span>()
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">handle</span><span class="op">|</span> {
                <span class="kw">let</span> <span class="ident">entry</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">entries</span>.<span class="ident">free</span>(<span class="ident">handle</span>);
                <span class="comment">// We should only find elements in this list with valid LRU location</span>
                <span class="macro">debug_assert!</span>(<span class="ident">entry</span>.<span class="ident">lru_index</span>.<span class="ident">is_some</span>());
                <span class="ident">entry</span>.<span class="ident">value</span>
            })
    }

    <span class="doccomment">/// This is a special case of `push_new`, which is a requirement for the texture</span>
    <span class="doccomment">/// cache. Sometimes, we want to replace the content of an existing handle if it</span>
    <span class="doccomment">/// exists, or insert a new element if the handle is invalid (for example, if an</span>
    <span class="doccomment">/// image is resized and it moves to a new location in the texture atlas). This</span>
    <span class="doccomment">/// method returns the old cache entry if it existed, so it can be freed by the caller.</span>
    <span class="attribute">#[<span class="ident">must_use</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">replace_or_insert</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">handle</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">WeakFreeListHandle</span><span class="op">&lt;</span><span class="ident">M</span><span class="op">&gt;</span>,
        <span class="ident">data</span>: <span class="ident">T</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
        <span class="kw">match</span> <span class="self">self</span>.<span class="ident">entries</span>.<span class="ident">get_opt_mut</span>(<span class="ident">handle</span>) {
            <span class="prelude-val">Some</span>(<span class="ident">entry</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="prelude-val">Some</span>(<span class="ident">mem::replace</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">entry</span>.<span class="ident">value</span>, <span class="ident">data</span>))
            }
            <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw-2">*</span><span class="ident">handle</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">push_new</span>(<span class="ident">data</span>);
                <span class="prelude-val">None</span>
            }
        }
    }

    <span class="doccomment">/// This is used by the calling code to signal that the element that this handle</span>
    <span class="doccomment">/// references has been used on this frame. Internally, it updates the links in</span>
    <span class="doccomment">/// the LRU tracking element to move this item to the end of the LRU list. Returns</span>
    <span class="doccomment">/// the underlying data in case the client wants to mutate it.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">touch</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">handle</span>: <span class="kw-2">&amp;</span><span class="ident">WeakFreeListHandle</span><span class="op">&lt;</span><span class="ident">M</span><span class="op">&gt;</span>
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">T</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">lru</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>.<span class="ident">lru</span>;

        <span class="self">self</span>.<span class="ident">entries</span>
            .<span class="ident">get_opt_mut</span>(<span class="ident">handle</span>)
            .<span class="ident">map</span>(<span class="op">|</span><span class="ident">entry</span><span class="op">|</span> {
                <span class="comment">// Only have a valid LRU index if eviction mode is auto</span>
                <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">lru_index</span>) <span class="op">=</span> <span class="ident">entry</span>.<span class="ident">lru_index</span> {
                    <span class="ident">lru</span>.<span class="ident">mark_used</span>(<span class="ident">lru_index</span>);
                }

                <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">entry</span>.<span class="ident">value</span>
            })
    }

    <span class="doccomment">/// In some special cases, the caller may want to manually manage the</span>
    <span class="doccomment">/// lifetime of a resource. This method removes the LRU tracking information</span>
    <span class="doccomment">/// for an element, and returns the strong handle to the caller to manage.</span>
    <span class="attribute">#[<span class="ident">must_use</span>]</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_manual_eviction</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">handle</span>: <span class="kw-2">&amp;</span><span class="ident">WeakFreeListHandle</span><span class="op">&lt;</span><span class="ident">M</span><span class="op">&gt;</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">FreeListHandle</span><span class="op">&lt;</span><span class="ident">M</span><span class="op">&gt;</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">entry</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">entries</span>
            .<span class="ident">get_opt_mut</span>(<span class="ident">handle</span>)
            .<span class="ident">expect</span>(<span class="string">&quot;bug: trying to set manual eviction on an invalid handle&quot;</span>);

        <span class="comment">// Remove the LRU tracking information from this element, if it exists.</span>
        <span class="comment">// (it may be None if manual eviction was already enabled for this element).</span>
        <span class="ident">entry</span>.<span class="ident">lru_index</span>.<span class="ident">take</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">lru_index</span><span class="op">|</span> {
            <span class="self">self</span>.<span class="ident">lru</span>.<span class="ident">remove</span>(<span class="ident">lru_index</span>)
        })
    }

    <span class="doccomment">/// Remove an element that is in manual eviction mode. This takes the caller</span>
    <span class="doccomment">/// managed strong handle, and removes this element from the freelist.</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">remove_manual_handle</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">handle</span>: <span class="ident">FreeListHandle</span><span class="op">&lt;</span><span class="ident">M</span><span class="op">&gt;</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">T</span> {
        <span class="kw">let</span> <span class="ident">entry</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">entries</span>.<span class="ident">free</span>(<span class="ident">handle</span>);
        <span class="macro">debug_assert_eq!</span>(<span class="ident">entry</span>.<span class="ident">lru_index</span>, <span class="prelude-val">None</span>, <span class="string">&quot;Must be manual eviction mode!&quot;</span>);
        <span class="ident">entry</span>.<span class="ident">value</span>
    }

    <span class="doccomment">/// Try to validate that the state of the cache is consistent</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
    <span class="kw">fn</span> <span class="ident">validate</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="self">self</span>.<span class="ident">lru</span>.<span class="ident">validate</span>();
    }
}

<span class="doccomment">/// Index of an LRU tracking element</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;capture&quot;</span>, <span class="ident">derive</span>(<span class="ident">Serialize</span>))]</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;replay&quot;</span>, <span class="ident">derive</span>(<span class="ident">Deserialize</span>))]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Copy</span>, <span class="ident">Clone</span>, <span class="ident">PartialEq</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>)]</span>
<span class="kw">struct</span> <span class="ident">ItemIndex</span>(<span class="ident">num::NonZeroU32</span>);

<span class="kw">impl</span> <span class="ident">ItemIndex</span> {
    <span class="kw">fn</span> <span class="ident">as_usize</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">usize</span> {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">get</span>() <span class="kw">as</span> <span class="ident">usize</span>
    }
}

<span class="doccomment">/// Stores a strong handle controlling the lifetime of the data in the LRU</span>
<span class="doccomment">/// cache, and a doubly-linked list node specifying where in the current LRU</span>
<span class="doccomment">/// order this element exists. These items are themselves backed by a freelist</span>
<span class="doccomment">/// to minimize heap allocations and improve cache access patterns.</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;capture&quot;</span>, <span class="ident">derive</span>(<span class="ident">Serialize</span>))]</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;replay&quot;</span>, <span class="ident">derive</span>(<span class="ident">Deserialize</span>))]</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Item</span><span class="op">&lt;</span><span class="ident">H</span><span class="op">&gt;</span> {
    <span class="ident">prev</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ItemIndex</span><span class="op">&gt;</span>,
    <span class="ident">next</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ItemIndex</span><span class="op">&gt;</span>,
    <span class="ident">handle</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">H</span><span class="op">&gt;</span>,
}

<span class="doccomment">/// Internal implementation of the LRU tracking list</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;capture&quot;</span>, <span class="ident">derive</span>(<span class="ident">Serialize</span>))]</span>
<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;replay&quot;</span>, <span class="ident">derive</span>(<span class="ident">Deserialize</span>))]</span>
<span class="kw">struct</span> <span class="ident">LRUTracker</span><span class="op">&lt;</span><span class="ident">H</span><span class="op">&gt;</span> {
    <span class="doccomment">/// Current head of the list - this is the oldest item that will be evicted next.</span>
    <span class="ident">head</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ItemIndex</span><span class="op">&gt;</span>,
    <span class="doccomment">/// Current tail of the list - this is the most recently used element.</span>
    <span class="ident">tail</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ItemIndex</span><span class="op">&gt;</span>,
    <span class="doccomment">/// As tracking items are removed, they are stored in a freelist, to minimize heap allocations</span>
    <span class="ident">free_list_head</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">ItemIndex</span><span class="op">&gt;</span>,
    <span class="doccomment">/// The freelist that stores all the LRU tracking items</span>
    <span class="ident">items</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">&lt;</span><span class="ident">H</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">H</span><span class="op">&gt;</span> <span class="ident">LRUTracker</span><span class="op">&lt;</span><span class="ident">H</span><span class="op">&gt;</span> <span class="kw">where</span> <span class="ident">H</span>: <span class="ident">std::fmt::Debug</span> {
    <span class="doccomment">/// Construct a new LRU tracker</span>
    <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
        <span class="comment">// Push a dummy entry in the vec that is never used. This ensures the NonZeroU32</span>
        <span class="comment">// property is respected, and we never create an ItemIndex(0).</span>
        <span class="kw">let</span> <span class="ident">items</span> <span class="op">=</span> <span class="macro">vec!</span>[
            <span class="ident">Item</span> {
                <span class="ident">prev</span>: <span class="prelude-val">None</span>,
                <span class="ident">next</span>: <span class="prelude-val">None</span>,
                <span class="ident">handle</span>: <span class="prelude-val">None</span>,
            },
        ];

        <span class="ident">LRUTracker</span> {
            <span class="ident">head</span>: <span class="prelude-val">None</span>,
            <span class="ident">tail</span>: <span class="prelude-val">None</span>,
            <span class="ident">free_list_head</span>: <span class="prelude-val">None</span>,
            <span class="ident">items</span>,
        }
    }

    <span class="doccomment">/// Internal function that takes an item index, and links it to the</span>
    <span class="doccomment">/// end of the tracker list (makes it the newest item).</span>
    <span class="kw">fn</span> <span class="ident">link_as_new_tail</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">item_index</span>: <span class="ident">ItemIndex</span>,
    ) {
        <span class="kw">match</span> (<span class="self">self</span>.<span class="ident">head</span>, <span class="self">self</span>.<span class="ident">tail</span>) {
            (<span class="prelude-val">Some</span>(..), <span class="prelude-val">Some</span>(<span class="ident">tail</span>)) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// Both a head and a tail</span>
                <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">item_index</span>.<span class="ident">as_usize</span>()].<span class="ident">prev</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">tail</span>);
                <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">item_index</span>.<span class="ident">as_usize</span>()].<span class="ident">next</span> <span class="op">=</span> <span class="prelude-val">None</span>;

                <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">tail</span>.<span class="ident">as_usize</span>()].<span class="ident">next</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">item_index</span>);
                <span class="self">self</span>.<span class="ident">tail</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">item_index</span>);
            }
            (<span class="prelude-val">None</span>, <span class="prelude-val">None</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// No head/tail, currently empty list</span>
                <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">item_index</span>.<span class="ident">as_usize</span>()].<span class="ident">prev</span> <span class="op">=</span> <span class="prelude-val">None</span>;
                <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">item_index</span>.<span class="ident">as_usize</span>()].<span class="ident">next</span> <span class="op">=</span> <span class="prelude-val">None</span>;

                <span class="self">self</span>.<span class="ident">head</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">item_index</span>);
                <span class="self">self</span>.<span class="ident">tail</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">item_index</span>);
            }
            (<span class="prelude-val">Some</span>(..), <span class="prelude-val">None</span>) <span class="op">|</span> (<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(..)) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// Invalid state</span>
                <span class="macro">unreachable!</span>();
            }
        }
    }

    <span class="doccomment">/// Internal function that takes an LRU item index, and removes it from</span>
    <span class="doccomment">/// the current doubly linked list. Used during removal of items, and also</span>
    <span class="doccomment">/// when items are moved to the back of the list as they&#39;re touched.</span>
    <span class="kw">fn</span> <span class="ident">unlink</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">item_index</span>: <span class="ident">ItemIndex</span>,
    ) {
        <span class="kw">let</span> (<span class="ident">next</span>, <span class="ident">prev</span>) <span class="op">=</span> {
            <span class="kw">let</span> <span class="ident">item</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">items</span>[<span class="ident">item_index</span>.<span class="ident">as_usize</span>()];
            (<span class="ident">item</span>.<span class="ident">next</span>, <span class="ident">item</span>.<span class="ident">prev</span>)
        };

        <span class="kw">match</span> <span class="ident">next</span> {
            <span class="prelude-val">Some</span>(<span class="ident">next</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">next</span>.<span class="ident">as_usize</span>()].<span class="ident">prev</span> <span class="op">=</span> <span class="ident">prev</span>;
            }
            <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">debug_assert_eq!</span>(<span class="self">self</span>.<span class="ident">tail</span>, <span class="prelude-val">Some</span>(<span class="ident">item_index</span>));
                <span class="self">self</span>.<span class="ident">tail</span> <span class="op">=</span> <span class="ident">prev</span>;
            }
        }

        <span class="kw">match</span> <span class="ident">prev</span> {
            <span class="prelude-val">Some</span>(<span class="ident">prev</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">prev</span>.<span class="ident">as_usize</span>()].<span class="ident">next</span> <span class="op">=</span> <span class="ident">next</span>;
            }
            <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="macro">debug_assert_eq!</span>(<span class="self">self</span>.<span class="ident">head</span>, <span class="prelude-val">Some</span>(<span class="ident">item_index</span>));
                <span class="self">self</span>.<span class="ident">head</span> <span class="op">=</span> <span class="ident">next</span>;
            }
        }
    }

    <span class="doccomment">/// Push a new LRU tracking item on to the back of the list, marking</span>
    <span class="doccomment">/// it as the most recent item.</span>
    <span class="kw">fn</span> <span class="ident">push_new</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">handle</span>: <span class="ident">H</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">ItemIndex</span> {
        <span class="comment">// See if there is a slot available in the current free list</span>
        <span class="kw">let</span> <span class="ident">item_index</span> <span class="op">=</span> <span class="kw">match</span> <span class="self">self</span>.<span class="ident">free_list_head</span> {
            <span class="prelude-val">Some</span>(<span class="ident">index</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// Reuse an existing slot</span>
                <span class="kw">let</span> <span class="ident">item</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">index</span>.<span class="ident">as_usize</span>()];

                <span class="macro">assert!</span>(<span class="ident">item</span>.<span class="ident">handle</span>.<span class="ident">is_none</span>());
                <span class="ident">item</span>.<span class="ident">handle</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">handle</span>);

                <span class="self">self</span>.<span class="ident">free_list_head</span> <span class="op">=</span> <span class="ident">item</span>.<span class="ident">next</span>;

                <span class="ident">index</span>
            }
            <span class="prelude-val">None</span> <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// No free slots available, push to the end of the array</span>
                <span class="kw">let</span> <span class="ident">index</span> <span class="op">=</span> <span class="ident">ItemIndex</span>(<span class="ident">num::NonZeroU32::new</span>(<span class="self">self</span>.<span class="ident">items</span>.<span class="ident">len</span>() <span class="kw">as</span> <span class="ident">u32</span>).<span class="ident">unwrap</span>());

                <span class="self">self</span>.<span class="ident">items</span>.<span class="ident">push</span>(<span class="ident">Item</span> {
                    <span class="ident">prev</span>: <span class="prelude-val">None</span>,
                    <span class="ident">next</span>: <span class="prelude-val">None</span>,
                    <span class="ident">handle</span>: <span class="prelude-val">Some</span>(<span class="ident">handle</span>),
                });

                <span class="ident">index</span>
            }
        };

        <span class="comment">// Now link this element into the LRU list</span>
        <span class="self">self</span>.<span class="ident">link_as_new_tail</span>(<span class="ident">item_index</span>);

        <span class="ident">item_index</span>
    }

    <span class="doccomment">/// Remove the oldest element from the front of the LRU list. Returns None</span>
    <span class="doccomment">/// if the list is empty.</span>
    <span class="kw">fn</span> <span class="ident">pop_front</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">H</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="ident">handle</span> <span class="op">=</span> <span class="kw">match</span> (<span class="self">self</span>.<span class="ident">head</span>, <span class="self">self</span>.<span class="ident">tail</span>) {
            (<span class="prelude-val">Some</span>(<span class="ident">head</span>), <span class="prelude-val">Some</span>(<span class="ident">tail</span>)) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="kw">let</span> <span class="ident">item_index</span> <span class="op">=</span> <span class="ident">head</span>;

                <span class="comment">// Head and tail are the same - removing the only element</span>
                <span class="kw">if</span> <span class="ident">head</span> <span class="op">=</span><span class="op">=</span> <span class="ident">tail</span> {
                    <span class="self">self</span>.<span class="ident">head</span> <span class="op">=</span> <span class="prelude-val">None</span>;
                    <span class="self">self</span>.<span class="ident">tail</span> <span class="op">=</span> <span class="prelude-val">None</span>;
                } <span class="kw">else</span> {
                    <span class="comment">// Update the head of the list, popping the first element off</span>
                    <span class="kw">let</span> <span class="ident">new_head</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">head</span>.<span class="ident">as_usize</span>()].<span class="ident">next</span>.<span class="ident">unwrap</span>();
                    <span class="self">self</span>.<span class="ident">head</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">new_head</span>);
                    <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">new_head</span>.<span class="ident">as_usize</span>()].<span class="ident">prev</span> <span class="op">=</span> <span class="prelude-val">None</span>;
                }

                <span class="comment">// Add this item to the freelist for later use</span>
                <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">item_index</span>.<span class="ident">as_usize</span>()].<span class="ident">next</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">free_list_head</span>;
                <span class="self">self</span>.<span class="ident">free_list_head</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">item_index</span>);

                <span class="comment">// Return the handle to the user</span>
                <span class="prelude-val">Some</span>(<span class="self">self</span>.<span class="ident">items</span>[<span class="ident">item_index</span>.<span class="ident">as_usize</span>()].<span class="ident">handle</span>.<span class="ident">take</span>().<span class="ident">unwrap</span>())
            }
            (<span class="prelude-val">None</span>, <span class="prelude-val">None</span>) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// List is empty</span>
                <span class="prelude-val">None</span>
            }
            (<span class="prelude-val">Some</span>(..), <span class="prelude-val">None</span>) <span class="op">|</span> (<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(..)) <span class="op">=</span><span class="op">&gt;</span> {
                <span class="comment">// Invalid state</span>
                <span class="macro">unreachable!</span>();
            }
        };

        <span class="ident">handle</span>
    }

    <span class="doccomment">/// Manually remove an item from the LRU tracking list. This is used</span>
    <span class="doccomment">/// when an element switches from having its lifetime managed by the LRU</span>
    <span class="doccomment">/// algorithm to having a manual eviction policy.</span>
    <span class="kw">fn</span> <span class="ident">remove</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">index</span>: <span class="ident">ItemIndex</span>,
    ) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">H</span> {
        <span class="comment">// Remove from the LRU list</span>
        <span class="self">self</span>.<span class="ident">unlink</span>(<span class="ident">index</span>);

        <span class="kw">let</span> <span class="ident">handle</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">index</span>.<span class="ident">as_usize</span>()].<span class="ident">handle</span>.<span class="ident">take</span>().<span class="ident">unwrap</span>();

        <span class="comment">// Add LRU item to the freelist for future use.</span>
        <span class="self">self</span>.<span class="ident">items</span>[<span class="ident">index</span>.<span class="ident">as_usize</span>()].<span class="ident">next</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">free_list_head</span>;
        <span class="self">self</span>.<span class="ident">free_list_head</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">index</span>);

        <span class="ident">handle</span>
    }

    <span class="doccomment">/// Called to mark that an item was used on this frame. It unlinks the</span>
    <span class="doccomment">/// tracking item, and then re-links it to the back of the list.</span>
    <span class="kw">fn</span> <span class="ident">mark_used</span>(
        <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>,
        <span class="ident">index</span>: <span class="ident">ItemIndex</span>,
    ) {
        <span class="self">self</span>.<span class="ident">unlink</span>(<span class="ident">index</span>);
        <span class="self">self</span>.<span class="ident">link_as_new_tail</span>(<span class="ident">index</span>);
    }

    <span class="doccomment">/// Try to validate that the state of the linked lists are consistent</span>
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
    <span class="kw">fn</span> <span class="ident">validate</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) {
        <span class="kw">use</span> <span class="ident">std::collections::HashSet</span>;

        <span class="comment">// Must have a valid head/tail or be empty</span>
        <span class="macro">assert!</span>((<span class="self">self</span>.<span class="ident">head</span>.<span class="ident">is_none</span>() <span class="op">&amp;&amp;</span> <span class="self">self</span>.<span class="ident">tail</span>.<span class="ident">is_none</span>()) <span class="op">|</span><span class="op">|</span> (<span class="self">self</span>.<span class="ident">head</span>.<span class="ident">is_some</span>() <span class="op">&amp;&amp;</span> <span class="self">self</span>.<span class="ident">tail</span>.<span class="ident">is_some</span>()));

        <span class="comment">// If there is a head, the prev of the head must be none</span>
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">head</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">head</span> {
            <span class="macro">assert!</span>(<span class="self">self</span>.<span class="ident">items</span>[<span class="ident">head</span>.<span class="ident">as_usize</span>()].<span class="ident">prev</span>.<span class="ident">is_none</span>());
        }

        <span class="comment">// If there is a tail, the next of the tail must be none</span>
        <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">tail</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">tail</span> {
            <span class="macro">assert!</span>(<span class="self">self</span>.<span class="ident">items</span>[<span class="ident">tail</span>.<span class="ident">as_usize</span>()].<span class="ident">next</span>.<span class="ident">is_none</span>());
        }

        <span class="comment">// Collect all free and valid items, both in forwards and reverse order</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">free_items</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">free_items_set</span> <span class="op">=</span> <span class="ident">HashSet::new</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">valid_items_front</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">valid_items_front_set</span> <span class="op">=</span> <span class="ident">HashSet::new</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">valid_items_reverse</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">valid_items_reverse_set</span> <span class="op">=</span> <span class="ident">HashSet::new</span>();

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">current</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">free_list_head</span>;
        <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">index</span>) <span class="op">=</span> <span class="ident">current</span> {
            <span class="kw">let</span> <span class="ident">item</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">items</span>[<span class="ident">index</span>.<span class="ident">as_usize</span>()];
            <span class="ident">free_items</span>.<span class="ident">push</span>(<span class="ident">index</span>);
            <span class="macro">assert!</span>(<span class="ident">free_items_set</span>.<span class="ident">insert</span>(<span class="ident">index</span>));
            <span class="ident">current</span> <span class="op">=</span> <span class="ident">item</span>.<span class="ident">next</span>;
        }

        <span class="ident">current</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">head</span>;
        <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">index</span>) <span class="op">=</span> <span class="ident">current</span> {
            <span class="kw">let</span> <span class="ident">item</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">items</span>[<span class="ident">index</span>.<span class="ident">as_usize</span>()];
            <span class="ident">valid_items_front</span>.<span class="ident">push</span>(<span class="ident">index</span>);
            <span class="macro">assert!</span>(<span class="ident">valid_items_front_set</span>.<span class="ident">insert</span>(<span class="ident">index</span>));
            <span class="ident">current</span> <span class="op">=</span> <span class="ident">item</span>.<span class="ident">next</span>;
        }

        <span class="ident">current</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">tail</span>;
        <span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">index</span>) <span class="op">=</span> <span class="ident">current</span> {
            <span class="kw">let</span> <span class="ident">item</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">items</span>[<span class="ident">index</span>.<span class="ident">as_usize</span>()];
            <span class="ident">valid_items_reverse</span>.<span class="ident">push</span>(<span class="ident">index</span>);
            <span class="macro">assert!</span>(<span class="op">!</span><span class="ident">valid_items_reverse_set</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">index</span>));
            <span class="ident">valid_items_reverse_set</span>.<span class="ident">insert</span>(<span class="ident">index</span>);
            <span class="ident">current</span> <span class="op">=</span> <span class="ident">item</span>.<span class="ident">prev</span>;
        }

        <span class="comment">// Ensure set lengths match the vec lengths (should be enforced by the assert check during insert anyway)</span>
        <span class="macro">assert_eq!</span>(<span class="ident">valid_items_front</span>.<span class="ident">len</span>(), <span class="ident">valid_items_front_set</span>.<span class="ident">len</span>());
        <span class="macro">assert_eq!</span>(<span class="ident">valid_items_reverse</span>.<span class="ident">len</span>(), <span class="ident">valid_items_reverse_set</span>.<span class="ident">len</span>());

        <span class="comment">// Length of the array should equal free + valid items count + 1 (dummy entry)</span>
        <span class="macro">assert_eq!</span>(<span class="ident">free_items</span>.<span class="ident">len</span>() <span class="op">+</span> <span class="ident">valid_items_front</span>.<span class="ident">len</span>() <span class="op">+</span> <span class="number">1</span>, <span class="self">self</span>.<span class="ident">items</span>.<span class="ident">len</span>());

        <span class="comment">// Should be same number of items whether iterating forwards or reverse</span>
        <span class="macro">assert_eq!</span>(<span class="ident">valid_items_front</span>.<span class="ident">len</span>(), <span class="ident">valid_items_reverse</span>.<span class="ident">len</span>());

        <span class="comment">// Ensure there are no items considered in the free list that are also in the valid list</span>
        <span class="macro">assert!</span>(<span class="ident">free_items_set</span>.<span class="ident">intersection</span>(<span class="kw-2">&amp;</span><span class="ident">valid_items_reverse_set</span>).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">HashSet</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>().<span class="ident">is_empty</span>());
        <span class="macro">assert!</span>(<span class="ident">free_items_set</span>.<span class="ident">intersection</span>(<span class="kw-2">&amp;</span><span class="ident">valid_items_front_set</span>).<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">HashSet</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>().<span class="ident">is_empty</span>());

        <span class="comment">// Should be the same number of items regardless of iteration direction</span>
        <span class="macro">assert_eq!</span>(<span class="ident">valid_items_front_set</span>.<span class="ident">len</span>(), <span class="ident">valid_items_reverse_set</span>.<span class="ident">len</span>());

        <span class="comment">// Ensure that the ordering is exactly the same, regardless of iteration direction</span>
        <span class="kw">for</span> (<span class="ident">i0</span>, <span class="ident">i1</span>) <span class="kw">in</span> <span class="ident">valid_items_front</span>.<span class="ident">iter</span>().<span class="ident">zip</span>(<span class="ident">valid_items_reverse</span>.<span class="ident">iter</span>().<span class="ident">rev</span>()) {
            <span class="macro">assert_eq!</span>(<span class="ident">i0</span>, <span class="ident">i1</span>);
        }
    }
}

<span class="attribute">#[<span class="ident">test</span>]</span>
<span class="kw">fn</span> <span class="ident">test_lru_tracker_push_pop</span>() {
    <span class="comment">// Push elements, pop them all off and ensure:</span>
    <span class="comment">// - Returned in oldest order</span>
    <span class="comment">// - pop_oldest returns None after last element popped</span>
    <span class="kw">struct</span> <span class="ident">CacheMarker</span>;
    <span class="kw">const</span> <span class="ident">NUM_ELEMENTS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">50</span>;

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span>: <span class="ident">LRUCache</span><span class="op">&lt;</span><span class="ident">usize</span>, <span class="ident">CacheMarker</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">LRUCache::new</span>();
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span> {
        <span class="ident">cache</span>.<span class="ident">push_new</span>(<span class="ident">i</span>);
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">pop_oldest</span>(), <span class="prelude-val">Some</span>(<span class="ident">i</span>));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">pop_oldest</span>(), <span class="prelude-val">None</span>);
}

<span class="attribute">#[<span class="ident">test</span>]</span>
<span class="kw">fn</span> <span class="ident">test_lru_tracker_push_touch_pop</span>() {
    <span class="comment">// Push elements, touch even handles, pop them all off and ensure:</span>
    <span class="comment">// - Returned in correct order</span>
    <span class="comment">// - pop_oldest returns None after last element popped</span>
    <span class="kw">struct</span> <span class="ident">CacheMarker</span>;
    <span class="kw">const</span> <span class="ident">NUM_ELEMENTS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">50</span>;

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span>: <span class="ident">LRUCache</span><span class="op">&lt;</span><span class="ident">usize</span>, <span class="ident">CacheMarker</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">LRUCache::new</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">handles</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span> {
        <span class="ident">handles</span>.<span class="ident">push</span>(<span class="ident">cache</span>.<span class="ident">push_new</span>(<span class="ident">i</span>));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span><span class="op">/</span><span class="number">2</span> {
        <span class="ident">cache</span>.<span class="ident">touch</span>(<span class="kw-2">&amp;</span><span class="ident">handles</span>[<span class="ident">i</span><span class="kw-2">*</span><span class="number">2</span>]);
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span><span class="op">/</span><span class="number">2</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">pop_oldest</span>(), <span class="prelude-val">Some</span>(<span class="ident">i</span><span class="kw-2">*</span><span class="number">2</span><span class="op">+</span><span class="number">1</span>));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span><span class="op">/</span><span class="number">2</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">pop_oldest</span>(), <span class="prelude-val">Some</span>(<span class="ident">i</span><span class="kw-2">*</span><span class="number">2</span>));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">pop_oldest</span>(), <span class="prelude-val">None</span>);
}

<span class="attribute">#[<span class="ident">test</span>]</span>
<span class="kw">fn</span> <span class="ident">test_lru_tracker_push_get</span>() {
    <span class="comment">// Push elements, ensure:</span>
    <span class="comment">// - get access via weak handles works</span>
    <span class="kw">struct</span> <span class="ident">CacheMarker</span>;
    <span class="kw">const</span> <span class="ident">NUM_ELEMENTS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">50</span>;

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span>: <span class="ident">LRUCache</span><span class="op">&lt;</span><span class="ident">usize</span>, <span class="ident">CacheMarker</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">LRUCache::new</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">handles</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span> {
        <span class="ident">handles</span>.<span class="ident">push</span>(<span class="ident">cache</span>.<span class="ident">push_new</span>(<span class="ident">i</span>));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span><span class="op">/</span><span class="number">2</span> {
        <span class="macro">assert!</span>(<span class="ident">cache</span>.<span class="ident">get_opt</span>(<span class="kw-2">&amp;</span><span class="ident">handles</span>[<span class="ident">i</span>]) <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="ident">i</span>));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();
}

<span class="attribute">#[<span class="ident">test</span>]</span>
<span class="kw">fn</span> <span class="ident">test_lru_tracker_push_replace_get</span>() {
    <span class="comment">// Push elements, replace contents, ensure:</span>
    <span class="comment">// - each element was replaced with new data correctly</span>
    <span class="comment">// - replace_or_insert works for invalid handles</span>
    <span class="kw">struct</span> <span class="ident">CacheMarker</span>;
    <span class="kw">const</span> <span class="ident">NUM_ELEMENTS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">50</span>;

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span>: <span class="ident">LRUCache</span><span class="op">&lt;</span><span class="ident">usize</span>, <span class="ident">CacheMarker</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">LRUCache::new</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">handles</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span> {
        <span class="ident">handles</span>.<span class="ident">push</span>(<span class="ident">cache</span>.<span class="ident">push_new</span>(<span class="ident">i</span>));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span> {
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">replace_or_insert</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">handles</span>[<span class="ident">i</span>], <span class="ident">i</span> <span class="op">*</span> <span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="ident">i</span>));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span><span class="op">/</span><span class="number">2</span> {
        <span class="macro">assert!</span>(<span class="ident">cache</span>.<span class="ident">get_opt</span>(<span class="kw-2">&amp;</span><span class="ident">handles</span>[<span class="ident">i</span>]) <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>(<span class="ident">i</span> <span class="op">*</span> <span class="number">2</span>)));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">empty_handle</span> <span class="op">=</span> <span class="ident">WeakFreeListHandle::invalid</span>();
    <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">replace_or_insert</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">empty_handle</span>, <span class="number">100</span>), <span class="prelude-val">None</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">get_opt</span>(<span class="kw-2">&amp;</span><span class="ident">empty_handle</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">100</span>));
}

<span class="attribute">#[<span class="ident">test</span>]</span>
<span class="kw">fn</span> <span class="ident">test_lru_tracker_manual_evict</span>() {
    <span class="comment">// Push elements, set even as manual eviction, ensure:</span>
    <span class="comment">// - correctly pop auto handles in correct order</span>
    <span class="comment">// - correctly remove manual handles, and have expected value</span>
    <span class="kw">struct</span> <span class="ident">CacheMarker</span>;
    <span class="kw">const</span> <span class="ident">NUM_ELEMENTS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">50</span>;

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cache</span>: <span class="ident">LRUCache</span><span class="op">&lt;</span><span class="ident">usize</span>, <span class="ident">CacheMarker</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">LRUCache::new</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">handles</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">manual_handles</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span> {
        <span class="ident">handles</span>.<span class="ident">push</span>(<span class="ident">cache</span>.<span class="ident">push_new</span>(<span class="ident">i</span>));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span><span class="op">/</span><span class="number">2</span> {
        <span class="ident">manual_handles</span>.<span class="ident">push</span>(<span class="ident">cache</span>.<span class="ident">set_manual_eviction</span>(<span class="kw-2">&amp;</span><span class="ident">handles</span>[<span class="ident">i</span><span class="kw-2">*</span><span class="number">2</span>]).<span class="ident">unwrap</span>());
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="ident">NUM_ELEMENTS</span><span class="op">/</span><span class="number">2</span> {
        <span class="macro">assert!</span>(<span class="ident">cache</span>.<span class="ident">pop_oldest</span>() <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">i</span><span class="kw-2">*</span><span class="number">2</span> <span class="op">+</span> <span class="number">1</span>));
    }
    <span class="ident">cache</span>.<span class="ident">validate</span>();

    <span class="macro">assert!</span>(<span class="ident">cache</span>.<span class="ident">pop_oldest</span>().<span class="ident">is_none</span>());

    <span class="kw">for</span> (<span class="ident">i</span>, <span class="ident">manual_handle</span>) <span class="kw">in</span> <span class="ident">manual_handles</span>.<span class="ident">drain</span>(..).<span class="ident">enumerate</span>() {
        <span class="macro">assert_eq!</span>(<span class="kw-2">*</span><span class="ident">cache</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="ident">manual_handle</span>), <span class="ident">i</span><span class="kw-2">*</span><span class="number">2</span>);
        <span class="macro">assert_eq!</span>(<span class="ident">cache</span>.<span class="ident">remove_manual_handle</span>(<span class="ident">manual_handle</span>), <span class="ident">i</span><span class="kw-2">*</span><span class="number">2</span>);
    }
}
</pre></div>
</section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="webrender" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script>
</body></html>