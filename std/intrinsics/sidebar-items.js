initSidebarItems({"struct":[["TyDesc",""]],"fn":[["abort","Abort the execution of the process."],["assume","Inform the optimizer that a condition is always true. If the condition is false, the behavior is undefined."],["atomic_and",""],["atomic_and_acq",""],["atomic_and_acqrel",""],["atomic_and_rel",""],["atomic_and_relaxed",""],["atomic_cxchg",""],["atomic_cxchg_acq",""],["atomic_cxchg_acqrel",""],["atomic_cxchg_rel",""],["atomic_cxchg_relaxed",""],["atomic_fence",""],["atomic_fence_acq",""],["atomic_fence_acqrel",""],["atomic_fence_rel",""],["atomic_load",""],["atomic_load_acq",""],["atomic_load_relaxed",""],["atomic_load_unordered",""],["atomic_max",""],["atomic_max_acq",""],["atomic_max_acqrel",""],["atomic_max_rel",""],["atomic_max_relaxed",""],["atomic_min",""],["atomic_min_acq",""],["atomic_min_acqrel",""],["atomic_min_rel",""],["atomic_min_relaxed",""],["atomic_nand",""],["atomic_nand_acq",""],["atomic_nand_acqrel",""],["atomic_nand_rel",""],["atomic_nand_relaxed",""],["atomic_or",""],["atomic_or_acq",""],["atomic_or_acqrel",""],["atomic_or_rel",""],["atomic_or_relaxed",""],["atomic_store",""],["atomic_store_rel",""],["atomic_store_relaxed",""],["atomic_store_unordered",""],["atomic_umax",""],["atomic_umax_acq",""],["atomic_umax_acqrel",""],["atomic_umax_rel",""],["atomic_umax_relaxed",""],["atomic_umin",""],["atomic_umin_acq",""],["atomic_umin_acqrel",""],["atomic_umin_rel",""],["atomic_umin_relaxed",""],["atomic_xadd",""],["atomic_xadd_acq",""],["atomic_xadd_acqrel",""],["atomic_xadd_rel",""],["atomic_xadd_relaxed",""],["atomic_xchg",""],["atomic_xchg_acq",""],["atomic_xchg_acqrel",""],["atomic_xchg_rel",""],["atomic_xchg_relaxed",""],["atomic_xor",""],["atomic_xor_acq",""],["atomic_xor_acqrel",""],["atomic_xor_rel",""],["atomic_xor_relaxed",""],["atomic_xsub",""],["atomic_xsub_acq",""],["atomic_xsub_acqrel",""],["atomic_xsub_rel",""],["atomic_xsub_relaxed",""],["breakpoint","Execute a breakpoint trap, for inspection by a debugger."],["bswap16","Reverses the bytes in a `u16`."],["bswap32","Reverses the bytes in a `u32`."],["bswap64","Reverses the bytes in a `u64`."],["ceilf32","Returns the smallest integer greater than or equal to an `f32`."],["ceilf64","Returns the smallest integer greater than or equal to an `f64`."],["copy_memory","Copies `count * size_of<T>` bytes from `src` to `dst`. The source and destination may overlap."],["copy_nonoverlapping_memory","Copies `count * size_of<T>` bytes from `src` to `dst`. The source and destination may *not* overlap."],["copysignf32","Copies the sign from `y` to `x` for `f32` values."],["copysignf64","Copies the sign from `y` to `x` for `f64` values."],["cosf32","Returns the cosine of an `f32`."],["cosf64","Returns the cosine of an `f64`."],["ctlz16","Returns the number of leading bits unset in a `u16`."],["ctlz32","Returns the number of leading bits unset in a `u32`."],["ctlz64","Returns the number of leading bits unset in a `u64`."],["ctlz8","Returns the number of leading bits unset in a `u8`."],["ctpop16","Returns the number of bits set in a `u16`."],["ctpop32","Returns the number of bits set in a `u32`."],["ctpop64","Returns the number of bits set in a `u64`."],["ctpop8","Returns the number of bits set in a `u8`."],["cttz16","Returns the number of trailing bits unset in a `u16`."],["cttz32","Returns the number of trailing bits unset in a `u32`."],["cttz64","Returns the number of trailing bits unset in a `u64`."],["cttz8","Returns the number of trailing bits unset in a `u8`."],["exp2f32","Returns 2 raised to the power of an `f32`."],["exp2f64","Returns 2 raised to the power of an `f64`."],["expf32","Returns the exponential of an `f32`."],["expf64","Returns the exponential of an `f64`."],["fabsf32","Returns the absolute value of an `f32`."],["fabsf64","Returns the absolute value of an `f64`."],["floorf32","Returns the largest integer less than or equal to an `f32`."],["floorf64","Returns the largest integer less than or equal to an `f64`."],["fmaf32","Returns `a * b + c` for `f32` values."],["fmaf64","Returns `a * b + c` for `f64` values."],["forget","Move a value out of scope without running drop glue."],["get_tydesc","Get a static pointer to a type descriptor."],["i16_add_with_overflow","Performs checked `i16` addition."],["i16_mul_with_overflow","Performs checked `i16` multiplication."],["i16_sub_with_overflow","Performs checked `i16` subtraction."],["i32_add_with_overflow","Performs checked `i32` addition."],["i32_mul_with_overflow","Performs checked `i32` multiplication."],["i32_sub_with_overflow","Performs checked `i32` subtraction."],["i64_add_with_overflow","Performs checked `i64` addition."],["i64_mul_with_overflow","Performs checked `i64` multiplication."],["i64_sub_with_overflow","Performs checked `i64` subtraction."],["i8_add_with_overflow","Performs checked `i8` addition."],["i8_mul_with_overflow","Performs checked `i8` multiplication."],["i8_sub_with_overflow","Performs checked `i8` subtraction."],["init","Create a value initialized to zero."],["log10f32","Returns the base 10 logarithm of an `f32`."],["log10f64","Returns the base 10 logarithm of an `f64`."],["log2f32","Returns the base 2 logarithm of an `f32`."],["log2f64","Returns the base 2 logarithm of an `f64`."],["logf32","Returns the natural logarithm of an `f32`."],["logf64","Returns the natural logarithm of an `f64`."],["min_align_of",""],["move_val_init","Move a value to an uninitialized memory location."],["nearbyintf32","Returns the nearest integer to an `f32`."],["nearbyintf64","Returns the nearest integer to an `f64`."],["needs_drop","Returns `true` if the actual type given as `T` requires drop glue; returns `false` if the actual type provided for `T` implements `Copy`."],["offset","Calculates the offset from a pointer. The offset *must* be in-bounds of the object, or one-byte-past-the-end. An arithmetic overflow is also undefined behaviour."],["overflowing_add","Returns (a + b) mod 2^N, where N is the width of N in bits."],["overflowing_mul","Returns (a * b) mod 2^N, where N is the width of N in bits."],["overflowing_sub","Returns (a - b) mod 2^N, where N is the width of N in bits."],["owns_managed","Returns `true` if a type is managed (will be allocated on the local heap)"],["powf32","Raises an `f32` to an `f32` power."],["powf64","Raises an `f64` to an `f64` power."],["powif32","Raises an `f32` to an integer power."],["powif64","Raises an `f64` to an integer power."],["pref_align_of",""],["return_address","Gives the address for the return value of the enclosing function."],["rintf32","Returns the nearest integer to an `f32`. May raise an inexact floating-point exception if the argument is not an integer."],["rintf64","Returns the nearest integer to an `f64`. May raise an inexact floating-point exception if the argument is not an integer."],["roundf32","Returns the nearest integer to an `f32`. Rounds half-way cases away from zero."],["roundf64","Returns the nearest integer to an `f64`. Rounds half-way cases away from zero."],["set_memory","Invokes memset on the specified pointer, setting `count * size_of::<T>()` bytes of memory starting at `dst` to `c`."],["sinf32","Returns the sine of an `f32`."],["sinf64","Returns the sine of an `f64`."],["size_of","The size of a type in bytes."],["sqrtf32","Returns the square root of an `f32`"],["sqrtf64","Returns the square root of an `f64`"],["transmute","Unsafely transforms a value of one type into a value of another type."],["truncf32","Returns the integer part of an `f32`."],["truncf64","Returns the integer part of an `f64`."],["type_id","Gets an identifier which is globally unique to the specified type. This function will return the same value for a type regardless of whichever crate it is invoked in."],["u16_add_with_overflow","Performs checked `u16` addition."],["u16_mul_with_overflow","Performs checked `u16` multiplication."],["u16_sub_with_overflow","Performs checked `u16` subtraction."],["u32_add_with_overflow","Performs checked `u32` addition."],["u32_mul_with_overflow","Performs checked `u32` multiplication."],["u32_sub_with_overflow","Performs checked `u32` subtraction."],["u64_add_with_overflow","Performs checked `u64` addition."],["u64_mul_with_overflow","Performs checked `u64` multiplication."],["u64_sub_with_overflow","Performs checked `u64` subtraction."],["u8_add_with_overflow","Performs checked `u8` addition."],["u8_mul_with_overflow","Performs checked `u8` multiplication."],["u8_sub_with_overflow","Performs checked `u8` subtraction."],["uninit","Create an uninitialized value."],["unreachable","Tell LLVM that this point in the code is not reachable, enabling further optimizations."],["volatile_copy_memory","Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with a size of `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`"],["volatile_copy_nonoverlapping_memory","Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with a size of `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`"],["volatile_load","Perform a volatile load from the `src` pointer."],["volatile_set_memory","Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a size of `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`."],["volatile_store","Perform a volatile store to the `dst` pointer."]],"type":[["GlueFn",""]]});