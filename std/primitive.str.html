<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="String slices."><meta name="keywords" content="rust, rustlang, rust-lang, str"><title>str - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize1.60.0.css"><link rel="stylesheet" type="text/css" href="../rustdoc1.60.0.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu1.60.0.css" disabled><link rel="stylesheet" type="text/css" href="../dark1.60.0.css" disabled><link rel="stylesheet" type="text/css" href="../light1.60.0.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage1.60.0.js"></script><script src="../crates1.60.0.js"></script><script defer src="../main1.60.0.js"></script>
    <noscript><link rel="stylesheet" href="../noscript1.60.0.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x161.60.0.png"><link rel="alternate icon" type="image/png" href="../favicon-32x321.60.0.png"><link rel="icon" type="image/svg+xml" href="../favicon1.60.0.svg"></head><body class="rustdoc primitive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../std/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo1.60.0.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../std/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo1.60.0.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">str</a></h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.as_bytes">as_bytes</a><a href="#method.as_bytes_mut">as_bytes_mut</a><a href="#method.as_mut_ptr">as_mut_ptr</a><a href="#method.as_ptr">as_ptr</a><a href="#method.bytes">bytes</a><a href="#method.char_indices">char_indices</a><a href="#method.chars">chars</a><a href="#method.contains">contains</a><a href="#method.encode_utf16">encode_utf16</a><a href="#method.ends_with">ends_with</a><a href="#method.eq_ignore_ascii_case">eq_ignore_ascii_case</a><a href="#method.escape_debug">escape_debug</a><a href="#method.escape_default">escape_default</a><a href="#method.escape_unicode">escape_unicode</a><a href="#method.find">find</a><a href="#method.get">get</a><a href="#method.get_mut">get_mut</a><a href="#method.get_unchecked">get_unchecked</a><a href="#method.get_unchecked_mut">get_unchecked_mut</a><a href="#method.into_boxed_bytes">into_boxed_bytes</a><a href="#method.into_string">into_string</a><a href="#method.is_ascii">is_ascii</a><a href="#method.is_char_boundary">is_char_boundary</a><a href="#method.is_empty">is_empty</a><a href="#method.len">len</a><a href="#method.lines">lines</a><a href="#method.lines_any">lines_any</a><a href="#method.make_ascii_lowercase">make_ascii_lowercase</a><a href="#method.make_ascii_uppercase">make_ascii_uppercase</a><a href="#method.match_indices">match_indices</a><a href="#method.matches">matches</a><a href="#method.parse">parse</a><a href="#method.repeat">repeat</a><a href="#method.replace">replace</a><a href="#method.replacen">replacen</a><a href="#method.rfind">rfind</a><a href="#method.rmatch_indices">rmatch_indices</a><a href="#method.rmatches">rmatches</a><a href="#method.rsplit">rsplit</a><a href="#method.rsplit_once">rsplit_once</a><a href="#method.rsplit_terminator">rsplit_terminator</a><a href="#method.rsplitn">rsplitn</a><a href="#method.slice_mut_unchecked">slice_mut_unchecked</a><a href="#method.slice_unchecked">slice_unchecked</a><a href="#method.split">split</a><a href="#method.split_ascii_whitespace">split_ascii_whitespace</a><a href="#method.split_at">split_at</a><a href="#method.split_at_mut">split_at_mut</a><a href="#method.split_inclusive">split_inclusive</a><a href="#method.split_once">split_once</a><a href="#method.split_terminator">split_terminator</a><a href="#method.split_whitespace">split_whitespace</a><a href="#method.splitn">splitn</a><a href="#method.starts_with">starts_with</a><a href="#method.strip_prefix">strip_prefix</a><a href="#method.strip_suffix">strip_suffix</a><a href="#method.to_ascii_lowercase">to_ascii_lowercase</a><a href="#method.to_ascii_uppercase">to_ascii_uppercase</a><a href="#method.to_lowercase">to_lowercase</a><a href="#method.to_uppercase">to_uppercase</a><a href="#method.trim">trim</a><a href="#method.trim_end">trim_end</a><a href="#method.trim_end_matches">trim_end_matches</a><a href="#method.trim_left">trim_left</a><a href="#method.trim_left_matches">trim_left_matches</a><a href="#method.trim_matches">trim_matches</a><a href="#method.trim_right">trim_right</a><a href="#method.trim_right_matches">trim_right_matches</a><a href="#method.trim_start">trim_start</a><a href="#method.trim_start_matches">trim_start_matches</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Add%3C%26%27_%20str%3E">Add&lt;&amp;&#39;_ str&gt;</a><a href="#impl-Add%3C%26%27a%20str%3E">Add&lt;&amp;&#39;a str&gt;</a><a href="#impl-AddAssign%3C%26%27_%20str%3E">AddAssign&lt;&amp;&#39;_ str&gt;</a><a href="#impl-AddAssign%3C%26%27a%20str%3E">AddAssign&lt;&amp;&#39;a str&gt;</a><a href="#impl-AsMut%3Cstr%3E">AsMut&lt;str&gt;</a><a href="#impl-AsRef%3C%5Bu8%5D%3E">AsRef&lt;[u8]&gt;</a><a href="#impl-AsRef%3COsStr%3E">AsRef&lt;OsStr&gt;</a><a href="#impl-AsRef%3CPath%3E">AsRef&lt;Path&gt;</a><a href="#impl-AsRef%3Cstr%3E">AsRef&lt;str&gt;</a><a href="#impl-AsciiExt">AsciiExt</a><a href="#impl-Borrow%3Cstr%3E">Borrow&lt;str&gt;</a><a href="#impl-BorrowMut%3Cstr%3E">BorrowMut&lt;str&gt;</a><a href="#impl-Concat%3Cstr%3E">Concat&lt;str&gt;</a><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-Display">Display</a><a href="#impl-Eq">Eq</a><a href="#impl-Extend%3C%26%27a%20str%3E">Extend&lt;&amp;&#39;a str&gt;</a><a href="#impl-From%3C%26%27_%20mut%20str%3E">From&lt;&amp;&#39;_ mut str&gt;</a><a href="#impl-From%3C%26%27_%20str%3E">From&lt;&amp;&#39;_ str&gt;</a><a href="#impl-From%3C%26%27a%20str%3E">From&lt;&amp;&#39;a str&gt;</a><a href="#impl-FromIterator%3C%26%27a%20str%3E">FromIterator&lt;&amp;&#39;a str&gt;</a><a href="#impl-FromIterator%3C%26%27b%20str%3E">FromIterator&lt;&amp;&#39;b str&gt;</a><a href="#impl-Hash">Hash</a><a href="#impl-Index%3CI%3E">Index&lt;I&gt;</a><a href="#impl-IndexMut%3CI%3E">IndexMut&lt;I&gt;</a><a href="#impl-Join%3C%26%27_%20str%3E">Join&lt;&amp;&#39;_ str&gt;</a><a href="#impl-Ord">Ord</a><a href="#impl-PartialEq%3C%26%27_%20str%3E">PartialEq&lt;&amp;&#39;_ str&gt;</a><a href="#impl-PartialEq%3C%26%27a%20str%3E">PartialEq&lt;&amp;&#39;a str&gt;</a><a href="#impl-PartialEq%3C%26%27b%20str%3E">PartialEq&lt;&amp;&#39;b str&gt;</a><a href="#impl-PartialEq%3CCow%3C%27a%2C%20str%3E%3E">PartialEq&lt;Cow&lt;&#39;a, str&gt;&gt;</a><a href="#impl-PartialEq%3COsStr%3E">PartialEq&lt;OsStr&gt;</a><a href="#impl-PartialEq%3COsString%3E">PartialEq&lt;OsString&gt;</a><a href="#impl-PartialEq%3CString%3E">PartialEq&lt;String&gt;</a><a href="#impl-PartialEq%3Cstr%3E">PartialEq&lt;str&gt;</a><a href="#impl-PartialOrd%3Cstr%3E">PartialOrd&lt;str&gt;</a><a href="#impl-Pattern%3C%27a%3E">Pattern&lt;&#39;a&gt;</a><a href="#impl-SliceIndex%3Cstr%3E">SliceIndex&lt;str&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-ToSocketAddrs">ToSocketAddrs</a><a href="#impl-ToString">ToString</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sized">!Sized</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-ToString">ToString</a></div></div><h2 class="location">In <a href="index.html">std</a></h2><div id="sidebar-vars" data-name="str" data-ty="primitive" data-relpath=""></div><script defer src="sidebar-items1.60.0.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../std/index.html"><img class="rust-logo" src="../rust-logo1.60.0.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush1.60.0.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div>
                                <input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel1.60.0.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Primitive Type <a class="primitive" href="#">str</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard1.60.0.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span>Â· <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>String slices.</p>
<p><em><a href="str/index.html">See also the <code>std::str</code> module</a>.</em></p>
<p>The <code>str</code> type, also called a â€˜string sliceâ€™, is the most primitive string
type. It is usually seen in its borrowed form, <code>&amp;str</code>. It is also the type
of string literals, <code>&amp;'static str</code>.</p>
<p>String slices are always valid UTF-8.</p>
<h2 id="examples" class="section-header"><a href="#examples">Examples</a></h2>
<p>String literals are string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">hello</span> <span class="op">=</span> <span class="string">&quot;Hello, world!&quot;</span>;

<span class="comment">// with an explicit type annotation</span>
<span class="kw">let</span> <span class="ident">hello</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span> <span class="op">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20hello%20%3D%20%22Hello%2C%20world!%22%3B%0A%0A%2F%2F%20with%20an%20explicit%20type%20annotation%0Alet%20hello%3A%20%26'static%20str%20%3D%20%22Hello%2C%20world!%22%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>They are <code>'static</code> because theyâ€™re stored directly in the final binary, and
so will be valid for the <code>'static</code> duration.</p>
<h2 id="representation" class="section-header"><a href="#representation">Representation</a></h2>
<p>A <code>&amp;str</code> is made up of two components: a pointer to some bytes, and a
length. You can look at these with the <a href="primitive.str.html#method.as_ptr"><code>as_ptr</code></a> and <a href="primitive.str.html#method.len"><code>len</code></a> methods:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::slice</span>;
<span class="kw">use</span> <span class="ident">std::str</span>;

<span class="kw">let</span> <span class="ident">story</span> <span class="op">=</span> <span class="string">&quot;Once upon a time...&quot;</span>;

<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">story</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="ident">story</span>.<span class="ident">len</span>();

<span class="comment">// story has nineteen bytes</span>
<span class="macro">assert_eq!</span>(<span class="number">19</span>, <span class="ident">len</span>);

<span class="comment">// We can re-build a str out of ptr and len. This is all unsafe because</span>
<span class="comment">// we are responsible for making sure the two components are valid:</span>
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="comment">// First, we build a &amp;[u8]...</span>
    <span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="ident">slice::from_raw_parts</span>(<span class="ident">ptr</span>, <span class="ident">len</span>);

    <span class="comment">// ... and then convert that slice into a string slice</span>
    <span class="ident">str::from_utf8</span>(<span class="ident">slice</span>)
};

<span class="macro">assert_eq!</span>(<span class="ident">s</span>, <span class="prelude-val">Ok</span>(<span class="ident">story</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aslice%3B%0Ause%20std%3A%3Astr%3B%0A%0Alet%20story%20%3D%20%22Once%20upon%20a%20time...%22%3B%0A%0Alet%20ptr%20%3D%20story.as_ptr()%3B%0Alet%20len%20%3D%20story.len()%3B%0A%0A%2F%2F%20story%20has%20nineteen%20bytes%0Aassert_eq!(19%2C%20len)%3B%0A%0A%2F%2F%20We%20can%20re-build%20a%20str%20out%20of%20ptr%20and%20len.%20This%20is%20all%20unsafe%20because%0A%2F%2F%20we%20are%20responsible%20for%20making%20sure%20the%20two%20components%20are%20valid%3A%0Alet%20s%20%3D%20unsafe%20%7B%0A%20%20%20%20%2F%2F%20First%2C%20we%20build%20a%20%26%5Bu8%5D...%0A%20%20%20%20let%20slice%20%3D%20slice%3A%3Afrom_raw_parts(ptr%2C%20len)%3B%0A%0A%20%20%20%20%2F%2F%20...%20and%20then%20convert%20that%20slice%20into%20a%20string%20slice%0A%20%20%20%20str%3A%3Afrom_utf8(slice)%0A%7D%3B%0A%0Aassert_eq!(s%2C%20Ok(story))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Note: This example shows the internals of <code>&amp;str</code>. <code>unsafe</code> should not be
used to get a string slice under normal circumstances. Use <code>as_str</code>
instead.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#122-2469" title="goto source code">source</a></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.len" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#145" title="goto source code">source</a></div><a href="#method.len" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="primitive.usize.html">usize</a></h4></div></summary><div class="docblock"><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not <a href="primitive.char.html"><code>char</code></a>s or graphemes. In other words,
it might not be what a human considers the length of the string.</p>
<h5 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="string">&quot;foo&quot;</span>.<span class="ident">len</span>();
<span class="macro">assert_eq!</span>(<span class="number">3</span>, <span class="ident">len</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;Æ’oo&quot;</span>.<span class="ident">len</span>(), <span class="number">4</span>); <span class="comment">// fancy f!</span>
<span class="macro">assert_eq!</span>(<span class="string">&quot;Æ’oo&quot;</span>.<span class="ident">chars</span>().<span class="ident">count</span>(), <span class="number">3</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20len%20%3D%20%22foo%22.len()%3B%0Aassert_eq!(3%2C%20len)%3B%0A%0Aassert_eq!(%22%C6%92oo%22.len()%2C%204)%3B%20%2F%2F%20fancy%20f!%0Aassert_eq!(%22%C6%92oo%22.chars().count()%2C%203)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.is_empty" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#166" title="goto source code">source</a></div><a href="#method.is_empty" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h5 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>;
<span class="macro">assert!</span>(<span class="ident">s</span>.<span class="ident">is_empty</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;not empty&quot;</span>;
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_empty</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%22%3B%0Aassert!(s.is_empty())%3B%0A%0Alet%20s%20%3D%20%22not%20empty%22%3B%0Aassert!(!s.is_empty())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.is_char_boundary" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#196" title="goto source code">source</a></div><a href="#method.is_char_boundary" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_char_boundary" class="fnname">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point
sequence or the end of the string.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h5 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="macro">assert!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">0</span>));
<span class="comment">// start of `è€`</span>
<span class="macro">assert!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">6</span>));
<span class="macro">assert!</span>(<span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="ident">s</span>.<span class="ident">len</span>()));

<span class="comment">// second byte of `Ã¶`</span>
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">2</span>));

<span class="comment">// third byte of `è€`</span>
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">s</span>.<span class="ident">is_char_boundary</span>(<span class="number">8</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0Aassert!(s.is_char_boundary(0))%3B%0A%2F%2F%20start%20of%20%60%E8%80%81%60%0Aassert!(s.is_char_boundary(6))%3B%0Aassert!(s.is_char_boundary(s.len()))%3B%0A%0A%2F%2F%20second%20byte%20of%20%60%C3%B6%60%0Aassert!(!s.is_char_boundary(2))%3B%0A%0A%2F%2F%20third%20byte%20of%20%60%E8%80%81%60%0Aassert!(!s.is_char_boundary(8))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_bytes" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.39.0">1.0.0 (const: 1.39.0)</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#238" title="goto source code">source</a></div><a href="#method.as_bytes" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.as_bytes" class="fnname">as_bytes</a>(&amp;self) -&gt; <a class="primitive" href="primitive.slice.html">&amp;[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a><span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="primitive" href="primitive.slice.html">&amp;[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></div><code class="content"><span class="where fmt-newline">impl <a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="primitive.slice.html">&amp;[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></span><span class="where fmt-newline">impl <a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="primitive.slice.html">&amp;mut [</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Converts a string slice to a byte slice. To convert the byte slice back
into a string slice, use the <a href="str/fn.from_utf8.html" title="from_utf8"><code>from_utf8</code></a> function.</p>
<h5 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">&quot;bors&quot;</span>.<span class="ident">as_bytes</span>();
<span class="macro">assert_eq!</span>(<span class="string">b&quot;bors&quot;</span>, <span class="ident">bytes</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20bytes%20%3D%20%22bors%22.as_bytes()%3B%0Aassert_eq!(b%22bors%22%2C%20bytes)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_bytes_mut" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#282" title="goto source code">source</a></div><a href="#method.as_bytes_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.as_bytes_mut" class="fnname">as_bytes_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.slice.html">&amp;mut [</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a><span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="primitive" href="primitive.slice.html">&amp;[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></div><code class="content"><span class="where fmt-newline">impl <a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="primitive.slice.html">&amp;[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></span><span class="where fmt-newline">impl <a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="primitive.slice.html">&amp;mut [</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Converts a mutable string slice to a mutable byte slice.</p>
<h5 id="safety" class="section-header"><a href="#safety">Safety</a></h5>
<p>The caller must ensure that the content of the slice is valid UTF-8
before the borrow ends and the underlying <code>str</code> is used.</p>
<p>Use of a <code>str</code> whose contents are not valid UTF-8 is undefined behavior.</p>
<h5 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;Hello&quot;</span>);
<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">s</span>.<span class="ident">as_bytes_mut</span>() };

<span class="macro">assert_eq!</span>(<span class="string">b&quot;Hello&quot;</span>, <span class="ident">bytes</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20String%3A%3Afrom(%22Hello%22)%3B%0Alet%20bytes%20%3D%20unsafe%20%7B%20s.as_bytes_mut()%20%7D%3B%0A%0Aassert_eq!(b%22Hello%22%2C%20bytes)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Mutability:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;ğŸ—»âˆˆğŸŒ&quot;</span>);

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_bytes_mut</span>();

    <span class="ident">bytes</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">0xF0</span>;
    <span class="ident">bytes</span>[<span class="number">1</span>] <span class="op">=</span> <span class="number">0x9F</span>;
    <span class="ident">bytes</span>[<span class="number">2</span>] <span class="op">=</span> <span class="number">0x8D</span>;
    <span class="ident">bytes</span>[<span class="number">3</span>] <span class="op">=</span> <span class="number">0x94</span>;
}

<span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸ”âˆˆğŸŒ&quot;</span>, <span class="ident">s</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20String%3A%3Afrom(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22)%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20let%20bytes%20%3D%20s.as_bytes_mut()%3B%0A%0A%20%20%20%20bytes%5B0%5D%20%3D%200xF0%3B%0A%20%20%20%20bytes%5B1%5D%20%3D%200x9F%3B%0A%20%20%20%20bytes%5B2%5D%20%3D%200x8D%3B%0A%20%20%20%20bytes%5B3%5D%20%3D%200x94%3B%0A%7D%0A%0Aassert_eq!(%22%F0%9F%8D%94%E2%88%88%F0%9F%8C%8F%22%2C%20s)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ptr" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const since 1.32.0">1.0.0 (const: 1.32.0)</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#313" title="goto source code">source</a></div><a href="#method.as_ptr" class="anchor"></a><h4 class="code-header">pub const fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.u8.html">u8</a></h4></div></summary><div class="docblock"><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html" title="u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>The caller must ensure that the returned pointer is never written to.
If you need to mutate the contents of the string slice, use <a href="primitive.str.html#method.as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<h5 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Hello&quot;</span>;
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">as_ptr</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22Hello%22%3B%0Alet%20ptr%20%3D%20s.as_ptr()%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_mut_ptr" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#328" title="goto source code">source</a></div><a href="#method.as_mut_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.u8.html">u8</a></h4></div></summary><div class="docblock"><p>Converts a mutable string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="primitive.u8.html" title="u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>It is your responsibility to make sure that the string slice only gets
modified in a way that it remains valid UTF-8.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#353" title="goto source code">source</a></div><a href="#method.get" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get" class="fnname">get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="option/enum.Option.html#variant.None" title="None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;ğŸ—»âˆˆğŸŒ&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;ğŸ—»&quot;</span>), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">0</span>..<span class="number">4</span>));

<span class="comment">// indices not on UTF-8 sequence boundaries</span>
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">get</span>(<span class="number">1</span>..).<span class="ident">is_none</span>());
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">get</span>(..<span class="number">8</span>).<span class="ident">is_none</span>());

<span class="comment">// out of bounds</span>
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">get</span>(..<span class="number">42</span>).<span class="ident">is_none</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%20%3D%20String%3A%3Afrom(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22)%3B%0A%0Aassert_eq!(Some(%22%F0%9F%97%BB%22)%2C%20v.get(0..4))%3B%0A%0A%2F%2F%20indices%20not%20on%20UTF-8%20sequence%20boundaries%0Aassert!(v.get(1..).is_none())%3B%0Aassert!(v.get(..8).is_none())%3B%0A%0A%2F%2F%20out%20of%20bounds%0Aassert!(v.get(..42).is_none())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_mut" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#385" title="goto source code">source</a></div><a href="#method.get_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fnname">get_mut</a>&lt;I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;i: I<br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns a mutable subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="option/enum.Option.html#variant.None" title="None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;hello&quot;</span>);
<span class="comment">// correct length</span>
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">get_mut</span>(<span class="number">0</span>..<span class="number">5</span>).<span class="ident">is_some</span>());
<span class="comment">// out of bounds</span>
<span class="macro">assert!</span>(<span class="ident">v</span>.<span class="ident">get_mut</span>(..<span class="number">42</span>).<span class="ident">is_none</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;he&quot;</span>), <span class="ident">v</span>.<span class="ident">get_mut</span>(<span class="number">0</span>..<span class="number">2</span>).<span class="ident">map</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">v</span>));

<span class="macro">assert_eq!</span>(<span class="string">&quot;hello&quot;</span>, <span class="ident">v</span>);
{
    <span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">get_mut</span>(<span class="number">0</span>..<span class="number">2</span>);
    <span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">s</span><span class="op">|</span> {
        <span class="ident">s</span>.<span class="ident">make_ascii_uppercase</span>();
        <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">s</span>
    });
    <span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;HE&quot;</span>), <span class="ident">s</span>);
}
<span class="macro">assert_eq!</span>(<span class="string">&quot;HEllo&quot;</span>, <span class="ident">v</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20String%3A%3Afrom(%22hello%22)%3B%0A%2F%2F%20correct%20length%0Aassert!(v.get_mut(0..5).is_some())%3B%0A%2F%2F%20out%20of%20bounds%0Aassert!(v.get_mut(..42).is_none())%3B%0Aassert_eq!(Some(%22he%22)%2C%20v.get_mut(0..2).map(%7Cv%7C%20%26*v))%3B%0A%0Aassert_eq!(%22hello%22%2C%20v)%3B%0A%7B%0A%20%20%20%20let%20s%20%3D%20v.get_mut(0..2)%3B%0A%20%20%20%20let%20s%20%3D%20s.map(%7Cs%7C%20%7B%0A%20%20%20%20%20%20%20%20s.make_ascii_uppercase()%3B%0A%20%20%20%20%20%20%20%20%26*s%0A%20%20%20%20%7D)%3B%0A%20%20%20%20assert_eq!(Some(%22HE%22)%2C%20s)%3B%0A%7D%0Aassert_eq!(%22HEllo%22%2C%20v)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#417" title="goto source code">source</a></div><a href="#method.get_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns an unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="string">&quot;ğŸ—»âˆˆğŸŒ&quot;</span>;
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸ—»&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;âˆˆ&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸŒ&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked</span>(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%20%3D%20%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22%3B%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(%22%F0%9F%97%BB%22%2C%20v.get_unchecked(0..4))%3B%0A%20%20%20%20assert_eq!(%22%E2%88%88%22%2C%20v.get_unchecked(4..7))%3B%0A%20%20%20%20assert_eq!(%22%F0%9F%8C%8F%22%2C%20v.get_unchecked(7..11))%3B%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked_mut" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#452" title="goto source code">source</a></div><a href="#method.get_unchecked_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;i: I<br>) -&gt; &amp;mut &lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns a mutable, unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety-2" class="section-header"><a href="#safety-2">Safety</a></h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;ğŸ—»âˆˆğŸŒ&quot;</span>);
<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸ—»&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;âˆˆ&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸŒ&quot;</span>, <span class="ident">v</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20v%20%3D%20String%3A%3Afrom(%22%F0%9F%97%BB%E2%88%88%F0%9F%8C%8F%22)%3B%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(%22%F0%9F%97%BB%22%2C%20v.get_unchecked_mut(0..4))%3B%0A%20%20%20%20assert_eq!(%22%E2%88%88%22%2C%20v.get_unchecked_mut(4..7))%3B%0A%20%20%20%20assert_eq!(%22%F0%9F%8C%8F%22%2C%20v.get_unchecked_mut(7..11))%3B%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.slice_unchecked" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#505" title="goto source code">source</a></div><a href="#method.slice_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.slice_unchecked" class="fnname">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="primitive.usize.html">usize</a>, end: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></div><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.29.0: <p>use <code>get_unchecked(begin..end)</code> instead</p>
</div></div></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="primitive.str.html" title="str"><code>str</code></a> and <a href="ops/trait.Index.html"><code>Index</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="primitive.str.html#method.slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h5 id="safety-3" class="section-header"><a href="#safety-3">Safety</a></h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h5 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>, <span class="ident">s</span>.<span class="ident">slice_unchecked</span>(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Hello, world!&quot;</span>;

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq!</span>(<span class="string">&quot;world&quot;</span>, <span class="ident">s</span>.<span class="ident">slice_unchecked</span>(<span class="number">7</span>, <span class="number">12</span>));
}</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%2C%20s.slice_unchecked(0%2C%2021))%3B%0A%7D%0A%0Alet%20s%20%3D%20%22Hello%2C%20world!%22%3B%0A%0Aunsafe%20%7B%0A%20%20%20%20assert_eq!(%22world%22%2C%20s.slice_unchecked(7%2C%2012))%3B%0A%7D%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.slice_mut_unchecked" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#538" title="goto source code">source</a></div><a href="#method.slice_mut_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.slice_mut_unchecked" class="fnname">slice_mut_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;begin: <a class="primitive" href="primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;end: <a class="primitive" href="primitive.usize.html">usize</a><br>) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></div><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.29.0: <p>use <code>get_unchecked_mut(begin..end)</code> instead</p>
</div></div></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.
This is generally not recommended, use with caution! For a safe
alternative see <a href="primitive.str.html" title="str"><code>str</code></a> and <a href="ops/trait.IndexMut.html"><code>IndexMut</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get an immutable string slice instead, see the
<a href="primitive.str.html#method.slice_unchecked"><code>slice_unchecked</code></a> method.</p>
<h5 id="safety-4" class="section-header"><a href="#safety-4">Safety</a></h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.split_at" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#578" title="goto source code">source</a></div><a href="#method.split_at" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.tuple.html">(</a>&amp;<a class="primitive" href="primitive.str.html">str</a>, &amp;<a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a></h4></div></summary><div class="docblock"><p>Divide one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="primitive.str.html#method.split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h5 id="panics" class="section-header"><a href="#panics">Panics</a></h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is
past the end of the last code point of the string slice.</p>
<h5 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Per Martin-LÃ¶f&quot;</span>;

<span class="kw">let</span> (<span class="ident">first</span>, <span class="ident">last</span>) <span class="op">=</span> <span class="ident">s</span>.<span class="ident">split_at</span>(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;Per&quot;</span>, <span class="ident">first</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot; Martin-LÃ¶f&quot;</span>, <span class="ident">last</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22Per%20Martin-L%C3%B6f%22%3B%0A%0Alet%20(first%2C%20last)%20%3D%20s.split_at(3)%3B%0A%0Aassert_eq!(%22Per%22%2C%20first)%3B%0Aassert_eq!(%22%20Martin-L%C3%B6f%22%2C%20last)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.split_at_mut" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#622" title="goto source code">source</a></div><a href="#method.split_at_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="primitive.tuple.html">(</a>&amp;mut <a class="primitive" href="primitive.str.html">str</a>, &amp;mut <a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a></h4></div></summary><div class="docblock"><p>Divide one mutable string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get immutable string slices instead, see the <a href="primitive.str.html#method.split_at"><code>split_at</code></a> method.</p>
<h5 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is
past the end of the last code point of the string slice.</p>
<h5 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;Per Martin-LÃ¶f&quot;</span>.<span class="ident">to_string</span>();
{
    <span class="kw">let</span> (<span class="ident">first</span>, <span class="ident">last</span>) <span class="op">=</span> <span class="ident">s</span>.<span class="ident">split_at_mut</span>(<span class="number">3</span>);
    <span class="ident">first</span>.<span class="ident">make_ascii_uppercase</span>();
    <span class="macro">assert_eq!</span>(<span class="string">&quot;PER&quot;</span>, <span class="ident">first</span>);
    <span class="macro">assert_eq!</span>(<span class="string">&quot; Martin-LÃ¶f&quot;</span>, <span class="ident">last</span>);
}
<span class="macro">assert_eq!</span>(<span class="string">&quot;PER Martin-LÃ¶f&quot;</span>, <span class="ident">s</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20%22Per%20Martin-L%C3%B6f%22.to_string()%3B%0A%7B%0A%20%20%20%20let%20(first%2C%20last)%20%3D%20s.split_at_mut(3)%3B%0A%20%20%20%20first.make_ascii_uppercase()%3B%0A%20%20%20%20assert_eq!(%22PER%22%2C%20first)%3B%0A%20%20%20%20assert_eq!(%22%20Martin-L%C3%B6f%22%2C%20last)%3B%0A%7D%0Aassert_eq!(%22PER%20Martin-L%C3%B6f%22%2C%20s)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.chars" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#688" title="goto source code">source</a></div><a href="#method.chars" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.chars" class="fnname">chars</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Chars.html" title="struct std::str::Chars">Chars</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.Chars.html" title="struct std::str::Chars">Chars</a>&lt;'a&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.Chars.html" title="struct std::str::Chars">Chars</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.char.html">char</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Returns an iterator over the <a href="primitive.char.html"><code>char</code></a>s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html"><code>char</code></a>. This method returns such an iterator.</p>
<p>Itâ€™s important to remember that <a href="primitive.char.html"><code>char</code></a> represents a Unicode Scalar
Value, and might not match your idea of what a â€˜characterâ€™ is. Iteration
over grapheme clusters may be what you actually want. This functionality
is not provided by Rustâ€™s standard library, check crates.io instead.</p>
<h5 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">chars</span>().<span class="ident">count</span>();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, <span class="ident">count</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">chars</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;g&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;d&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;b&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;e&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">chars</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20word%20%3D%20%22goodbye%22%3B%0A%0Alet%20count%20%3D%20word.chars().count()%3B%0Aassert_eq!(7%2C%20count)%3B%0A%0Alet%20mut%20chars%20%3D%20word.chars()%3B%0A%0Aassert_eq!(Some('g')%2C%20chars.next())%3B%0Aassert_eq!(Some('o')%2C%20chars.next())%3B%0Aassert_eq!(Some('o')%2C%20chars.next())%3B%0Aassert_eq!(Some('d')%2C%20chars.next())%3B%0Aassert_eq!(Some('b')%2C%20chars.next())%3B%0Aassert_eq!(Some('y')%2C%20chars.next())%3B%0Aassert_eq!(Some('e')%2C%20chars.next())%3B%0A%0Aassert_eq!(None%2C%20chars.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Remember, <a href="primitive.char.html"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="string">&quot;yÌ†&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">chars</span> <span class="op">=</span> <span class="ident">y</span>.<span class="ident">chars</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>()); <span class="comment">// not &#39;yÌ†&#39;</span>
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;\u{0306}&#39;</span>), <span class="ident">chars</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">chars</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20y%20%3D%20%22y%CC%86%22%3B%0A%0Alet%20mut%20chars%20%3D%20y.chars()%3B%0A%0Aassert_eq!(Some('y')%2C%20chars.next())%3B%20%2F%2F%20not%20'y%CC%86'%0Aassert_eq!(Some('%5Cu%7B0306%7D')%2C%20chars.next())%3B%0A%0Aassert_eq!(None%2C%20chars.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.char_indices" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#745" title="goto source code">source</a></div><a href="#method.char_indices" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.char_indices" class="fnname">char_indices</a>(&amp;self) -&gt; <a class="struct" href="str/struct.CharIndices.html" title="struct std::str::CharIndices">CharIndices</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.CharIndices.html" title="struct std::str::CharIndices">CharIndices</a>&lt;'a&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.CharIndices.html" title="struct std::str::CharIndices">CharIndices</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.tuple.html">(</a><a class="primitive" href="primitive.usize.html">usize</a>, <a class="primitive" href="primitive.char.html">char</a><a class="primitive" href="primitive.tuple.html">)</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Returns an iterator over the <a href="primitive.char.html"><code>char</code></a>s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="primitive.char.html"><code>char</code></a>. This method returns an iterator of both
these <a href="primitive.char.html"><code>char</code></a>s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the <a href="primitive.char.html"><code>char</code></a> is
second.</p>
<h5 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let</span> <span class="ident">count</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">char_indices</span>().<span class="ident">count</span>();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, <span class="ident">count</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">char_indices</span> <span class="op">=</span> <span class="ident">word</span>.<span class="ident">char_indices</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;g&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;o&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">&#39;o&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;d&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;b&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">&#39;y&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">&#39;e&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">char_indices</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20word%20%3D%20%22goodbye%22%3B%0A%0Alet%20count%20%3D%20word.char_indices().count()%3B%0Aassert_eq!(7%2C%20count)%3B%0A%0Alet%20mut%20char_indices%20%3D%20word.char_indices()%3B%0A%0Aassert_eq!(Some((0%2C%20'g'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((1%2C%20'o'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((2%2C%20'o'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((3%2C%20'd'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((4%2C%20'b'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((5%2C%20'y'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((6%2C%20'e'))%2C%20char_indices.next())%3B%0A%0Aassert_eq!(None%2C%20char_indices.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Remember, <a href="primitive.char.html"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">yes</span> <span class="op">=</span> <span class="string">&quot;yÌ†es&quot;</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">char_indices</span> <span class="op">=</span> <span class="ident">yes</span>.<span class="ident">char_indices</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;y&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>()); <span class="comment">// not (0, &#39;yÌ†&#39;)</span>
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;\u{0306}&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="comment">// note the 3 here - the last character took up two bytes</span>
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;e&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;s&#39;</span>)), <span class="ident">char_indices</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">char_indices</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20yes%20%3D%20%22y%CC%86es%22%3B%0A%0Alet%20mut%20char_indices%20%3D%20yes.char_indices()%3B%0A%0Aassert_eq!(Some((0%2C%20'y'))%2C%20char_indices.next())%3B%20%2F%2F%20not%20(0%2C%20'y%CC%86')%0Aassert_eq!(Some((1%2C%20'%5Cu%7B0306%7D'))%2C%20char_indices.next())%3B%0A%0A%2F%2F%20note%20the%203%20here%20-%20the%20last%20character%20took%20up%20two%20bytes%0Aassert_eq!(Some((3%2C%20'e'))%2C%20char_indices.next())%3B%0Aassert_eq!(Some((4%2C%20's'))%2C%20char_indices.next())%3B%0A%0Aassert_eq!(None%2C%20char_indices.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.bytes" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#770" title="goto source code">source</a></div><a href="#method.bytes" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.bytes" class="fnname">bytes</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Bytes.html" title="struct std::str::Bytes">Bytes</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.Bytes.html" title="struct std::str::Bytes">Bytes</a>&lt;'_&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.Bytes.html" title="struct std::str::Bytes">Bytes</a>&lt;'_&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.u8.html">u8</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>An iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h5 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="string">&quot;bors&quot;</span>.<span class="ident">bytes</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;b&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;o&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;r&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;s&#39;</span>), <span class="ident">bytes</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">bytes</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20bytes%20%3D%20%22bors%22.bytes()%3B%0A%0Aassert_eq!(Some(b'b')%2C%20bytes.next())%3B%0Aassert_eq!(Some(b'o')%2C%20bytes.next())%3B%0Aassert_eq!(Some(b'r')%2C%20bytes.next())%3B%0Aassert_eq!(Some(b's')%2C%20bytes.next())%3B%0A%0Aassert_eq!(None%2C%20bytes.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.split_whitespace" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#815" title="goto source code">source</a></div><a href="#method.split_whitespace" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_whitespace" class="fnname">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="str/struct.SplitWhitespace.html" title="struct std::str::SplitWhitespace">SplitWhitespace</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.SplitWhitespace.html" title="struct std::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.SplitWhitespace.html" title="struct std::str::SplitWhitespace">SplitWhitespace</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Splits a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace
instead, use <a href="primitive.str.html#method.split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p>
<h5 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot;A few words&quot;</span>.<span class="ident">split_whitespace</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20iter%20%3D%20%22A%20few%20words%22.split_whitespace()%3B%0A%0Aassert_eq!(Some(%22A%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22few%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22words%22)%2C%20iter.next())%3B%0A%0Aassert_eq!(None%2C%20iter.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>All kinds of whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot; Mary   had\ta\u{2009}little  \n\t lamb&quot;</span>.<span class="ident">split_whitespace</span>();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20iter%20%3D%20%22%20Mary%20%20%20had%5Cta%5Cu%7B2009%7Dlittle%20%20%5Cn%5Ct%20lamb%22.split_whitespace()%3B%0Aassert_eq!(Some(%22Mary%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22had%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22a%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22little%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22lamb%22)%2C%20iter.next())%3B%0A%0Aassert_eq!(None%2C%20iter.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.split_ascii_whitespace" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#858" title="goto source code">source</a></div><a href="#method.split_ascii_whitespace" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_ascii_whitespace" class="fnname">split_ascii_whitespace</a>(&amp;self) -&gt; <a class="struct" href="str/struct.SplitAsciiWhitespace.html" title="struct std::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.SplitAsciiWhitespace.html" title="struct std::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'a&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.SplitAsciiWhitespace.html" title="struct std::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Splits a string slice by ASCII whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of ASCII whitespace.</p>
<p>To split by Unicode <code>Whitespace</code> instead, use <a href="primitive.str.html#method.split_whitespace"><code>split_whitespace</code></a>.</p>
<h5 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot;A few words&quot;</span>.<span class="ident">split_ascii_whitespace</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20iter%20%3D%20%22A%20few%20words%22.split_ascii_whitespace()%3B%0A%0Aassert_eq!(Some(%22A%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22few%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22words%22)%2C%20iter.next())%3B%0A%0Aassert_eq!(None%2C%20iter.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>All kinds of ASCII whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="string">&quot; Mary   had\ta little  \n\t lamb&quot;</span>.<span class="ident">split_ascii_whitespace</span>();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), <span class="ident">iter</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">iter</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20iter%20%3D%20%22%20Mary%20%20%20had%5Cta%20little%20%20%5Cn%5Ct%20lamb%22.split_ascii_whitespace()%3B%0Aassert_eq!(Some(%22Mary%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22had%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22a%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22little%22)%2C%20iter.next())%3B%0Aassert_eq!(Some(%22lamb%22)%2C%20iter.next())%3B%0A%0Aassert_eq!(None%2C%20iter.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.lines" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#904" title="goto source code">source</a></div><a href="#method.lines" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.lines" class="fnname">lines</a>(&amp;self) -&gt; <a class="struct" href="str/struct.Lines.html" title="struct std::str::Lines">Lines</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.Lines.html" title="struct std::str::Lines">Lines</a>&lt;'a&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.Lines.html" title="struct std::str::Lines">Lines</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>An iterator over the lines of a string, as string slices.</p>
<p>Lines are ended with either a newline (<code>\n</code>) or a carriage return with
a line feed (<code>\r\n</code>).</p>
<p>The final line ending is optional. A string that ends with a final line
ending will return the same lines as an otherwise identical string
without a final line ending.</p>
<h5 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo\r\nbar\n\nbaz\n&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lines</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">lines</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">lines</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20text%20%3D%20%22foo%5Cr%5Cnbar%5Cn%5Cnbaz%5Cn%22%3B%0Alet%20mut%20lines%20%3D%20text.lines()%3B%0A%0Aassert_eq!(Some(%22foo%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22bar%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22baz%22)%2C%20lines.next())%3B%0A%0Aassert_eq!(None%2C%20lines.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>The final line ending isnâ€™t required:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;foo\nbar\n\r\nbaz&quot;</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">lines</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">lines</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), <span class="ident">lines</span>.<span class="ident">next</span>());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, <span class="ident">lines</span>.<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20text%20%3D%20%22foo%5Cnbar%5Cn%5Cr%5Cnbaz%22%3B%0Alet%20mut%20lines%20%3D%20text.lines()%3B%0A%0Aassert_eq!(Some(%22foo%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22bar%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22%22)%2C%20lines.next())%3B%0Aassert_eq!(Some(%22baz%22)%2C%20lines.next())%3B%0A%0Aassert_eq!(None%2C%20lines.next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.lines_any" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#913" title="goto source code">source</a></div><a href="#method.lines_any" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.lines_any" class="fnname">lines_any</a>(&amp;self) -&gt; <a class="struct" href="str/struct.LinesAny.html" title="struct std::str::LinesAny">LinesAny</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.LinesAny.html" title="struct std::str::LinesAny">LinesAny</a>&lt;'a&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.LinesAny.html" title="struct std::str::LinesAny">LinesAny</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span></h4></div><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.4.0: <p>use lines() instead now</p>
</div></div></summary><div class="docblock"><p>An iterator over the lines of a string.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.encode_utf16" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#934" title="goto source code">source</a></div><a href="#method.encode_utf16" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.encode_utf16" class="fnname">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EncodeUtf16.html" title="struct std::str::EncodeUtf16">EncodeUtf16</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.EncodeUtf16.html" title="struct std::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.EncodeUtf16.html" title="struct std::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.u16.html">u16</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p>
<h5 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">text</span> <span class="op">=</span> <span class="string">&quot;ZaÅ¼Ã³Å‚Ä‡ gÄ™Å›lÄ… jaÅºÅ„&quot;</span>;

<span class="kw">let</span> <span class="ident">utf8_len</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">len</span>();
<span class="kw">let</span> <span class="ident">utf16_len</span> <span class="op">=</span> <span class="ident">text</span>.<span class="ident">encode_utf16</span>().<span class="ident">count</span>();

<span class="macro">assert!</span>(<span class="ident">utf16_len</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">utf8_len</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20text%20%3D%20%22Za%C5%BC%C3%B3%C5%82%C4%87%20g%C4%99%C5%9Bl%C4%85%20ja%C5%BA%C5%84%22%3B%0A%0Alet%20utf8_len%20%3D%20text.len()%3B%0Alet%20utf16_len%20%3D%20text.encode_utf16().count()%3B%0A%0Aassert!(utf16_len%20%3C%3D%20utf8_len)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.contains" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#961" title="goto source code">source</a></div><a href="#method.contains" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.contains" class="fnname">contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(<span class="ident">bananas</span>.<span class="ident">contains</span>(<span class="string">&quot;nana&quot;</span>));
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">contains</span>(<span class="string">&quot;apples&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20bananas%20%3D%20%22bananas%22%3B%0A%0Aassert!(bananas.contains(%22nana%22))%3B%0Aassert!(!bananas.contains(%22apples%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.starts_with" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#987" title="goto source code">source</a></div><a href="#method.starts_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(<span class="ident">bananas</span>.<span class="ident">starts_with</span>(<span class="string">&quot;bana&quot;</span>));
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">starts_with</span>(<span class="string">&quot;nana&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20bananas%20%3D%20%22bananas%22%3B%0A%0Aassert!(bananas.starts_with(%22bana%22))%3B%0Aassert!(!bananas.starts_with(%22nana%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ends_with" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1013-1015" title="goto source code">source</a></div><a href="#method.ends_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">bananas</span> <span class="op">=</span> <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(<span class="ident">bananas</span>.<span class="ident">ends_with</span>(<span class="string">&quot;anas&quot;</span>));
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bananas</span>.<span class="ident">ends_with</span>(<span class="string">&quot;nana&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20bananas%20%3D%20%22bananas%22%3B%0A%0Aassert!(bananas.ends_with(%22anas%22))%3B%0Aassert!(!bananas.ends_with(%22nana%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.find" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1064" title="goto source code">source</a></div><a href="#method.find" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.find" class="fnname">find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="option/enum.Option.html#variant.None" title="None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard Gepardi&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&#39;Ã©&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="string">&quot;pard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">17</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%20Gepardi%22%3B%0A%0Aassert_eq!(s.find('L')%2C%20Some(0))%3B%0Aassert_eq!(s.find('%C3%A9')%2C%20Some(14))%3B%0Aassert_eq!(s.find(%22pard%22)%2C%20Some(17))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>More complex patterns using point-free style and closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">char::is_whitespace</span>), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">char::is_lowercase</span>), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="op">|</span><span class="ident">c</span>: <span class="ident">char</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_whitespace</span>() <span class="op">|</span><span class="op">|</span> <span class="ident">c</span>.<span class="ident">is_lowercase</span>()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="op">|</span><span class="ident">c</span>: <span class="ident">char</span><span class="op">|</span> (<span class="ident">c</span> <span class="op">&lt;</span> <span class="string">&#39;o&#39;</span>) <span class="op">&amp;&amp;</span> (<span class="ident">c</span> <span class="op">&gt;</span> <span class="string">&#39;a&#39;</span>)), <span class="prelude-val">Some</span>(<span class="number">4</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0A%0Aassert_eq!(s.find(char%3A%3Ais_whitespace)%2C%20Some(5))%3B%0Aassert_eq!(s.find(char%3A%3Ais_lowercase)%2C%20Some(1))%3B%0Aassert_eq!(s.find(%7Cc%3A%20char%7C%20c.is_whitespace()%20%7C%7C%20c.is_lowercase())%2C%20Some(1))%3B%0Aassert_eq!(s.find(%7Cc%3A%20char%7C%20(c%20%3C%20'o')%20%26%26%20(c%20%3E%20'a'))%2C%20Some(4))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">find</span>(<span class="ident">x</span>), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0A%0Aassert_eq!(s.find(x)%2C%20None)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.rfind" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1110-1112" title="goto source code">source</a></div><a href="#method.rfind" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rfind" class="fnname">rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns the byte index for the first character of the rightmost match of the pattern in
this string slice.</p>
<p>Returns <a href="option/enum.Option.html#variant.None" title="None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard Gepardi&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&#39;Ã©&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="string">&quot;pard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">24</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%20Gepardi%22%3B%0A%0Aassert_eq!(s.rfind('L')%2C%20Some(13))%3B%0Aassert_eq!(s.rfind('%C3%A9')%2C%20Some(14))%3B%0Aassert_eq!(s.rfind(%22pard%22)%2C%20Some(24))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>More complex patterns with closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">char::is_whitespace</span>), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">char::is_lowercase</span>), <span class="prelude-val">Some</span>(<span class="number">20</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0A%0Aassert_eq!(s.rfind(char%3A%3Ais_whitespace)%2C%20Some(12))%3B%0Aassert_eq!(s.rfind(char%3A%3Ais_lowercase)%2C%20Some(20))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq!</span>(<span class="ident">s</span>.<span class="ident">rfind</span>(<span class="ident">x</span>), <span class="prelude-val">None</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0A%0Aassert_eq!(s.rfind(x)%2C%20None)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.split" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1232" title="goto source code">source</a></div><a href="#method.split" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split" class="fnname">split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.Split.html" title="struct std::str::Split">Split</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.Split.html" title="struct std::str::Split">Split</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.Split.html" title="struct std::str::Split">Split</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior" class="section-header"><a href="#iterator-behavior">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rsplit"><code>rsplit</code></a> method can be used.</p>
<h5 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;lamb&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">split</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">split</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1def2ghi&quot;</span>.<span class="ident">split</span>(<span class="ident">char::is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXtigerXleopard&quot;</span>.<span class="ident">split</span>(<span class="ident">char::is_uppercase</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lamb%22.split('%20').collect()%3B%0Aassert_eq!(v%2C%20%5B%22Mary%22%2C%20%22had%22%2C%20%22a%22%2C%20%22little%22%2C%20%22lamb%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22%22.split('X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lionXXtigerXleopard%22.split('X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22lion%22%2C%20%22%22%2C%20%22tiger%22%2C%20%22leopard%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lion%3A%3Atiger%3A%3Aleopard%22.split(%22%3A%3A%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22lion%22%2C%20%22tiger%22%2C%20%22leopard%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abc1def2ghi%22.split(char%3A%3Ais_numeric).collect()%3B%0Aassert_eq!(v%2C%20%5B%22abc%22%2C%20%22def%22%2C%20%22ghi%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lionXtigerXleopard%22.split(char%3A%3Ais_uppercase).collect()%3B%0Aassert_eq!(v%2C%20%5B%22lion%22%2C%20%22tiger%22%2C%20%22leopard%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;2020-11-03 23:59&quot;</span>.<span class="ident">split</span>(<span class="kw-2">&amp;</span>[<span class="string">&#39;-&#39;</span>, <span class="string">&#39; &#39;</span>, <span class="string">&#39;:&#39;</span>, <span class="string">&#39;@&#39;</span>][..]).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;2020&quot;</span>, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;03&quot;</span>, <span class="string">&quot;23&quot;</span>, <span class="string">&quot;59&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%222020-11-03%2023%3A59%22.split(%26%5B'-'%2C%20'%20'%2C%20'%3A'%2C%20'%40'%5D%5B..%5D).collect()%3B%0Aassert_eq!(v%2C%20%5B%222020%22%2C%20%2211%22%2C%20%2203%22%2C%20%2223%22%2C%20%2259%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abc1defXghi%22.split(%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22abc%22%2C%20%22def%22%2C%20%22ghi%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;||||a||b|c&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39;|&#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20%22%7C%7C%7C%7Ca%7C%7Cb%7Cc%22.to_string()%3B%0Alet%20d%3A%20Vec%3C_%3E%20%3D%20x.split('%7C').collect()%3B%0A%0Aassert_eq!(d%2C%20%26%5B%22%22%2C%20%22%22%2C%20%22%22%2C%20%22%22%2C%20%22a%22%2C%20%22%22%2C%20%22b%22%2C%20%22c%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Contiguous separators are separated by the empty string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;(///)&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39;/&#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;(&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;)&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20%22(%2F%2F%2F)%22.to_string()%3B%0Alet%20d%3A%20Vec%3C_%3E%20%3D%20x.split('%2F').collect()%3B%0A%0Aassert_eq!(d%2C%20%26%5B%22(%22%2C%20%22%22%2C%20%22%22%2C%20%22)%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;010&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;0&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20d%3A%20Vec%3C_%3E%20%3D%20%22010%22.split(%220%22).collect()%3B%0Aassert_eq!(d%2C%20%26%5B%22%22%2C%20%221%22%2C%20%22%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">f</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;rust&quot;</span>.<span class="ident">split</span>(<span class="string">&quot;&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">f</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20f%3A%20Vec%3C_%3E%20%3D%20%22rust%22.split(%22%22).collect()%3B%0Aassert_eq!(f%2C%20%26%5B%22%22%2C%20%22r%22%2C%20%22u%22%2C%20%22s%22%2C%20%22t%22%2C%20%22%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="string">&quot;    a  b c&quot;</span>.<span class="ident">to_string</span>();
<span class="kw">let</span> <span class="ident">d</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();

<span class="macro">assert_eq!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20x%20%3D%20%22%20%20%20%20a%20%20b%20c%22.to_string()%3B%0Alet%20d%3A%20Vec%3C_%3E%20%3D%20x.split('%20').collect()%3B%0A%0Aassert_eq!(d%2C%20%26%5B%22%22%2C%20%22%22%2C%20%22%22%2C%20%22%22%2C%20%22a%22%2C%20%22%22%2C%20%22b%22%2C%20%22c%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>It does <em>not</em> give you:</p>

<div class='information'><div class='tooltip ignore'>â“˜</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="macro">assert_eq!</span>(<span class="ident">d</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(d%2C%20%26%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Use <a href="primitive.str.html#method.split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.split_inclusive" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1272" title="goto source code">source</a></div><a href="#method.split_inclusive" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fnname">split_inclusive</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.SplitInclusive.html" title="struct std::str::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.SplitInclusive.html" title="struct std::str::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.SplitInclusive.html" title="struct std::str::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern. Differs from the iterator produced by
<code>split</code> in that <code>split_inclusive</code> leaves the matched part as the
terminator of the substring.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb\nlittle lamb\nlittle lamb.&quot;</span>
    .<span class="ident">split_inclusive</span>(<span class="string">&#39;\n&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary had a little lamb\n&quot;</span>, <span class="string">&quot;little lamb\n&quot;</span>, <span class="string">&quot;little lamb.&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lamb%5Cnlittle%20lamb%5Cnlittle%20lamb.%22%0A%20%20%20%20.split_inclusive('%5Cn').collect()%3B%0Aassert_eq!(v%2C%20%5B%22Mary%20had%20a%20little%20lamb%5Cn%22%2C%20%22little%20lamb%5Cn%22%2C%20%22little%20lamb.%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>If the last element of the string is matched,
that element will be considered the terminator of the preceding substring.
That substring will be the last item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb\nlittle lamb\nlittle lamb.\n&quot;</span>
    .<span class="ident">split_inclusive</span>(<span class="string">&#39;\n&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary had a little lamb\n&quot;</span>, <span class="string">&quot;little lamb\n&quot;</span>, <span class="string">&quot;little lamb.\n&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lamb%5Cnlittle%20lamb%5Cnlittle%20lamb.%5Cn%22%0A%20%20%20%20.split_inclusive('%5Cn').collect()%3B%0Aassert_eq!(v%2C%20%5B%22Mary%20had%20a%20little%20lamb%5Cn%22%2C%20%22little%20lamb%5Cn%22%2C%20%22little%20lamb.%5Cn%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.rsplit" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1327-1329" title="goto source code">source</a></div><a href="#method.rsplit" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RSplit.html" title="struct std::str::RSplit">RSplit</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.RSplit.html" title="struct std::str::RSplit">RSplit</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.RSplit.html" title="struct std::str::RSplit">RSplit</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern and yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-1" class="section-header"><a href="#iterator-behavior-1">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.split"><code>split</code></a> method can be used.</p>
<h5 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;Mary&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;lion&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplit</span>(<span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lion&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lamb%22.rsplit('%20').collect()%3B%0Aassert_eq!(v%2C%20%5B%22lamb%22%2C%20%22little%22%2C%20%22a%22%2C%20%22had%22%2C%20%22Mary%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22%22.rsplit('X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lionXXtigerXleopard%22.rsplit('X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22leopard%22%2C%20%22tiger%22%2C%20%22%22%2C%20%22lion%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lion%3A%3Atiger%3A%3Aleopard%22.rsplit(%22%3A%3A%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22leopard%22%2C%20%22tiger%22%2C%20%22lion%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;abc&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abc1defXghi%22.rsplit(%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22ghi%22%2C%20%22def%22%2C%20%22abc%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.split_terminator" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1378" title="goto source code">source</a></div><a href="#method.split_terminator" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_terminator" class="fnname">split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.SplitTerminator.html" title="struct std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.SplitTerminator.html" title="struct std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.SplitTerminator.html" title="struct std::str::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="primitive.str.html#method.split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-2" class="section-header"><a href="#iterator-behavior-2">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h5 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B.&quot;</span>.<span class="ident">split_terminator</span>(<span class="string">&#39;.&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A..B..&quot;</span>.<span class="ident">split_terminator</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B:C.D&quot;</span>.<span class="ident">split_terminator</span>(<span class="kw-2">&amp;</span>[<span class="string">&#39;.&#39;</span>, <span class="string">&#39;:&#39;</span>][..]).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A.B.%22.split_terminator('.').collect()%3B%0Aassert_eq!(v%2C%20%5B%22A%22%2C%20%22B%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A..B..%22.split_terminator(%22.%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22A%22%2C%20%22%22%2C%20%22B%22%2C%20%22%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A.B%3AC.D%22.split_terminator(%26%5B'.'%2C%20'%3A'%5D%5B..%5D).collect()%3B%0Aassert_eq!(v%2C%20%5B%22A%22%2C%20%22B%22%2C%20%22C%22%2C%20%22D%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.rsplit_terminator" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1424-1426" title="goto source code">source</a></div><a href="#method.rsplit_terminator" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplit_terminator" class="fnname">rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RSplitTerminator.html" title="struct std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.RSplitTerminator.html" title="struct std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.RSplitTerminator.html" title="struct std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="primitive.str.html#method.split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-3" class="section-header"><a href="#iterator-behavior-3">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h5 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B.&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="string">&#39;.&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A..B..&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="string">&quot;.&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;A.B:C.D&quot;</span>.<span class="ident">rsplit_terminator</span>(<span class="kw-2">&amp;</span>[<span class="string">&#39;.&#39;</span>, <span class="string">&#39;:&#39;</span>][..]).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A.B.%22.rsplit_terminator('.').collect()%3B%0Aassert_eq!(v%2C%20%5B%22B%22%2C%20%22A%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A..B..%22.rsplit_terminator(%22.%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22%22%2C%20%22B%22%2C%20%22%22%2C%20%22A%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22A.B%3AC.D%22.rsplit_terminator(%26%5B'.'%2C%20'%3A'%5D%5B..%5D).collect()%3B%0Aassert_eq!(v%2C%20%5B%22D%22%2C%20%22C%22%2C%20%22B%22%2C%20%22A%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.splitn" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1479" title="goto source code">source</a></div><a href="#method.splitn" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="str/struct.SplitN.html" title="struct std::str::SplitN">SplitN</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.SplitN.html" title="struct std::str::SplitN">SplitN</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.SplitN.html" title="struct std::str::SplitN">SplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by a
pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-4" class="section-header"><a href="#iterator-behavior-4">Iterator behavior</a></h5>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="primitive.str.html#method.rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h5 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lambda&quot;</span>.<span class="ident">splitn</span>(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a little lambda&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">splitn</span>(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tigerXleopard&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXdef&quot;</span>.<span class="ident">splitn</span>(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abcXdef&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;&quot;</span>.<span class="ident">splitn</span>(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lambda%22.splitn(3%2C%20'%20').collect()%3B%0Aassert_eq!(v%2C%20%5B%22Mary%22%2C%20%22had%22%2C%20%22a%20little%20lambda%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lionXXtigerXleopard%22.splitn(3%2C%20%22X%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22lion%22%2C%20%22%22%2C%20%22tigerXleopard%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abcXdef%22.splitn(1%2C%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22abcXdef%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22%22.splitn(1%2C%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;defXghi&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abc1defXghi%22.splitn(2%2C%20%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22abc%22%2C%20%22defXghi%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.rsplitn" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1528-1530" title="goto source code">source</a></div><a href="#method.rsplitn" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="str/struct.RSplitN.html" title="struct std::str::RSplitN">RSplitN</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.RSplitN.html" title="struct std::str::RSplitN">RSplitN</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.RSplitN.html" title="struct std::str::RSplitN">RSplitN</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning
at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-5" class="section-header"><a href="#iterator-behavior-5">Iterator behavior</a></h5>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="primitive.str.html#method.splitn"><code>splitn</code></a> method can be used.</p>
<h5 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;Mary had a little lamb&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;Mary had a&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lionXXtigerXleopard&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">3</span>, <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lionX&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;lion::tiger::leopard&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;lion::tiger&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22Mary%20had%20a%20little%20lamb%22.rsplitn(3%2C%20'%20').collect()%3B%0Aassert_eq!(v%2C%20%5B%22lamb%22%2C%20%22little%22%2C%20%22Mary%20had%20a%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lionXXtigerXleopard%22.rsplitn(3%2C%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22leopard%22%2C%20%22tiger%22%2C%20%22lionX%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22lion%3A%3Atiger%3A%3Aleopard%22.rsplitn(2%2C%20%22%3A%3A%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22leopard%22%2C%20%22lion%3A%3Atiger%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abc1defXghi&quot;</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;abc1def&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abc1defXghi%22.rsplitn(2%2C%20%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X').collect()%3B%0Aassert_eq!(v%2C%20%5B%22ghi%22%2C%20%22abc1def%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.split_once" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1547" title="goto source code">source</a></div><a href="#method.split_once" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_once" class="fnname">split_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.tuple.html">(</a>&amp;'a <a class="primitive" href="primitive.str.html">str</a>, &amp;'a <a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Splits the string on the first occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;cfg&quot;</span>.<span class="ident">split_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo&quot;</span>.<span class="ident">split_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo&quot;</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo=bar&quot;</span>.<span class="ident">split_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo=bar&quot;</span>)));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22cfg%22.split_once('%3D')%2C%20None)%3B%0Aassert_eq!(%22cfg%3Dfoo%22.split_once('%3D')%2C%20Some((%22cfg%22%2C%20%22foo%22)))%3B%0Aassert_eq!(%22cfg%3Dfoo%3Dbar%22.split_once('%3D')%2C%20Some((%22cfg%22%2C%20%22foo%3Dbar%22)))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.rsplit_once" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1565-1567" title="goto source code">source</a></div><a href="#method.rsplit_once" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplit_once" class="fnname">rsplit_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="primitive" href="primitive.tuple.html">(</a>&amp;'a <a class="primitive" href="primitive.str.html">str</a>, &amp;'a <a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Splits the string on the last occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;cfg&quot;</span>.<span class="ident">rsplit_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo&quot;</span>.<span class="ident">rsplit_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo&quot;</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo=bar&quot;</span>.<span class="ident">rsplit_once</span>(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg=foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22cfg%22.rsplit_once('%3D')%2C%20None)%3B%0Aassert_eq!(%22cfg%3Dfoo%22.rsplit_once('%3D')%2C%20Some((%22cfg%22%2C%20%22foo%22)))%3B%0Aassert_eq!(%22cfg%3Dfoo%3Dbar%22.rsplit_once('%3D')%2C%20Some((%22cfg%3Dfoo%22%2C%20%22bar%22)))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.matches" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1607" title="goto source code">source</a></div><a href="#method.matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.matches" class="fnname">matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.Matches.html" title="struct std::str::Matches">Matches</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.Matches.html" title="struct std::str::Matches">Matches</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.Matches.html" title="struct std::str::Matches">Matches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within the given string
slice.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-6" class="section-header"><a href="#iterator-behavior-6">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.matches"><code>rmatches</code></a> method can be used.</p>
<h5 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">matches</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abc2abc3&quot;</span>.<span class="ident">matches</span>(<span class="ident">char::is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abcXXXabcYYYabc%22.matches(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22abc%22%2C%20%22abc%22%2C%20%22abc%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%221abc2abc3%22.matches(char%3A%3Ais_numeric).collect()%3B%0Aassert_eq!(v%2C%20%5B%221%22%2C%20%222%22%2C%20%223%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.rmatches" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1643-1645" title="goto source code">source</a></div><a href="#method.rmatches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rmatches" class="fnname">rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RMatches.html" title="struct std::str::RMatches">RMatches</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.RMatches.html" title="struct std::str::RMatches">RMatches</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.RMatches.html" title="struct std::str::RMatches">RMatches</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="primitive" href="primitive.str.html">str</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within this string slice,
yielded in reverse order.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-7" class="section-header"><a href="#iterator-behavior-7">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.matches"><code>matches</code></a> method can be used.</p>
<h5 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">rmatches</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abc2abc3&quot;</span>.<span class="ident">rmatches</span>(<span class="ident">char::is_numeric</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [<span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%22abcXXXabcYYYabc%22.rmatches(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B%22abc%22%2C%20%22abc%22%2C%20%22abc%22%5D)%3B%0A%0Alet%20v%3A%20Vec%3C%26str%3E%20%3D%20%221abc2abc3%22.rmatches(char%3A%3Ais_numeric).collect()%3B%0Aassert_eq!(v%2C%20%5B%223%22%2C%20%222%22%2C%20%221%22%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.match_indices" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1689" title="goto source code">source</a></div><a href="#method.match_indices" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.match_indices" class="fnname">match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.MatchIndices.html" title="struct std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.MatchIndices.html" title="struct std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.MatchIndices.html" title="struct std::str::MatchIndices">MatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.tuple.html">(</a><a class="primitive" href="primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-8" class="section-header"><a href="#iterator-behavior-8">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="primitive.char.html"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="primitive.str.html#method.rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h5 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abcabc2&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;ababa&quot;</span>.<span class="ident">match_indices</span>(<span class="string">&quot;aba&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">0</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the first `aba`</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%22abcXXXabcYYYabc%22.match_indices(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(0%2C%20%22abc%22)%2C%20(6%2C%20%22abc%22)%2C%20(12%2C%20%22abc%22)%5D)%3B%0A%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%221abcabc2%22.match_indices(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(1%2C%20%22abc%22)%2C%20(4%2C%20%22abc%22)%5D)%3B%0A%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%22ababa%22.match_indices(%22aba%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(0%2C%20%22aba%22)%5D)%3B%20%2F%2F%20only%20the%20first%20%60aba%60%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.rmatch_indices" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1731-1733" title="goto source code">source</a></div><a href="#method.rmatch_indices" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rmatch_indices" class="fnname">rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="str/struct.RMatchIndices.html" title="struct std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.RMatchIndices.html" title="struct std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a, P&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.RMatchIndices.html" title="struct std::str::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.tuple.html">(</a><a class="primitive" href="primitive.usize.html">usize</a>, &amp;'a <a class="primitive" href="primitive.str.html">str</a><a class="primitive" href="primitive.tuple.html">)</a>;</span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-9" class="section-header"><a href="#iterator-behavior-9">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="iter/trait.DoubleEndedIterator.html" title="DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="primitive.str.html#method.match_indices"><code>match_indices</code></a> method can be used.</p>
<h5 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;1abcabc2&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;abc&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="string">&quot;ababa&quot;</span>.<span class="ident">rmatch_indices</span>(<span class="string">&quot;aba&quot;</span>).<span class="ident">collect</span>();
<span class="macro">assert_eq!</span>(<span class="ident">v</span>, [(<span class="number">2</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the last `aba`</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%22abcXXXabcYYYabc%22.rmatch_indices(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(12%2C%20%22abc%22)%2C%20(6%2C%20%22abc%22)%2C%20(0%2C%20%22abc%22)%5D)%3B%0A%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%221abcabc2%22.rmatch_indices(%22abc%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(4%2C%20%22abc%22)%2C%20(1%2C%20%22abc%22)%5D)%3B%0A%0Alet%20v%3A%20Vec%3C_%3E%20%3D%20%22ababa%22.rmatch_indices(%22aba%22).collect()%3B%0Aassert_eq!(v%2C%20%5B(2%2C%20%22aba%22)%5D)%3B%20%2F%2F%20only%20the%20last%20%60aba%60%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.trim" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1756" title="goto source code">source</a></div><a href="#method.trim" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim" class="fnname">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class="docblock"><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20Hello%5Ctworld%5Ct%22%3B%0A%0Aassert_eq!(%22Hello%5Ctworld%22%2C%20s.trim())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.trim_start" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1794" title="goto source code">source</a></div><a href="#method.trim_start" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_start" class="fnname">trim_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality" class="section-header"><a href="#text-directionality">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld\t&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_start</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20Hello%5Ctworld%5Ct%22%3B%0Aassert_eq!(%22Hello%5Ctworld%5Ct%22%2C%20s.trim_start())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_start</span>().<span class="ident">chars</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  ×¢×‘×¨×™×ª  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×¢&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_start</span>().<span class="ident">chars</span>().<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20%20English%20%20%22%3B%0Aassert!(Some('E')%20%3D%3D%20s.trim_start().chars().next())%3B%0A%0Alet%20s%20%3D%20%22%20%20%D7%A2%D7%91%D7%A8%D7%99%D7%AA%20%20%22%3B%0Aassert!(Some('%D7%A2')%20%3D%3D%20s.trim_start().chars().next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.trim_end" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#1832" title="goto source code">source</a></div><a href="#method.trim_end" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_end" class="fnname">trim_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-1" class="section-header"><a href="#text-directionality-1">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-41" class="section-header"><a href="#examples-41">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot; Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_end</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20Hello%5Ctworld%5Ct%22%3B%0Aassert_eq!(%22%20Hello%5Ctworld%22%2C%20s.trim_end())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_end</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  ×¢×‘×¨×™×ª  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×ª&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_end</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20%20English%20%20%22%3B%0Aassert!(Some('h')%20%3D%3D%20s.trim_end().chars().rev().next())%3B%0A%0Alet%20s%20%3D%20%22%20%20%D7%A2%D7%91%D7%A8%D7%99%D7%AA%20%20%22%3B%0Aassert!(Some('%D7%AA')%20%3D%3D%20s.trim_end().chars().rev().next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.trim_left" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1876" title="goto source code">source</a></div><a href="#method.trim_left" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_left" class="fnname">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></div><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_start</code></p>
</div></div></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-2" class="section-header"><a href="#text-directionality-2">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-42" class="section-header"><a href="#examples-42">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld\t&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_left</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20Hello%5Ctworld%5Ct%22%3B%0A%0Aassert_eq!(%22Hello%5Ctworld%5Ct%22%2C%20s.trim_left())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  English&quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_left</span>().<span class="ident">chars</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;  ×¢×‘×¨×™×ª&quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×¢&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_left</span>().<span class="ident">chars</span>().<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20%20English%22%3B%0Aassert!(Some('E')%20%3D%3D%20s.trim_left().chars().next())%3B%0A%0Alet%20s%20%3D%20%22%20%20%D7%A2%D7%91%D7%A8%D7%99%D7%AA%22%3B%0Aassert!(Some('%D7%A2')%20%3D%3D%20s.trim_left().chars().next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.trim_right" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1920" title="goto source code">source</a></div><a href="#method.trim_right" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_right" class="fnname">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></div><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_end</code></p>
</div></div></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-3" class="section-header"><a href="#text-directionality-3">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-43" class="section-header"><a href="#examples-43">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot; Hello\tworld&quot;</span>, <span class="ident">s</span>.<span class="ident">trim_right</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22%20Hello%5Ctworld%5Ct%22%3B%0A%0Aassert_eq!(%22%20Hello%5Ctworld%22%2C%20s.trim_right())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_right</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;×¢×‘×¨×™×ª  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×ª&#39;</span>) <span class="op">==</span> <span class="ident">s</span>.<span class="ident">trim_right</span>().<span class="ident">chars</span>().<span class="ident">rev</span>().<span class="ident">next</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22English%20%20%22%3B%0Aassert!(Some('h')%20%3D%3D%20s.trim_right().chars().rev().next())%3B%0A%0Alet%20s%20%3D%20%22%D7%A2%D7%91%D7%A8%D7%99%D7%AA%20%20%22%3B%0Aassert!(Some('%D7%AA')%20%3D%3D%20s.trim_right().chars().rev().next())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.trim_matches" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#1953-1955" title="goto source code">source</a></div><a href="#method.trim_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_matches" class="fnname">trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.DoubleEndedSearcher.html" title="trait std::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a function
or closure that determines if a character matches.</p>
<h5 id="examples-44" class="section-header"><a href="#examples-44">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_matches</span>(<span class="ident">char::is_numeric</span>), <span class="string">&quot;foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%2211foo1bar11%22.trim_matches('1')%2C%20%22foo1bar%22)%3B%0Aassert_eq!(%22123foo1bar123%22.trim_matches(char%3A%3Ais_numeric)%2C%20%22foo1bar%22)%3B%0A%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0Aassert_eq!(%2212foo1bar12%22.trim_matches(x)%2C%20%22foo1bar%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1foo1barXX&quot;</span>.<span class="ident">trim_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%221foo1barXX%22.trim_matches(%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X')%2C%20%22foo1bar%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.trim_start_matches" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2002" title="goto source code">source</a></div><a href="#method.trim_start_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_start_matches" class="fnname">trim_start_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-4" class="section-header"><a href="#text-directionality-4">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-45" class="section-header"><a href="#examples-45">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_start_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_start_matches</span>(<span class="ident">char::is_numeric</span>), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_start_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar12&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%2211foo1bar11%22.trim_start_matches('1')%2C%20%22foo1bar11%22)%3B%0Aassert_eq!(%22123foo1bar123%22.trim_start_matches(char%3A%3Ais_numeric)%2C%20%22foo1bar123%22)%3B%0A%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0Aassert_eq!(%2212foo1bar12%22.trim_start_matches(x)%2C%20%22foo1bar12%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.strip_prefix" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2035" title="goto source code">source</a></div><a href="#method.strip_prefix" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fnname">strip_prefix</a>&lt;'a, P&gt;(&amp;'a self, prefix: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns a string slice with the prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns substring after the prefix, wrapped
in <code>Some</code>.  Unlike <code>trim_start_matches</code>, this method removes the prefix exactly once.</p>
<p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-46" class="section-header"><a href="#examples-46">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;foo:bar&quot;</span>.<span class="ident">strip_prefix</span>(<span class="string">&quot;foo:&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;foo:bar&quot;</span>.<span class="ident">strip_prefix</span>(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;foofoo&quot;</span>.<span class="ident">strip_prefix</span>(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22foo%3Abar%22.strip_prefix(%22foo%3A%22)%2C%20Some(%22bar%22))%3B%0Aassert_eq!(%22foo%3Abar%22.strip_prefix(%22bar%22)%2C%20None)%3B%0Aassert_eq!(%22foofoo%22.strip_prefix(%22foo%22)%2C%20Some(%22foo%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.strip_suffix" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2062-2065" title="goto source code">source</a></div><a href="#method.strip_suffix" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fnname">strip_suffix</a>&lt;'a, P&gt;(&amp;'a self, suffix: P) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns a string slice with the suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix,
wrapped in <code>Some</code>.  Unlike <code>trim_end_matches</code>, this method removes the suffix exactly once.</p>
<p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-47" class="section-header"><a href="#examples-47">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;bar:foo&quot;</span>.<span class="ident">strip_suffix</span>(<span class="string">&quot;:foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;bar:foo&quot;</span>.<span class="ident">strip_suffix</span>(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;foofoo&quot;</span>.<span class="ident">strip_suffix</span>(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22bar%3Afoo%22.strip_suffix(%22%3Afoo%22)%2C%20Some(%22bar%22))%3B%0Aassert_eq!(%22bar%3Afoo%22.strip_suffix(%22bar%22)%2C%20None)%3B%0Aassert_eq!(%22foofoo%22.strip_suffix(%22foo%22)%2C%20Some(%22foo%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.trim_end_matches" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2106-2108" title="goto source code">source</a></div><a href="#method.trim_end_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_end_matches" class="fnname">trim_end_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-5" class="section-header"><a href="#text-directionality-5">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-48" class="section-header"><a href="#examples-48">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="ident">char::is_numeric</span>), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="ident">x</span>), <span class="string">&quot;12foo1bar&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%2211foo1bar11%22.trim_end_matches('1')%2C%20%2211foo1bar%22)%3B%0Aassert_eq!(%22123foo1bar123%22.trim_end_matches(char%3A%3Ais_numeric)%2C%20%22123foo1bar%22)%3B%0A%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0Aassert_eq!(%2212foo1bar12%22.trim_end_matches(x)%2C%20%2212foo1bar%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1fooX&quot;</span>.<span class="ident">trim_end_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%221fooX%22.trim_end_matches(%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X')%2C%20%221foo%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.trim_left_matches" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2152" title="goto source code">source</a></div><a href="#method.trim_left_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_left_matches" class="fnname">trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_start_matches</code></p>
</div></div></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-6" class="section-header"><a href="#text-directionality-6">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-49" class="section-header"><a href="#examples-49">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="ident">char::is_numeric</span>), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_left_matches</span>(<span class="ident">x</span>), <span class="string">&quot;foo1bar12&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%2211foo1bar11%22.trim_left_matches('1')%2C%20%22foo1bar11%22)%3B%0Aassert_eq!(%22123foo1bar123%22.trim_left_matches(char%3A%3Ais_numeric)%2C%20%22foo1bar123%22)%3B%0A%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0Aassert_eq!(%2212foo1bar12%22.trim_left_matches(x)%2C%20%22foo1bar12%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.trim_right_matches" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2195-2197" title="goto source code">source</a></div><a href="#method.trim_right_matches" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trim_right_matches" class="fnname">trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;P as <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type std::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="str/pattern/trait.ReverseSearcher.html" title="trait std::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,&nbsp;</span></h4></div><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.33.0: <p>superseded by <code>trim_end_matches</code></p>
</div></div></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="str/pattern/index.html">pattern</a> can be a <code>&amp;str</code>, <a href="primitive.char.html"><code>char</code></a>, a slice of <a href="primitive.char.html"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-7" class="section-header"><a href="#text-directionality-7">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-50" class="section-header"><a href="#examples-50">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="ident">char::is_numeric</span>), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="ident">x</span>), <span class="string">&quot;12foo1bar&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%2211foo1bar11%22.trim_right_matches('1')%2C%20%2211foo1bar%22)%3B%0Aassert_eq!(%22123foo1bar123%22.trim_right_matches(char%3A%3Ais_numeric)%2C%20%22123foo1bar%22)%3B%0A%0Alet%20x%3A%20%26%5B_%5D%20%3D%20%26%5B'1'%2C%20'2'%5D%3B%0Aassert_eq!(%2212foo1bar12%22.trim_right_matches(x)%2C%20%2212foo1bar%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1fooX&quot;</span>.<span class="ident">trim_right_matches</span>(<span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;1&#39;</span> <span class="op">|</span><span class="op">|</span> <span class="ident">c</span> <span class="op">==</span> <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%221fooX%22.trim_right_matches(%7Cc%7C%20c%20%3D%3D%20'1'%20%7C%7C%20c%20%3D%3D%20'X')%2C%20%221foo%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.parse" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2247" title="goto source code">source</a></div><a href="#method.parse" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.parse" class="fnname">parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;F, &lt;F as <a class="trait" href="str/trait.FromStr.html" title="trait std::str::FromStr">FromStr</a>&gt;::<a class="associatedtype" href="str/trait.FromStr.html#associatedtype.Err" title="type std::str::FromStr::Err">Err</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="str/trait.FromStr.html" title="trait std::str::FromStr">FromStr</a>,&nbsp;</span></h4></div></summary><div class="docblock"><p>Parses this string slice into another type.</p>
<p>Because <code>parse</code> is so general, it can cause problems with type
inference. As such, <code>parse</code> is one of the few times youâ€™ll see
the syntax affectionately known as the â€˜turbofishâ€™: <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
youâ€™re trying to parse into.</p>
<p><code>parse</code> can parse into any type that implements the <a href="str/trait.FromStr.html" title="FromStr"><code>FromStr</code></a> trait.</p>
<h5 id="errors" class="section-header"><a href="#errors">Errors</a></h5>
<p>Will return <a href="str/trait.FromStr.html#associatedtype.Err"><code>Err</code></a> if itâ€™s not possible to parse this string slice into
the desired type.</p>
<h5 id="examples-51" class="section-header"><a href="#examples-51">Examples</a></h5>
<p>Basic usage</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">four</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="string">&quot;4&quot;</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>();

<span class="macro">assert_eq!</span>(<span class="number">4</span>, <span class="ident">four</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20four%3A%20u32%20%3D%20%224%22.parse().unwrap()%3B%0A%0Aassert_eq!(4%2C%20four)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using the â€˜turbofishâ€™ instead of annotating <code>four</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">four</span> <span class="op">=</span> <span class="string">&quot;4&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), <span class="ident">four</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20four%20%3D%20%224%22.parse%3A%3A%3Cu32%3E()%3B%0A%0Aassert_eq!(Ok(4)%2C%20four)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Failing to parse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">nope</span> <span class="op">=</span> <span class="string">&quot;j&quot;</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>();

<span class="macro">assert!</span>(<span class="ident">nope</span>.<span class="ident">is_err</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20nope%20%3D%20%22j%22.parse%3A%3A%3Cu32%3E()%3B%0A%0Aassert!(nope.is_err())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.is_ascii" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2265" title="goto source code">source</a></div><a href="#method.is_ascii" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_ascii" class="fnname">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>Checks if all characters in this string are within the ASCII range.</p>
<h5 id="examples-52" class="section-header"><a href="#examples-52">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">ascii</span> <span class="op">=</span> <span class="string">&quot;hello!\n&quot;</span>;
<span class="kw">let</span> <span class="ident">non_ascii</span> <span class="op">=</span> <span class="string">&quot;GrÃ¼ÃŸe, JÃ¼rgen â¤&quot;</span>;

<span class="macro">assert!</span>(<span class="ident">ascii</span>.<span class="ident">is_ascii</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">non_ascii</span>.<span class="ident">is_ascii</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20ascii%20%3D%20%22hello!%5Cn%22%3B%0Alet%20non_ascii%20%3D%20%22Gr%C3%BC%C3%9Fe%2C%20J%C3%BCrgen%20%E2%9D%A4%22%3B%0A%0Aassert!(ascii.is_ascii())%3B%0Aassert!(!non_ascii.is_ascii())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq_ignore_ascii_case" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2287" title="goto source code">source</a></div><a href="#method.eq_ignore_ascii_case" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.eq_ignore_ascii_case" class="fnname">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class="docblock"><p>Checks that two strings are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
<h5 id="examples-53" class="section-header"><a href="#examples-53">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="string">&quot;Ferris&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERRIS&quot;</span>));
<span class="macro">assert!</span>(<span class="string">&quot;FerrÃ¶s&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERRÃ¶S&quot;</span>));
<span class="macro">assert!</span>(<span class="op">!</span><span class="string">&quot;FerrÃ¶s&quot;</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="string">&quot;FERRÃ–S&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert!(%22Ferris%22.eq_ignore_ascii_case(%22FERRIS%22))%3B%0Aassert!(%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%B6S%22))%3B%0Aassert!(!%22Ferr%C3%B6s%22.eq_ignore_ascii_case(%22FERR%C3%96S%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.make_ascii_uppercase" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2312" title="goto source code">source</a></div><a href="#method.make_ascii_uppercase" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.make_ascii_uppercase" class="fnname">make_ascii_uppercase</a>(&amp;mut self)</h4></div></summary><div class="docblock"><p>Converts this string to its ASCII upper case equivalent in-place.</p>
<p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To return a new uppercased value without modifying the existing one, use
<a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase()</code></a>.</p>
<h5 id="examples-54" class="section-header"><a href="#examples-54">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;GrÃ¼ÃŸe, JÃ¼rgen â¤&quot;</span>);

<span class="ident">s</span>.<span class="ident">make_ascii_uppercase</span>();

<span class="macro">assert_eq!</span>(<span class="string">&quot;GRÃ¼ÃŸE, JÃ¼RGEN â¤&quot;</span>, <span class="ident">s</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20String%3A%3Afrom(%22Gr%C3%BC%C3%9Fe%2C%20J%C3%BCrgen%20%E2%9D%A4%22)%3B%0A%0As.make_ascii_uppercase()%3B%0A%0Aassert_eq!(%22GR%C3%BC%C3%9FE%2C%20J%C3%BCRGEN%20%E2%9D%A4%22%2C%20s)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.make_ascii_lowercase" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2339" title="goto source code">source</a></div><a href="#method.make_ascii_lowercase" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.make_ascii_lowercase" class="fnname">make_ascii_lowercase</a>(&amp;mut self)</h4></div></summary><div class="docblock"><p>Converts this string to its ASCII lower case equivalent in-place.</p>
<p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To return a new lowercased value without modifying the existing one, use
<a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase()</code></a>.</p>
<h5 id="examples-55" class="section-header"><a href="#examples-55">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;GRÃœÃŸE, JÃœRGEN â¤&quot;</span>);

<span class="ident">s</span>.<span class="ident">make_ascii_lowercase</span>();

<span class="macro">assert_eq!</span>(<span class="string">&quot;grÃœÃŸe, jÃœrgen â¤&quot;</span>, <span class="ident">s</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20mut%20s%20%3D%20String%3A%3Afrom(%22GR%C3%9C%C3%9FE%2C%20J%C3%9CRGEN%20%E2%9D%A4%22)%3B%0A%0As.make_ascii_lowercase()%3B%0A%0Aassert_eq!(%22gr%C3%9C%C3%9Fe%2C%20j%C3%9Crgen%20%E2%9D%A4%22%2C%20s)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.escape_debug" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2382" title="goto source code">source</a></div><a href="#method.escape_debug" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.escape_debug" class="fnname">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeDebug.html" title="struct std::str::EscapeDebug">EscapeDebug</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.EscapeDebug.html" title="struct std::str::EscapeDebug">EscapeDebug</a>&lt;'a&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.EscapeDebug.html" title="struct std::str::EscapeDebug">EscapeDebug</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.char.html">char</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_debug" title="char::escape_debug"><code>char::escape_debug</code></a>.</p>
<p>Note: only extended grapheme codepoints that begin the string will be
escaped.</p>
<h5 id="examples-56" class="section-header"><a href="#examples-56">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_debug</span>() {
    <span class="macro">print!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">c</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afor%20c%20in%20%22%E2%9D%A4%5Cn!%22.escape_debug()%20%7B%0A%20%20%20%20print!(%22%7B%7D%22%2C%20c)%3B%0A%7D%0Aprintln!()%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_debug</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%7B%7D%22%2C%20%22%E2%9D%A4%5Cn!%22.escape_debug())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;â¤\\n!&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%E2%9D%A4%5C%5Cn!%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_debug</span>().<span class="ident">to_string</span>(), <span class="string">&quot;â¤\\n!&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22%E2%9D%A4%5Cn!%22.escape_debug().to_string()%2C%20%22%E2%9D%A4%5C%5Cn!%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.escape_default" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2428" title="goto source code">source</a></div><a href="#method.escape_default" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.escape_default" class="fnname">escape_default</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeDefault.html" title="struct std::str::EscapeDefault">EscapeDefault</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.EscapeDefault.html" title="struct std::str::EscapeDefault">EscapeDefault</a>&lt;'a&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.EscapeDefault.html" title="struct std::str::EscapeDefault">EscapeDefault</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.char.html">char</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_default" title="char::escape_default"><code>char::escape_default</code></a>.</p>
<h5 id="examples-57" class="section-header"><a href="#examples-57">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_default</span>() {
    <span class="macro">print!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">c</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afor%20c%20in%20%22%E2%9D%A4%5Cn!%22.escape_default()%20%7B%0A%20%20%20%20print!(%22%7B%7D%22%2C%20c)%3B%0A%7D%0Aprintln!()%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_default</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%7B%7D%22%2C%20%22%E2%9D%A4%5Cn!%22.escape_default())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;\\u{{2764}}\\n!&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cn!%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_default</span>().<span class="ident">to_string</span>(), <span class="string">&quot;\\u{2764}\\n!&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22%E2%9D%A4%5Cn!%22.escape_default().to_string()%2C%20%22%5C%5Cu%7B2764%7D%5C%5Cn!%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.escape_unicode" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2466" title="goto source code">source</a></div><a href="#method.escape_unicode" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.escape_unicode" class="fnname">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="str/struct.EscapeUnicode.html" title="struct std::str::EscapeUnicode">EscapeUnicode</a>&lt;'_&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="str/struct.EscapeUnicode.html" title="struct std::str::EscapeUnicode">EscapeUnicode</a>&lt;'a&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;'a&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="str/struct.EscapeUnicode.html" title="struct std::str::EscapeUnicode">EscapeUnicode</a>&lt;'a&gt;</span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="primitive.char.html">char</a>;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="primitive.char.html#method.escape_unicode" title="char::escape_unicode"><code>char::escape_unicode</code></a>.</p>
<h5 id="examples-58" class="section-header"><a href="#examples-58">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for</span> <span class="ident">c</span> <span class="kw">in</span> <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_unicode</span>() {
    <span class="macro">print!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">c</span>);
}
<span class="macro">println!</span>();</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Afor%20c%20in%20%22%E2%9D%A4%5Cn!%22.escape_unicode()%20%7B%0A%20%20%20%20print!(%22%7B%7D%22%2C%20c)%3B%0A%7D%0Aprintln!()%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_unicode</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%7B%7D%22%2C%20%22%E2%9D%A4%5Cn!%22.escape_unicode())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;\\u{{2764}}\\u{{a}}\\u{{21}}&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22%5C%5Cu%7B%7B2764%7D%7D%5C%5Cu%7B%7Ba%7D%7D%5C%5Cu%7B%7B21%7D%7D%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;â¤\n!&quot;</span>.<span class="ident">escape_unicode</span>().<span class="ident">to_string</span>(), <span class="string">&quot;\\u{2764}\\u{a}\\u{21}&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22%E2%9D%A4%5Cn!%22.escape_unicode().to_string()%2C%20%22%5C%5Cu%7B2764%7D%5C%5Cu%7Ba%7D%5C%5Cu%7B21%7D%22)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#240-593" title="goto source code">source</a></div><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="docblock"><p>Methods for string slices.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into_boxed_bytes" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/alloc/str.rs.html#256" title="goto source code">source</a></div><a href="#method.into_boxed_bytes" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_boxed_bytes" class="fnname">into_boxed_bytes</a>(self: <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>, <a class="struct" href="alloc/struct.Global.html" title="struct std::alloc::Global">Global</a>&gt;) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.slice.html">[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a>, <a class="struct" href="alloc/struct.Global.html" title="struct std::alloc::Global">Global</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;F, A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;F, A&gt; <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;F, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a> + <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a> + 'static,&nbsp;</span></span><span class="where fmt-newline">    type <a href="future/trait.Future.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;F as <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a>&gt;::<a class="associatedtype" href="future/trait.Future.html#associatedtype.Output" title="type std::future::Future::Output">Output</a>;</span><span class="where fmt-newline">impl&lt;I, A&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;I, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;I as <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="iter/trait.Iterator.html#associatedtype.Item" title="type std::iter::Iterator::Item">Item</a>;</span><span class="where fmt-newline">impl&lt;R:&nbsp;<a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;R&gt;</span><span class="where fmt-newline">impl&lt;W:&nbsp;<a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;W&gt;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Converts a <code>Box&lt;str&gt;</code> into a <code>Box&lt;[u8]&gt;</code> without copying or allocating.</p>
<h5 id="examples-59" class="section-header"><a href="#examples-59">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is a string&quot;</span>;
<span class="kw">let</span> <span class="ident">boxed_str</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">to_owned</span>().<span class="ident">into_boxed_str</span>();
<span class="kw">let</span> <span class="ident">boxed_bytes</span> <span class="op">=</span> <span class="ident">boxed_str</span>.<span class="ident">into_boxed_bytes</span>();
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span><span class="ident">boxed_bytes</span>, <span class="kw-2">*</span><span class="ident">s</span>.<span class="ident">as_bytes</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22this%20is%20a%20string%22%3B%0Alet%20boxed_str%20%3D%20s.to_owned().into_boxed_str()%3B%0Alet%20boxed_bytes%20%3D%20boxed_str.into_boxed_bytes()%3B%0Aassert_eq!(*boxed_bytes%2C%20*s.as_bytes())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.replace" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#287" title="goto source code">source</a></div><a href="#method.replace" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.replace" class="fnname">replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Replaces all matches of a pattern with another string.</p>
<p><code>replace</code> creates a new <a href="string/struct.String.html" title="String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice.</p>
<h5 id="examples-60" class="section-header"><a href="#examples-60">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;this is new&quot;</span>, <span class="ident">s</span>.<span class="ident">replace</span>(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22this%20is%20old%22%3B%0A%0Aassert_eq!(%22this%20is%20new%22%2C%20s.replace(%22old%22%2C%20%22new%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>When the pattern doesnâ€™t match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="ident">s</span>, <span class="ident">s</span>.<span class="ident">replace</span>(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22this%20is%20old%22%3B%0Aassert_eq!(s%2C%20s.replace(%22cookie%20monster%22%2C%20%22little%20lamb%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.replacen" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> Â· <a class="srclink" href="../src/alloc/str.rs.html#326" title="goto source code">source</a></div><a href="#method.replacen" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.replacen" class="fnname">replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class="primitive" href="primitive.str.html">str</a>, count: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,&nbsp;</span></h4></div></summary><div class="docblock"><p>Replaces first N matches of a pattern with another string.</p>
<p><code>replacen</code> creates a new <a href="string/struct.String.html" title="String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice at most <code>count</code> times.</p>
<h5 id="examples-61" class="section-header"><a href="#examples-61">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;foo foo 123 foo&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;new new 123 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;new&quot;</span>, <span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;faa fao 123 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&#39;o&#39;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;foo foo new23 foo&quot;</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="ident">char::is_numeric</span>, <span class="string">&quot;new&quot;</span>, <span class="number">1</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22foo%20foo%20123%20foo%22%3B%0Aassert_eq!(%22new%20new%20123%20foo%22%2C%20s.replacen(%22foo%22%2C%20%22new%22%2C%202))%3B%0Aassert_eq!(%22faa%20fao%20123%20foo%22%2C%20s.replacen('o'%2C%20%22a%22%2C%203))%3B%0Aassert_eq!(%22foo%20foo%20new23%20foo%22%2C%20s.replacen(char%3A%3Ais_numeric%2C%20%22new%22%2C%201))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>When the pattern doesnâ€™t match:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="ident">s</span>, <span class="ident">s</span>.<span class="ident">replacen</span>(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>, <span class="number">10</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22this%20is%20old%22%3B%0Aassert_eq!(s%2C%20s.replacen(%22cookie%20monster%22%2C%20%22little%20lamb%22%2C%2010))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_lowercase" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="srclink" href="../src/alloc/str.rs.html#382" title="goto source code">source</a></div><a href="#method.to_lowercase" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.to_lowercase" class="fnname">to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="docblock"><p>Returns the lowercase equivalent of this string slice, as a new <a href="string/struct.String.html" title="String"><code>String</code></a>.</p>
<p>â€˜Lowercaseâ€™ is defined according to the terms of the Unicode Derived Core Property
<code>Lowercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="string/struct.String.html" title="String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-62" class="section-header"><a href="#examples-62">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;HELLO&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;hello&quot;</span>, <span class="ident">s</span>.<span class="ident">to_lowercase</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22HELLO%22%3B%0A%0Aassert_eq!(%22hello%22%2C%20s.to_lowercase())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A tricky example, with sigma:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">sigma</span> <span class="op">=</span> <span class="string">&quot;Î£&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;Ïƒ&quot;</span>, <span class="ident">sigma</span>.<span class="ident">to_lowercase</span>());

<span class="comment">// but at the end of a word, it&#39;s Ï‚, not Ïƒ:</span>
<span class="kw">let</span> <span class="ident">odysseus</span> <span class="op">=</span> <span class="string">&quot;á½ˆÎ”Î¥Î£Î£Î•ÎÎ£&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;á½€Î´Ï…ÏƒÏƒÎµÏÏ‚&quot;</span>, <span class="ident">odysseus</span>.<span class="ident">to_lowercase</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20sigma%20%3D%20%22%CE%A3%22%3B%0A%0Aassert_eq!(%22%CF%83%22%2C%20sigma.to_lowercase())%3B%0A%0A%2F%2F%20but%20at%20the%20end%20of%20a%20word%2C%20it's%20%CF%82%2C%20not%20%CF%83%3A%0Alet%20odysseus%20%3D%20%22%E1%BD%88%CE%94%CE%A5%CE%A3%CE%A3%CE%95%CE%8E%CE%A3%22%3B%0A%0Aassert_eq!(%22%E1%BD%80%CE%B4%CF%85%CF%83%CF%83%CE%B5%CF%8D%CF%82%22%2C%20odysseus.to_lowercase())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Languages without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">new_year</span> <span class="op">=</span> <span class="string">&quot;å†œå†æ–°å¹´&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="ident">new_year</span>, <span class="ident">new_year</span>.<span class="ident">to_lowercase</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20new_year%20%3D%20%22%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%22%3B%0A%0Aassert_eq!(new_year%2C%20new_year.to_lowercase())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_uppercase" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="srclink" href="../src/alloc/str.rs.html#464" title="goto source code">source</a></div><a href="#method.to_uppercase" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.to_uppercase" class="fnname">to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="docblock"><p>Returns the uppercase equivalent of this string slice, as a new <a href="string/struct.String.html" title="String"><code>String</code></a>.</p>
<p>â€˜Uppercaseâ€™ is defined according to the terms of the Unicode Derived Core Property
<code>Uppercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="string/struct.String.html" title="String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-63" class="section-header"><a href="#examples-63">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;hello&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;HELLO&quot;</span>, <span class="ident">s</span>.<span class="ident">to_uppercase</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22hello%22%3B%0A%0Aassert_eq!(%22HELLO%22%2C%20s.to_uppercase())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">new_year</span> <span class="op">=</span> <span class="string">&quot;å†œå†æ–°å¹´&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="ident">new_year</span>, <span class="ident">new_year</span>.<span class="ident">to_uppercase</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20new_year%20%3D%20%22%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%22%3B%0A%0Aassert_eq!(new_year%2C%20new_year.to_uppercase())%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>One character can become multiple:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;tschÃ¼ÃŸ&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;TSCHÃœSS&quot;</span>, <span class="ident">s</span>.<span class="ident">to_uppercase</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22tsch%C3%BC%C3%9F%22%3B%0A%0Aassert_eq!(%22TSCH%C3%9CSS%22%2C%20s.to_uppercase())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into_string" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="srclink" href="../src/alloc/str.rs.html#498" title="goto source code">source</a></div><a href="#method.into_string" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_string" class="fnname">into_string</a>(self: <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>, <a class="struct" href="alloc/struct.Global.html" title="struct std::alloc::Global">Global</a>&gt;) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="docblock"><p>Converts a <a href="boxed/struct.Box.html" title="Box&lt;str&gt;"><code>Box&lt;str&gt;</code></a> into a <a href="string/struct.String.html" title="String"><code>String</code></a> without copying or allocating.</p>
<h5 id="examples-64" class="section-header"><a href="#examples-64">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">string</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;birthday gift&quot;</span>);
<span class="kw">let</span> <span class="ident">boxed_str</span> <span class="op">=</span> <span class="ident">string</span>.<span class="ident">clone</span>().<span class="ident">into_boxed_str</span>();

<span class="macro">assert_eq!</span>(<span class="ident">boxed_str</span>.<span class="ident">into_string</span>(), <span class="ident">string</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20string%20%3D%20String%3A%3Afrom(%22birthday%20gift%22)%3B%0Alet%20boxed_str%20%3D%20string.clone().into_boxed_str()%3B%0A%0Aassert_eq!(boxed_str.into_string()%2C%20string)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.repeat" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> Â· <a class="srclink" href="../src/alloc/str.rs.html#526" title="goto source code">source</a></div><a href="#method.repeat" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.repeat" class="fnname">repeat</a>(&amp;self, n: <a class="primitive" href="primitive.usize.html">usize</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="docblock"><p>Creates a new <a href="string/struct.String.html" title="String"><code>String</code></a> by repeating a string <code>n</code> times.</p>
<h5 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h5>
<p>This function will panic if the capacity would overflow.</p>
<h5 id="examples-65" class="section-header"><a href="#examples-65">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;abc&quot;</span>.<span class="ident">repeat</span>(<span class="number">4</span>), <span class="ident">String::from</span>(<span class="string">&quot;abcabcabcabc&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22abc%22.repeat(4)%2C%20String%3A%3Afrom(%22abcabcabcabc%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
<p>A panic upon overflow:</p>

<div class='information'><div class='tooltip should_panic'>â“˜</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic"><code><span class="comment">// this will panic at runtime</span>
<span class="kw">let</span> <span class="ident">huge</span> <span class="op">=</span> <span class="string">&quot;0123456789abcdef&quot;</span>.<span class="ident">repeat</span>(<span class="ident">usize::MAX</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20this%20will%20panic%20at%20runtime%0Afn%20main()%20%7B%0Alet%20huge%20%3D%20%220123456789abcdef%22.repeat(usize%3A%3AMAX)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_ascii_uppercase" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="srclink" href="../src/alloc/str.rs.html#555" title="goto source code">source</a></div><a href="#method.to_ascii_uppercase" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.to_ascii_uppercase" class="fnname">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII upper case equivalent.</p>
<p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To uppercase the value in-place, use <a href="primitive.str.html#method.make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p>
<p>To uppercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p>
<h5 id="examples-66" class="section-header"><a href="#examples-66">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;GrÃ¼ÃŸe, JÃ¼rgen â¤&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;GRÃ¼ÃŸE, JÃ¼RGEN â¤&quot;</span>, <span class="ident">s</span>.<span class="ident">to_ascii_uppercase</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22Gr%C3%BC%C3%9Fe%2C%20J%C3%BCrgen%20%E2%9D%A4%22%3B%0A%0Aassert_eq!(%22GR%C3%BC%C3%9FE%2C%20J%C3%BCRGEN%20%E2%9D%A4%22%2C%20s.to_ascii_uppercase())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_ascii_lowercase" class="method has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="srclink" href="../src/alloc/str.rs.html#587" title="goto source code">source</a></div><a href="#method.to_ascii_lowercase" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.to_ascii_lowercase" class="fnname">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII lower case equivalent.</p>
<p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To lowercase the value in-place, use <a href="primitive.str.html#method.make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p>
<p>To lowercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p>
<h5 id="examples-67" class="section-header"><a href="#examples-67">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;GrÃ¼ÃŸe, JÃ¼rgen â¤&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;grÃ¼ÃŸe, jÃ¼rgen â¤&quot;</span>, <span class="ident">s</span>.<span class="ident">to_ascii_lowercase</span>());</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22Gr%C3%BC%C3%9Fe%2C%20J%C3%BCrgen%20%E2%9D%A4%22%3B%0A%0Aassert_eq!(%22gr%C3%BC%C3%9Fe%2C%20j%C3%BCrgen%20%E2%9D%A4%22%2C%20s.to_ascii_lowercase())%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Add%3C%26%27_%20str%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2196-2204" title="goto source code">source</a></div><a href="#impl-Add%3C%26%27_%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_&gt; <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="docblock"><p>Implements the <code>+</code> operator for concatenating two strings.</p>
<p>This consumes the <code>String</code> on the left-hand side and re-uses its buffer (growing it if
necessary). This is done to avoid allocating a new <code>String</code> and copying the entire contents on
every operation, which would lead to <em>O</em>(<em>n</em>^2) running time when building an <em>n</em>-byte string by
repeated concatenation.</p>
<p>The string on the right-hand side is only borrowed; its contents are copied into the returned
<code>String</code>.</p>
<h4 id="examples-70" class="section-header"><a href="#examples-70">Examples</a></h4>
<p>Concatenating two <code>String</code>s takes the first by value and borrows the second:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;hello&quot;</span>);
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot; world&quot;</span>);
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span> <span class="op">+</span> <span class="kw-2">&amp;</span><span class="ident">b</span>;
<span class="comment">// `a` is moved and can no longer be used here.</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20a%20%3D%20String%3A%3Afrom(%22hello%22)%3B%0Alet%20b%20%3D%20String%3A%3Afrom(%22%20world%22)%3B%0Alet%20c%20%3D%20a%20%2B%20%26b%3B%0A%2F%2F%20%60a%60%20is%20moved%20and%20can%20no%20longer%20be%20used%20here.%0A%7D&amp;edition=2021">Run</a></div>
<p>If you want to keep using the first <code>String</code>, you can clone it and append to the clone instead:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot;hello&quot;</span>);
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="ident">String::from</span>(<span class="string">&quot; world&quot;</span>);
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span>.<span class="ident">clone</span>() <span class="op">+</span> <span class="kw-2">&amp;</span><span class="ident">b</span>;
<span class="comment">// `a` is still valid here.</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20a%20%3D%20String%3A%3Afrom(%22hello%22)%3B%0Alet%20b%20%3D%20String%3A%3Afrom(%22%20world%22)%3B%0Alet%20c%20%3D%20a.clone()%20%2B%20%26b%3B%0A%2F%2F%20%60a%60%20is%20still%20valid%20here.%0A%7D&amp;edition=2021">Run</a></div>
<p>Concatenating <code>&amp;str</code> slices can be done by converting the first to a <code>String</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="string">&quot;hello&quot;</span>;
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="string">&quot; world&quot;</span>;
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">a</span>.<span class="ident">to_string</span>() <span class="op">+</span> <span class="ident">b</span>;</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20a%20%3D%20%22hello%22%3B%0Alet%20b%20%3D%20%22%20world%22%3B%0Alet%20c%20%3D%20a.to_string()%20%2B%20b%3B%0A%7D&amp;edition=2021">Run</a></div>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output-9" class="type trait-impl has-srclink"><a href="#associatedtype.Output-9" class="anchor"></a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class='docblock'><p>The resulting type after applying the <code>+</code> operator.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.add-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2200" title="goto source code">source</a></div><a href="#method.add-1" class="anchor"></a><h4 class="code-header">pub fn <a href="ops/trait.Add.html#tymethod.add" class="fnname">add</a>(self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class='docblock'><p>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Add%3C%26%27a%20str%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span> Â· <a class="srclink" href="../src/alloc/borrow.rs.html#442-450" title="goto source code">source</a></div><a href="#impl-Add%3C%26%27a%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output-8" class="type trait-impl has-srclink"><a href="#associatedtype.Output-8" class="anchor"></a><h4 class="code-header">type <a href="ops/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></div></summary><div class='docblock'><p>The resulting type after applying the <code>+</code> operator.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.add" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#446" title="goto source code">source</a></div><a href="#method.add" class="anchor"></a><h4 class="code-header">pub fn <a href="ops/trait.Add.html#tymethod.add" class="fnname">add</a>(self, rhs: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; &lt;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt; as <a class="trait" href="ops/trait.Add.html" title="trait std::ops::Add">Add</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="ops/trait.Add.html#associatedtype.Output" title="type std::ops::Add::Output">Output</a></h4></div></summary><div class='docblock'><p>Performs the <code>+</code> operation. <a href="ops/trait.Add.html#tymethod.add">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AddAssign%3C%26%27_%20str%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> Â· <a class="srclink" href="../src/alloc/string.rs.html#2211-2216" title="goto source code">source</a></div><a href="#impl-AddAssign%3C%26%27_%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_&gt; <a class="trait" href="ops/trait.AddAssign.html" title="trait std::ops::AddAssign">AddAssign</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="docblock"><p>Implements the <code>+=</code> operator for appending to a <code>String</code>.</p>
<p>This has the same behavior as the <a href="string/struct.String.html#method.push_str" title="String::push_str"><code>push_str</code></a> method.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.add_assign-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2213" title="goto source code">source</a></div><a href="#method.add_assign-1" class="anchor"></a><h4 class="code-header">pub fn <a href="ops/trait.AddAssign.html#tymethod.add_assign" class="fnname">add_assign</a>(&amp;mut self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>)</h4></div></summary><div class='docblock'><p>Performs the <code>+=</code> operation. <a href="ops/trait.AddAssign.html#tymethod.add_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AddAssign%3C%26%27a%20str%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.14.0">1.14.0</span> Â· <a class="srclink" href="../src/alloc/borrow.rs.html#466-479" title="goto source code">source</a></div><a href="#impl-AddAssign%3C%26%27a%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="ops/trait.AddAssign.html" title="trait std::ops::AddAssign">AddAssign</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.add_assign" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/borrow.rs.html#467" title="goto source code">source</a></div><a href="#method.add_assign" class="anchor"></a><h4 class="code-header">pub fn <a href="ops/trait.AddAssign.html#tymethod.add_assign" class="fnname">add_assign</a>(&amp;mut self, rhs: &amp;'a <a class="primitive" href="primitive.str.html">str</a>)</h4></div></summary><div class='docblock'><p>Performs the <code>+=</code> operation. <a href="ops/trait.AddAssign.html#tymethod.add_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsMut%3Cstr%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· <a class="srclink" href="../src/core/convert/mod.rs.html#627-632" title="goto source code">source</a></div><a href="#impl-AsMut%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.AsMut.html" title="trait std::convert::AsMut">AsMut</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#629" title="goto source code">source</a></div><a href="#method.as_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsMut%3Cstr%3E-1" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.43.0">1.43.0</span> Â· <a class="srclink" href="../src/alloc/string.rs.html#2492-2497" title="goto source code">source</a></div><a href="#impl-AsMut%3Cstr%3E-1" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.AsMut.html" title="trait std::convert::AsMut">AsMut</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_mut-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2494" title="goto source code">source</a></div><a href="#method.as_mut-1" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsRef%3C%5Bu8%5D%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2472-2477" title="goto source code">source</a></div><a href="#impl-AsRef%3C%5Bu8%5D%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.slice.html">[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ref-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2474" title="goto source code">source</a></div><a href="#method.as_ref-1" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; <a class="primitive" href="primitive.slice.html">&amp;[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a><span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="primitive" href="primitive.slice.html">&amp;[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></div><code class="content"><span class="where fmt-newline">impl <a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="primitive.slice.html">&amp;[</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></span><span class="where fmt-newline">impl <a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="primitive.slice.html">&amp;mut [</a><a class="primitive" href="primitive.u8.html">u8</a><a class="primitive" href="primitive.slice.html">]</a></span></code></span></div></span></span></h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsRef%3COsStr%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#1249-1254" title="goto source code">source</a></div><a href="#impl-AsRef%3COsStr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ref-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#1251-1253" title="goto source code">source</a></div><a href="#method.as_ref-4" class="anchor"></a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a></h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsRef%3CPath%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/path.rs.html#2993-2998" title="goto source code">source</a></div><a href="#impl-AsRef%3CPath%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="path/struct.Path.html" title="struct std::path::Path">Path</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ref-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/path.rs.html#2995-2997" title="goto source code">source</a></div><a href="#method.as_ref-5" class="anchor"></a><h4 class="code-header">fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="path/struct.Path.html" title="struct std::path::Path">Path</a></h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsRef%3Cstr%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#619-624" title="goto source code">source</a></div><a href="#impl-AsRef%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ref" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/convert/mod.rs.html#621" title="goto source code">source</a></div><a href="#method.as_ref" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsRef%3Cstr%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2484-2489" title="goto source code">source</a></div><a href="#impl-AsRef%3Cstr%3E-1" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ref-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2486" title="goto source code">source</a></div><a href="#method.as_ref-2" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsRef%3Cstr%3E-2" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.55.0">1.55.0</span> Â· <a class="srclink" href="../src/alloc/string.rs.html#2802-2806" title="goto source code">source</a></div><a href="#impl-AsRef%3Cstr%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="convert/trait.AsRef.html" title="trait std::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.Drain.html" title="struct std::string::Drain">Drain</a>&lt;'a&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.as_ref-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2803" title="goto source code">source</a></div><a href="#method.as_ref-3" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-AsciiExt" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ascii.rs.html#204-208" title="goto source code">source</a></div><a href="#impl-AsciiExt" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="ascii/trait.AsciiExt.html" title="trait std::ascii::AsciiExt">AsciiExt</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned-1" class="type trait-impl has-srclink"><a href="#associatedtype.Owned-1" class="anchor"></a><h4 class="code-header">type <a href="ascii/trait.AsciiExt.html#associatedtype.Owned" class="associatedtype">Owned</a> = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p>
</div></div><div class='docblock'><p>Container type for copied ASCII characters.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.is_ascii-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ascii.rs.html#207" title="goto source code">source</a></div><a href="#method.is_ascii-1" class="anchor"></a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.is_ascii" class="fnname">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p>
</div></div><div class='docblock'><p>Checks if the value is within the ASCII range. <a href="ascii/trait.AsciiExt.html#tymethod.is_ascii">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_ascii_uppercase-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ascii.rs.html#207" title="goto source code">source</a></div><a href="#method.to_ascii_uppercase-1" class="anchor"></a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.to_ascii_uppercase" class="fnname">to_ascii_uppercase</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="ascii/trait.AsciiExt.html#associatedtype.Owned" title="type std::ascii::AsciiExt::Owned">Owned</a></h4></div></summary><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p>
</div></div><div class='docblock'><p>Makes a copy of the value in its ASCII upper case equivalent. <a href="ascii/trait.AsciiExt.html#tymethod.to_ascii_uppercase">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_ascii_lowercase-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ascii.rs.html#207" title="goto source code">source</a></div><a href="#method.to_ascii_lowercase-1" class="anchor"></a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.to_ascii_lowercase" class="fnname">to_ascii_lowercase</a>(&amp;self) -&gt; Self::<a class="associatedtype" href="ascii/trait.AsciiExt.html#associatedtype.Owned" title="type std::ascii::AsciiExt::Owned">Owned</a></h4></div></summary><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p>
</div></div><div class='docblock'><p>Makes a copy of the value in its ASCII lower case equivalent. <a href="ascii/trait.AsciiExt.html#tymethod.to_ascii_lowercase">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq_ignore_ascii_case-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ascii.rs.html#207" title="goto source code">source</a></div><a href="#method.eq_ignore_ascii_case-1" class="anchor"></a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.eq_ignore_ascii_case" class="fnname">eq_ignore_ascii_case</a>(&amp;self, o: <a class="primitive" href="primitive.reference.html">&amp;</a>Self) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p>
</div></div><div class='docblock'><p>Checks that two values are an ASCII case-insensitive match. <a href="ascii/trait.AsciiExt.html#tymethod.eq_ignore_ascii_case">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.make_ascii_uppercase-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ascii.rs.html#207" title="goto source code">source</a></div><a href="#method.make_ascii_uppercase-1" class="anchor"></a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.make_ascii_uppercase" class="fnname">make_ascii_uppercase</a>(&amp;mut self)</h4></div></summary><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p>
</div></div><div class='docblock'><p>Converts this type to its ASCII upper case equivalent in-place. <a href="ascii/trait.AsciiExt.html#tymethod.make_ascii_uppercase">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.make_ascii_lowercase-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ascii.rs.html#207" title="goto source code">source</a></div><a href="#method.make_ascii_lowercase-1" class="anchor"></a><h4 class="code-header">fn <a href="ascii/trait.AsciiExt.html#tymethod.make_ascii_lowercase" class="fnname">make_ascii_lowercase</a>(&amp;mut self)</h4></div></summary><div class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span> Deprecated since 1.26.0: <p>use inherent methods instead</p>
</div></div><div class='docblock'><p>Converts this type to its ASCII lower case equivalent in-place. <a href="ascii/trait.AsciiExt.html#tymethod.make_ascii_lowercase">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Borrow%3Cstr%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#206-211" title="goto source code">source</a></div><a href="#impl-Borrow%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#208" title="goto source code">source</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-BorrowMut%3Cstr%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> Â· <a class="srclink" href="../src/alloc/str.rs.html#214-219" title="goto source code">source</a></div><a href="#impl-BorrowMut%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#216" title="goto source code">source</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Concat%3Cstr%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#79-85" title="goto source code">source</a></div><a href="#impl-Concat%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;S&gt; <a class="trait" href="slice/trait.Concat.html" title="trait std::slice::Concat">Concat</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.slice.html">[</a>S<a class="primitive" href="primitive.slice.html">]</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h3></div></summary><div class="docblock"><p>Note: <code>str</code> in <code>Concat&lt;str&gt;</code> is not meaningful here.
This type parameter of the trait only exists to enable another impl.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output-7" class="type trait-impl has-srclink"><a href="#associatedtype.Output-7" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.Concat.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_concat_trait</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</div></div><div class='docblock'><p>The resulting type after concatenation</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.concat" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#82" title="goto source code">source</a></div><a href="#method.concat" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.Concat.html#tymethod.concat" class="fnname">concat</a>(slice: <a class="primitive" href="primitive.slice.html">&amp;[S]</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_concat_trait</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</div></div><div class='docblock'><p>Implementation of <a href="primitive.slice.html#method.concat"><code>[T]::concat</code></a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Debug" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2148-2170" title="goto source code">source</a></div><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2149" title="goto source code">source</a></div><a href="#method.fmt" class="anchor"></a><h4 class="code-header">pub fn <a href="fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Default" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0, const unstable">1.0.0 (const: <a href="https://github.com/rust-lang/rust/issues/87864" title="Tracking issue for const_default_impls">unstable</a>)</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2481-2487" title="goto source code">source</a></div><a href="#impl-Default" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_&gt; <a class="trait" href="default/trait.Default.html" title="trait std::default::Default">Default</a> for &amp;'_ <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.default" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2484" title="goto source code">source</a></div><a href="#method.default" class="anchor"></a><h4 class="code-header">pub fn <a href="default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; &amp;'_ <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class="docblock"><p>Creates an empty str</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Default-1" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.28.0">1.28.0</span> Â· <a class="srclink" href="../src/core/str/mod.rs.html#2490-2497" title="goto source code">source</a></div><a href="#impl-Default-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_&gt; <a class="trait" href="default/trait.Default.html" title="trait std::default::Default">Default</a> for &amp;'_ mut <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.default-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/mod.rs.html#2493" title="goto source code">source</a></div><a href="#method.default-1" class="anchor"></a><h4 class="code-header">pub fn <a href="default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; &amp;'_ mut <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class="docblock"><p>Creates an empty mutable str</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Display" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2173-2177" title="goto source code">source</a></div><a href="#impl-Display" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="fmt/trait.Display.html" title="trait std::fmt::Display">Display</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.fmt-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/fmt/mod.rs.html#2174" title="goto source code">source</a></div><a href="#method.fmt-1" class="anchor"></a><h4 class="code-header">pub fn <a href="fmt/trait.Display.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="primitive.unit.html">()</a>, <a class="struct" href="fmt/struct.Error.html" title="struct std::fmt::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="fmt/trait.Display.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Extend%3C%26%27a%20str%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#1982-1991" title="goto source code">source</a></div><a href="#impl-Extend%3C%26%27a%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="iter/trait.Extend.html" title="trait std::iter::Extend">Extend</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.extend" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#1983" title="goto source code">source</a></div><a href="#method.extend" class="anchor"></a><h4 class="code-header">pub fn <a href="iter/trait.Extend.html#tymethod.extend" class="fnname">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h4></div></summary><div class='docblock'><p>Extends a collection with the contents of an iterator. <a href="iter/trait.Extend.html#tymethod.extend">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.extend_one" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#1988" title="goto source code">source</a></div><a href="#method.extend_one" class="anchor"></a><h4 class="code-header">pub fn <a href="iter/trait.Extend.html#method.extend_one" class="fnname">extend_one</a>(&amp;mut self, s: &amp;'a <a class="primitive" href="primitive.str.html">str</a>)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></div><div class='docblock'><p>Extends a collection with exactly one element.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.extend_reserve" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/iter/traits/collect.rs.html#345" title="goto source code">source</a></div><a href="#method.extend_reserve" class="anchor"></a><h4 class="code-header">fn <a href="iter/trait.Extend.html#method.extend_reserve" class="fnname">extend_reserve</a>(&amp;mut self, additional: <a class="primitive" href="primitive.usize.html">usize</a>)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>extend_one</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/72631">#72631</a>)</div></div><div class='docblock'><p>Reserves capacity in a collection for the given number of additional elements. <a href="iter/trait.Extend.html#method.extend_reserve">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3C%26%27_%20mut%20str%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.44.0">1.44.0</span> Â· <a class="srclink" href="../src/alloc/string.rs.html#2521-2529" title="goto source code">source</a></div><a href="#impl-From%3C%26%27_%20mut%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;'_ mut <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2526" title="goto source code">source</a></div><a href="#method.from-3" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: &amp;mut <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="docblock"><p>Converts a <code>&amp;mut str</code> into a <a href="string/struct.String.html" title="String"><code>String</code></a>.</p>
<p>The result is allocated on the heap.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3C%26%27_%20str%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2509-2517" title="goto source code">source</a></div><a href="#impl-From%3C%26%27_%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2514" title="goto source code">source</a></div><a href="#method.from" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="docblock"><p>Converts a <code>&amp;str</code> into a <a href="string/struct.String.html" title="String"><code>String</code></a>.</p>
<p>The result is allocated on the heap.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3C%26%27_%20str%3E-1" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· <a class="srclink" href="../src/alloc/rc.rs.html#1806-1821" title="goto source code">source</a></div><a href="#impl-From%3C%26%27_%20str%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="rc/struct.Rc.html" title="struct std::rc::Rc">Rc</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/rc.rs.html#1817" title="goto source code">source</a></div><a href="#method.from-1" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(v: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="rc/struct.Rc.html" title="struct std::rc::Rc">Rc</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></div></summary><div class="docblock"><p>Allocate a reference-counted string slice and copy <code>v</code> into it.</p>
<h5 id="example" class="section-header"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">shared</span>: <span class="ident">Rc</span><span class="op">&lt;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Rc::from</span>(<span class="string">&quot;statue&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;statue&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">shared</span>[..]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0Alet%20shared%3A%20Rc%3Cstr%3E%20%3D%20Rc%3A%3Afrom(%22statue%22)%3B%0Aassert_eq!(%22statue%22%2C%20%26shared%5B..%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3C%26%27_%20str%3E-2" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· <a class="srclink" href="../src/alloc/sync.rs.html#2401-2416" title="goto source code">source</a></div><a href="#impl-From%3C%26%27_%20str%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="sync/struct.Arc.html" title="struct std::sync::Arc">Arc</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/sync.rs.html#2412" title="goto source code">source</a></div><a href="#method.from-4" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(v: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="sync/struct.Arc.html" title="struct std::sync::Arc">Arc</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;</h4></div></summary><div class="docblock"><p>Allocate a reference-counted <code>str</code> and copy <code>v</code> into it.</p>
<h5 id="example-2" class="section-header"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">shared</span>: <span class="ident">Arc</span><span class="op">&lt;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Arc::from</span>(<span class="string">&quot;eggplant&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;eggplant&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">shared</span>[..]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3AArc%3B%0Alet%20shared%3A%20Arc%3Cstr%3E%20%3D%20Arc%3A%3Afrom(%22eggplant%22)%3B%0Aassert_eq!(%22eggplant%22%2C%20%26shared%5B..%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3C%26%27_%20str%3E-3" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.17.0">1.17.0</span> Â· <a class="srclink" href="../src/alloc/boxed.rs.html#1443-1459" title="goto source code">source</a></div><a href="#impl-From%3C%26%27_%20str%3E-3" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>, <a class="struct" href="alloc/struct.Global.html" title="struct std::alloc::Global">Global</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/boxed.rs.html#1456" title="goto source code">source</a></div><a href="#method.from-5" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;<a class="primitive" href="primitive.str.html">str</a>, <a class="struct" href="alloc/struct.Global.html" title="struct std::alloc::Global">Global</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;F, A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;F, A&gt; <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;F, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a> + <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a> + 'static,&nbsp;</span></span><span class="where fmt-newline">    type <a href="future/trait.Future.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;F as <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a>&gt;::<a class="associatedtype" href="future/trait.Future.html#associatedtype.Output" title="type std::future::Future::Output">Output</a>;</span><span class="where fmt-newline">impl&lt;I, A&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;I, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;I as <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="iter/trait.Iterator.html#associatedtype.Item" title="type std::iter::Iterator::Item">Item</a>;</span><span class="where fmt-newline">impl&lt;R:&nbsp;<a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;R&gt;</span><span class="where fmt-newline">impl&lt;W:&nbsp;<a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;W&gt;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Converts a <code>&amp;str</code> into a <code>Box&lt;str&gt;</code></p>
<p>This conversion allocates on the heap
and performs a copy of <code>s</code>.</p>
<h5 id="examples-71" class="section-header"><a href="#examples-71">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">boxed</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box::from</span>(<span class="string">&quot;hello&quot;</span>);
<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">boxed</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20boxed%3A%20Box%3Cstr%3E%20%3D%20Box%3A%3Afrom(%22hello%22)%3B%0Aprintln!(%22%7B%7D%22%2C%20boxed)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3C%26%27_%20str%3E-4" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/vec/mod.rs.html#2990-3001" title="goto source code">source</a></div><a href="#impl-From%3C%26%27_%20str%3E-4" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8.html">u8</a>, <a class="struct" href="alloc/struct.Global.html" title="struct std::alloc::Global">Global</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/vec/mod.rs.html#2998" title="goto source code">source</a></div><a href="#method.from-6" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8.html">u8</a>, <a class="struct" href="alloc/struct.Global.html" title="struct std::alloc::Global">Global</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8.html">u8</a>, A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;A:&nbsp;<a class="trait" href="alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>&gt; <a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="vec/struct.Vec.html" title="struct std::vec::Vec">Vec</a>&lt;<a class="primitive" href="primitive.u8.html">u8</a>, A&gt;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Allocate a <code>Vec&lt;u8&gt;</code> and fill it with a UTF-8 string.</p>
<h5 id="examples-72" class="section-header"><a href="#examples-72">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="ident">Vec::from</span>(<span class="string">&quot;123&quot;</span>), <span class="macro">vec!</span>[<span class="string">b&#39;1&#39;</span>, <span class="string">b&#39;2&#39;</span>, <span class="string">b&#39;3&#39;</span>]);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(Vec%3A%3Afrom(%22123%22)%2C%20vec!%5Bb'1'%2C%20b'2'%2C%20b'3'%5D)%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3C%26%27_%20str%3E-5" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/error.rs.html#305-325" title="goto source code">source</a></div><a href="#impl-From%3C%26%27_%20str%3E-5" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a> + <a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> + <a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> + 'a&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-7" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/error.rs.html#322-324" title="goto source code">source</a></div><a href="#method.from-7" class="anchor"></a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(err: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a> + <a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> + <a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> + 'a&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;F, A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;F, A&gt; <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;F, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a> + <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a> + 'static,&nbsp;</span></span><span class="where fmt-newline">    type <a href="future/trait.Future.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;F as <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a>&gt;::<a class="associatedtype" href="future/trait.Future.html#associatedtype.Output" title="type std::future::Future::Output">Output</a>;</span><span class="where fmt-newline">impl&lt;I, A&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;I, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;I as <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="iter/trait.Iterator.html#associatedtype.Item" title="type std::iter::Iterator::Item">Item</a>;</span><span class="where fmt-newline">impl&lt;R:&nbsp;<a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;R&gt;</span><span class="where fmt-newline">impl&lt;W:&nbsp;<a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;W&gt;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Converts a <a href="primitive.str.html"><code>str</code></a> into a box of dyn <a href="error/trait.Error.html" title="Error"><code>Error</code></a> + <a href="marker/trait.Send.html" title="Send"><code>Send</code></a> + <a href="marker/trait.Sync.html" title="Sync"><code>Sync</code></a>.</p>
<h5 id="examples-73" class="section-header"><a href="#examples-73">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">std::mem</span>;

<span class="kw">let</span> <span class="ident">a_str_error</span> <span class="op">=</span> <span class="string">&quot;a str error&quot;</span>;
<span class="kw">let</span> <span class="ident">a_boxed_error</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">Error</span> <span class="op">+</span> <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span><span class="op">&gt;</span><span class="ident">::from</span>(<span class="ident">a_str_error</span>);
<span class="macro">assert!</span>(
    <span class="ident">mem::size_of</span>::<span class="op">&lt;</span><span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">Error</span> <span class="op">+</span> <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span><span class="op">&gt;</span><span class="op">&gt;</span>() <span class="op">==</span> <span class="ident">mem::size_of_val</span>(<span class="kw-2">&amp;</span><span class="ident">a_boxed_error</span>))</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aerror%3A%3AError%3B%0Ause%20std%3A%3Amem%3B%0A%0Alet%20a_str_error%20%3D%20%22a%20str%20error%22%3B%0Alet%20a_boxed_error%20%3D%20Box%3A%3A%3Cdyn%20Error%20%2B%20Send%20%2B%20Sync%3E%3A%3Afrom(a_str_error)%3B%0Aassert!(%0A%20%20%20%20mem%3A%3Asize_of%3A%3A%3CBox%3Cdyn%20Error%20%2B%20Send%20%2B%20Sync%3E%3E()%20%3D%3D%20mem%3A%3Asize_of_val(%26a_boxed_error))%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3C%26%27_%20str%3E-6" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> Â· <a class="srclink" href="../src/std/error.rs.html#328-346" title="goto source code">source</a></div><a href="#impl-From%3C%26%27_%20str%3E-6" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-8" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/error.rs.html#343-345" title="goto source code">source</a></div><a href="#method.from-8" class="anchor"></a><h4 class="code-header">fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(err: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;dyn <a class="trait" href="error/trait.Error.html" title="trait std::error::Error">Error</a>&gt;<span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;F, A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;F, A&gt; <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;F, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a> + <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a> + 'static,&nbsp;</span></span><span class="where fmt-newline">    type <a href="future/trait.Future.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;F as <a class="trait" href="future/trait.Future.html" title="trait std::future::Future">Future</a>&gt;::<a class="associatedtype" href="future/trait.Future.html#associatedtype.Output" title="type std::future::Future::Output">Output</a>;</span><span class="where fmt-newline">impl&lt;I, A&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;I, A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="alloc/trait.Allocator.html" title="trait std::alloc::Allocator">Allocator</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;I as <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="iter/trait.Iterator.html#associatedtype.Item" title="type std::iter::Iterator::Item">Item</a>;</span><span class="where fmt-newline">impl&lt;R:&nbsp;<a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;R&gt;</span><span class="where fmt-newline">impl&lt;W:&nbsp;<a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="trait" href="io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="boxed/struct.Box.html" title="struct std::boxed::Box">Box</a>&lt;W&gt;</span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Converts a <a href="primitive.str.html"><code>str</code></a> into a box of dyn <a href="error/trait.Error.html" title="Error"><code>Error</code></a>.</p>
<h5 id="examples-74" class="section-header"><a href="#examples-74">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">std::mem</span>;

<span class="kw">let</span> <span class="ident">a_str_error</span> <span class="op">=</span> <span class="string">&quot;a str error&quot;</span>;
<span class="kw">let</span> <span class="ident">a_boxed_error</span> <span class="op">=</span> <span class="ident">Box</span>::<span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="ident">::from</span>(<span class="ident">a_str_error</span>);
<span class="macro">assert!</span>(<span class="ident">mem::size_of</span>::<span class="op">&lt;</span><span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span>() <span class="op">==</span> <span class="ident">mem::size_of_val</span>(<span class="kw-2">&amp;</span><span class="ident">a_boxed_error</span>))</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aerror%3A%3AError%3B%0Ause%20std%3A%3Amem%3B%0A%0Alet%20a_str_error%20%3D%20%22a%20str%20error%22%3B%0Alet%20a_boxed_error%20%3D%20Box%3A%3A%3Cdyn%20Error%3E%3A%3Afrom(a_str_error)%3B%0Aassert!(mem%3A%3Asize_of%3A%3A%3CBox%3Cdyn%20Error%3E%3E()%20%3D%3D%20mem%3A%3Asize_of_val(%26a_boxed_error))%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3C%26%27a%20str%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2613-2630" title="goto source code">source</a></div><a href="#impl-From%3C%26%27a%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="convert/trait.From.html" title="trait std::convert::From">From</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2627" title="goto source code">source</a></div><a href="#method.from-2" class="anchor"></a><h4 class="code-header">pub fn <a href="convert/trait.From.html#tymethod.from" class="fnname">from</a>(s: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></div></summary><div class="docblock"><p>Converts a string slice into a <a href="borrow/enum.Cow.html#variant.Borrowed" title="borrow::Cow::Borrowed"><code>Borrowed</code></a> variant.
No heap allocation is performed, and the string
is not copied.</p>
<h5 id="example-1" class="section-header"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="ident">Cow::from</span>(<span class="string">&quot;eggplant&quot;</span>), <span class="ident">Cow::Borrowed</span>(<span class="string">&quot;eggplant&quot;</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Ause%20std%3A%3Aborrow%3A%3ACow%3B%0Aassert_eq!(Cow%3A%3Afrom(%22eggplant%22)%2C%20Cow%3A%3ABorrowed(%22eggplant%22))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-FromIterator%3C%26%27a%20str%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#1884-1890" title="goto source code">source</a></div><a href="#impl-FromIterator%3C%26%27a%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from_iter" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#1885" title="goto source code">source</a></div><a href="#method.from_iter" class="anchor"></a><h4 class="code-header">pub fn <a href="iter/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h4></div></summary><div class='docblock'><p>Creates a value from an iterator. <a href="iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-FromIterator%3C%26%27b%20str%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> Â· <a class="srclink" href="../src/alloc/string.rs.html#2687-2691" title="goto source code">source</a></div><a href="#impl-FromIterator%3C%26%27b%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="iter/trait.FromIterator.html" title="trait std::iter::FromIterator">FromIterator</a>&lt;&amp;'b <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from_iter-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2688" title="goto source code">source</a></div><a href="#method.from_iter-1" class="anchor"></a><h4 class="code-header">pub fn <a href="iter/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;I&gt;(it: I) -&gt; <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="iter/trait.IntoIterator.html" title="trait std::iter::IntoIterator">IntoIterator</a>&lt;Item = &amp;'b <a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h4></div></summary><div class='docblock'><p>Creates a value from an iterator. <a href="iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Hash" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/hash/mod.rs.html#709-715" title="goto source code">source</a></div><a href="#impl-Hash" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="hash/trait.Hash.html" title="trait std::hash::Hash">Hash</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.hash" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/hash/mod.rs.html#711" title="goto source code">source</a></div><a href="#method.hash" class="anchor"></a><h4 class="code-header">pub fn <a href="hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></h4></div></summary><div class='docblock'><p>Feeds this value into the given <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.hash_slice" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> Â· <a class="srclink" href="../src/core/hash/mod.rs.html#237-239" title="goto source code">source</a></div><a href="#method.hash_slice" class="anchor"></a><h4 class="code-header">fn <a href="hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="hash/trait.Hasher.html" title="trait std::hash::Hasher">Hasher</a>,&nbsp;</span></h4></div></summary><div class='docblock'><p>Feeds a slice of this type into the given <a href="hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Index%3CI%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#56-66" title="goto source code">source</a></div><a href="#impl-Index%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;I&gt; <a class="trait" href="ops/trait.Index.html" title="trait std::ops::Index">Index</a>&lt;I&gt; for <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output-6" class="type trait-impl has-srclink"><a href="#associatedtype.Output-6" class="anchor"></a><h4 class="code-header">type <a href="ops/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#63" title="goto source code">source</a></div><a href="#method.index-6" class="anchor"></a><h4 class="code-header">pub fn <a href="ops/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: I) -&gt; &amp;&lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class='docblock'><p>Performs the indexing (<code>container[index]</code>) operation. <a href="ops/trait.Index.html#tymethod.index">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-IndexMut%3CI%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#69-77" title="goto source code">source</a></div><a href="#impl-IndexMut%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;I&gt; <a class="trait" href="ops/trait.IndexMut.html" title="trait std::ops::IndexMut">IndexMut</a>&lt;I&gt; for <a class="primitive" href="primitive.str.html">str</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index_mut-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#74" title="goto source code">source</a></div><a href="#method.index_mut-6" class="anchor"></a><h4 class="code-header">pub fn <a href="ops/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: I) -&gt; &amp;mut &lt;I as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class='docblock'><p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="ops/trait.IndexMut.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Join%3C%26%27_%20str%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#89-95" title="goto source code">source</a></div><a href="#impl-Join%3C%26%27_%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'_, S&gt; <a class="trait" href="slice/trait.Join.html" title="trait std::slice::Join">Join</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.slice.html">[</a>S<a class="primitive" href="primitive.slice.html">]</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output-10" class="type trait-impl has-srclink"><a href="#associatedtype.Output-10" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.Join.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_concat_trait</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</div></div><div class='docblock'><p>The resulting type after concatenation</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.join" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#92" title="goto source code">source</a></div><a href="#method.join" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.Join.html#tymethod.join" class="fnname">join</a>(slice: <a class="primitive" href="primitive.slice.html">&amp;[S]</a>, sep: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_concat_trait</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27747">#27747</a>)</div></div><div class='docblock'><p>Implementation of <a href="primitive.slice.html#method.join"><code>[T]::join</code></a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Ord" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#18-23" title="goto source code">source</a></div><a href="#impl-Ord" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.Ord.html" title="trait std::cmp::Ord">Ord</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="docblock"><p>Implements ordering of strings.</p>
<p>Strings are ordered  <a href="cmp/trait.Ord.html#lexicographical-comparison">lexicographically</a> by their byte values. This orders Unicode code
points based on their positions in the code charts. This is not necessarily the same as
â€œalphabeticalâ€ order, which varies by language and locale. Sorting strings according to
culturally-accepted standards requires locale-specific data that is outside the scope of
the <code>str</code> type.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.cmp" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#20" title="goto source code">source</a></div><a href="#method.cmp" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a></h4></div></summary><div class='docblock'><p>This method returns an <a href="cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.max" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· <a class="srclink" href="../src/core/cmp.rs.html#785-787" title="goto source code">source</a></div><a href="#method.max" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Compares and returns the maximum of two values. <a href="cmp/trait.Ord.html#method.max">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.min" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· <a class="srclink" href="../src/core/cmp.rs.html#805-807" title="goto source code">source</a></div><a href="#method.min" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Compares and returns the minimum of two values. <a href="cmp/trait.Ord.html#method.min">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clamp" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> Â· <a class="srclink" href="../src/core/cmp.rs.html#830-832" title="goto source code">source</a></div><a href="#method.clamp" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</h4></div></summary><div class='docblock'><p>Restrict a value to a certain interval. <a href="cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3C%26%27_%20str%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span> Â· <a class="srclink" href="../src/std/ffi/os_str.rs.html#550-555" title="goto source code">source</a></div><a href="#impl-PartialEq%3C%26%27_%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;&amp;'_ <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-11" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#552-554" title="goto source code">source</a></div><a href="#method.eq-11" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;&amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-11" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#219" title="goto source code">source</a></div><a href="#method.ne-11" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3C%26%27a%20str%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2115" title="goto source code">source</a></div><a href="#impl-PartialEq%3C%26%27a%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2115" title="goto source code">source</a></div><a href="#method.eq-3" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;&amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2115" title="goto source code">source</a></div><a href="#method.ne-3" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;&amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3C%26%27b%20str%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2119" title="goto source code">source</a></div><a href="#impl-PartialEq%3C%26%27b%20str%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;&amp;'b <a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2119" title="goto source code">source</a></div><a href="#method.eq-4" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;&amp;'b <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2119" title="goto source code">source</a></div><a href="#method.ne-4" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;&amp;'b <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3CCow%3C%27a%2C%20str%3E%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2119" title="goto source code">source</a></div><a href="#impl-PartialEq%3CCow%3C%27a%2C%20str%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;&gt; for &amp;'b <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2119" title="goto source code">source</a></div><a href="#method.eq-2" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2119" title="goto source code">source</a></div><a href="#method.ne-2" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3CCow%3C%27a%2C%20str%3E%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2117" title="goto source code">source</a></div><a href="#impl-PartialEq%3CCow%3C%27a%2C%20str%3E%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-8" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2117" title="goto source code">source</a></div><a href="#method.eq-8" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-8" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2117" title="goto source code">source</a></div><a href="#method.ne-8" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3COsStr%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#1095-1100" title="goto source code">source</a></div><a href="#impl-PartialEq%3COsStr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-14" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#1097-1099" title="goto source code">source</a></div><a href="#method.eq-14" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-14" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#219" title="goto source code">source</a></div><a href="#method.ne-14" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3COsString%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#542-547" title="goto source code">source</a></div><a href="#impl-PartialEq%3COsString%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-10" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#544-546" title="goto source code">source</a></div><a href="#method.eq-10" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-10" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#219" title="goto source code">source</a></div><a href="#method.ne-10" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3COsString%3E-1" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.29.0">1.29.0</span> Â· <a class="srclink" href="../src/std/ffi/os_str.rs.html#558-563" title="goto source code">source</a></div><a href="#impl-PartialEq%3COsString%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a>&gt; for &amp;'a <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-12" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#560-562" title="goto source code">source</a></div><a href="#method.eq-12" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-12" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#219" title="goto source code">source</a></div><a href="#method.ne-12" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3CString%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2115" title="goto source code">source</a></div><a href="#impl-PartialEq%3CString%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>&gt; for &amp;'a <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2115" title="goto source code">source</a></div><a href="#method.eq-1" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2115" title="goto source code">source</a></div><a href="#method.ne-1" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3CString%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2114" title="goto source code">source</a></div><a href="#impl-PartialEq%3CString%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2114" title="goto source code">source</a></div><a href="#method.eq-5" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2114" title="goto source code">source</a></div><a href="#method.ne-5" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3Cstr%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#26-35" title="goto source code">source</a></div><a href="#impl-PartialEq%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#28" title="goto source code">source</a></div><a href="#method.eq" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#32" title="goto source code">source</a></div><a href="#method.ne" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3Cstr%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2114" title="goto source code">source</a></div><a href="#impl-PartialEq%3Cstr%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2114" title="goto source code">source</a></div><a href="#method.eq-6" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2114" title="goto source code">source</a></div><a href="#method.ne-6" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3Cstr%3E-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2117" title="goto source code">source</a></div><a href="#impl-PartialEq%3Cstr%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="enum" href="borrow/enum.Cow.html" title="enum std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="primitive.str.html">str</a>&gt;</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-7" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2117" title="goto source code">source</a></div><a href="#method.eq-7" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-7" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2117" title="goto source code">source</a></div><a href="#method.ne-7" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3Cstr%3E-3" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#534-539" title="goto source code">source</a></div><a href="#impl-PartialEq%3Cstr%3E-3" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-9" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#536-538" title="goto source code">source</a></div><a href="#method.eq-9" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-9" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#219" title="goto source code">source</a></div><a href="#method.ne-9" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialEq%3Cstr%3E-4" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#1087-1092" title="goto source code">source</a></div><a href="#impl-PartialEq%3Cstr%3E-4" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialEq.html" title="trait std::cmp::PartialEq">PartialEq</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.eq-13" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#1089-1091" title="goto source code">source</a></div><a href="#method.eq-13" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ne-13" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#219" title="goto source code">source</a></div><a href="#method.ne-13" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialOrd%3Cstr%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#48-53" title="goto source code">source</a></div><a href="#impl-PartialOrd%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="docblock"><p>Implements comparison operations on strings.</p>
<p>Strings are compared <a href="cmp/trait.Ord.html#lexicographical-comparison">lexicographically</a> by their byte values. This compares Unicode code
points based on their positions in the code charts. This is not necessarily the same as
â€œalphabeticalâ€ order, which varies by language and locale. Comparing strings according to
culturally-accepted standards requires locale-specific data that is outside the scope of
the <code>str</code> type.</p>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.partial_cmp" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#50" title="goto source code">source</a></div><a href="#method.partial_cmp" class="anchor"></a><h4 class="code-header">pub fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></div></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.lt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1082" title="goto source code">source</a></div><a href="#method.lt" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.le" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1102" title="goto source code">source</a></div><a href="#method.le" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.gt" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1125" title="goto source code">source</a></div><a href="#method.gt" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ge" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1145" title="goto source code">source</a></div><a href="#method.ge" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialOrd%3Cstr%3E-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#593-598" title="goto source code">source</a></div><a href="#impl-PartialOrd%3Cstr%3E-1" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ffi/struct.OsString.html" title="struct std::ffi::OsString">OsString</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.partial_cmp-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#595-597" title="goto source code">source</a></div><a href="#method.partial_cmp-1" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></div></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.lt-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1082" title="goto source code">source</a></div><a href="#method.lt-1" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.le-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1102" title="goto source code">source</a></div><a href="#method.le-1" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.gt-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1125" title="goto source code">source</a></div><a href="#method.gt-1" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ge-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1145" title="goto source code">source</a></div><a href="#method.ge-1" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-PartialOrd%3Cstr%3E-2" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#1130-1135" title="goto source code">source</a></div><a href="#impl-PartialOrd%3Cstr%3E-2" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.PartialOrd.html" title="trait std::cmp::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ffi/struct.OsStr.html" title="struct std::ffi::OsStr">OsStr</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.partial_cmp-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/ffi/os_str.rs.html#1132-1134" title="goto source code">source</a></div><a href="#method.partial_cmp-2" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;<a class="enum" href="cmp/enum.Ordering.html" title="enum std::cmp::Ordering">Ordering</a>&gt;</h4></div></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.lt-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1082" title="goto source code">source</a></div><a href="#method.lt-2" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.le-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1102" title="goto source code">source</a></div><a href="#method.le-2" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.gt-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1125" title="goto source code">source</a></div><a href="#method.gt-2" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ge-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/cmp.rs.html#1145" title="goto source code">source</a></div><a href="#method.ge-2" class="anchor"></a><h4 class="code-header">fn <a href="cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Pattern%3C%27a%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#935-977" title="goto source code">source</a></div><a href="#impl-Pattern%3C%27a%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, 'b&gt; <a class="trait" href="str/pattern/trait.Pattern.html" title="trait std::str::pattern::Pattern">Pattern</a>&lt;'a&gt; for &amp;'b <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="docblock"><p>Non-allocating substring search.</p>
<p>Will handle the pattern <code>&quot;&quot;</code> as returning empty matches at each character
boundary.</p>
<h4 id="examples-69" class="section-header"><a href="#examples-69">Examples</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;Hello world&quot;</span>.<span class="ident">find</span>(<span class="string">&quot;world&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">6</span>));</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aassert_eq!(%22Hello%20world%22.find(%22world%22)%2C%20Some(6))%3B%0A%7D&amp;edition=2021">Run</a></div>
</div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.is_prefix_of" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#945" title="goto source code">source</a></div><a href="#method.is_prefix_of" class="anchor"></a><h4 class="code-header">pub fn <a href="str/pattern/trait.Pattern.html#method.is_prefix_of" class="fnname">is_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></div></summary><div class="docblock"><p>Checks whether the pattern matches at the front of the haystack.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.strip_prefix_of" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#951" title="goto source code">source</a></div><a href="#method.strip_prefix_of" class="anchor"></a><h4 class="code-header">pub fn <a href="str/pattern/trait.Pattern.html#method.strip_prefix_of" class="fnname">strip_prefix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></div></summary><div class="docblock"><p>Removes the pattern from the front of haystack, if it matches.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.is_suffix_of" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#962" title="goto source code">source</a></div><a href="#method.is_suffix_of" class="anchor"></a><h4 class="code-header">pub fn <a href="str/pattern/trait.Pattern.html#method.is_suffix_of" class="fnname">is_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></div></summary><div class="docblock"><p>Checks whether the pattern matches at the back of the haystack.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.strip_suffix_of" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#968" title="goto source code">source</a></div><a href="#method.strip_suffix_of" class="anchor"></a><h4 class="code-header">pub fn <a href="str/pattern/trait.Pattern.html#method.strip_suffix_of" class="fnname">strip_suffix_of</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="primitive.str.html">str</a>&gt;</h4></div><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></div></summary><div class="docblock"><p>Removes the pattern from the back of haystack, if it matches.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="associatedtype.Searcher" class="type trait-impl has-srclink"><a href="#associatedtype.Searcher" class="anchor"></a><h4 class="code-header">type <a href="str/pattern/trait.Pattern.html#associatedtype.Searcher" class="associatedtype">Searcher</a> = <a class="struct" href="str/pattern/struct.StrSearcher.html" title="struct std::str::pattern::StrSearcher">StrSearcher</a>&lt;'a, 'b&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></div><div class='docblock'><p>Associated searcher for this pattern</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into_searcher" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#939" title="goto source code">source</a></div><a href="#method.into_searcher" class="anchor"></a><h4 class="code-header">pub fn <a href="str/pattern/trait.Pattern.html#tymethod.into_searcher" class="fnname">into_searcher</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="struct" href="str/pattern/struct.StrSearcher.html" title="struct std::str::pattern::StrSearcher">StrSearcher</a>&lt;'a, 'b&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></div><div class='docblock'><p>Constructs the associated searcher from
<code>self</code> and the <code>haystack</code> to search in. <a href="str/pattern/trait.Pattern.html#tymethod.into_searcher">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.is_contained_in" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/pattern.rs.html#108" title="goto source code">source</a></div><a href="#method.is_contained_in" class="anchor"></a><h4 class="code-header">fn <a href="str/pattern/trait.Pattern.html#method.is_contained_in" class="fnname">is_contained_in</a>(self, haystack: &amp;'a <a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="primitive" href="primitive.bool.html">bool</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>pattern</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/27721">#27721</a>)</div></div><div class='docblock'><p>Checks whether the pattern matches anywhere in the haystack</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-SliceIndex%3Cstr%3E" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#163-232" title="goto source code">source</a></div><a href="#impl-SliceIndex%3Cstr%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></div></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin .. end]</code> or <code>&amp;mut self[begin .. end]</code>.</p>
<p>Returns a slice of the given string from the byte range
[<code>begin</code>, <code>end</code>).</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h4>
<p>Panics if <code>begin</code> or <code>end</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), if <code>begin &gt; end</code>, or if
<code>end &gt; len</code>.</p>
<h4 id="examples-68" class="section-header"><a href="#examples-68">Examples</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">s</span>[<span class="number">0</span> .. <span class="number">1</span>], <span class="string">&quot;L&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">s</span>[<span class="number">1</span> .. <span class="number">9</span>], <span class="string">&quot;Ã¶we è€&quot;</span>);

<span class="comment">// these will panic:</span>
<span class="comment">// byte 2 lies within `Ã¶`:</span>
<span class="comment">// &amp;s[2 ..3];</span>

<span class="comment">// byte 8 lies within `è€`</span>
<span class="comment">// &amp;s[1 .. 8];</span>

<span class="comment">// byte 100 is outside the string</span>
<span class="comment">// &amp;s[3 .. 100];</span></code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Alet%20s%20%3D%20%22L%C3%B6we%20%E8%80%81%E8%99%8E%20L%C3%A9opard%22%3B%0Aassert_eq!(%26s%5B0%20..%201%5D%2C%20%22L%22)%3B%0A%0Aassert_eq!(%26s%5B1%20..%209%5D%2C%20%22%C3%B6we%20%E8%80%81%22)%3B%0A%0A%2F%2F%20these%20will%20panic%3A%0A%2F%2F%20byte%202%20lies%20within%20%60%C3%B6%60%3A%0A%2F%2F%20%26s%5B2%20..3%5D%3B%0A%0A%2F%2F%20byte%208%20lies%20within%20%60%E8%80%81%60%0A%2F%2F%20%26s%5B1%20..%208%5D%3B%0A%0A%2F%2F%20byte%20100%20is%20outside%20the%20string%0A%2F%2F%20%26s%5B3%20..%20100%5D%3B%0A%7D&amp;edition=2021">Run</a></div>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output" class="type trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#166" title="goto source code">source</a></div><a href="#method.get-1" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;<a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_mut-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#180" title="goto source code">source</a></div><a href="#method.get_mut-1" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#193" title="goto source code">source</a></div><a href="#method.get_unchecked-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked_mut-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#202" title="goto source code">source</a></div><a href="#method.get_unchecked_mut-1" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#210" title="goto source code">source</a></div><a href="#method.index" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;&lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a><span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;A&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="iter/trait.Step.html" title="trait std::iter::Step">Step</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = A;</span></code></span></div></span></span></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#218" title="goto source code">source</a></div><a href="#method.index_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a><span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;A&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="ops/struct.Range.html" title="struct std::ops::Range">Range</a>&lt;A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="iter/trait.Step.html" title="trait std::iter::Step">Step</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = A;</span></code></span></div></span></span></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-SliceIndex%3Cstr%3E-1" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#396-430" title="goto source code">source</a></div><a href="#impl-SliceIndex%3Cstr%3E-1" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></div></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin ..= end]</code> or <code>&amp;mut self[begin ..= end]</code>.</p>
<p>Returns a slice of the given string from the byte range
[<code>begin</code>, <code>end</code>]. Equivalent to <code>&amp;self [begin .. end + 1]</code> or <code>&amp;mut self[begin .. end + 1]</code>, except if <code>end</code> has the maximum value for
<code>usize</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<h4 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h4>
<p>Panics if <code>begin</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), if <code>end</code> does not point
to the ending byte offset of a character (<code>end + 1</code> is either a starting
byte offset or equal to <code>len</code>), if <code>begin &gt; end</code>, or if <code>end &gt;= len</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output-1" class="type trait-impl has-srclink"><a href="#associatedtype.Output-1" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#399" title="goto source code">source</a></div><a href="#method.get-2" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;<a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_mut-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#403" title="goto source code">source</a></div><a href="#method.get_mut-2" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#407" title="goto source code">source</a></div><a href="#method.get_unchecked-2" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked_mut-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#412" title="goto source code">source</a></div><a href="#method.get_unchecked_mut-2" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#417" title="goto source code">source</a></div><a href="#method.index-1" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;<a class="primitive" href="primitive.str.html">str</a><br>) -&gt; &amp;&lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a><span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;A&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="iter/trait.Step.html" title="trait std::iter::Step">Step</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = A;</span></code></span></div></span></span></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index_mut-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#424" title="goto source code">source</a></div><a href="#method.index_mut-1" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a><span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;A&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="ops/struct.RangeInclusive.html" title="struct std::ops::RangeInclusive">RangeInclusive</a>&lt;A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="iter/trait.Step.html" title="trait std::iter::Step">Step</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = A;</span></code></span></div></span></span></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-SliceIndex%3Cstr%3E-2" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#250-302" title="goto source code">source</a></div><a href="#impl-SliceIndex%3Cstr%3E-2" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></div></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[.. end]</code> or <code>&amp;mut self[.. end]</code>.</p>
<p>Returns a slice of the given string from the byte range [0, <code>end</code>).
Equivalent to <code>&amp;self[0 .. end]</code> or <code>&amp;mut self[0 .. end]</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h4>
<p>Panics if <code>end</code> does not point to the starting byte offset of a
character (as defined by <code>is_char_boundary</code>), or if <code>end &gt; len</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output-2" class="type trait-impl has-srclink"><a href="#associatedtype.Output-2" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#253" title="goto source code">source</a></div><a href="#method.get-3" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;<a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_mut-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#263" title="goto source code">source</a></div><a href="#method.get_mut-3" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#273" title="goto source code">source</a></div><a href="#method.get_unchecked-3" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked_mut-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#279" title="goto source code">source</a></div><a href="#method.get_unchecked_mut-3" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#285" title="goto source code">source</a></div><a href="#method.index-2" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;&lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index_mut-2" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#293" title="goto source code">source</a></div><a href="#method.index_mut-2" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.RangeTo.html" title="struct std::ops::RangeTo">RangeTo</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-SliceIndex%3Cstr%3E-3" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#320-377" title="goto source code">source</a></div><a href="#impl-SliceIndex%3Cstr%3E-3" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></div></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[begin ..]</code> or <code>&amp;mut self[begin ..]</code>.</p>
<p>Returns a slice of the given string from the byte range [<code>begin</code>, <code>len</code>).
Equivalent to <code>&amp;self[begin .. len]</code> or <code>&amp;mut self[begin .. len]</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<h4 id="panics-6" class="section-header"><a href="#panics-6">Panics</a></h4>
<p>Panics if <code>begin</code> does not point to the starting byte offset of
a character (as defined by <code>is_char_boundary</code>), or if <code>begin &gt; len</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output-3" class="type trait-impl has-srclink"><a href="#associatedtype.Output-3" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#323" title="goto source code">source</a></div><a href="#method.get-4" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;<a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_mut-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#333" title="goto source code">source</a></div><a href="#method.get_mut-4" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#343" title="goto source code">source</a></div><a href="#method.get_unchecked-4" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked_mut-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#352" title="goto source code">source</a></div><a href="#method.get_unchecked_mut-4" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#360" title="goto source code">source</a></div><a href="#method.index-3" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;<a class="primitive" href="primitive.str.html">str</a><br>) -&gt; &amp;&lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a><span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;A&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="iter/trait.Step.html" title="trait std::iter::Step">Step</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = A;</span></code></span></div></span></span></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index_mut-3" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#368" title="goto source code">source</a></div><a href="#method.index_mut-3" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a><span class="notable-traits"><span class="notable-traits-tooltip">â“˜<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;A&gt;</div><code class="content"><span class="where fmt-newline">impl&lt;A&gt; <a class="trait" href="iter/trait.Iterator.html" title="trait std::iter::Iterator">Iterator</a> for <a class="struct" href="ops/struct.RangeFrom.html" title="struct std::ops::RangeFrom">RangeFrom</a>&lt;A&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="iter/trait.Step.html" title="trait std::iter::Step">Step</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="iter/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = A;</span></code></span></div></span></span></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-SliceIndex%3Cstr%3E-4" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.26.0">1.26.0</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#447-481" title="goto source code">source</a></div><a href="#impl-SliceIndex%3Cstr%3E-4" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt;</h3></div></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[..= end]</code> or <code>&amp;mut self[..= end]</code>.</p>
<p>Returns a slice of the given string from the byte range [0, <code>end</code>].
Equivalent to <code>&amp;self [0 .. end + 1]</code>, except if <code>end</code> has the maximum
value for <code>usize</code>.</p>
<p>This operation is <em>O</em>(1).</p>
<h4 id="panics-7" class="section-header"><a href="#panics-7">Panics</a></h4>
<p>Panics if <code>end</code> does not point to the ending byte offset of a character
(<code>end + 1</code> is either a starting byte offset as defined by
<code>is_char_boundary</code>, or equal to <code>len</code>), or if <code>end &gt;= len</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output-4" class="type trait-impl has-srclink"><a href="#associatedtype.Output-4" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#450" title="goto source code">source</a></div><a href="#method.get-5" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;<a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_mut-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#454" title="goto source code">source</a></div><a href="#method.get_mut-5" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#458" title="goto source code">source</a></div><a href="#method.get_unchecked-5" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked_mut-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#463" title="goto source code">source</a></div><a href="#method.get_unchecked_mut-5" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#468" title="goto source code">source</a></div><a href="#method.index-4" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;<a class="primitive" href="primitive.str.html">str</a><br>) -&gt; &amp;&lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index_mut-4" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#475" title="goto source code">source</a></div><a href="#method.index_mut-4" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.RangeToInclusive.html" title="struct std::ops::RangeToInclusive">RangeToInclusive</a>&lt;<a class="primitive" href="primitive.usize.html">usize</a>&gt; as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-SliceIndex%3Cstr%3E-5" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="srclink" href="../src/core/str/traits.rs.html#99-125" title="goto source code">source</a></div><a href="#impl-SliceIndex%3Cstr%3E-5" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt; for <a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a></h3></div></summary><div class="docblock"><p>Implements substring slicing with syntax <code>&amp;self[..]</code> or <code>&amp;mut self[..]</code>.</p>
<p>Returns a slice of the whole string, i.e., returns <code>&amp;self</code> or <code>&amp;mut self</code>. Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>. Unlike
other indexing operations, this can never panic.</p>
<p>This operation is <em>O</em>(1).</p>
<p>Prior to 1.20.0, these indexing operations were still supported by
direct implementation of <code>Index</code> and <code>IndexMut</code>.</p>
<p>Equivalent to <code>&amp;self[0 .. len]</code> or <code>&amp;mut self[0 .. len]</code>.</p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output-5" class="type trait-impl has-srclink"><a href="#associatedtype.Output-5" class="anchor"></a><h4 class="code-header">type <a href="slice/trait.SliceIndex.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="primitive" href="primitive.str.html">str</a></h4></div></summary><div class='docblock'><p>The output type returned by methods.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#102" title="goto source code">source</a></div><a href="#method.get-6" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get" class="fnname">get</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;&lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_mut-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#106" title="goto source code">source</a></div><a href="#method.get_mut-6" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.get_mut" class="fnname">get_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="enum" href="option/enum.Option.html" title="enum std::option::Option">Option</a>&lt;&amp;mut &lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a>&gt;</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, if in
bounds. <a href="slice/trait.SliceIndex.html#tymethod.get_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#110" title="goto source code">source</a></div><a href="#method.get_unchecked-6" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked" class="fnname">get_unchecked</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*const </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*const </a>&lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.get_unchecked_mut-6" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#114" title="goto source code">source</a></div><a href="#method.get_unchecked_mut-6" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut" class="fnname">get_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: <a class="primitive" href="primitive.pointer.html">*mut </a><a class="primitive" href="primitive.str.html">str</a><br>) -&gt; <a class="primitive" href="primitive.pointer.html">*mut </a>&lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, without
performing any bounds checking.
Calling this method with an out-of-bounds index or a dangling <code>slice</code> pointer
is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em> even if the resulting reference is not used. <a href="slice/trait.SliceIndex.html#tymethod.get_unchecked_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#118" title="goto source code">source</a></div><a href="#method.index-5" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index" class="fnname">index</a>(self, slice: &amp;<a class="primitive" href="primitive.str.html">str</a>) -&gt; &amp;&lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a shared reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.index_mut-5" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#122" title="goto source code">source</a></div><a href="#method.index_mut-5" class="anchor"></a><h4 class="code-header">pub fn <a href="slice/trait.SliceIndex.html#tymethod.index_mut" class="fnname">index_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slice: &amp;mut <a class="primitive" href="primitive.str.html">str</a><br>) -&gt; &amp;mut &lt;<a class="struct" href="ops/struct.RangeFull.html" title="struct std::ops::RangeFull">RangeFull</a> as <a class="trait" href="slice/trait.SliceIndex.html" title="trait std::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="slice/trait.SliceIndex.html#associatedtype.Output" title="type std::slice::SliceIndex::Output">Output</a></h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>slice_index_methods</code>)</div></div><div class='docblock'><p>Returns a mutable reference to the output at this location, panicking
if out of bounds. <a href="slice/trait.SliceIndex.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ToOwned" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#223-235" title="goto source code">source</a></div><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="borrow/trait.ToOwned.html" title="trait std::borrow::ToOwned">ToOwned</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#226" title="goto source code">source</a></div><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/str.rs.html#230" title="goto source code">source</a></div><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: &amp;mut <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a>)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/41263">#41263</a>)</div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ToSocketAddrs" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/net/addr.rs.html#993-1003" title="goto source code">source</a></div><a href="#impl-ToSocketAddrs" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="net/trait.ToSocketAddrs.html" title="trait std::net::ToSocketAddrs">ToSocketAddrs</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Iter" class="type trait-impl has-srclink"><a href="#associatedtype.Iter" class="anchor"></a><h4 class="code-header">type <a href="net/trait.ToSocketAddrs.html#associatedtype.Iter" class="associatedtype">Iter</a> = <a class="struct" href="vec/struct.IntoIter.html" title="struct std::vec::IntoIter">IntoIter</a>&lt;<a class="enum" href="net/enum.SocketAddr.html" title="enum std::net::SocketAddr">SocketAddr</a>&gt;</h4></div></summary><div class='docblock'><p>Returned iterator over socket addresses which this type may correspond
to. <a href="net/trait.ToSocketAddrs.html#associatedtype.Iter">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_socket_addrs" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/std/net/addr.rs.html#995-1002" title="goto source code">source</a></div><a href="#method.to_socket_addrs" class="anchor"></a><h4 class="code-header">fn <a href="net/trait.ToSocketAddrs.html#tymethod.to_socket_addrs" class="fnname">to_socket_addrs</a>(&amp;self) -&gt; <a class="type" href="io/type.Result.html" title="type std::io::Result">Result</a>&lt;<a class="struct" href="vec/struct.IntoIter.html" title="struct std::vec::IntoIter">IntoIter</a>&lt;<a class="enum" href="net/enum.SocketAddr.html" title="enum std::net::SocketAddr">SocketAddr</a>&gt;&gt;</h4></div></summary><div class='docblock'><p>Converts this object to an iterator of resolved <a href="net/enum.SocketAddr.html" title="SocketAddr"><code>SocketAddr</code></a>s. <a href="net/trait.ToSocketAddrs.html#tymethod.to_socket_addrs">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ToString" class="impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> Â· <a class="srclink" href="../src/alloc/string.rs.html#2458-2463" title="goto source code">source</a></div><a href="#impl-ToString" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="string/trait.ToString.html" title="trait std::string::ToString">ToString</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_string" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2460" title="goto source code">source</a></div><a href="#method.to_string" class="anchor"></a><h4 class="code-header">pub fn <a href="string/trait.ToString.html#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class='docblock'><p>Converts the given value to a <code>String</code>. <a href="string/trait.ToString.html#tymethod.to_string">Read more</a></p>
</div></details></div></details><div id="impl-Eq" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/str/traits.rs.html#38" title="goto source code">source</a></div><a href="#impl-Eq" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="cmp/trait.Eq.html" title="trait std::cmp::Eq">Eq</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div><div id="impl-Send" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div><div id="impl-Sized" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Sized" class="anchor"></a><h3 class="code-header in-band">impl !<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="primitive" href="primitive.str.html">str</a></h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/any.rs.html#132-136" title="goto source code">source</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="any/trait.Any.html" title="trait std::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/any.rs.html#133" title="goto source code">source</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#209-214" title="goto source code">source</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#211" title="goto source code">source</a></div><a href="#method.borrow-1" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#218-222" title="goto source code">source</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/core/borrow.rs.html#219" title="goto source code">source</a></div><a href="#method.borrow_mut-1" class="anchor"></a><h4 class="code-header">pub fn <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ToString-1" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2388-2402" title="goto source code">source</a></div><a href="#impl-ToString-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="string/trait.ToString.html" title="trait std::string::ToString">ToString</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="fmt/trait.Display.html" title="trait std::fmt::Display">Display</a> + ?<a class="trait" href="marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_string-1" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/alloc/string.rs.html#2394" title="goto source code">source</a></div><a href="#method.to_string-1" class="anchor"></a><h4 class="code-header">pub default fn <a href="string/trait.ToString.html#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="string/struct.String.html" title="struct std::string::String">String</a></h4></div></summary><div class='docblock'><p>Converts the given value to a <code>String</code>. <a href="string/trait.ToString.html#tymethod.to_string">Read more</a></p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="std" data-themes="ayu,dark,light" data-resource-suffix="1.60.0" data-rustdoc-version="1.60.0-nightly (5e57faa78 2022-01-19)" ></div>
</body></html>