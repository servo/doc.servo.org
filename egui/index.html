<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`egui`:  an easy-to-use GUI in pure Rust!"><title>egui - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="egui" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../egui/index.html">egui</a><span class="version">0.29.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">egui</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/egui/lib.rs.html#1-720">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><code>egui</code>:  an easy-to-use GUI in pure Rust!</p>
<p>Try the live web demo: <a href="https://www.egui.rs/#demo">https://www.egui.rs/#demo</a>. Read more about egui at <a href="https://github.com/emilk/egui">https://github.com/emilk/egui</a>.</p>
<p><code>egui</code> is in heavy development, with each new version having breaking changes.
You need to have rust 1.76.0 or later to use <code>egui</code>.</p>
<p>To quickly get started with egui, you can take a look at <a href="https://github.com/emilk/eframe_template"><code>eframe_template</code></a>
which uses <a href="https://docs.rs/eframe"><code>eframe</code></a>.</p>
<p>To create a GUI using egui you first need a <a href="context/struct.Context.html" title="struct egui::context::Context"><code>Context</code></a> (by convention referred to by <code>ctx</code>).
Then you add a <a href="containers/window/struct.Window.html" title="struct egui::containers::window::Window"><code>Window</code></a> or a <a href="containers/panel/struct.SidePanel.html" title="struct egui::containers::panel::SidePanel"><code>SidePanel</code></a> to get a <a href="ui/struct.Ui.html" title="struct egui::ui::Ui"><code>Ui</code></a>, which is what youâ€™ll be using to add all the buttons and labels that you need.</p>
<h3 id="feature-flags"><a class="doc-anchor" href="#feature-flags">Â§</a>Feature flags</h3><h2 id="using-egui"><a class="doc-anchor" href="#using-egui">Â§</a>Using egui</h2>
<p>To see what is possible to build with egui you can check out the online demo at <a href="https://www.egui.rs/#demo">https://www.egui.rs/#demo</a>.</p>
<p>If you like the â€œlearning by doingâ€ approach, clone <a href="https://github.com/emilk/eframe_template">https://github.com/emilk/eframe_template</a> and get started using egui right away.</p>
<h4 id="a-simple-example"><a class="doc-anchor" href="#a-simple-example">Â§</a>A simple example</h4>
<p>Here is a simple counter that can be incremented and decremented using two buttons:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>ui_counter(ui: <span class="kw-2">&amp;mut </span>egui::Ui, counter: <span class="kw-2">&amp;mut </span>i32) {
    <span class="comment">// Put the buttons and label on the same row:
    </span>ui.horizontal(|ui| {
        <span class="kw">if </span>ui.button(<span class="string">"âˆ’"</span>).clicked() {
            <span class="kw-2">*</span>counter -= <span class="number">1</span>;
        }
        ui.label(counter.to_string());
        <span class="kw">if </span>ui.button(<span class="string">"+"</span>).clicked() {
            <span class="kw-2">*</span>counter += <span class="number">1</span>;
        }
    });
}</code></pre></div>
<p>In some GUI frameworks this would require defining multiple types and functions with callbacks or message handlers,
but thanks to <code>egui</code> being immediate mode everything is one self-contained function!</p>
<h4 id="getting-a-ui"><a class="doc-anchor" href="#getting-a-ui">Â§</a>Getting a <a href="ui/struct.Ui.html" title="struct egui::ui::Ui"><code>Ui</code></a></h4>
<p>Use one of <a href="containers/panel/struct.SidePanel.html" title="struct egui::containers::panel::SidePanel"><code>SidePanel</code></a>, <a href="containers/panel/struct.TopBottomPanel.html" title="struct egui::containers::panel::TopBottomPanel"><code>TopBottomPanel</code></a>, <a href="containers/panel/struct.CentralPanel.html" title="struct egui::containers::panel::CentralPanel"><code>CentralPanel</code></a>, <a href="containers/window/struct.Window.html" title="struct egui::containers::window::Window"><code>Window</code></a> or <a href="containers/area/struct.Area.html" title="struct egui::containers::area::Area"><code>Area</code></a> to
get access to an <a href="ui/struct.Ui.html" title="struct egui::ui::Ui"><code>Ui</code></a> where you can put widgets. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>egui::CentralPanel::default().show(<span class="kw-2">&amp;</span>ctx, |ui| {
    ui.add(egui::Label::new(<span class="string">"Hello World!"</span>));
    ui.label(<span class="string">"A shorter and more convenient way to add a label."</span>);
    <span class="kw">if </span>ui.button(<span class="string">"Click me"</span>).clicked() {
        <span class="comment">// take some action here
    </span>}
});</code></pre></div>
<h4 id="quick-start"><a class="doc-anchor" href="#quick-start">Â§</a>Quick start</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ui.label(<span class="string">"This is a label"</span>);
ui.hyperlink(<span class="string">"https://github.com/emilk/egui"</span>);
ui.text_edit_singleline(<span class="kw-2">&amp;mut </span>my_string);
<span class="kw">if </span>ui.button(<span class="string">"Click me"</span>).clicked() { }
ui.add(egui::Slider::new(<span class="kw-2">&amp;mut </span>my_f32, <span class="number">0.0</span>..=<span class="number">100.0</span>));
ui.add(egui::DragValue::new(<span class="kw-2">&amp;mut </span>my_f32));

ui.checkbox(<span class="kw-2">&amp;mut </span>my_boolean, <span class="string">"Checkbox"</span>);

<span class="attr">#[derive(PartialEq)]
</span><span class="kw">enum </span>Enum { First, Second, Third }
ui.horizontal(|ui| {
    ui.radio_value(<span class="kw-2">&amp;mut </span>my_enum, Enum::First, <span class="string">"First"</span>);
    ui.radio_value(<span class="kw-2">&amp;mut </span>my_enum, Enum::Second, <span class="string">"Second"</span>);
    ui.radio_value(<span class="kw-2">&amp;mut </span>my_enum, Enum::Third, <span class="string">"Third"</span>);
});

ui.separator();

ui.image((my_image, egui::Vec2::new(<span class="number">640.0</span>, <span class="number">480.0</span>)));

ui.collapsing(<span class="string">"Click to see what is hidden!"</span>, |ui| {
    ui.label(<span class="string">"Not much, as it turns out"</span>);
});</code></pre></div>
<h3 id="viewports"><a class="doc-anchor" href="#viewports">Â§</a>Viewports</h3>
<p>Some egui backends support multiple <em>viewports</em>, which is what egui calls the native OS windows it resides in.
See <a href="viewport/index.html" title="mod egui::viewport"><code>crate::viewport</code></a> for more information.</p>
<h3 id="coordinate-system"><a class="doc-anchor" href="#coordinate-system">Â§</a>Coordinate system</h3>
<p>The left-top corner of the screen is <code>(0.0, 0.0)</code>,
with X increasing to the right and Y increasing downwards.</p>
<p><code>egui</code> uses logical <em>points</em> as its coordinate system.
Those related to physical <em>pixels</em> by the <code>pixels_per_point</code> scale factor.
For example, a high-dpi screen can have <code>pixels_per_point = 2.0</code>,
meaning there are two physical screen pixels for each logical point.</p>
<p>Angles are in radians, and are measured clockwise from the X-axis, which has angle=0.</p>
<h2 id="integrating-with-egui"><a class="doc-anchor" href="#integrating-with-egui">Â§</a>Integrating with egui</h2>
<p>Most likely you are using an existing <code>egui</code> backend/integration such as <a href="https://docs.rs/eframe"><code>eframe</code></a>, <a href="https://docs.rs/bevy_egui"><code>bevy_egui</code></a>,
or <a href="https://github.com/not-fl3/egui-miniquad"><code>egui-miniquad</code></a>,
but if you want to integrate <code>egui</code> into a new game engine or graphics backend, this is the section for you.</p>
<p>You need to collect <a href="data/input/struct.RawInput.html" title="struct egui::data::input::RawInput"><code>RawInput</code></a> and handle <a href="data/output/struct.FullOutput.html" title="struct egui::data::output::FullOutput"><code>FullOutput</code></a>. The basic structure is this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>ctx = egui::Context::default();

<span class="comment">// Game loop:
</span><span class="kw">loop </span>{
    <span class="kw">let </span>raw_input: egui::RawInput = gather_input();

    <span class="kw">let </span>full_output = ctx.run(raw_input, |ctx| {
        egui::CentralPanel::default().show(<span class="kw-2">&amp;</span>ctx, |ui| {
            ui.label(<span class="string">"Hello world!"</span>);
            <span class="kw">if </span>ui.button(<span class="string">"Click me"</span>).clicked() {
                <span class="comment">// take some action here
            </span>}
        });
    });
    handle_platform_output(full_output.platform_output);
    <span class="kw">let </span>clipped_primitives = ctx.tessellate(full_output.shapes, full_output.pixels_per_point);
    paint(full_output.textures_delta, clipped_primitives);
}</code></pre></div>
<p>For a reference OpenGL renderer, see <a href="https://github.com/emilk/egui/blob/master/crates/egui_glow/src/painter.rs">the <code>egui_glow</code> painter</a>.</p>
<h4 id="debugging-your-renderer"><a class="doc-anchor" href="#debugging-your-renderer">Â§</a>Debugging your renderer</h4><h5 id="things-look-jagged"><a class="doc-anchor" href="#things-look-jagged">Â§</a>Things look jagged</h5>
<ul>
<li>Turn off backface culling.</li>
</ul>
<h5 id="my-text-is-blurry"><a class="doc-anchor" href="#my-text-is-blurry">Â§</a>My text is blurry</h5>
<ul>
<li>Make sure you set the proper <code>pixels_per_point</code> in the input to egui.</li>
<li>Make sure the texture sampler is not off by half a pixel. Try nearest-neighbor sampler to check.</li>
</ul>
<h5 id="my-windows-are-too-transparent-or-too-dark"><a class="doc-anchor" href="#my-windows-are-too-transparent-or-too-dark">Â§</a>My windows are too transparent or too dark</h5>
<ul>
<li>egui uses premultiplied alpha, so make sure your blending function is <code>(ONE, ONE_MINUS_SRC_ALPHA)</code>.</li>
<li>Make sure your texture sampler is clamped (<code>GL_CLAMP_TO_EDGE</code>).</li>
<li>egui prefers linear color spaces for all blending so:
<ul>
<li>Use an sRGBA-aware texture if available (e.g. <code>GL_SRGB8_ALPHA8</code>).
<ul>
<li>Otherwise: remember to decode gamma in the fragment shader.</li>
</ul>
</li>
<li>Decode the gamma of the incoming vertex colors in your vertex shader.</li>
<li>Turn on sRGBA/linear framebuffer if available (<code>GL_FRAMEBUFFER_SRGB</code>).
<ul>
<li>Otherwise: gamma-encode the colors before you write them again.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="understanding-immediate-mode"><a class="doc-anchor" href="#understanding-immediate-mode">Â§</a>Understanding immediate mode</h2>
<p><code>egui</code> is an immediate mode GUI library.</p>
<p>Immediate mode has its roots in gaming, where everything on the screen is painted at the
display refresh rate, i.e. at 60+ frames per second.
In immediate mode GUIs, the entire interface is laid out and painted at the same high rate.
This makes immediate mode GUIs especially well suited for highly interactive applications.</p>
<p>It is useful to fully grok what â€œimmediate modeâ€ implies.</p>
<p>Here is an example to illustrate it:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if </span>ui.button(<span class="string">"click me"</span>).clicked() {
    take_action()
}</code></pre></div>
<p>This code is being executed each frame at maybe 60 frames per second.
Each frame egui does these things:</p>
<ul>
<li>lays out the letters <code>click me</code> in order to figure out the size of the button</li>
<li>decides where on screen to place the button</li>
<li>check if the mouse is hovering or clicking that location</li>
<li>chose button colors based on if it is being hovered or clicked</li>
<li>add a <a href="enum.Shape.html#variant.Rect" title="variant egui::Shape::Rect"><code>Shape::Rect</code></a> and <a href="enum.Shape.html#variant.Text" title="variant egui::Shape::Text"><code>Shape::Text</code></a> to the list of shapes to be painted later this frame</li>
<li>return a <a href="response/struct.Response.html" title="struct egui::response::Response"><code>Response</code></a> with the <a href="response/struct.Response.html#method.clicked" title="method egui::response::Response::clicked"><code>clicked</code></a> member so the user can check for interactions</li>
</ul>
<p>There is no button being created and stored somewhere.
The only output of this call is some colored shapes, and a <a href="response/struct.Response.html" title="struct egui::response::Response"><code>Response</code></a>.</p>
<p>Similarly, consider this code:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ui.add(egui::Slider::new(<span class="kw-2">&amp;mut </span>value, <span class="number">0.0</span>..=<span class="number">100.0</span>).text(<span class="string">"My value"</span>));</code></pre></div>
<p>Here egui will read <code>value</code> (an <code>f32</code>) to display the slider, then look if the mouse is dragging the slider and if so change the <code>value</code>.
Note that <code>egui</code> does not store the slider value for you - it only displays the current value, and changes it
by how much the slider has been dragged in the previous few milliseconds.
This means it is responsibility of the egui user to store the state (<code>value</code>) so that it persists between frames.</p>
<p>It can be useful to read the code for the toggle switch example widget to get a better understanding
of how egui works: <a href="https://github.com/emilk/egui/blob/master/crates/egui_demo_lib/src/demo/toggle_switch.rs">https://github.com/emilk/egui/blob/master/crates/egui_demo_lib/src/demo/toggle_switch.rs</a>.</p>
<p>Read more about the pros and cons of immediate mode at <a href="https://github.com/emilk/egui#why-immediate-mode">https://github.com/emilk/egui#why-immediate-mode</a>.</p>
<h3 id="multi-pass-immediate-mode"><a class="doc-anchor" href="#multi-pass-immediate-mode">Â§</a>Multi-pass immediate mode</h3>
<p>By default, egui usually only does one pass for each rendered frame.
However, egui supports multi-pass immediate mode.
Another pass can be requested with <a href="context/struct.Context.html#method.request_discard" title="method egui::context::Context::request_discard"><code>Context::request_discard</code></a>.</p>
<p>This is used by some widgets to cover up â€œfirst-frame jittersâ€.
For instance, the <a href="grid/struct.Grid.html" title="struct egui::grid::Grid"><code>Grid</code></a> needs to know the width of all columns before it can properly place the widgets.
But it cannot know the width of widgets to come.
So it stores the max widths of previous frames and uses that.
This means the first time a <code>Grid</code> is shown it will <em>guess</em> the widths of the columns, and will usually guess wrong.
This means the contents of the grid will be wrong for one frame, before settling to the correct places.
Therefore <code>Grid</code> calls <a href="context/struct.Context.html#method.request_discard" title="method egui::context::Context::request_discard"><code>Context::request_discard</code></a> when it is first shown, so the wrong placement is never
visible to the end user.</p>
<p>This is an example of a form of multi-pass immediate mode, where earlier passes are used for sizing,
and later passes for layout.</p>
<p>See <a href="context/struct.Context.html#method.request_discard" title="method egui::context::Context::request_discard"><code>Context::request_discard</code></a> and <a href="memory/struct.Options.html#structfield.max_passes" title="field egui::memory::Options::max_passes"><code>Options::max_passes</code></a> for more.</p>
<h2 id="misc"><a class="doc-anchor" href="#misc">Â§</a>Misc</h2><h3 id="how-widgets-works"><a class="doc-anchor" href="#how-widgets-works">Â§</a>How widgets works</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">if </span>ui.button(<span class="string">"click me"</span>).clicked() { take_action() }</code></pre></div>
<p>is short for</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>button = egui::Button::new(<span class="string">"click me"</span>);
<span class="kw">if </span>ui.add(button).clicked() { take_action() }</code></pre></div>
<p>which is short for</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>button = egui::Button::new(<span class="string">"click me"</span>);
<span class="kw">let </span>response = button.ui(ui);
<span class="kw">if </span>response.clicked() { take_action() }</code></pre></div>
<p><a href="widgets/button/struct.Button.html" title="struct egui::widgets::button::Button"><code>Button</code></a> uses the builder pattern to create the data required to show it. The <a href="widgets/button/struct.Button.html" title="struct egui::widgets::button::Button"><code>Button</code></a> is then discarded.</p>
<p><a href="widgets/button/struct.Button.html" title="struct egui::widgets::button::Button"><code>Button</code></a> implements <code>trait</code> <a href="widgets/trait.Widget.html" title="trait egui::widgets::Widget"><code>Widget</code></a>, which looks like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub trait </span>Widget {
    <span class="doccomment">/// Allocate space, interact, paint, and return a [`Response`].
    </span><span class="kw">fn </span>ui(<span class="self">self</span>, ui: <span class="kw-2">&amp;mut </span>Ui) -&gt; Response;
}</code></pre></div>
<h3 id="widget-interaction"><a class="doc-anchor" href="#widget-interaction">Â§</a>Widget interaction</h3>
<p>Each widget has a <a href="sense/struct.Sense.html" title="struct egui::sense::Sense"><code>Sense</code></a>, which defines whether or not the widget
is sensitive to clicking and/or drags.</p>
<p>For instance, a <a href="widgets/button/struct.Button.html" title="struct egui::widgets::button::Button"><code>Button</code></a> only has a <a href="sense/struct.Sense.html#method.click" title="associated function egui::sense::Sense::click"><code>Sense::click</code></a> (by default).
This means if you drag a button it will not respond with <a href="response/struct.Response.html#method.dragged" title="method egui::response::Response::dragged"><code>Response::dragged</code></a>.
Instead, the drag will continue through the button to the first
widget behind it that is sensitive to dragging, which for instance could be
a <a href="containers/scroll_area/struct.ScrollArea.html" title="struct egui::containers::scroll_area::ScrollArea"><code>ScrollArea</code></a>. This lets you scroll by dragging a scroll area (important
on touch screens), just as long as you donâ€™t drag on a widget that is sensitive
to drags (e.g. a <a href="widgets/slider/struct.Slider.html" title="struct egui::widgets::slider::Slider"><code>Slider</code></a>).</p>
<p>When widgets overlap it is the last added one
that is considered to be on top and which will get input priority.</p>
<p>The widget interaction logic is run at the <em>start</em> of each frame,
based on the output from the previous frame.
This means that when a new widget shows up you cannot click it in the same
frame (i.e. in the same fraction of a second), but unless the user
is spider-man, they wouldnâ€™t be fast enough to do so anyways.</p>
<p>By running the interaction code early, egui can actually
tell you if a widget is being interacted with <em>before</em> you add it,
as long as you know its <a href="id/struct.Id.html" title="struct egui::id::Id"><code>Id</code></a> before-hand (e.g. using <a href="ui/struct.Ui.html#method.next_auto_id" title="method egui::ui::Ui::next_auto_id"><code>Ui::next_auto_id</code></a>),
by calling <a href="context/struct.Context.html#method.read_response" title="method egui::context::Context::read_response"><code>Context::read_response</code></a>.
This can be useful in some circumstances in order to style a widget,
or to respond to interactions before adding the widget
(perhaps on top of other widgets).</p>
<h3 id="auto-sizing-panels-and-windows"><a class="doc-anchor" href="#auto-sizing-panels-and-windows">Â§</a>Auto-sizing panels and windows</h3>
<p>In egui, all panels and windows auto-shrink to fit the content.
If the window or panel is also resizable, this can lead to a weird behavior
where you can drag the edge of the panel/window to make it larger, and
when you release the panel/window shrinks again.
This is an artifact of immediate mode, and here are some alternatives on how to avoid it:</p>
<ol>
<li>Turn off resizing with <a href="containers/window/struct.Window.html#method.resizable" title="method egui::containers::window::Window::resizable"><code>Window::resizable</code></a>, <a href="containers/panel/struct.SidePanel.html#method.resizable" title="method egui::containers::panel::SidePanel::resizable"><code>SidePanel::resizable</code></a>, <a href="containers/panel/struct.TopBottomPanel.html#method.resizable" title="method egui::containers::panel::TopBottomPanel::resizable"><code>TopBottomPanel::resizable</code></a>.</li>
<li>Wrap your panel contents in a <a href="containers/scroll_area/struct.ScrollArea.html" title="struct egui::containers::scroll_area::ScrollArea"><code>ScrollArea</code></a>, or use <a href="containers/window/struct.Window.html#method.vscroll" title="method egui::containers::window::Window::vscroll"><code>Window::vscroll</code></a> and <a href="containers/window/struct.Window.html#method.hscroll" title="method egui::containers::window::Window::hscroll"><code>Window::hscroll</code></a>.</li>
<li>Use a justified layout:</li>
</ol>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ui.with_layout(egui::Layout::top_down_justified(egui::Align::Center), |ui| {
    ui.button(<span class="string">"I am becoming wider as needed"</span>);
});</code></pre></div>
<ol start="4">
<li>Fill in extra space with emptiness:</li>
</ol>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ui.allocate_space(ui.available_size()); <span class="comment">// put this LAST in your panel/window code</span></code></pre></div>
<h3 id="sizes"><a class="doc-anchor" href="#sizes">Â§</a>Sizes</h3>
<p>You can control the size of widgets using <a href="ui/struct.Ui.html#method.add_sized" title="method egui::ui::Ui::add_sized"><code>Ui::add_sized</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>ui.add_sized([<span class="number">40.0</span>, <span class="number">20.0</span>], egui::DragValue::new(<span class="kw-2">&amp;mut </span>my_value));</code></pre></div>
<h3 id="code-snippets"><a class="doc-anchor" href="#code-snippets">Â§</a>Code snippets</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Miscellaneous tips and tricks

</span>ui.horizontal_wrapped(|ui| {
    ui.spacing_mut().item_spacing.x = <span class="number">0.0</span>; <span class="comment">// remove spacing between widgets
    // `radio_value` also works for enums, integers, and more.
    </span>ui.radio_value(<span class="kw-2">&amp;mut </span>some_bool, <span class="bool-val">false</span>, <span class="string">"Off"</span>);
    ui.radio_value(<span class="kw-2">&amp;mut </span>some_bool, <span class="bool-val">true</span>, <span class="string">"On"</span>);
});

ui.group(|ui| {
    ui.label(<span class="string">"Within a frame"</span>);
    ui.set_min_height(<span class="number">200.0</span>);
});

<span class="comment">// A `scope` creates a temporary [`Ui`] in which you can change settings:
</span>ui.scope(|ui| {
    ui.visuals_mut().override_text_color = <span class="prelude-val">Some</span>(egui::Color32::RED);
    ui.style_mut().override_text_style = <span class="prelude-val">Some</span>(egui::TextStyle::Monospace);
    ui.style_mut().wrap_mode = <span class="prelude-val">Some</span>(TextWrapMode::Truncate);

    ui.label(<span class="string">"This text will be red, monospace, and won't wrap to a new line"</span>);
}); <span class="comment">// the temporary settings are reverted here</span></code></pre></div>
<h3 id="installing-additional-fonts"><a class="doc-anchor" href="#installing-additional-fonts">Â§</a>Installing additional fonts</h3>
<p>The default egui fonts only support latin and cryllic characters, and some emojis.
To use egui with e.g. asian characters you need to install your own font (<code>.ttf</code> or <code>.otf</code>) using <a href="context/struct.Context.html#method.set_fonts" title="method egui::context::Context::set_fonts"><code>Context::set_fonts</code></a>.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.LayerId"><code>pub use self::layers::<a class="struct" href="layers/struct.LayerId.html" title="struct egui::layers::LayerId">LayerId</a>;</code></div></li><li><div class="item-name" id="reexport.Order"><code>pub use self::layers::<a class="enum" href="layers/enum.Order.html" title="enum egui::layers::Order">Order</a>;</code></div></li><li><div class="item-name" id="reexport.SizeHint"><code>pub use self::load::<a class="enum" href="load/enum.SizeHint.html" title="enum egui::load::SizeHint">SizeHint</a>;</code></div></li><li><div class="item-name" id="reexport.FontSelection"><code>pub use self::style::<a class="enum" href="style/enum.FontSelection.html" title="enum egui::style::FontSelection">FontSelection</a>;</code></div></li><li><div class="item-name" id="reexport.Spacing"><code>pub use self::style::<a class="struct" href="style/struct.Spacing.html" title="struct egui::style::Spacing">Spacing</a>;</code></div></li><li><div class="item-name" id="reexport.Style"><code>pub use self::style::<a class="struct" href="style/struct.Style.html" title="struct egui::style::Style">Style</a>;</code></div></li><li><div class="item-name" id="reexport.TextStyle"><code>pub use self::style::<a class="enum" href="style/enum.TextStyle.html" title="enum egui::style::TextStyle">TextStyle</a>;</code></div></li><li><div class="item-name" id="reexport.Visuals"><code>pub use self::style::<a class="struct" href="style/struct.Visuals.html" title="struct egui::style::Visuals">Visuals</a>;</code></div></li><li><div class="item-name" id="reexport.RichText"><code>pub use self::widget_text::<a class="struct" href="widget_text/struct.RichText.html" title="struct egui::widget_text::RichText">RichText</a>;</code></div></li><li><div class="item-name" id="reexport.WidgetText"><code>pub use self::widget_text::<a class="enum" href="widget_text/enum.WidgetText.html" title="enum egui::widget_text::WidgetText">WidgetText</a>;</code></div></li><li><div class="item-name" id="reexport.ahash"><code>pub use <a class="mod" href="../ahash/index.html" title="mod ahash">ahash</a>;</code></div></li><li><div class="item-name" id="reexport.epaint"><code>pub use <a class="mod" href="../epaint/index.html" title="mod epaint">epaint</a>;</code></div></li><li><div class="item-name" id="reexport.ecolor"><code>pub use epaint::<a class="mod" href="../ecolor/index.html" title="mod ecolor">ecolor</a>;</code></div></li><li><div class="item-name" id="reexport.emath"><code>pub use epaint::<a class="mod" href="../emath/index.html" title="mod emath">emath</a>;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="containers/index.html" title="mod egui::containers">containers</a>::*;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="viewport/index.html" title="mod egui::viewport">viewport</a>::*;</code></div></li><li><div class="item-name"><code>pub use self::<a class="mod" href="widgets/index.html" title="mod egui::widgets">widgets</a>::*;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="animation_manager/index.html" title="mod egui::animation_manager">animation_manager</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="containers/index.html" title="mod egui::containers">containers</a></div><div class="desc docblock-short">Containers are pieces of the UI which wraps other pieces of UI. Examples: <a href="containers/window/struct.Window.html" title="struct egui::containers::window::Window"><code>Window</code></a>, <a href="containers/scroll_area/struct.ScrollArea.html" title="struct egui::containers::scroll_area::ScrollArea"><code>ScrollArea</code></a>, <a href="containers/resize/struct.Resize.html" title="struct egui::containers::resize::Resize"><code>Resize</code></a>, <a href="containers/panel/struct.SidePanel.html" title="struct egui::containers::panel::SidePanel"><code>SidePanel</code></a>, etc.</div></li><li><div class="item-name"><a class="mod" href="context/index.html" title="mod egui::context">context</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="data/index.html" title="mod egui::data">data</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">All the data sent between egui and the backend</div></li><li><div class="item-name"><a class="mod" href="debug_text/index.html" title="mod egui::debug_text">debug_text</a></div><div class="desc docblock-short">This is an example of how to create a plugin for egui.</div></li><li><div class="item-name"><a class="mod" href="drag_and_drop/index.html" title="mod egui::drag_and_drop">drag_and_drop</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="grid/index.html" title="mod egui::grid">grid</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="gui_zoom/index.html" title="mod egui::gui_zoom">gui_zoom</a></div><div class="desc docblock-short">Helpers for zooming the whole GUI of an app (changing <a href="context/struct.Context.html#method.pixels_per_point" title="method egui::context::Context::pixels_per_point"><code>Context::pixels_per_point</code></a>.</div></li><li><div class="item-name"><a class="mod" href="hit_test/index.html" title="mod egui::hit_test">hit_test</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="id/index.html" title="mod egui::id">id</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="input_state/index.html" title="mod egui::input_state">input_state</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="interaction/index.html" title="mod egui::interaction">interaction</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">How mouse and touch interzcts with widgets.</div></li><li><div class="item-name"><a class="mod" href="introspection/index.html" title="mod egui::introspection">introspection</a></div><div class="desc docblock-short">Showing UI:s for egui/epaint types.</div></li><li><div class="item-name"><a class="mod" href="layers/index.html" title="mod egui::layers">layers</a></div><div class="desc docblock-short">Handles paint layers, i.e. how things
are sometimes painted behind or in front of other things.</div></li><li><div class="item-name"><a class="mod" href="layout/index.html" title="mod egui::layout">layout</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="load/index.html" title="mod egui::load">load</a></div><div class="desc docblock-short">Image loading</div></li><li><div class="item-name"><a class="mod" href="memory/index.html" title="mod egui::memory">memory</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="menu/index.html" title="mod egui::menu">menu</a></div><div class="desc docblock-short">Menu bar functionality (very basic so far).</div></li><li><div class="item-name"><a class="mod" href="mutex/index.html" title="mod egui::mutex">mutex</a></div><div class="desc docblock-short">Helper module that adds extra checks when the <code>deadlock_detection</code> feature is turned on.</div></li><li><div class="item-name"><a class="mod" href="os/index.html" title="mod egui::os">os</a></div></li><li><div class="item-name"><a class="mod" href="output/index.html" title="mod egui::output">output</a></div><div class="desc docblock-short">All the data egui returns to the backend at the end of each frame.</div></li><li><div class="item-name"><a class="mod" href="painter/index.html" title="mod egui::painter">painter</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="pass_state/index.html" title="mod egui::pass_state">pass_state</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="placer/index.html" title="mod egui::placer">placer</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="profiling_scopes/index.html" title="mod egui::profiling_scopes">profiling_scopes</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="response/index.html" title="mod egui::response">response</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="sense/index.html" title="mod egui::sense">sense</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="special_emojis/index.html" title="mod egui::special_emojis">special_emojis</a></div><div class="desc docblock-short">The default egui fonts supports around 1216 emojis in total.
Here are some of the most useful:
âˆâŠ—â—â˜â™ââ´âµâ¶â·
â©âªâ­â®â¸â¹âºâ– â–¶ğŸ“¾ğŸ”€ğŸ”ğŸ”ƒ
â˜€â˜â˜…â˜†â˜â˜‘â˜œâ˜â˜â˜Ÿâ›ƒâ›¶âœ”
â†ºâ†»âŸ²âŸ³â¬…â¡â¬†â¬‡â¬ˆâ¬‰â¬Šâ¬‹â¬Œâ¬â®¨â®©â®ªâ®«
â™¡
ğŸ“…ğŸ“†
ğŸ“ˆğŸ“‰ğŸ“Š
ğŸ“‹ğŸ“ŒğŸ“ğŸ“¤ğŸ“¥ğŸ”†
ğŸ”ˆğŸ”‰ğŸ”ŠğŸ”ğŸ”ğŸ”—ğŸ”˜
ğŸ•“ğŸ–§ğŸ–©ğŸ–®ğŸ–±ğŸ–´ğŸ–µğŸ–¼ğŸ—€ğŸ—ğŸ—‹ğŸ—ğŸ—‘ğŸ—™ğŸš«â“</div></li><li><div class="item-name"><a class="mod" href="style/index.html" title="mod egui::style">style</a></div><div class="desc docblock-short">egui theme (spacing, colors, etc).</div></li><li><div class="item-name"><a class="mod" href="text/index.html" title="mod egui::text">text</a></div></li><li><div class="item-name"><a class="mod" href="text_selection/index.html" title="mod egui::text_selection">text_selection</a></div><div class="desc docblock-short">Helpers regarding text selection for labels and text edit.</div></li><li><div class="item-name"><a class="mod" href="ui/index.html" title="mod egui::ui">ui</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="ui_builder/index.html" title="mod egui::ui_builder">ui_builder</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="ui_stack/index.html" title="mod egui::ui_stack">ui_stack</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="util/index.html" title="mod egui::util">util</a></div><div class="desc docblock-short">Miscellaneous tools used by the rest of egui.</div></li><li><div class="item-name"><a class="mod" href="viewport/index.html" title="mod egui::viewport">viewport</a></div><div class="desc docblock-short">egui supports multiple viewports, corresponding to multiple native windows.</div></li><li><div class="item-name"><a class="mod" href="widget_rect/index.html" title="mod egui::widget_rect">widget_rect</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></li><li><div class="item-name"><a class="mod" href="widget_text/index.html" title="mod egui::widget_text">widget_text</a></div></li><li><div class="item-name"><a class="mod" href="widgets/index.html" title="mod egui::widgets">widgets</a></div><div class="desc docblock-short">Widgets are pieces of GUI such as <a href="widgets/label/struct.Label.html" title="struct egui::widgets::label::Label"><code>Label</code></a>, <a href="widgets/button/struct.Button.html" title="struct egui::widgets::button::Button"><code>Button</code></a>, <a href="widgets/slider/struct.Slider.html" title="struct egui::widgets::slider::Slider"><code>Slider</code></a> etc.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.generate_loader_id.html" title="macro egui::generate_loader_id">generate_loader_id</a></div><div class="desc docblock-short">Used to get a unique ID when implementing one of the loader traits: <a href="load/trait.BytesLoader.html#tymethod.id" title="method egui::load::BytesLoader::id"><code>BytesLoader::id</code></a>, <a href="load/trait.ImageLoader.html#tymethod.id" title="method egui::load::ImageLoader::id"><code>ImageLoader::id</code></a>, and <a href="load/trait.TextureLoader.html#tymethod.id" title="method egui::load::TextureLoader::id"><code>TextureLoader::id</code></a>.</div></li><li><div class="item-name"><a class="macro" href="macro.github_link_file.html" title="macro egui::github_link_file">github_link_file</a></div><div class="desc docblock-short">Create a <a href="widgets/hyperlink/struct.Hyperlink.html" title="struct egui::widgets::hyperlink::Hyperlink"><code>Hyperlink</code></a> to the current <a href="https://doc.rust-lang.org/1.80.1/core/macro.file.html" title="macro core::file"><code>file!()</code></a> on github.</div></li><li><div class="item-name"><a class="macro" href="macro.github_link_file_line.html" title="macro egui::github_link_file_line">github_link_file_line</a></div><div class="desc docblock-short">Create a <a href="widgets/hyperlink/struct.Hyperlink.html" title="struct egui::widgets::hyperlink::Hyperlink"><code>Hyperlink</code></a> to the current <a href="https://doc.rust-lang.org/1.80.1/core/macro.file.html" title="macro core::file"><code>file!()</code></a> (and line) on Github</div></li><li><div class="item-name"><a class="macro" href="macro.include_image.html" title="macro egui::include_image">include_image</a></div><div class="desc docblock-short">Include an image in the binary.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Align2.html" title="struct egui::Align2">Align2</a></div><div class="desc docblock-short">Two-dimension alignment, e.g. <a href="struct.Align2.html#associatedconstant.LEFT_TOP" title="associated constant egui::Align2::LEFT_TOP"><code>Align2::LEFT_TOP</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.ClippedPrimitive.html" title="struct egui::ClippedPrimitive">ClippedPrimitive</a></div><div class="desc docblock-short">A <a href="struct.Mesh.html" title="struct egui::Mesh"><code>Mesh</code></a> or <a href="struct.PaintCallback.html" title="struct egui::PaintCallback"><code>PaintCallback</code></a> within a clip rectangle.</div></li><li><div class="item-name"><a class="struct" href="struct.Color32.html" title="struct egui::Color32">Color32</a></div><div class="desc docblock-short">This format is used for space-efficient color representation (32 bits).</div></li><li><div class="item-name"><a class="struct" href="struct.ColorImage.html" title="struct egui::ColorImage">ColorImage</a></div><div class="desc docblock-short">A 2D RGBA color image in RAM.</div></li><li><div class="item-name"><a class="struct" href="struct.Context.html" title="struct egui::Context">Context</a></div><div class="desc docblock-short">Your handle to egui.</div></li><li><div class="item-name"><a class="struct" href="struct.DragAndDrop.html" title="struct egui::DragAndDrop">DragAndDrop</a></div><div class="desc docblock-short">Tracking of drag-and-drop payload.</div></li><li><div class="item-name"><a class="struct" href="struct.DroppedFile.html" title="struct egui::DroppedFile">DroppedFile</a></div><div class="desc docblock-short">A file dropped into egui.</div></li><li><div class="item-name"><a class="struct" href="struct.EventFilter.html" title="struct egui::EventFilter">EventFilter</a></div><div class="desc docblock-short">Controls which events that a focused widget will have exclusive access to.</div></li><li><div class="item-name"><a class="struct" href="struct.FontData.html" title="struct egui::FontData">FontData</a></div><div class="desc docblock-short">A <code>.ttf</code> or <code>.otf</code> file and a font face index.</div></li><li><div class="item-name"><a class="struct" href="struct.FontDefinitions.html" title="struct egui::FontDefinitions">FontDefinitions</a></div><div class="desc docblock-short">Describes the font data and the sizes to use.</div></li><li><div class="item-name"><a class="struct" href="struct.FontId.html" title="struct egui::FontId">FontId</a></div><div class="desc docblock-short">How to select a sized font.</div></li><li><div class="item-name"><a class="struct" href="struct.FontImage.html" title="struct egui::FontImage">FontImage</a></div><div class="desc docblock-short">A single-channel image designed for the font texture.</div></li><li><div class="item-name"><a class="struct" href="struct.FontTweak.html" title="struct egui::FontTweak">FontTweak</a></div><div class="desc docblock-short">Extra scale and vertical tweak to apply to all text of a certain font.</div></li><li><div class="item-name"><a class="struct" href="struct.FullOutput.html" title="struct egui::FullOutput">FullOutput</a></div><div class="desc docblock-short">What egui emits each frame from <a href="context/struct.Context.html#method.run" title="method egui::context::Context::run"><code>crate::Context::run</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Galley.html" title="struct egui::Galley">Galley</a></div><div class="desc docblock-short">Text that has been laid out, ready for painting.</div></li><li><div class="item-name"><a class="struct" href="struct.Grid.html" title="struct egui::Grid">Grid</a></div><div class="desc docblock-short">A simple grid layout.</div></li><li><div class="item-name"><a class="struct" href="struct.HoveredFile.html" title="struct egui::HoveredFile">HoveredFile</a></div><div class="desc docblock-short">A file about to be dropped into egui.</div></li><li><div class="item-name"><a class="struct" href="struct.Id.html" title="struct egui::Id">Id</a></div><div class="desc docblock-short">egui tracks widgets frame-to-frame using <a href="id/struct.Id.html" title="struct egui::id::Id"><code>Id</code></a>s.</div></li><li><div class="item-name"><a class="struct" href="struct.InnerResponse.html" title="struct egui::InnerResponse">InnerResponse</a></div><div class="desc docblock-short">Returned when we wrap some ui-code and want to return both
the results of the inner function and the ui as a whole, e.g.:</div></li><li><div class="item-name"><a class="struct" href="struct.InputState.html" title="struct egui::InputState">InputState</a></div><div class="desc docblock-short">Input state that egui updates each frame.</div></li><li><div class="item-name"><a class="struct" href="struct.KeyboardShortcut.html" title="struct egui::KeyboardShortcut">KeyboardShortcut</a></div><div class="desc docblock-short">A keyboard shortcut, e.g. <code>Ctrl+Alt+W</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Layout.html" title="struct egui::Layout">Layout</a></div><div class="desc docblock-short">The layout of a <a href="ui/struct.Ui.html" title="struct egui::ui::Ui"><code>Ui</code></a>, e.g. â€œvertical &amp; centeredâ€.</div></li><li><div class="item-name"><a class="struct" href="struct.Margin.html" title="struct egui::Margin">Margin</a></div><div class="desc docblock-short">A value for all four sides of a rectangle,
often used to express padding or spacing.</div></li><li><div class="item-name"><a class="struct" href="struct.Memory.html" title="struct egui::Memory">Memory</a></div><div class="desc docblock-short">The data that egui persists between frames.</div></li><li><div class="item-name"><a class="struct" href="struct.Mesh.html" title="struct egui::Mesh">Mesh</a></div><div class="desc docblock-short">Textured triangles in two dimensions.</div></li><li><div class="item-name"><a class="struct" href="struct.ModifierNames.html" title="struct egui::ModifierNames">ModifierNames</a></div><div class="desc docblock-short">Names of different modifier keys.</div></li><li><div class="item-name"><a class="struct" href="struct.Modifiers.html" title="struct egui::Modifiers">Modifiers</a></div><div class="desc docblock-short">State of the modifier keys. These must be fed to egui.</div></li><li><div class="item-name"><a class="struct" href="struct.MultiTouchInfo.html" title="struct egui::MultiTouchInfo">MultiTouchInfo</a></div><div class="desc docblock-short">All you probably need to know about a multi-touch gesture.</div></li><li><div class="item-name"><a class="struct" href="struct.OpenUrl.html" title="struct egui::OpenUrl">OpenUrl</a></div><div class="desc docblock-short">What URL to open, and how.</div></li><li><div class="item-name"><a class="struct" href="struct.Options.html" title="struct egui::Options">Options</a></div><div class="desc docblock-short">Some global options that you can read and write.</div></li><li><div class="item-name"><a class="struct" href="struct.PaintCallback.html" title="struct egui::PaintCallback">PaintCallback</a></div><div class="desc docblock-short">If you want to paint some 3D shapes inside an egui region, you can use this.</div></li><li><div class="item-name"><a class="struct" href="struct.PaintCallbackInfo.html" title="struct egui::PaintCallbackInfo">PaintCallbackInfo</a></div><div class="desc docblock-short">Information passed along with <a href="struct.PaintCallback.html" title="struct egui::PaintCallback"><code>PaintCallback</code></a> (<a href="enum.Shape.html#variant.Callback" title="variant egui::Shape::Callback"><code>Shape::Callback</code></a>).</div></li><li><div class="item-name"><a class="struct" href="struct.Painter.html" title="struct egui::Painter">Painter</a></div><div class="desc docblock-short">Helper to paint shapes and text to a specific region on a specific layer.</div></li><li><div class="item-name"><a class="struct" href="struct.PlatformOutput.html" title="struct egui::PlatformOutput">PlatformOutput</a></div><div class="desc docblock-short">The non-rendering part of what egui emits each frame.</div></li><li><div class="item-name"><a class="struct" href="struct.PointerState.html" title="struct egui::PointerState">PointerState</a></div><div class="desc docblock-short">Mouse or touch state.</div></li><li><div class="item-name"><a class="struct" href="struct.Pos2.html" title="struct egui::Pos2">Pos2</a></div><div class="desc docblock-short">A position on screen.</div></li><li><div class="item-name"><a class="struct" href="struct.Rangef.html" title="struct egui::Rangef">Rangef</a></div><div class="desc docblock-short">Inclusive range of floats, i.e. <code>min..=max</code>, but more ergonomic than <a href="https://doc.rust-lang.org/1.80.1/core/ops/range/struct.RangeInclusive.html" title="struct core::ops::range::RangeInclusive"><code>RangeInclusive</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RawInput.html" title="struct egui::RawInput">RawInput</a></div><div class="desc docblock-short">What the integrations provides to egui at the start of each frame.</div></li><li><div class="item-name"><a class="struct" href="struct.Rect.html" title="struct egui::Rect">Rect</a></div><div class="desc docblock-short">A rectangular region of space.</div></li><li><div class="item-name"><a class="struct" href="struct.RepaintCause.html" title="struct egui::RepaintCause">RepaintCause</a></div><div class="desc docblock-short">What called <a href="context/struct.Context.html#method.request_repaint" title="method egui::context::Context::request_repaint"><code>Context::request_repaint</code></a> or <a href="context/struct.Context.html#method.request_discard" title="method egui::context::Context::request_discard"><code>Context::request_discard</code></a>?</div></li><li><div class="item-name"><a class="struct" href="struct.RequestRepaintInfo.html" title="struct egui::RequestRepaintInfo">RequestRepaintInfo</a></div><div class="desc docblock-short">Information given to the backend about when it is time to repaint the ui.</div></li><li><div class="item-name"><a class="struct" href="struct.Response.html" title="struct egui::Response">Response</a></div><div class="desc docblock-short">The result of adding a widget to a <a href="ui/struct.Ui.html" title="struct egui::ui::Ui"><code>Ui</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Rgba.html" title="struct egui::Rgba">Rgba</a></div><div class="desc docblock-short">0-1 linear space <code>RGBA</code> color with premultiplied alpha.</div></li><li><div class="item-name"><a class="struct" href="struct.Rounding.html" title="struct egui::Rounding">Rounding</a></div><div class="desc docblock-short">How rounded the corners of things should be</div></li><li><div class="item-name"><a class="struct" href="struct.Sense.html" title="struct egui::Sense">Sense</a></div><div class="desc docblock-short">What sort of interaction is a widget sensitive to?</div></li><li><div class="item-name"><a class="struct" href="struct.Shadow.html" title="struct egui::Shadow">Shadow</a></div><div class="desc docblock-short">The color and fuzziness of a fuzzy shape.</div></li><li><div class="item-name"><a class="struct" href="struct.Stroke.html" title="struct egui::Stroke">Stroke</a></div><div class="desc docblock-short">Describes the width and color of a line.</div></li><li><div class="item-name"><a class="struct" href="struct.TextFormat.html" title="struct egui::TextFormat">TextFormat</a></div><div class="desc docblock-short">Formatting option for a section of text.</div></li><li><div class="item-name"><a class="struct" href="struct.TextureHandle.html" title="struct egui::TextureHandle">TextureHandle</a></div><div class="desc docblock-short">Used to paint images.</div></li><li><div class="item-name"><a class="struct" href="struct.TextureOptions.html" title="struct egui::TextureOptions">TextureOptions</a></div><div class="desc docblock-short">How the texture texels are filtered.</div></li><li><div class="item-name"><a class="struct" href="struct.TexturesDelta.html" title="struct egui::TexturesDelta">TexturesDelta</a></div><div class="desc docblock-short">What has been allocated and freed during the last period.</div></li><li><div class="item-name"><a class="struct" href="struct.TouchDeviceId.html" title="struct egui::TouchDeviceId">TouchDeviceId</a></div><div class="desc docblock-short">this is a <code>u64</code> as values of this kind can always be obtained by hashing</div></li><li><div class="item-name"><a class="struct" href="struct.TouchId.html" title="struct egui::TouchId">TouchId</a></div><div class="desc docblock-short">Unique identification of a touch occurrence (finger or pen or â€¦).
A Touch ID is valid until the finger is lifted.
A new ID is used for the next touch.</div></li><li><div class="item-name"><a class="struct" href="struct.Ui.html" title="struct egui::Ui">Ui</a></div><div class="desc docblock-short">This is what you use to place widgets.</div></li><li><div class="item-name"><a class="struct" href="struct.UiBuilder.html" title="struct egui::UiBuilder">UiBuilder</a></div><div class="desc docblock-short">Build a <a href="ui/struct.Ui.html" title="struct egui::ui::Ui"><code>Ui</code></a> as the chlild of another <a href="ui/struct.Ui.html" title="struct egui::ui::Ui"><code>Ui</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.UiStack.html" title="struct egui::UiStack">UiStack</a></div><div class="desc docblock-short">Information about a <a href="ui/struct.Ui.html" title="struct egui::ui::Ui"><code>crate::Ui</code></a> and its parents.</div></li><li><div class="item-name"><a class="struct" href="struct.UiStackInfo.html" title="struct egui::UiStackInfo">UiStackInfo</a></div><div class="desc docblock-short">Information about a <a href="ui/struct.Ui.html" title="struct egui::ui::Ui"><code>crate::Ui</code></a> to be included in the corresponding <a href="ui_stack/struct.UiStack.html" title="struct egui::ui_stack::UiStack"><code>UiStack</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.UiStackIterator.html" title="struct egui::UiStackIterator">UiStackIterator</a></div><div class="desc docblock-short">Iterator that walks up a stack of <code>StackFrame</code>s.</div></li><li><div class="item-name"><a class="struct" href="struct.UiTags.html" title="struct egui::UiTags">UiTags</a></div><div class="desc docblock-short">User-chosen tags.</div></li><li><div class="item-name"><a class="struct" href="struct.Vec2.html" title="struct egui::Vec2">Vec2</a></div><div class="desc docblock-short">A vector has a direction and length.
A <a href="struct.Vec2.html" title="struct egui::Vec2"><code>Vec2</code></a> is often used to represent a size.</div></li><li><div class="item-name"><a class="struct" href="struct.Vec2b.html" title="struct egui::Vec2b">Vec2b</a></div><div class="desc docblock-short">Two bools, one for each axis (X and Y).</div></li><li><div class="item-name"><a class="struct" href="struct.ViewportInfo.html" title="struct egui::ViewportInfo">ViewportInfo</a></div><div class="desc docblock-short">Information about the current viewport, given as input each frame.</div></li><li><div class="item-name"><a class="struct" href="struct.WidgetInfo.html" title="struct egui::WidgetInfo">WidgetInfo</a></div><div class="desc docblock-short">Describes a widget such as a <a href="widgets/button/struct.Button.html" title="struct egui::widgets::button::Button"><code>crate::Button</code></a> or a <a href="widgets/text_edit/builder/struct.TextEdit.html" title="struct egui::widgets::text_edit::builder::TextEdit"><code>crate::TextEdit</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.WidgetRect.html" title="struct egui::WidgetRect">WidgetRect</a></div><div class="desc docblock-short">Used to store each widgetâ€™s <a href="id/struct.Id.html" title="struct egui::id::Id">Id</a>, <a href="struct.Rect.html" title="struct egui::Rect">Rect</a> and <a href="sense/struct.Sense.html" title="struct egui::sense::Sense">Sense</a> each frame.</div></li><li><div class="item-name"><a class="struct" href="struct.WidgetRects.html" title="struct egui::WidgetRects">WidgetRects</a></div><div class="desc docblock-short">Stores the <a href="widget_rect/struct.WidgetRect.html" title="struct egui::widget_rect::WidgetRect"><code>WidgetRect</code></a>s of all widgets generated during a single egui update/frame.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Align.html" title="enum egui::Align">Align</a></div><div class="desc docblock-short">left/center/right or top/center/bottom alignment for e.g. anchors and layouts.</div></li><li><div class="item-name"><a class="enum" href="enum.CursorIcon.html" title="enum egui::CursorIcon">CursorIcon</a></div><div class="desc docblock-short">A mouse cursor icon.</div></li><li><div class="item-name"><a class="enum" href="enum.Direction.html" title="enum egui::Direction">Direction</a></div><div class="desc docblock-short">Layout direction, one of <a href="layout/enum.Direction.html#variant.LeftToRight" title="variant egui::layout::Direction::LeftToRight"><code>LeftToRight</code></a>, <a href="layout/enum.Direction.html#variant.RightToLeft" title="variant egui::layout::Direction::RightToLeft"><code>RightToLeft</code></a>, <a href="layout/enum.Direction.html#variant.TopDown" title="variant egui::layout::Direction::TopDown"><code>TopDown</code></a>, <a href="layout/enum.Direction.html#variant.BottomUp" title="variant egui::layout::Direction::BottomUp"><code>BottomUp</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.Event.html" title="enum egui::Event">Event</a></div><div class="desc docblock-short">An input event generated by the integration.</div></li><li><div class="item-name"><a class="enum" href="enum.FontFamily.html" title="enum egui::FontFamily">FontFamily</a></div><div class="desc docblock-short">Font of unknown size.</div></li><li><div class="item-name"><a class="enum" href="enum.ImageData.html" title="enum egui::ImageData">ImageData</a></div><div class="desc docblock-short">An image stored in RAM.</div></li><li><div class="item-name"><a class="enum" href="enum.ImeEvent.html" title="enum egui::ImeEvent">ImeEvent</a></div><div class="desc docblock-short">IME event.</div></li><li><div class="item-name"><a class="enum" href="enum.Key.html" title="enum egui::Key">Key</a></div><div class="desc docblock-short">Keyboard keys.</div></li><li><div class="item-name"><a class="enum" href="enum.MouseWheelUnit.html" title="enum egui::MouseWheelUnit">MouseWheelUnit</a></div><div class="desc docblock-short">The unit associated with the numeric value of a mouse wheel event</div></li><li><div class="item-name"><a class="enum" href="enum.PointerButton.html" title="enum egui::PointerButton">PointerButton</a></div><div class="desc docblock-short">Mouse button (or similar for touch input)</div></li><li><div class="item-name"><a class="enum" href="enum.Shape.html" title="enum egui::Shape">Shape</a></div><div class="desc docblock-short">A paint primitive such as a circle or a piece of text.
Coordinates are all screen space points (not physical pixels).</div></li><li><div class="item-name"><a class="enum" href="enum.TextWrapMode.html" title="enum egui::TextWrapMode">TextWrapMode</a></div><div class="desc docblock-short">How to wrap and elide text.</div></li><li><div class="item-name"><a class="enum" href="enum.TextureFilter.html" title="enum egui::TextureFilter">TextureFilter</a></div><div class="desc docblock-short">How the texture texels are filtered.</div></li><li><div class="item-name"><a class="enum" href="enum.TextureId.html" title="enum egui::TextureId">TextureId</a></div><div class="desc docblock-short">What texture to use in a <a href="struct.Mesh.html" title="struct egui::Mesh"><code>Mesh</code></a> mesh.</div></li><li><div class="item-name"><a class="enum" href="enum.TextureWrapMode.html" title="enum egui::TextureWrapMode">TextureWrapMode</a></div><div class="desc docblock-short">Defines how textures are wrapped around objects when texture coordinates fall outside the [0, 1] range.</div></li><li><div class="item-name"><a class="enum" href="enum.Theme.html" title="enum egui::Theme">Theme</a></div><div class="desc docblock-short">Dark or Light theme.</div></li><li><div class="item-name"><a class="enum" href="enum.ThemePreference.html" title="enum egui::ThemePreference">ThemePreference</a></div><div class="desc docblock-short">The userâ€™s theme preference.</div></li><li><div class="item-name"><a class="enum" href="enum.TouchPhase.html" title="enum egui::TouchPhase">TouchPhase</a></div><div class="desc docblock-short">In what phase a touch event is in.</div></li><li><div class="item-name"><a class="enum" href="enum.UiKind.html" title="enum egui::UiKind">UiKind</a></div><div class="desc docblock-short">What kind is this <a href="ui/struct.Ui.html" title="struct egui::ui::Ui"><code>crate::Ui</code></a>?</div></li><li><div class="item-name"><a class="enum" href="enum.UserAttentionType.html" title="enum egui::UserAttentionType">UserAttentionType</a></div><div class="desc docblock-short">Types of attention to request from a user when a native window is not in focus.</div></li><li><div class="item-name"><a class="enum" href="enum.ViewportEvent.html" title="enum egui::ViewportEvent">ViewportEvent</a></div><div class="desc docblock-short">An input event from the backend into egui, about a specific <a href="viewport/index.html" title="mod egui::viewport">viewport</a>.</div></li><li><div class="item-name"><a class="enum" href="enum.WidgetType.html" title="enum egui::WidgetType">WidgetType</a></div><div class="desc docblock-short">The different types of built-in widgets in egui</div></li></ul><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.MINUS_CHAR_STR.html" title="constant egui::MINUS_CHAR_STR">MINUS_CHAR_STR</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="desc docblock-short">The minus character: <a href="https://www.compart.com/en/unicode/U+2212">https://www.compart.com/en/unicode/U+2212</a></div></li><li><div class="item-name"><a class="constant" href="constant.NUM_POINTER_BUTTONS.html" title="constant egui::NUM_POINTER_BUTTONS">NUM_POINTER_BUTTONS</a></div><div class="desc docblock-short">Number of pointer buttons supported by egui, i.e. the number of possible states of <a href="data/input/enum.PointerButton.html" title="enum egui::data::input::PointerButton"><code>PointerButton</code></a>.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.NumExt.html" title="trait egui::NumExt">NumExt</a></div><div class="desc docblock-short">Extends <code>f32</code>, <a href="struct.Vec2.html" title="struct egui::Vec2"><code>Vec2</code></a> etc with <code>at_least</code> and <code>at_most</code> as aliases for <code>max</code> and <code>min</code>.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.__run_test_ctx.html" title="fn egui::__run_test_ctx">__run_test_ctx</a></div><div class="desc docblock-short">For use in tests; especially doctests.</div></li><li><div class="item-name"><a class="fn" href="fn.__run_test_ui.html" title="fn egui::__run_test_ui">__run_test_ui</a></div><div class="desc docblock-short">For use in tests; especially doctests.</div></li><li><div class="item-name"><a class="fn" href="fn.lerp.html" title="fn egui::lerp">lerp</a></div><div class="desc docblock-short">Linear interpolation.</div></li><li><div class="item-name"><a class="fn" href="fn.pos2.html" title="fn egui::pos2">pos2</a></div><div class="desc docblock-short"><code>pos2(x, y) == Pos2::new(x, y)</code></div></li><li><div class="item-name"><a class="fn" href="fn.remap.html" title="fn egui::remap">remap</a></div><div class="desc docblock-short">Linearly remap a value from one range to another,
so that when <code>x == from.start()</code> returns <code>to.start()</code>
and when <code>x == from.end()</code> returns <code>to.end()</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.remap_clamp.html" title="fn egui::remap_clamp">remap_clamp</a></div><div class="desc docblock-short">Like <a href="fn.remap.html" title="fn egui::remap"><code>remap</code></a>, but also clamps the value so that the returned value is always in the <code>to</code> range.</div></li><li><div class="item-name"><a class="fn" href="fn.vec2.html" title="fn egui::vec2">vec2</a></div><div class="desc docblock-short"><code>vec2(x, y) == Vec2::new(x, y)</code></div></li><li><div class="item-name"><a class="fn" href="fn.warn_if_debug_build.html" title="fn egui::warn_if_debug_build">warn_if_debug_build</a></div><div class="desc docblock-short">Helper function that adds a label when compiling with debug assertions enabled.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.IdMap.html" title="type egui::IdMap">IdMap</a></div><div class="desc docblock-short"><code>IdMap&lt;V&gt;</code> is a <code>HashMap&lt;Id, V&gt;</code> optimized by knowing that <a href="id/struct.Id.html" title="struct egui::id::Id"><code>Id</code></a> has good entropy, and doesnâ€™t need more hashing.</div></li></ul></section></div></main></body></html>