<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Span - slices for C++"><title>SelfHostedCache in script::dom::bindings::import::module::jsapi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../../../../" data-static-root-path="../../../../../../static.files/" data-current-crate="script" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../../../script/index.html">script</a><span class="version">0.0.1</span></h2></div><h2 class="location"><a href="#">SelfHostedCache</a></h2><div class="sidebar-elems"><h2><a href="index.html">In script::dom::bindings::import::module::jsapi</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Type Alias <a href="../../../../../index.html">script</a>::<wbr><a href="../../../../index.html">dom</a>::<wbr><a href="../../../index.html">bindings</a>::<wbr><a href="../../index.html">import</a>::<wbr><a href="../index.html">module</a>::<wbr><a href="index.html">jsapi</a>::<wbr><a class="type" href="#">SelfHostedCache</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../../../../src/mozjs_sys/home/runner/work/servo/servo/target/debug/build/mozjs_sys-143fabef74859ace/out/build/jsapi.rs.html#14494">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub type SelfHostedCache = [<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u64.html">u64</a>; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.array.html">2</a>];</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Span - slices for C++</p>
<p>Span implements Rust’s slice concept for C++. It’s called “Span” instead of
“Slice” to follow the naming used in C++ Core Guidelines.</p>
<p>A Span wraps a pointer and a length that identify a non-owning view to a
contiguous block of memory of objects of the same type. Various types,
including (pre-decay) C arrays, XPCOM strings, nsTArray, mozilla::Array,
mozilla::Range and contiguous standard-library containers, auto-convert
into Spans when attempting to pass them as arguments to methods that take
Spans. (Span itself autoconverts into mozilla::Range.)</p>
<p>Like Rust’s slices, Span provides safety against out-of-bounds access by
performing run-time bound checks. However, unlike Rust’s slices, Span
cannot provide safety against use-after-free.</p>
<p>(Note: Span is like Rust’s slice only conceptually. Due to the lack of
ABI guarantees, you should still decompose spans/slices to raw pointer
and length parts when crossing the FFI. The Elements() and data() methods
are guaranteed to return a non-null pointer even for zero-length spans,
so the pointer can be used as a raw part of a Rust slice without further
checks.)</p>
<p>In addition to having constructors (with the support of deduction guides)
that take various well-known types, a Span for an arbitrary type can be
constructed from a pointer and a length or a pointer and another pointer
pointing just past the last element.</p>
<p>A Span<const char> or Span<const char16_t> can be obtained for const char*
or const char16_t pointing to a zero-terminated string using the
MakeStringSpan() function (which treats a nullptr argument equivalently
to the empty string). Corresponding implicit constructor does not exist
in order to avoid accidental construction in cases where const char* or
const char16_t* do not point to a zero-terminated string.</p>
<p>Span has methods that follow the Mozilla naming style and methods that
don’t. The methods that follow the Mozilla naming style are meant to be
used directly from Mozilla code. The methods that don’t are meant for
integration with C++11 range-based loops and with meta-programming that
expects the same methods that are found on the standard-library
containers. For example, to decompose a Span into its parts in Mozilla
code, use Elements() and Length() (as with nsTArray) instead of data()
and size() (as with std::vector).</p>
<p>The pointer and length wrapped by a Span cannot be changed after a Span has
been created. When new values are required, simply create a new Span. Span
has a method called Subspan() that works analogously to the Substring()
method of XPCOM strings taking a start index and an optional length. As a
Mozilla extension (relative to Microsoft’s gsl::span that mozilla::Span is
based on), Span has methods From(start), To(end) and FromTo(start, end)
that correspond to Rust’s &amp;slice[start..], &amp;slice[..end] and
&amp;slice[start..end], respectively. (That is, the end index is the index of
the first element not to be included in the new subspan.)</p>
<p>When indicating a Span that’s only read from, const goes inside the type
parameter. Don’t put const in front of Span. That is:
size_t ReadsFromOneSpanAndWritesToAnother(Span<const uint8_t> aReadFrom,
Span&lt;uint8_t&gt; aWrittenTo);</p>
<p>Any Span<const T> can be viewed as Span<const uint8_t> using the function
AsBytes(). Any Span<T> can be viewed as Span&lt;uint8_t&gt; using the function
AsWritableBytes().</p>
<p>Note that iterators from different Span instances are uncomparable, even if
they refer to the same memory. This also applies to any spans derived via
Subspan etc.</p>
</div></details></section></div></main></body></html>