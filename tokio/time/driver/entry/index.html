<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Timer state structures."><meta name="keywords" content="rust, rustlang, rust-lang, entry"><title>tokio::time::driver::entry - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../../storage.js"></script><script src="../../../../crates.js"></script><script defer src="../../../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../../tokio/index.html"><div class="logo-container"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../../../tokio/index.html"><div class="logo-container"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Module entry</a></h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#constants">Constants</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="entry" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../../tokio/index.html"><img class="rust-logo" src="../../../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div>
                                <input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Module <a href="../../../index.html">tokio</a>::<wbr><a href="../../index.html">time</a>::<wbr><a href="../index.html">driver</a>::<wbr><a class="mod" href="#">entry</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../../../src/tokio/time/driver/entry.rs.html#1-631" title="goto source code">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Timer state structures.</p>
<p>This module contains the heart of the intrusive timer implementation, and as
such the structures inside are full of tricky concurrency and unsafe code.</p>
<h2 id="ground-rules" class="section-header"><a href="#ground-rules">Ground rules</a></h2>
<p>The heart of the timer implementation here is the <a href="struct.TimerShared.html" title="TimerShared"><code>TimerShared</code></a> structure,
shared between the <a href="struct.TimerEntry.html" title="TimerEntry"><code>TimerEntry</code></a> and the driver. Generally, we permit access
to <a href="struct.TimerShared.html" title="TimerShared"><code>TimerShared</code></a> ONLY via either 1) a mutable reference to <a href="struct.TimerEntry.html" title="TimerEntry"><code>TimerEntry</code></a> or
2) a held driver lock.</p>
<p>It follows from this that any changes made while holding BOTH 1 and 2 will
be reliably visible, regardless of ordering. This is because of the acq/rel
fences on the driver lock ensuring ordering with 2, and rust mutable
reference rules for 1 (a mutable reference to an object can’t be passed
between threads without an acq/rel barrier, and same-thread we have local
happens-before ordering).</p>
<h2 id="state-field" class="section-header"><a href="#state-field">State field</a></h2>
<p>Each timer has a state field associated with it. This field contains either
the current scheduled time, or a special flag value indicating its state.
This state can either indicate that the timer is on the ‘pending’ queue (and
thus will be fired with an <code>Ok(())</code> result soon) or that it has already been
fired/deregistered.</p>
<p>This single state field allows for code that is firing the timer to
synchronize with any racing <code>reset</code> calls reliably.</p>
<h2 id="cached-vs-true-timeouts" class="section-header"><a href="#cached-vs-true-timeouts">Cached vs true timeouts</a></h2>
<p>To allow for the use case of a timeout that is periodically reset before
expiration to be as lightweight as possible, we support optimistically
lock-free timer resets, in the case where a timer is rescheduled to a later
point than it was originally scheduled for.</p>
<p>This is accomplished by lazily rescheduling timers. That is, we update the
state field field with the true expiration of the timer from the holder of
the <a href="struct.TimerEntry.html" title="TimerEntry"><code>TimerEntry</code></a>. When the driver services timers (ie, whenever it’s
walking lists of timers), it checks this “true when” value, and reschedules
based on it.</p>
<p>We do, however, also need to track what the expiration time was when we
originally registered the timer; this is used to locate the right linked
list when the timer is being cancelled. This is referred to as the “cached
when” internally.</p>
<p>There is of course a race condition between timer reset and timer
expiration. If the driver fails to observe the updated expiration time, it
could trigger expiration of the timer too early. However, because
<a href="struct.TimerHandle.html#method.mark_pending"><code>mark_pending</code></a> performs a compare-and-swap, it will identify this race and
refuse to mark the timer as pending.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.CachePadded.html" title="tokio::time::driver::entry::CachePadded struct">CachePadded</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StateCell.html" title="tokio::time::driver::entry::StateCell struct">StateCell</a></div><div class="item-right docblock-short"><p>This structure holds the current shared state of the timer - its scheduled
time (if registered), or otherwise the result of the timer completing, as
well as the registered waker.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TimerEntry.html" title="tokio::time::driver::entry::TimerEntry struct">TimerEntry</a></div><div class="item-right docblock-short"><p>A timer entry.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TimerHandle.html" title="tokio::time::driver::entry::TimerHandle struct">TimerHandle</a></div><div class="item-right docblock-short"><p>An TimerHandle is the (non-enforced) “unique” pointer from the driver to the
timer entry. Generally, at most one TimerHandle exists for a timer at a time
(enforced by the timer state machine).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TimerShared.html" title="tokio::time::driver::entry::TimerShared struct">TimerShared</a></div><div class="item-right docblock-short"><p>The shared state structure of a timer. This structure is shared between the
frontend (<code>Entry</code>) and driver backend.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TimerSharedPadded.html" title="tokio::time::driver::entry::TimerSharedPadded struct">TimerSharedPadded</a></div><div class="item-right docblock-short"><p>Additional shared state between the driver and the timer which is cache
padded. This contains the information that the driver thread accesses most
frequently to minimize contention. In particular, we move it away from the
waker, as the waker is updated on every poll.</p>
</div></div></div><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.STATE_DEREGISTERED.html" title="tokio::time::driver::entry::STATE_DEREGISTERED constant">STATE_DEREGISTERED</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.STATE_MIN_VALUE.html" title="tokio::time::driver::entry::STATE_MIN_VALUE constant">STATE_MIN_VALUE</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.STATE_PENDING_FIRE.html" title="tokio::time::driver::entry::STATE_PENDING_FIRE constant">STATE_PENDING_FIRE</a></div><div class="item-right docblock-short"></div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.EntryList.html" title="tokio::time::driver::entry::EntryList type">EntryList</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.TimerResult.html" title="tokio::time::driver::entry::TimerResult type">TimerResult</a></div><div class="item-right docblock-short"></div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../../" data-current-crate="tokio" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0-nightly (5e57faa78 2022-01-19)" ></div>
</body></html>