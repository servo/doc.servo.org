<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The task module."><title>tokio::runtime::task - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="tokio" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../tokio/index.html">tokio</a><span class="version">1.41.0</span></h2></div><h2 class="location"><a href="#">Module task</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In tokio::runtime</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">tokio</a>::<wbr><a href="../index.html">runtime</a>::<wbr><a class="mod" href="#">task</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/tokio/runtime/task/mod.rs.html#1-545">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The task module.</p>
<p>The task module contains the code that manages spawned tasks and provides a
safe API for the rest of the runtime to use. Each task in a runtime is
stored in an <code>OwnedTasks</code> or <code>LocalOwnedTasks</code> object.</p>
<h2 id="task-reference-types"><a class="doc-anchor" href="#task-reference-types">§</a>Task reference types</h2>
<p>A task is usually referenced by multiple handles, and there are several
types of handles.</p>
<ul>
<li>
<p><code>OwnedTask</code> - tasks stored in an <code>OwnedTasks</code> or <code>LocalOwnedTasks</code> are of this
reference type.</p>
</li>
<li>
<p><code>JoinHandle</code> - each task has a <code>JoinHandle</code> that allows access to the output
of the task.</p>
</li>
<li>
<p><code>Waker</code> - every waker for a task has this reference type. There can be any
number of waker references.</p>
</li>
<li>
<p><code>Notified</code> - tracks whether the task is notified.</p>
</li>
<li>
<p><code>Unowned</code> - this task reference type is used for tasks not stored in any
runtime. Mainly used for blocking tasks, but also in tests.</p>
</li>
</ul>
<p>The task uses a reference count to keep track of how many active references
exist. The <code>Unowned</code> reference type takes up two ref-counts. All other
reference types take up a single ref-count.</p>
<p>Besides the waker type, each task has at most one of each reference type.</p>
<h2 id="state"><a class="doc-anchor" href="#state">§</a>State</h2>
<p>The task stores its state in an atomic <code>usize</code> with various bitfields for the
necessary information. The state has the following bitfields:</p>
<ul>
<li>
<p><code>RUNNING</code> - Tracks whether the task is currently being polled or cancelled.
This bit functions as a lock around the task.</p>
</li>
<li>
<p><code>COMPLETE</code> - Is one once the future has fully completed and has been
dropped. Never unset once set. Never set together with RUNNING.</p>
</li>
<li>
<p><code>NOTIFIED</code> - Tracks whether a Notified object currently exists.</p>
</li>
<li>
<p><code>CANCELLED</code> - Is set to one for tasks that should be cancelled as soon as
possible. May take any value for completed tasks.</p>
</li>
<li>
<p><code>JOIN_INTEREST</code> - Is set to one if there exists a <code>JoinHandle</code>.</p>
</li>
<li>
<p><code>JOIN_WAKER</code> - Acts as an access control bit for the join handle waker. The
protocol for its usage is described below.</p>
</li>
</ul>
<p>The rest of the bits are used for the ref-count.</p>
<h2 id="fields-in-the-task"><a class="doc-anchor" href="#fields-in-the-task">§</a>Fields in the task</h2>
<p>The task has various fields. This section describes how and when it is safe
to access a field.</p>
<ul>
<li>
<p>The state field is accessed with atomic instructions.</p>
</li>
<li>
<p>The <code>OwnedTask</code> reference has exclusive access to the <code>owned</code> field.</p>
</li>
<li>
<p>The Notified reference has exclusive access to the <code>queue_next</code> field.</p>
</li>
<li>
<p>The <code>owner_id</code> field can be set as part of construction of the task, but
is otherwise immutable and anyone can access the field immutably without
synchronization.</p>
</li>
<li>
<p>If COMPLETE is one, then the <code>JoinHandle</code> has exclusive access to the
stage field. If COMPLETE is zero, then the RUNNING bitfield functions as
a lock for the stage field, and it can be accessed only by the thread
that set RUNNING to one.</p>
</li>
<li>
<p>The waker field may be concurrently accessed by different threads: in one
thread the runtime may complete a task and <em>read</em> the waker field to
invoke the waker, and in another thread the task’s <code>JoinHandle</code> may be
polled, and if the task hasn’t yet completed, the <code>JoinHandle</code> may <em>write</em>
a waker to the waker field. The <code>JOIN_WAKER</code> bit ensures safe access by
multiple threads to the waker field using the following rules:</p>
<ol>
<li>
<p><code>JOIN_WAKER</code> is initialized to zero.</p>
</li>
<li>
<p>If <code>JOIN_WAKER</code> is zero, then the <code>JoinHandle</code> has exclusive (mutable)
access to the waker field.</p>
</li>
<li>
<p>If <code>JOIN_WAKER</code> is one, then the <code>JoinHandle</code> has shared (read-only)
access to the waker field.</p>
</li>
<li>
<p>If <code>JOIN_WAKER</code> is one and COMPLETE is one, then the runtime has shared
(read-only) access to the waker field.</p>
</li>
<li>
<p>If the <code>JoinHandle</code> needs to write to the waker field, then the
<code>JoinHandle</code> needs to (i) successfully set <code>JOIN_WAKER</code> to zero if it is
not already zero to gain exclusive access to the waker field per rule
2, (ii) write a waker, and (iii) successfully set <code>JOIN_WAKER</code> to one.</p>
</li>
<li>
<p>The <code>JoinHandle</code> can change <code>JOIN_WAKER</code> only if COMPLETE is zero (i.e.
the task hasn’t yet completed).</p>
</li>
</ol>
<p>Rule 6 implies that the steps (i) or (iii) of rule 5 may fail due to a
race. If step (i) fails, then the attempt to write a waker is aborted. If
step (iii) fails because COMPLETE is set to one by another thread after
step (i), then the waker field is cleared. Once COMPLETE is one (i.e.
task has completed), the <code>JoinHandle</code> will not modify <code>JOIN_WAKER</code>. After the
runtime sets COMPLETE to one, it invokes the waker if there is one.</p>
</li>
</ul>
<p>All other fields are immutable and can be accessed immutably without
synchronization by anyone.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>This section goes through various situations and explains why the API is
safe in that situation.</p>
<h3 id="polling-or-dropping-the-future"><a class="doc-anchor" href="#polling-or-dropping-the-future">§</a>Polling or dropping the future</h3>
<p>Any mutable access to the future happens after obtaining a lock by modifying
the RUNNING field, so exclusive access is ensured.</p>
<p>When the task completes, exclusive access to the output is transferred to
the <code>JoinHandle</code>. If the <code>JoinHandle</code> is already dropped when the transition to
complete happens, the thread performing that transition retains exclusive
access to the output and should immediately drop it.</p>
<h3 id="non-send-futures"><a class="doc-anchor" href="#non-send-futures">§</a>Non-Send futures</h3>
<p>If a future is not Send, then it is bound to a <code>LocalOwnedTasks</code>.  The future
will only ever be polled or dropped given a <code>LocalNotified</code> or inside a call
to <code>LocalOwnedTasks::shutdown_all</code>. In either case, it is guaranteed that the
future is on the right thread.</p>
<p>If the task is never removed from the <code>LocalOwnedTasks</code>, then it is leaked, so
there is no risk that the task is dropped on some other thread when the last
ref-count drops.</p>
<h3 id="non-send-output"><a class="doc-anchor" href="#non-send-output">§</a>Non-Send output</h3>
<p>When a task completes, the output is placed in the stage of the task. Then,
a transition that sets COMPLETE to true is performed, and the value of
<code>JOIN_INTEREST</code> when this transition happens is read.</p>
<p>If <code>JOIN_INTEREST</code> is zero when the transition to COMPLETE happens, then the
output is immediately dropped.</p>
<p>If <code>JOIN_INTEREST</code> is one when the transition to COMPLETE happens, then the
<code>JoinHandle</code> is responsible for cleaning up the output. If the output is not
Send, then this happens:</p>
<ol>
<li>The output is created on the thread that the future was polled on. Since
only non-Send futures can have non-Send output, the future was polled on
the thread that the future was spawned from.</li>
<li>Since <code>JoinHandle&lt;Output&gt;</code> is not Send if Output is not Send, the
<code>JoinHandle</code> is also on the thread that the future was spawned from.</li>
<li>Thus, the <code>JoinHandle</code> will not move the output across threads when it
takes or drops the output.</li>
</ol>
<h3 id="recursive-pollshutdown"><a class="doc-anchor" href="#recursive-pollshutdown">§</a>Recursive poll/shutdown</h3>
<p>Calling poll from inside a shutdown call or vice-versa is not prevented by
the API exposed by the task module, so this has to be safe. In either case,
the lock in the RUNNING bitfield makes the inner call return immediately. If
the inner call is a <code>shutdown</code> call, then the CANCELLED bit is set, and the
poll call will notice it when the poll finishes, and the task is cancelled
at that point.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.JoinError"><code>pub use self::error::<a class="struct" href="error/struct.JoinError.html" title="struct tokio::runtime::task::error::JoinError">JoinError</a>;</code></div></li><li><div class="item-name" id="reexport.id"><code>pub use id::<a class="fn" href="id/fn.id.html" title="fn tokio::runtime::task::id::id">id</a>;</code></div></li><li><div class="item-name" id="reexport.try_id"><code>pub use id::<a class="fn" href="id/fn.try_id.html" title="fn tokio::runtime::task::id::try_id">try_id</a>;</code></div></li><li><div class="item-name" id="reexport.Id"><code>pub use id::<a class="struct" href="id/struct.Id.html" title="struct tokio::runtime::task::id::Id">Id</a>;</code></div></li><li><div class="item-name" id="reexport.AbortHandle"><code>pub use self::abort::<a class="struct" href="abort/struct.AbortHandle.html" title="struct tokio::runtime::task::abort::AbortHandle">AbortHandle</a>;</code></div></li><li><div class="item-name" id="reexport.JoinHandle"><code>pub use self::join::<a class="struct" href="join/struct.JoinHandle.html" title="struct tokio::runtime::task::join::JoinHandle">JoinHandle</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="abort/index.html" title="mod tokio::runtime::task::abort">abort</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="core/index.html" title="mod tokio::runtime::task::core">core</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Core task module.</div></li><li><div class="item-name"><a class="mod" href="error/index.html" title="mod tokio::runtime::task::error">error</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="harness/index.html" title="mod tokio::runtime::task::harness">harness</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="id/index.html" title="mod tokio::runtime::task::id">id</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="join/index.html" title="mod tokio::runtime::task::join">join</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="list/index.html" title="mod tokio::runtime::task::list">list</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">This module has containers for storing the tasks spawned on a scheduler. The
<code>OwnedTasks</code> container is thread-safe but can only store tasks that
implement Send. The <code>LocalOwnedTasks</code> container is not thread safe, but can
store non-Send tasks.</div></li><li><div class="item-name"><a class="mod" href="raw/index.html" title="mod tokio::runtime::task::raw">raw</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="state/index.html" title="mod tokio::runtime::task::state">state</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="mod" href="waker/index.html" title="mod tokio::runtime::task::waker">waker</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.LocalNotified.html" title="struct tokio::runtime::task::LocalNotified">LocalNotified</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">A non-Send variant of Notified with the invariant that it is on a thread
where it is safe to poll it.</div></li><li><div class="item-name"><a class="struct" href="struct.Notified.html" title="struct tokio::runtime::task::Notified">Notified</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">A task was notified.</div></li><li><div class="item-name"><a class="struct" href="struct.Task.html" title="struct tokio::runtime::task::Task">Task</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">An owned handle to the task, tracked by ref count.</div></li><li><div class="item-name"><a class="struct" href="struct.TaskHarnessScheduleHooks.html" title="struct tokio::runtime::task::TaskHarnessScheduleHooks">TaskHarnessScheduleHooks</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Hooks for scheduling tasks which are needed in the task harness.</div></li><li><div class="item-name"><a class="struct" href="struct.UnownedTask.html" title="struct tokio::runtime::task::UnownedTask">UnownedTask</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">A task that is not owned by any <code>OwnedTasks</code>. Used for blocking tasks.
This type holds two ref-counts.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Schedule.html" title="trait tokio::runtime::task::Schedule">Schedule</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.new_task.html" title="fn tokio::runtime::task::new_task">new_task</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">This is the constructor for a new task. Three references to the task are
created. The first task reference is usually put into an <code>OwnedTasks</code>
immediately. The Notified is sent to the scheduler as an ordinary
notification.</div></li><li><div class="item-name"><a class="fn" href="fn.unowned.html" title="fn tokio::runtime::task::unowned">unowned</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Creates a new task with an associated join handle. This method is used
only when the task is not going to be stored in an <code>OwnedTasks</code> list.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Result.html" title="type tokio::runtime::task::Result">Result</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Task result sent back.</div></li></ul></section></div></main></body></html>