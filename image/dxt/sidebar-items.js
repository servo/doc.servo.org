initSidebarItems({"enum":[["DXTVariant","What version of DXT compression are we using? Note that DXT2 and DXT4 are left away as theyâ€™re just DXT3 and DXT5 with premultiplied alpha"]],"fn":[["alpha_table_dxt5","Constructs the DXT5 alpha lookup table from the two alpha entries if alpha0 > alpha1, constructs a table of [a0, a1, 6 linearly interpolated values from a0 to a1] if alpha0 <= alpha1, constructs a table of [a0, a1, 4 linearly interpolated values from a0 to a1, 0, 0xFF]"],["decode_dxt1_block","Decodes a 8-byte bock of dxt5 data to a 16xRGB block"],["decode_dxt1_row","Decode a row of DXT1 data to four rows of RGBA data. source.len() should be a multiple of 8, otherwise this panics."],["decode_dxt3_block","Decodes a 16-byte bock of dxt3 data to a 16xRGBA block"],["decode_dxt3_row","Decode a row of DXT3 data to four rows of RGBA data. source.len() should be a multiple of 16, otherwise this panics."],["decode_dxt5_block","Decodes a 16-byte bock of dxt5 data to a 16xRGBA block"],["decode_dxt5_row","Decode a row of DXT5 data to four rows of RGBA data. source.len() should be a multiple of 16, otherwise this panics."],["decode_dxt_colors","decodes an 8-byte dxt color block into the RGB channels of a 16xRGB or 16xRGBA block. source should have a length of 8, dest a length of 48 (RGB) or 64 (RGBA)"],["diff","returns the squared error between two RGB values"],["enc565_decode","decodes a 5-bit R, 6-bit G, 5-bit B 16-bit packed color value into 8-bit RGB mapping is done so min/max range values are preserved. So for 5-bit values 0x00 -> 0x00 and 0x1F -> 0xFF"],["enc565_encode","encodes an 8-bit RGB value into a 5-bit R, 6-bit G, 5-bit B 16-bit packed color value mapping preserves min/max values. It is guaranteed that i == encode(decode(i)) for all i"],["encode_dxt1_block","Encodes a RGBx16 sequence of bytes into a 8 bytes DXT1 block"],["encode_dxt1_row","Decode a row of DXT1 data to four rows of RGBA data. source.len() should be a multiple of 8, otherwise this panics."],["encode_dxt3_block","Encodes a RGBAx16 sequence of bytes into a 16 bytes DXT3 block"],["encode_dxt3_row","Decode a row of DXT3 data to four rows of RGBA data. source.len() should be a multiple of 16, otherwise this panics."],["encode_dxt5_alpha","Encodes a buffer of 16 alpha bytes into a dxt5 alpha index table, where the alpha table they are indexed against is created by calling alpha_table_dxt5(alpha0, alpha1) returns the resulting error and alpha table"],["encode_dxt5_block","Encodes a RGBAx16 sequence of bytes to a 16 bytes DXT5 block"],["encode_dxt5_row","Decode a row of DXT5 data to four rows of RGBA data. source.len() should be a multiple of 16, otherwise this panics."],["encode_dxt_colors","Tries to perform the color encoding part of dxt compression the approach taken is simple, it picks unique combinations of the colors present in the block, and attempts to encode the block with each, picking the encoding that yields the least squared error out of all of them."],["square","utility function: squares a value"]],"struct":[["DxtDecoder","DXT decoder"],["DxtEncoder","DXT encoder"],["DxtReader","DXT reader"]],"type":[["DXTEncoder","DXT encoder"],["DXTReader","DXT reader"],["DxtVariant","DXT compression version."],["Rgb",""]]});