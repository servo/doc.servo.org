initSidebarItems({"constant":[["BITMAPCOREHEADER_SIZE",""],["BITMAPINFOHEADER_SIZE",""],["BITMAPV2HEADER_SIZE",""],["BITMAPV3HEADER_SIZE",""],["BITMAPV4HEADER_SIZE",""],["BITMAPV5HEADER_SIZE",""],["MAX_INITIAL_PIXELS","The maximum starting number of pixels in the pixel buffer, might want to tweak this."],["MAX_WIDTH_HEIGHT","The maximum width/height the decoder will process."],["R8_G8_B8_COLOR_MASK",""],["RLE_ESCAPE",""],["RLE_ESCAPE_DELTA",""],["RLE_ESCAPE_EOF",""],["RLE_ESCAPE_EOL",""]],"enum":[["BMPHeaderType",""],["ChannelWidthError","Distinct image types whose saved channel width can be invalid"],["Chunker",""],["DecoderError","All errors that can occur when attempting to parse a BMP"],["FormatFullBytes",""],["ImageType",""],["RLEInsn",""]],"fn":[["blank_bytes","Sets all bytes in an mutable iterator over slices of bytes to 0."],["check_for_overflow","Convenience function to check if the combination of width, length and number of channels would result in a buffer that would overflow."],["extend_buffer","Extend the buffer to `full_size`, copying existing data to the end of the buffer. Returns slice pointing to the part of the buffer that is not yet filled in."],["num_bytes","Calculate how many many bytes a buffer holding a decoded image with these properties would require. Returns `None` if the buffer size would overflow or if one of the sizes are negative."],["set_1bit_pixel_run",""],["set_2bit_pixel_run",""],["set_4bit_pixel_run",""],["set_8bit_pixel_run",""],["with_rows","Call the provided function on each row of the provided buffer, returning Err if the provided function returns an error, extends the buffer if itâ€™s not large enough."]],"static":[["LOOKUP_TABLE_3_BIT_TO_8_BIT",""],["LOOKUP_TABLE_4_BIT_TO_8_BIT",""],["LOOKUP_TABLE_5_BIT_TO_8_BIT",""],["LOOKUP_TABLE_6_BIT_TO_8_BIT",""],["R5_G5_B5_COLOR_MASK",""]],"struct":[["Bitfield",""],["Bitfields",""],["BmpDecoder","A bmp decoder"],["BmpReader","Wrapper struct around a `Cursor<Vec<u8>>`"],["RLEInsnIterator",""],["RowIterator",""]]});