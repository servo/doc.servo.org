initSidebarItems({"constant":[["SHARING_CACHE_KEY",""],["SHARING_CACHE_SIZE","The amount of nodes that the style sharing candidate cache should hold at most."]],"mod":[["checks","Different checks done during the style sharing process in order to determine quickly whether it’s worth to share style, and whether two different elements can indeed share the same style."]],"struct":[["FakeCandidate",""],["OpaqueComputedValues","Opaque pointer type to compare ComputedValues identities."],["SharingCacheBase",""],["StyleSharingCache","An LRU cache of the last few nodes seen, so that we can aggressively try to reuse their styles."],["StyleSharingCandidate","Information regarding a style sharing candidate, that is, an entry in the style sharing cache."],["StyleSharingTarget","An element we want to test against the style sharing cache."],["ValidationData","Some data we want to avoid recomputing all the time while trying to share style."]],"type":[["SharingCache","Style sharing caches are are large allocations, so we store them in thread-local storage such that they can be reused across style traversals. Ideally, we’d just stack-allocate these buffers with uninitialized memory, but right now rustc can’t avoid memmoving the entire cache during setup, which gets very expensive. See issues like [1] and [2]."],["StoredSharingCache",""],["TypelessSharingCache",""]]});