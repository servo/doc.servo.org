<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The rustc book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="what-is-rustc.html"><strong aria-hidden="true">1.</strong> What is rustc?</a></li><li class="chapter-item expanded "><a href="command-line-arguments.html"><strong aria-hidden="true">2.</strong> Command-line arguments</a></li><li class="chapter-item expanded "><a href="lints/index.html"><strong aria-hidden="true">3.</strong> Lints</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lints/levels.html"><strong aria-hidden="true">3.1.</strong> Lint levels</a></li><li class="chapter-item expanded "><a href="lints/groups.html"><strong aria-hidden="true">3.2.</strong> Lint Groups</a></li><li class="chapter-item expanded "><a href="lints/listing/index.html"><strong aria-hidden="true">3.3.</strong> Lint listing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="lints/listing/allowed-by-default.html"><strong aria-hidden="true">3.3.1.</strong> Allowed-by-default lints</a></li><li class="chapter-item expanded "><a href="lints/listing/warn-by-default.html"><strong aria-hidden="true">3.3.2.</strong> Warn-by-default lints</a></li><li class="chapter-item expanded "><a href="lints/listing/deny-by-default.html"><strong aria-hidden="true">3.3.3.</strong> Deny-by-default lints</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="codegen-options/index.html"><strong aria-hidden="true">4.</strong> Codegen options</a></li><li class="chapter-item expanded "><a href="json.html"><strong aria-hidden="true">5.</strong> JSON Output</a></li><li class="chapter-item expanded "><a href="tests/index.html"><strong aria-hidden="true">6.</strong> Tests</a></li><li class="chapter-item expanded "><a href="platform-support.html"><strong aria-hidden="true">7.</strong> Platform Support</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="platform-support/TEMPLATE.html"><strong aria-hidden="true">7.1.</strong> Template for target-specific documentation</a></li><li class="chapter-item expanded "><a href="platform-support/aarch64-apple-ios-sim.html"><strong aria-hidden="true">7.2.</strong> aarch64-apple-ios-sim</a></li><li class="chapter-item expanded "><a href="platform-support/kmc-solid.html"><strong aria-hidden="true">7.3.</strong> -kmc-solid_</a></li><li class="chapter-item expanded "><a href="platform-support/x86_64-unknown-none.html"><strong aria-hidden="true">7.4.</strong> x86_64-unknown-none</a></li><li class="chapter-item expanded "><a href="platform-support/wasm64-unknown-unknown.html"><strong aria-hidden="true">7.5.</strong> wasm64-unknown-unknown</a></li></ol></li><li class="chapter-item expanded "><a href="target-tier-policy.html"><strong aria-hidden="true">8.</strong> Target Tier Policy</a></li><li class="chapter-item expanded "><a href="targets/index.html"><strong aria-hidden="true">9.</strong> Targets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="targets/built-in.html"><strong aria-hidden="true">9.1.</strong> Built-in Targets</a></li><li class="chapter-item expanded "><a href="targets/custom.html"><strong aria-hidden="true">9.2.</strong> Custom Targets</a></li><li class="chapter-item expanded "><a href="targets/known-issues.html"><strong aria-hidden="true">9.3.</strong> Known Issues</a></li></ol></li><li class="chapter-item expanded "><a href="profile-guided-optimization.html"><strong aria-hidden="true">10.</strong> Profile-guided Optimization</a></li><li class="chapter-item expanded "><a href="linker-plugin-lto.html"><strong aria-hidden="true">11.</strong> Linker-plugin based LTO</a></li><li class="chapter-item expanded "><a href="exploit-mitigations.html"><strong aria-hidden="true">12.</strong> Exploit Mitigations</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">13.</strong> Contributing to rustc</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The rustc book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust/tree/master/src/doc/rustc" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="what-is-rustc"><a class="header" href="#what-is-rustc">What is rustc?</a></h1>
<p>Welcome to &quot;The rustc book&quot;! <code>rustc</code> is the compiler for the Rust programming
language, provided by the project itself. Compilers take your source code and
produce binary code, either as a library or executable.</p>
<p>Most Rust programmers don't invoke <code>rustc</code> directly, but instead do it through
<a href="../cargo/index.html">Cargo</a>. It's all in service of <code>rustc</code> though! If you
want to see how Cargo calls <code>rustc</code>, you can</p>
<pre><code class="language-bash">$ cargo build --verbose
</code></pre>
<p>And it will print out each <code>rustc</code> invocation. This book can help you
understand what each of these options does. Additionally, while most
Rustaceans use Cargo, not all do: sometimes they integrate <code>rustc</code> into other
build systems. This book should provide a guide to all of the options you'd
need to do so.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<p>Let's say you've got a little hello world program in a file <code>hello.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>To turn this source code into an executable, you can use <code>rustc</code>:</p>
<pre><code class="language-bash">$ rustc hello.rs
$ ./hello # on a *NIX
$ .\hello.exe # on Windows
</code></pre>
<p>Note that we only ever pass <code>rustc</code> the <em>crate root</em>, not every file we wish
to compile. For example, if we had a <code>main.rs</code> that looked like this:</p>
<pre><code class="language-rust ignore (needs-multiple-files)">mod foo;

fn main() {
    foo::hello();
}
</code></pre>
<p>And a <code>foo.rs</code> that had this:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn hello() {
    println!(&quot;Hello, world!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>To compile this, we'd run this command:</p>
<pre><code class="language-bash">$ rustc main.rs
</code></pre>
<p>No need to tell <code>rustc</code> about <code>foo.rs</code>; the <code>mod</code> statements give it
everything that it needs. This is different than how you would use a C
compiler, where you invoke the compiler on each file, and then link
everything together. In other words, the <em>crate</em> is a translation unit, not a
particular module.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-arguments"><a class="header" href="#command-line-arguments">Command-line arguments</a></h1>
<p>Here's a list of command-line arguments to <code>rustc</code> and what they do.</p>
<p><a id="option-help"></a></p>
<h2 id="-h--help-get-help"><a class="header" href="#-h--help-get-help"><code>-h</code>/<code>--help</code>: get help</a></h2>
<p>This flag will print out help information for <code>rustc</code>.</p>
<p><a id="option-cfg"></a></p>
<h2 id="--cfg-configure-the-compilation-environment"><a class="header" href="#--cfg-configure-the-compilation-environment"><code>--cfg</code>: configure the compilation environment</a></h2>
<p>This flag can turn on or off various <code>#[cfg]</code> settings for <a href="../reference/conditional-compilation.html">conditional
compilation</a>.</p>
<p>The value can either be a single identifier or two identifiers separated by <code>=</code>.</p>
<p>For examples, <code>--cfg 'verbose'</code> or <code>--cfg 'feature=&quot;serde&quot;'</code>. These correspond
to <code>#[cfg(verbose)]</code> and <code>#[cfg(feature = &quot;serde&quot;)]</code> respectively.</p>
<p><a id="option-l-search-path"></a></p>
<h2 id="-l-add-a-directory-to-the-library-search-path"><a class="header" href="#-l-add-a-directory-to-the-library-search-path"><code>-L</code>: add a directory to the library search path</a></h2>
<p>The <code>-L</code> flag adds a path to search for external crates and libraries.</p>
<p>The kind of search path can optionally be specified with the form <code>-L KIND=PATH</code> where <code>KIND</code> may be one of:</p>
<ul>
<li><code>dependency</code> — Only search for transitive dependencies in this directory.</li>
<li><code>crate</code> — Only search for this crate's direct dependencies in this
directory.</li>
<li><code>native</code> — Only search for native libraries in this directory.</li>
<li><code>framework</code> — Only search for macOS frameworks in this directory.</li>
<li><code>all</code> — Search for all library kinds in this directory. This is the default
if <code>KIND</code> is not specified.</li>
</ul>
<p><a id="option-l-link-lib"></a></p>
<h2 id="-l-link-the-generated-crate-to-a-native-library"><a class="header" href="#-l-link-the-generated-crate-to-a-native-library"><code>-l</code>: link the generated crate to a native library</a></h2>
<p>This flag allows you to specify linking to a specific native library when building
a crate.</p>
<p>The kind of library can optionally be specified with the form <code>-l KIND=lib</code>
where <code>KIND</code> may be one of:</p>
<ul>
<li><code>dylib</code> — A native dynamic library.</li>
<li><code>static</code> — A native static library (such as a <code>.a</code> archive).</li>
<li><code>framework</code> — A macOS framework.</li>
</ul>
<p>The kind of library can be specified in a <a href="../reference/items/external-blocks.html#the-link-attribute"><code>#[link]</code>
attribute</a>. If the kind is not specified in the <code>link</code>
attribute or on the command-line, it will link a dynamic library if available,
otherwise it will use a static library. If the kind is specified on the
command-line, it will override the kind specified in a <code>link</code> attribute.</p>
<p>The name used in a <code>link</code> attribute may be overridden using the form <code>-l ATTR_NAME:LINK_NAME</code> where <code>ATTR_NAME</code> is the name in the <code>link</code> attribute,
and <code>LINK_NAME</code> is the name of the actual library that will be linked.</p>
<p><a id="option-crate-type"></a></p>
<h2 id="--crate-type-a-list-of-types-of-crates-for-the-compiler-to-emit"><a class="header" href="#--crate-type-a-list-of-types-of-crates-for-the-compiler-to-emit"><code>--crate-type</code>: a list of types of crates for the compiler to emit</a></h2>
<p>This instructs <code>rustc</code> on which crate type to build. This flag accepts a
comma-separated list of values, and may be specified multiple times. The valid
crate types are:</p>
<ul>
<li><code>lib</code> — Generates a library kind preferred by the compiler, currently
defaults to <code>rlib</code>.</li>
<li><code>rlib</code> — A Rust static library.</li>
<li><code>staticlib</code> — A native static library.</li>
<li><code>dylib</code> — A Rust dynamic library.</li>
<li><code>cdylib</code> — A native dynamic library.</li>
<li><code>bin</code> — A runnable executable program.</li>
<li><code>proc-macro</code> — Generates a format suitable for a procedural macro library
that may be loaded by the compiler.</li>
</ul>
<p>The crate type may be specified with the <a href="../reference/linkage.html"><code>crate_type</code> attribute</a>.
The <code>--crate-type</code> command-line value will override the <code>crate_type</code>
attribute.</p>
<p>More details may be found in the <a href="../reference/linkage.html">linkage chapter</a> of the reference.</p>
<p><a id="option-crate-name"></a></p>
<h2 id="--crate-name-specify-the-name-of-the-crate-being-built"><a class="header" href="#--crate-name-specify-the-name-of-the-crate-being-built"><code>--crate-name</code>: specify the name of the crate being built</a></h2>
<p>This informs <code>rustc</code> of the name of your crate.</p>
<p><a id="option-edition"></a></p>
<h2 id="--edition-specify-the-edition-to-use"><a class="header" href="#--edition-specify-the-edition-to-use"><code>--edition</code>: specify the edition to use</a></h2>
<p>This flag takes a value of <code>2015</code>, <code>2018</code> or <code>2021</code>. The default is <code>2015</code>. More
information about editions may be found in the <a href="../edition-guide/introduction.html">edition guide</a>.</p>
<p><a id="option-emit"></a></p>
<h2 id="--emit-specifies-the-types-of-output-files-to-generate"><a class="header" href="#--emit-specifies-the-types-of-output-files-to-generate"><code>--emit</code>: specifies the types of output files to generate</a></h2>
<p>This flag controls the types of output files generated by the compiler. It
accepts a comma-separated list of values, and may be specified multiple times.
The valid emit kinds are:</p>
<ul>
<li><code>asm</code> — Generates a file with the crate's assembly code. The default output
filename is <code>CRATE_NAME.s</code>.</li>
<li><code>dep-info</code> — Generates a file with Makefile syntax that indicates all the
source files that were loaded to generate the crate. The default output
filename is <code>CRATE_NAME.d</code>.</li>
<li><code>link</code> — Generates the crates specified by <code>--crate-type</code>. The default
output filenames depend on the crate type and platform. This is the default
if <code>--emit</code> is not specified.</li>
<li><code>llvm-bc</code> — Generates a binary file containing the <a href="https://llvm.org/docs/BitCodeFormat.html">LLVM bitcode</a>. The
default output filename is <code>CRATE_NAME.bc</code>.</li>
<li><code>llvm-ir</code> — Generates a file containing <a href="https://llvm.org/docs/LangRef.html">LLVM IR</a>. The default output
filename is <code>CRATE_NAME.ll</code>.</li>
<li><code>metadata</code> — Generates a file containing metadata about the crate. The
default output filename is <code>CRATE_NAME.rmeta</code>.</li>
<li><code>mir</code> — Generates a file containing rustc's mid-level intermediate
representation. The default output filename is <code>CRATE_NAME.mir</code>.</li>
<li><code>obj</code> — Generates a native object file. The default output filename is
<code>CRATE_NAME.o</code>.</li>
</ul>
<p>The output filename can be set with the <a href="command-line-arguments.html#option-o-output"><code>-o</code> flag</a>. A
suffix may be added to the filename with the <a href="codegen-options/index.html#extra-filename"><code>-C extra-filename</code>
flag</a>. The files are written to the
current directory unless the <a href="command-line-arguments.html#option-out-dir"><code>--out-dir</code> flag</a> is used. Each
emission type may also specify the output filename with the form <code>KIND=PATH</code>,
which takes precedence over the <code>-o</code> flag.</p>
<p><a id="option-print"></a></p>
<h2 id="--print-print-compiler-information"><a class="header" href="#--print-print-compiler-information"><code>--print</code>: print compiler information</a></h2>
<p>This flag prints out various information about the compiler. This flag may be
specified multiple times, and the information is printed in the order the
flags are specified. Specifying a <code>--print</code> flag will usually disable the
<a href="command-line-arguments.html#option-emit"><code>--emit</code></a> step and will only print the requested information.
The valid types of print values are:</p>
<ul>
<li><code>crate-name</code> — The name of the crate.</li>
<li><code>file-names</code> — The names of the files created by the <code>link</code> emit kind.</li>
<li><code>sysroot</code> — Path to the sysroot.</li>
<li><code>target-libdir</code> - Path to the target libdir.</li>
<li><code>cfg</code> — List of cfg values. See <a href="../reference/conditional-compilation.html">conditional compilation</a> for more
information about cfg values.</li>
<li><code>target-list</code> — List of known targets. The target may be selected with the
<code>--target</code> flag.</li>
<li><code>target-cpus</code> — List of available CPU values for the current target. The
target CPU may be selected with the <a href="codegen-options/index.html#target-cpu"><code>-C target-cpu=val</code>
flag</a>.</li>
<li><code>target-features</code> — List of available target features for the current
target. Target features may be enabled with the <a href="codegen-options/index.html#target-feature"><code>-C target-feature=val</code>
flag</a>.  This flag is unsafe. See
<a href="targets/known-issues.html">known issues</a> for more details.</li>
<li><code>relocation-models</code> — List of relocation models. Relocation models may be
selected with the <a href="codegen-options/index.html#relocation-model"><code>-C relocation-model=val</code>
flag</a>.</li>
<li><code>code-models</code> — List of code models. Code models may be selected with the
<a href="codegen-options/index.html#code-model"><code>-C code-model=val</code> flag</a>.</li>
<li><code>tls-models</code> — List of Thread Local Storage models supported. The model may
be selected with the <code>-Z tls-model=val</code> flag.</li>
<li><code>native-static-libs</code> — This may be used when creating a <code>staticlib</code> crate
type. If this is the only flag, it will perform a full compilation and
include a diagnostic note that indicates the linker flags to use when
linking the resulting static library. The note starts with the text
<code>native-static-libs:</code> to make it easier to fetch the output.</li>
</ul>
<p><a id="option-g-debug"></a></p>
<h2 id="-g-include-debug-information"><a class="header" href="#-g-include-debug-information"><code>-g</code>: include debug information</a></h2>
<p>A synonym for <a href="codegen-options/index.html#debuginfo"><code>-C debuginfo=2</code></a>.</p>
<p><a id="option-o-optimize"></a></p>
<h2 id="-o-optimize-your-code"><a class="header" href="#-o-optimize-your-code"><code>-O</code>: optimize your code</a></h2>
<p>A synonym for <a href="codegen-options/index.html#opt-level"><code>-C opt-level=2</code></a>.</p>
<p><a id="option-o-output"></a></p>
<h2 id="-o-filename-of-the-output"><a class="header" href="#-o-filename-of-the-output"><code>-o</code>: filename of the output</a></h2>
<p>This flag controls the output filename.</p>
<p><a id="option-out-dir"></a></p>
<h2 id="--out-dir-directory-to-write-the-output-in"><a class="header" href="#--out-dir-directory-to-write-the-output-in"><code>--out-dir</code>: directory to write the output in</a></h2>
<p>The outputted crate will be written to this directory. This flag is ignored if
the <a href="command-line-arguments.html#option-o-output"><code>-o</code> flag</a> is used.</p>
<p><a id="option-explain"></a></p>
<h2 id="--explain-provide-a-detailed-explanation-of-an-error-message"><a class="header" href="#--explain-provide-a-detailed-explanation-of-an-error-message"><code>--explain</code>: provide a detailed explanation of an error message</a></h2>
<p>Each error of <code>rustc</code>'s comes with an error code; this will print
out a longer explanation of a given error.</p>
<p><a id="option-test"></a></p>
<h2 id="--test-build-a-test-harness"><a class="header" href="#--test-build-a-test-harness"><code>--test</code>: build a test harness</a></h2>
<p>When compiling this crate, <code>rustc</code> will ignore your <code>main</code> function
and instead produce a test harness. See the <a href="tests/index.html">Tests chapter</a>
for more information about tests.</p>
<p><a id="option-target"></a></p>
<h2 id="--target-select-a-target-triple-to-build"><a class="header" href="#--target-select-a-target-triple-to-build"><code>--target</code>: select a target triple to build</a></h2>
<p>This controls which <a href="targets/index.html">target</a> to produce.</p>
<p><a id="option-w-warn"></a></p>
<h2 id="-w-set-lint-warnings"><a class="header" href="#-w-set-lint-warnings"><code>-W</code>: set lint warnings</a></h2>
<p>This flag will set which lints should be set to the <a href="lints/levels.html#warn">warn level</a>.</p>
<p><em>Note:</em> The order of these lint level arguments is taken into account, see <a href="lints/levels.html#via-compiler-flag">lint level via compiler flag</a> for more information.</p>
<p><a id="option-a-allow"></a></p>
<h2 id="-a-set-lint-allowed"><a class="header" href="#-a-set-lint-allowed"><code>-A</code>: set lint allowed</a></h2>
<p>This flag will set which lints should be set to the <a href="lints/levels.html#allow">allow level</a>.</p>
<p><em>Note:</em> The order of these lint level arguments is taken into account, see <a href="lints/levels.html#via-compiler-flag">lint level via compiler flag</a> for more information.</p>
<p><a id="option-d-deny"></a></p>
<h2 id="-d-set-lint-denied"><a class="header" href="#-d-set-lint-denied"><code>-D</code>: set lint denied</a></h2>
<p>This flag will set which lints should be set to the <a href="lints/levels.html#deny">deny level</a>.</p>
<p><em>Note:</em> The order of these lint level arguments is taken into account, see <a href="lints/levels.html#via-compiler-flag">lint level via compiler flag</a> for more information.</p>
<p><a id="option-f-forbid"></a></p>
<h2 id="-f-set-lint-forbidden"><a class="header" href="#-f-set-lint-forbidden"><code>-F</code>: set lint forbidden</a></h2>
<p>This flag will set which lints should be set to the <a href="lints/levels.html#forbid">forbid level</a>.</p>
<p><em>Note:</em> The order of these lint level arguments is taken into account, see <a href="lints/levels.html#via-compiler-flag">lint level via compiler flag</a> for more information.</p>
<p><a id="option-z-unstable"></a></p>
<h2 id="-z-set-unstable-options"><a class="header" href="#-z-set-unstable-options"><code>-Z</code>: set unstable options</a></h2>
<p>This flag will allow you to set unstable options of rustc. In order to set multiple options,
the -Z flag can be used multiple times. For example: <code>rustc -Z verbose -Z time</code>.
Specifying options with -Z is only available on nightly. To view all available options
run: <code>rustc -Z help</code>.</p>
<p><a id="option-cap-lints"></a></p>
<h2 id="--cap-lints-set-the-most-restrictive-lint-level"><a class="header" href="#--cap-lints-set-the-most-restrictive-lint-level"><code>--cap-lints</code>: set the most restrictive lint level</a></h2>
<p>This flag lets you 'cap' lints, for more, <a href="lints/levels.html#capping-lints">see here</a>.</p>
<p><a id="option-codegen"></a></p>
<h2 id="-c--codegen-code-generation-options"><a class="header" href="#-c--codegen-code-generation-options"><code>-C</code>/<code>--codegen</code>: code generation options</a></h2>
<p>This flag will allow you to set <a href="codegen-options/index.html">codegen options</a>.</p>
<p><a id="option-version"></a></p>
<h2 id="-v--version-print-a-version"><a class="header" href="#-v--version-print-a-version"><code>-V</code>/<code>--version</code>: print a version</a></h2>
<p>This flag will print out <code>rustc</code>'s version.</p>
<p><a id="option-verbose"></a></p>
<h2 id="-v--verbose-use-verbose-output"><a class="header" href="#-v--verbose-use-verbose-output"><code>-v</code>/<code>--verbose</code>: use verbose output</a></h2>
<p>This flag, when combined with other flags, makes them produce extra output.</p>
<p><a id="option-extern"></a></p>
<h2 id="--extern-specify-where-an-external-library-is-located"><a class="header" href="#--extern-specify-where-an-external-library-is-located"><code>--extern</code>: specify where an external library is located</a></h2>
<p>This flag allows you to pass the name and location for an external crate of a
direct dependency. Indirect dependencies (dependencies of dependencies) are
located using the <a href="command-line-arguments.html#option-l-search-path"><code>-L</code> flag</a>. The given crate name is
added to the <a href="../reference/names/preludes.html#extern-prelude">extern prelude</a>, similar to specifying <code>extern crate</code> within the
root module. The given crate name does not need to match the name
the library was built with.</p>
<p>Specifying <code>--extern</code> has one behavior difference from <code>extern crate</code>:
<code>--extern</code> merely makes the crate a <em>candidate</em> for being linked; it does not
actually link it unless it's actively used. In rare occasions you may wish
to ensure a crate is linked even if you don't actively use it from your
code: for example, if it changes the global allocator or if it contains
<code>#[no_mangle]</code> symbols for use by other programming languages. In such
cases you'll need to use <code>extern crate</code>.</p>
<p>This flag may be specified multiple times. This flag takes an argument with
either of the following formats:</p>
<ul>
<li><code>CRATENAME=PATH</code> — Indicates the given crate is found at the given path.</li>
<li><code>CRATENAME</code> — Indicates the given crate may be found in the search path,
such as within the sysroot or via the <code>-L</code> flag.</li>
</ul>
<p>The same crate name may be specified multiple times for different crate types.
If both an <code>rlib</code> and <code>dylib</code> are found, an internal algorithm is used to
decide which to use for linking. The <a href="codegen-options/index.html#prefer-dynamic"><code>-C prefer-dynamic</code>
flag</a> may be used to influence which is used.</p>
<p>If the same crate name is specified with and without a path, the one with the
path is used and the pathless flag has no effect.</p>
<p><a id="option-sysroot"></a></p>
<h2 id="--sysroot-override-the-system-root"><a class="header" href="#--sysroot-override-the-system-root"><code>--sysroot</code>: Override the system root</a></h2>
<p>The &quot;sysroot&quot; is where <code>rustc</code> looks for the crates that come with the Rust
distribution; this flag allows that to be overridden.</p>
<p><a id="option-error-format"></a></p>
<h2 id="--error-format-control-how-errors-are-produced"><a class="header" href="#--error-format-control-how-errors-are-produced"><code>--error-format</code>: control how errors are produced</a></h2>
<p>This flag lets you control the format of messages. Messages are printed to
stderr. The valid options are:</p>
<ul>
<li><code>human</code> — Human-readable output. This is the default.</li>
<li><code>json</code> — Structured JSON output. See <a href="json.html">the JSON chapter</a> for more detail.</li>
<li><code>short</code> — Short, one-line messages.</li>
</ul>
<p><a id="option-color"></a></p>
<h2 id="--color-configure-coloring-of-output"><a class="header" href="#--color-configure-coloring-of-output"><code>--color</code>: configure coloring of output</a></h2>
<p>This flag lets you control color settings of the output. The valid options
are:</p>
<ul>
<li><code>auto</code> — Use colors if output goes to a tty. This is the default.</li>
<li><code>always</code> — Always use colors.</li>
<li><code>never</code> — Never colorize output.</li>
</ul>
<p><a id="option-remap-path-prefix"></a></p>
<h2 id="--remap-path-prefix-remap-source-names-in-output"><a class="header" href="#--remap-path-prefix-remap-source-names-in-output"><code>--remap-path-prefix</code>: remap source names in output</a></h2>
<p>Remap source path prefixes in all output, including compiler diagnostics,
debug information, macro expansions, etc. It takes a value of the form
<code>FROM=TO</code> where a path prefix equal to <code>FROM</code> is rewritten to the value <code>TO</code>.
The <code>FROM</code> may itself contain an <code>=</code> symbol, but the <code>TO</code> value may not. This
flag may be specified multiple times.</p>
<p>This is useful for normalizing build products, for example by removing the
current directory out of pathnames emitted into the object files. The
replacement is purely textual, with no consideration of the current system's
pathname syntax. For example <code>--remap-path-prefix foo=bar</code> will match
<code>foo/lib.rs</code> but not <code>./foo/lib.rs</code>.</p>
<p><a id="option-json"></a></p>
<h2 id="--json-configure-json-messages-printed-by-the-compiler"><a class="header" href="#--json-configure-json-messages-printed-by-the-compiler"><code>--json</code>: configure json messages printed by the compiler</a></h2>
<p>When the <a href="command-line-arguments.html#option-error-format"><code>--error-format=json</code> option</a> is passed to
rustc then all of the compiler's diagnostic output will be emitted in the form
of JSON blobs. The <code>--json</code> argument can be used in conjunction with
<code>--error-format=json</code> to configure what the JSON blobs contain as well as
which ones are emitted.</p>
<p>With <code>--error-format=json</code> the compiler will always emit any compiler errors as
a JSON blob, but the following options are also available to the <code>--json</code> flag
to customize the output:</p>
<ul>
<li>
<p><code>diagnostic-short</code> - json blobs for diagnostic messages should use the &quot;short&quot;
rendering instead of the normal &quot;human&quot; default. This means that the output of
<code>--error-format=short</code> will be embedded into the JSON diagnostics instead of
the default <code>--error-format=human</code>.</p>
</li>
<li>
<p><code>diagnostic-rendered-ansi</code> - by default JSON blobs in their <code>rendered</code> field
will contain a plain text rendering of the diagnostic. This option instead
indicates that the diagnostic should have embedded ANSI color codes intended
to be used to colorize the message in the manner rustc typically already does
for terminal outputs. Note that this is usefully combined with crates like
<a href="https://crates.io/crates/fwdansi"><code>fwdansi</code></a> to translate these ANSI codes
on Windows to console commands or
<a href="https://crates.io/crates/strip-ansi-escapes"><code>strip-ansi-escapes</code></a> if you'd
like to optionally remove the ansi colors afterwards.</p>
</li>
<li>
<p><code>artifacts</code> - this instructs rustc to emit a JSON blob for each artifact that
is emitted. An artifact corresponds to a request from the <a href="command-line-arguments.html#option-emit"><code>--emit</code> CLI
argument</a>, and as soon as the artifact is available on the
filesystem a notification will be emitted.</p>
</li>
</ul>
<p>Note that it is invalid to combine the <code>--json</code> argument with the
<a href="command-line-arguments.html#option-color"><code>--color</code></a> argument, and it is required to combine <code>--json</code>
with <code>--error-format=json</code>.</p>
<p>See <a href="json.html">the JSON chapter</a> for more detail.</p>
<p><a id="at-path"></a></p>
<h2 id="path-load-command-line-flags-from-a-path"><a class="header" href="#path-load-command-line-flags-from-a-path"><code>@path</code>: load command-line flags from a path</a></h2>
<p>If you specify <code>@path</code> on the command-line, then it will open <code>path</code> and read
command line options from it. These options are one per line; a blank line indicates
an empty option. The file can use Unix or Windows style line endings, and must be
encoded as UTF-8.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lints"><a class="header" href="#lints">Lints</a></h1>
<p>In software, a &quot;lint&quot; is a tool used to help improve your source code. The
Rust compiler contains a number of lints, and when it compiles your code, it will
also run the lints. These lints may produce a warning, an error, or nothing at all,
depending on how you've configured things.</p>
<p>Here's a small example:</p>
<pre><code class="language-bash">$ cat main.rs
fn main() {
    let x = 5;
}
$ rustc main.rs
warning: unused variable: `x`
 --&gt; main.rs:2:9
  |
2 |     let x = 5;
  |         ^
  |
  = note: `#[warn(unused_variables)]` on by default
  = note: to avoid this warning, consider using `_x` instead
</code></pre>
<p>This is the <code>unused_variables</code> lint, and it tells you that you've introduced
a variable that you don't use in your code. That's not <em>wrong</em>, so it's not
an error, but it might be a bug, so you get a warning.</p>
<h2 id="future-incompatible-lints"><a class="header" href="#future-incompatible-lints">Future-incompatible lints</a></h2>
<p>Sometimes the compiler needs to be changed to fix an issue that can cause
existing code to stop compiling. &quot;Future-incompatible&quot; lints are issued in
these cases to give users of Rust a smooth transition to the new behavior.
Initially, the compiler will continue to accept the problematic code and issue
a warning. The warning has a description of the problem, a notice that this
will become an error in the future, and a link to a tracking issue that
provides detailed information and an opportunity for feedback. This gives
users some time to fix the code to accommodate the change. After some time,
the warning may become an error.</p>
<p>The following is an example of what a future-incompatible looks like:</p>
<pre><code class="language-text">warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)
  --&gt; lint_example.rs:11:13
   |
11 |     let y = &amp;x.data.0;
   |             ^^^^^^^^^
   |
   = note: `#[warn(safe_packed_borrows)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #46043 &lt;https://github.com/rust-lang/rust/issues/46043&gt;
   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior
</code></pre>
<p>For more information about the process and policy of future-incompatible
changes, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/1589-rustc-bug-fix-procedure.md">RFC 1589</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lint-levels"><a class="header" href="#lint-levels">Lint levels</a></h1>
<p>In <code>rustc</code>, lints are divided into five <em>levels</em>:</p>
<ol>
<li>allow</li>
<li>warn</li>
<li>force-warn</li>
<li>deny</li>
<li>forbid</li>
</ol>
<p>Each lint has a default level (explained in the lint listing later in this
chapter), and the compiler has a default warning level. First, let's explain
what these levels mean, and then we'll talk about configuration.</p>
<h2 id="allow"><a class="header" href="#allow">allow</a></h2>
<p>These lints exist, but by default, do nothing. For example, consider this
source:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>Compiling this file produces no warnings:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib
$
</code></pre>
<p>But this code violates the <code>missing_docs</code> lint.</p>
<p>These lints exist mostly to be manually turned on via configuration, as we'll
talk about later in this section.</p>
<h2 id="warn"><a class="header" href="#warn">warn</a></h2>
<p>The 'warn' lint level will produce a warning if you violate the lint. For example,
this code runs afoul of the <code>unused_variables</code> lint:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn foo() {
    let x = 5;
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce this warning:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib
warning: unused variable: `x`
 --&gt; lib.rs:2:9
  |
2 |     let x = 5;
  |         ^
  |
  = note: `#[warn(unused_variables)]` on by default
  = note: to avoid this warning, consider using `_x` instead
</code></pre>
<h2 id="force-warn"><a class="header" href="#force-warn">force-warn</a></h2>
<p>'force-warn' is a special lint level. It's the same as 'warn' in that a lint
at this level will produce a warning, but unlike the 'warn' level, the
'force-warn' level cannot be overridden. If a lint is set to 'force-warn', it
is guaranteed to warn: no more, no less. This is true even if the overall lint
level is capped via cap-lints.</p>
<h2 id="deny"><a class="header" href="#deny">deny</a></h2>
<p>A 'deny' lint produces an error if you violate it. For example, this code
runs into the <code>exceeding_bitshifts</code> lint.</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    100u8 &lt;&lt; 10;
}
</code></pre></pre>
<pre><code class="language-bash">$ rustc main.rs
error: bitshift exceeds the type's number of bits
 --&gt; main.rs:2:13
  |
2 |     100u8 &lt;&lt; 10;
  |     ^^^^^^^^^^^
  |
  = note: `#[deny(exceeding_bitshifts)]` on by default
</code></pre>
<p>What's the difference between an error from a lint and a regular old error?
Lints are configurable via levels, so in a similar way to 'allow' lints,
warnings that are 'deny' by default let you allow them. Similarly, you may
wish to set up a lint that is <code>warn</code> by default to produce an error instead.
This lint level gives you that.</p>
<h2 id="forbid"><a class="header" href="#forbid">forbid</a></h2>
<p>'forbid' is a special lint level that fills the same role for 'deny' that
'force-warn' does for 'warn'. It's the same as 'deny' in that a lint at this
level will produce an error, but unlike the 'deny' level, the 'forbid' level
can not be overridden to be anything lower than an error.  However, lint
levels may still be capped with <code>--cap-lints</code> (see below) so <code>rustc --cap- lints warn</code> will make lints set to 'forbid' just
warn.</p>
<h2 id="configuring-warning-levels"><a class="header" href="#configuring-warning-levels">Configuring warning levels</a></h2>
<p>Remember our <code>missing_docs</code> example from the 'allow' lint level?</p>
<pre><code class="language-bash">$ cat lib.rs
pub fn foo() {}
$ rustc lib.rs --crate-type=lib
$
</code></pre>
<p>We can configure this lint to operate at a higher level, both with
compiler flags, as well as with an attribute in the source code.</p>
<p>You can also &quot;cap&quot; lints so that the compiler can choose to ignore
certain lint levels. We'll talk about that last.</p>
<h3 id="via-compiler-flag"><a class="header" href="#via-compiler-flag">Via compiler flag</a></h3>
<p>The <code>-A</code>, <code>-W</code>, <code>--force-warn</code> <code>-D</code>, and <code>-F</code> flags let you turn one or more lints
into allowed, warning, force-warn, deny, or forbid levels, like this:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -W missing-docs
warning: missing documentation for crate
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^
  |
  = note: requested on the command line with `-W missing-docs`

warning: missing documentation for a function
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^
</code></pre>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D missing-docs
error: missing documentation for crate
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^
  |
  = note: requested on the command line with `-D missing-docs`

error: missing documentation for a function
 --&gt; lib.rs:1:1
  |
1 | pub fn foo() {}
  | ^^^^^^^^^^^^

error: aborting due to 2 previous errors
</code></pre>
<p>You can also pass each flag more than once for changing multiple lints:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D missing-docs -D unused-variables
</code></pre>
<p>And of course, you can mix these five flags together:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D missing-docs -A unused-variables
</code></pre>
<p>The order of these command line arguments is taken into account. The following allows the <code>unused-variables</code> lint, because it is the last argument for that lint:</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D unused-variables -A unused-variables
</code></pre>
<p>You can make use of this behavior by overriding the level of one specific lint out of a group of lints. The following example denies all the lints in the <code>unused</code> group, but explicitly allows the <code>unused-variables</code> lint in that group (forbid still trumps everything regardless of ordering):</p>
<pre><code class="language-bash">$ rustc lib.rs --crate-type=lib -D unused -A unused-variables
</code></pre>
<p>Since <code>force-warn</code> and <code>forbid</code> cannot be overridden, setting
one of them will prevent any later level for the same lint from
taking effect.</p>
<h3 id="via-an-attribute"><a class="header" href="#via-an-attribute">Via an attribute</a></h3>
<p>You can also modify the lint level with a crate-wide attribute:</p>
<pre><code class="language-bash">$ cat lib.rs
#![warn(missing_docs)]

pub fn foo() {}
$ rustc lib.rs --crate-type=lib
warning: missing documentation for crate
 --&gt; lib.rs:1:1
  |
1 | / #![warn(missing_docs)]
2 | |
3 | | pub fn foo() {}
  | |_______________^
  |
note: lint level defined here
 --&gt; lib.rs:1:9
  |
1 | #![warn(missing_docs)]
  |         ^^^^^^^^^^^^

warning: missing documentation for a function
 --&gt; lib.rs:3:1
  |
3 | pub fn foo() {}
  | ^^^^^^^^^^^^
</code></pre>
<p><code>warn</code>, <code>allow</code>, <code>deny</code>, and <code>forbid</code> all work this way. There is
no way to set a lint to <code>force-warn</code> using an attribute.</p>
<p>You can also pass in multiple lints per attribute:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(missing_docs, unused_variables)]

<span class="boring">fn main() {
</span>pub fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>And use multiple attributes together:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(missing_docs)]
#![deny(unused_variables)]

<span class="boring">fn main() {
</span>pub fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<h3 id="capping-lints"><a class="header" href="#capping-lints">Capping lints</a></h3>
<p><code>rustc</code> supports a flag, <code>--cap-lints LEVEL</code> that sets the &quot;lint cap level.&quot;
This is the maximum level for all lints. So for example, if we take our
code sample from the &quot;deny&quot; lint level above:</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    100u8 &lt;&lt; 10;
}
</code></pre></pre>
<p>And we compile it, capping lints to warn:</p>
<pre><code class="language-bash">$ rustc lib.rs --cap-lints warn
warning: bitshift exceeds the type's number of bits
 --&gt; lib.rs:2:5
  |
2 |     100u8 &lt;&lt; 10;
  |     ^^^^^^^^^^^
  |
  = note: `#[warn(exceeding_bitshifts)]` on by default

warning: this expression will panic at run-time
 --&gt; lib.rs:2:5
  |
2 |     100u8 &lt;&lt; 10;
  |     ^^^^^^^^^^^ attempt to shift left with overflow
</code></pre>
<p>It now only warns, rather than errors. We can go further and allow all lints:</p>
<pre><code class="language-bash">$ rustc lib.rs --cap-lints allow
$
</code></pre>
<p>This feature is used heavily by Cargo; it will pass <code>--cap-lints allow</code> when
compiling your dependencies, so that if they have any warnings, they do not
pollute the output of your build.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lint-groups"><a class="header" href="#lint-groups">Lint Groups</a></h1>
<p><code>rustc</code> has the concept of a &quot;lint group&quot;, where you can toggle several warnings
through one name.</p>
<p>For example, the <code>nonstandard-style</code> lint sets <code>non-camel-case-types</code>,
<code>non-snake-case</code>, and <code>non-upper-case-globals</code> all at once. So these are
equivalent:</p>
<pre><code class="language-bash">$ rustc -D nonstandard-style
$ rustc -D non-camel-case-types -D non-snake-case -D non-upper-case-globals
</code></pre>
<p>Here's a list of each lint group, and the lints that they are made up of:</p>
<table><thead><tr><th>Group</th><th>Description</th><th>Lints</th></tr></thead><tbody>
<tr><td>warnings</td><td>All lints that are set to issue warnings</td><td>See <a href="lints/listing/warn-by-default.html">warn-by-default</a> for the default set of warnings</td></tr>
<tr><td>future-incompatible</td><td>Lints that detect code that has future-compatibility problems</td><td><a href="lints/listing/deny-by-default.html#ambiguous-associated-items">ambiguous-associated-items</a>, <a href="lints/listing/warn-by-default.html#cenum-impl-drop-cast">cenum-impl-drop-cast</a>, <a href="lints/listing/warn-by-default.html#coherence-leak-check">coherence-leak-check</a>, <a href="lints/listing/deny-by-default.html#conflicting-repr-hints">conflicting-repr-hints</a>, <a href="lints/listing/deny-by-default.html#const-err">const-err</a>, <a href="lints/listing/warn-by-default.html#const-evaluatable-unchecked">const-evaluatable-unchecked</a>, <a href="lints/listing/warn-by-default.html#deprecated-cfg-attr-crate-type-name">deprecated-cfg-attr-crate-type-name</a>, <a href="lints/listing/warn-by-default.html#deref-into-dyn-supertrait">deref-into-dyn-supertrait</a>, <a href="lints/listing/warn-by-default.html#forbidden-lint-groups">forbidden-lint-groups</a>, <a href="lints/listing/deny-by-default.html#ill-formed-attribute-input">ill-formed-attribute-input</a>, <a href="lints/listing/warn-by-default.html#illegal-floating-point-literal-pattern">illegal-floating-point-literal-pattern</a>, <a href="lints/listing/warn-by-default.html#indirect-structural-match">indirect-structural-match</a>, <a href="lints/listing/warn-by-default.html#invalid-doc-attributes">invalid-doc-attributes</a>, <a href="lints/listing/deny-by-default.html#invalid-type-param-default">invalid-type-param-default</a>, <a href="lints/listing/warn-by-default.html#late-bound-lifetime-arguments">late-bound-lifetime-arguments</a>, <a href="lints/listing/warn-by-default.html#legacy-derive-helpers">legacy-derive-helpers</a>, <a href="lints/listing/deny-by-default.html#macro-expanded-macro-exports-accessed-by-absolute-paths">macro-expanded-macro-exports-accessed-by-absolute-paths</a>, <a href="lints/listing/deny-by-default.html#missing-fragment-specifier">missing-fragment-specifier</a>, <a href="lints/listing/warn-by-default.html#mutable-borrow-reservation-conflict">mutable-borrow-reservation-conflict</a>, <a href="lints/listing/warn-by-default.html#nontrivial-structural-match">nontrivial-structural-match</a>, <a href="lints/listing/deny-by-default.html#order-dependent-trait-objects">order-dependent-trait-objects</a>, <a href="lints/listing/deny-by-default.html#patterns-in-fns-without-body">patterns-in-fns-without-body</a>, <a href="lints/listing/allowed-by-default.html#pointer-structural-match">pointer-structural-match</a>, <a href="lints/listing/warn-by-default.html#private-in-public">private-in-public</a>, <a href="lints/listing/deny-by-default.html#proc-macro-back-compat">proc-macro-back-compat</a>, <a href="lints/listing/deny-by-default.html#proc-macro-derive-resolution-fallback">proc-macro-derive-resolution-fallback</a>, <a href="lints/listing/deny-by-default.html#pub-use-of-private-extern-crate">pub-use-of-private-extern-crate</a>, <a href="lints/listing/warn-by-default.html#semicolon-in-expressions-from-macros">semicolon-in-expressions-from-macros</a>, <a href="lints/listing/deny-by-default.html#soft-unstable">soft-unstable</a>, <a href="lints/listing/warn-by-default.html#unaligned-references">unaligned-references</a>, <a href="lints/listing/warn-by-default.html#uninhabited-static">uninhabited-static</a>, <a href="lints/listing/warn-by-default.html#unstable-name-collisions">unstable-name-collisions</a>, <a href="lints/listing/warn-by-default.html#unsupported-calling-conventions">unsupported-calling-conventions</a>, <a href="lints/listing/warn-by-default.html#unsupported-naked-functions">unsupported-naked-functions</a>, <a href="lints/listing/warn-by-default.html#where-clauses-object-safety">where-clauses-object-safety</a></td></tr>
<tr><td>nonstandard-style</td><td>Violation of standard naming conventions</td><td><a href="lints/listing/warn-by-default.html#non-camel-case-types">non-camel-case-types</a>, <a href="lints/listing/warn-by-default.html#non-snake-case">non-snake-case</a>, <a href="lints/listing/warn-by-default.html#non-upper-case-globals">non-upper-case-globals</a></td></tr>
<tr><td>rust-2018-compatibility</td><td>Lints used to transition code from the 2015 edition to 2018</td><td><a href="lints/listing/allowed-by-default.html#absolute-paths-not-starting-with-crate">absolute-paths-not-starting-with-crate</a>, <a href="lints/listing/warn-by-default.html#anonymous-parameters">anonymous-parameters</a>, <a href="lints/listing/allowed-by-default.html#keyword-idents">keyword-idents</a>, <a href="lints/listing/warn-by-default.html#tyvar-behind-raw-pointer">tyvar-behind-raw-pointer</a></td></tr>
<tr><td>rust-2018-idioms</td><td>Lints to nudge you toward idiomatic features of Rust 2018</td><td><a href="lints/listing/warn-by-default.html#bare-trait-objects">bare-trait-objects</a>, <a href="lints/listing/allowed-by-default.html#elided-lifetimes-in-paths">elided-lifetimes-in-paths</a>, <a href="lints/listing/warn-by-default.html#ellipsis-inclusive-range-patterns">ellipsis-inclusive-range-patterns</a>, <a href="lints/listing/allowed-by-default.html#explicit-outlives-requirements">explicit-outlives-requirements</a>, <a href="lints/listing/allowed-by-default.html#unused-extern-crates">unused-extern-crates</a></td></tr>
<tr><td>rust-2021-compatibility</td><td>Lints used to transition code from the 2018 edition to 2021</td><td><a href="lints/listing/warn-by-default.html#array-into-iter">array-into-iter</a>, <a href="lints/listing/warn-by-default.html#bare-trait-objects">bare-trait-objects</a>, <a href="lints/listing/warn-by-default.html#ellipsis-inclusive-range-patterns">ellipsis-inclusive-range-patterns</a>, <a href="lints/listing/warn-by-default.html#non-fmt-panics">non-fmt-panics</a>, <a href="lints/listing/allowed-by-default.html#rust-2021-incompatible-closure-captures">rust-2021-incompatible-closure-captures</a>, <a href="lints/listing/allowed-by-default.html#rust-2021-incompatible-or-patterns">rust-2021-incompatible-or-patterns</a>, <a href="lints/listing/allowed-by-default.html#rust-2021-prefixes-incompatible-syntax">rust-2021-prefixes-incompatible-syntax</a>, <a href="lints/listing/allowed-by-default.html#rust-2021-prelude-collisions">rust-2021-prelude-collisions</a></td></tr>
<tr><td>unused</td><td>Lints that detect things being declared but not used, or excess syntax</td><td><a href="lints/listing/warn-by-default.html#dead-code">dead-code</a>, <a href="lints/listing/warn-by-default.html#path-statements">path-statements</a>, <a href="lints/listing/warn-by-default.html#redundant-semicolons">redundant-semicolons</a>, <a href="lints/listing/warn-by-default.html#unreachable-code">unreachable-code</a>, <a href="lints/listing/warn-by-default.html#unreachable-patterns">unreachable-patterns</a>, <a href="lints/listing/warn-by-default.html#unused-allocation">unused-allocation</a>, <a href="lints/listing/warn-by-default.html#unused-assignments">unused-assignments</a>, <a href="lints/listing/warn-by-default.html#unused-attributes">unused-attributes</a>, <a href="lints/listing/warn-by-default.html#unused-braces">unused-braces</a>, <a href="lints/listing/warn-by-default.html#unused-doc-comments">unused-doc-comments</a>, <a href="lints/listing/allowed-by-default.html#unused-extern-crates">unused-extern-crates</a>, <a href="lints/listing/warn-by-default.html#unused-features">unused-features</a>, <a href="lints/listing/warn-by-default.html#unused-imports">unused-imports</a>, <a href="lints/listing/warn-by-default.html#unused-labels">unused-labels</a>, <a href="lints/listing/warn-by-default.html#unused-macros">unused-macros</a>, <a href="lints/listing/warn-by-default.html#unused-must-use">unused-must-use</a>, <a href="lints/listing/warn-by-default.html#unused-mut">unused-mut</a>, <a href="lints/listing/warn-by-default.html#unused-parens">unused-parens</a>, <a href="lints/listing/warn-by-default.html#unused-unsafe">unused-unsafe</a>, <a href="lints/listing/warn-by-default.html#unused-variables">unused-variables</a></td></tr>
</tbody></table>
<p>Additionally, there's a <code>bad-style</code> lint group that's a deprecated alias for <code>nonstandard-style</code>.</p>
<p>Finally, you can also see the table above by invoking <code>rustc -W help</code>. This will give you the exact values for the specific
compiler you have installed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lint-listing"><a class="header" href="#lint-listing">Lint listing</a></h1>
<p>This section lists out all of the lints, grouped by their default lint levels.</p>
<p>You can also see this list by running <code>rustc -W help</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="allowed-by-default-lints"><a class="header" href="#allowed-by-default-lints">Allowed-by-default lints</a></h1>
<p>These lints are all set to the 'allow' level by default. As such, they won't show up
unless you set them to a higher lint level with a flag or attribute.</p>
<ul>
<li><a href="lints/listing/allowed-by-default.html#absolute-paths-not-starting-with-crate"><code>absolute_paths_not_starting_with_crate</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#box-pointers"><code>box_pointers</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#elided-lifetimes-in-paths"><code>elided_lifetimes_in_paths</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#explicit-outlives-requirements"><code>explicit_outlives_requirements</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#keyword-idents"><code>keyword_idents</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#macro-use-extern-crate"><code>macro_use_extern_crate</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#meta-variable-misuse"><code>meta_variable_misuse</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#missing-abi"><code>missing_abi</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#missing-copy-implementations"><code>missing_copy_implementations</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#missing-debug-implementations"><code>missing_debug_implementations</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#missing-docs"><code>missing_docs</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#must-not-suspend"><code>must_not_suspend</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#non-ascii-idents"><code>non_ascii_idents</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#non-exhaustive-omitted-patterns"><code>non_exhaustive_omitted_patterns</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#noop-method-call"><code>noop_method_call</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#pointer-structural-match"><code>pointer_structural_match</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#rust-2021-incompatible-closure-captures"><code>rust_2021_incompatible_closure_captures</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#rust-2021-incompatible-or-patterns"><code>rust_2021_incompatible_or_patterns</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#rust-2021-prefixes-incompatible-syntax"><code>rust_2021_prefixes_incompatible_syntax</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#rust-2021-prelude-collisions"><code>rust_2021_prelude_collisions</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#single-use-lifetimes"><code>single_use_lifetimes</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#trivial-casts"><code>trivial_casts</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#trivial-numeric-casts"><code>trivial_numeric_casts</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#unreachable-pub"><code>unreachable_pub</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#unsafe-code"><code>unsafe_code</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn"><code>unsafe_op_in_unsafe_fn</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#unstable-features"><code>unstable_features</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#unused-crate-dependencies"><code>unused_crate_dependencies</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#unused-extern-crates"><code>unused_extern_crates</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#unused-import-braces"><code>unused_import_braces</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#unused-lifetimes"><code>unused_lifetimes</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#unused-qualifications"><code>unused_qualifications</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#unused-results"><code>unused_results</code></a></li>
<li><a href="lints/listing/allowed-by-default.html#variant-size-differences"><code>variant_size_differences</code></a></li>
</ul>
<h2 id="absolute-paths-not-starting-with-crate"><a class="header" href="#absolute-paths-not-starting-with-crate">absolute-paths-not-starting-with-crate</a></h2>
<p>The <code>absolute_paths_not_starting_with_crate</code> lint detects fully
qualified paths that start with a module name instead of <code>crate</code>,
<code>self</code>, or an extern crate name</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2015 compile_fail">#![deny(absolute_paths_not_starting_with_crate)]

mod foo {
    pub fn bar() {}
}

fn main() {
    ::foo::bar();
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: absolute paths must start with `self`, `super`, `crate`, or an external crate name in the 2018 edition
 --&gt; lint_example.rs:8:5
  |
8 |     ::foo::bar();
  |     ^^^^^^^^^^ help: use `crate`: `crate::foo::bar`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(absolute_paths_not_starting_with_crate)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see issue #53130 &lt;https://github.com/rust-lang/rust/issues/53130&gt;

</code></pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking
backwards compatibility. This lint catches code that uses absolute
paths in the style of the 2015 edition. In the 2015 edition, absolute
paths (those starting with <code>::</code>) refer to either the crate root or an
external crate. In the 2018 edition it was changed so that they only
refer to external crates. The path prefix <code>crate::</code> should be used
instead to reference items from the crate root.</p>
<p>If you switch the compiler from the 2015 to 2018 edition without
updating the code, then it will fail to compile if the old style paths
are used. You can manually change the paths to use the <code>crate::</code>
prefix to transition to the 2018 edition.</p>
<p>This lint solves the problem automatically. It is &quot;allow&quot; by default
because the code is perfectly valid in the 2015 edition. The <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag will switch this lint to &quot;warn&quot;
and automatically apply the suggested fix from the compiler. This
provides a completely automated way to update old code to the 2018
edition.</p>
<h2 id="box-pointers"><a class="header" href="#box-pointers">box-pointers</a></h2>
<p>The <code>box_pointers</code> lints use of the Box type.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(box_pointers)]
<span class="boring">fn main() {
</span>struct Foo {
    x: Box&lt;isize&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type uses owned (Box type) pointers: Box&lt;isize&gt;
 --&gt; lint_example.rs:4:5
  |
4 |     x: Box&lt;isize&gt;,
  |     ^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(box_pointers)]
  |         ^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation</a></h3>
<p>This lint is mostly historical, and not particularly useful. <code>Box&lt;T&gt;</code>
used to be built into the language, and the only way to do heap
allocation. Today's Rust can call into other allocators, etc.</p>
<h2 id="elided-lifetimes-in-paths"><a class="header" href="#elided-lifetimes-in-paths">elided-lifetimes-in-paths</a></h2>
<p>The <code>elided_lifetimes_in_paths</code> lint detects the use of hidden
lifetime parameters.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(elided_lifetimes_in_paths)]
<span class="boring">fn main() {
</span>struct Foo&lt;'a&gt; {
    x: &amp;'a u32
}

fn foo(x: &amp;Foo) {
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: hidden lifetime parameters in types are deprecated
 --&gt; lint_example.rs:7:12
  |
7 | fn foo(x: &amp;Foo) {
  |            ^^^ expected named lifetime parameter
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(elided_lifetimes_in_paths)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using the `'_` lifetime
  |
7 | fn foo(x: &amp;Foo&lt;'_&gt;) {
  |            ~~~~~~~

</code></pre>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation</a></h3>
<p>Elided lifetime parameters can make it difficult to see at a glance
that borrowing is occurring. This lint ensures that lifetime
parameters are always explicitly stated, even if it is the <code>'_</code>
<a href="https://doc.rust-lang.org/reference/lifetime-elision.html#lifetime-elision-in-functions">placeholder lifetime</a>.</p>
<p>This lint is &quot;allow&quot; by default because it has some known issues, and
may require a significant transition for old code.</p>
<h2 id="explicit-outlives-requirements"><a class="header" href="#explicit-outlives-requirements">explicit-outlives-requirements</a></h2>
<p>The <code>explicit_outlives_requirements</code> lint detects unnecessary
lifetime bounds that can be inferred.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(unused)]
</span>#![deny(explicit_outlives_requirements)]

struct SharedRef&lt;'a, T&gt;
where
    T: 'a,
{
    data: &amp;'a T,
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: outlives requirements can be inferred
 --&gt; lint_example.rs:5:24
  |
5 |   struct SharedRef&lt;'a, T&gt;
  |  ________________________^
6 | | where
7 | |     T: 'a,
  | |__________^ help: remove this bound
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(explicit_outlives_requirements)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-3"><a class="header" href="#explanation-3">Explanation</a></h3>
<p>If a <code>struct</code> contains a reference, such as <code>&amp;'a T</code>, the compiler
requires that <code>T</code> outlives the lifetime <code>'a</code>. This historically
required writing an explicit lifetime bound to indicate this
requirement. However, this can be overly explicit, causing clutter and
unnecessary complexity. The language was changed to automatically
infer the bound if it is not specified. Specifically, if the struct
contains a reference, directly or indirectly, to <code>T</code> with lifetime
<code>'x</code>, then it will infer that <code>T: 'x</code> is a requirement.</p>
<p>This lint is &quot;allow&quot; by default because it can be noisy for existing
code that already had these requirements. This is a stylistic choice,
as it is still valid to explicitly state the bound. It also has some
false positives that can cause confusion.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2093-infer-outlives.md">RFC 2093</a> for more details.</p>
<h2 id="keyword-idents"><a class="header" href="#keyword-idents">keyword-idents</a></h2>
<p>The <code>keyword_idents</code> lint detects edition keywords being used as an
identifier.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2015 compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(keyword_idents)]
<span class="boring">fn main() {
</span>// edition 2015
fn dyn() {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `dyn` is a keyword in the 2018 edition
 --&gt; lint_example.rs:4:4
  |
4 | fn dyn() {}
  |    ^^^ help: you can use a raw identifier to stay compatible: `r#dyn`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(keyword_idents)]
  |         ^^^^^^^^^^^^^^
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see issue #49716 &lt;https://github.com/rust-lang/rust/issues/49716&gt;

</code></pre>
<h3 id="explanation-4"><a class="header" href="#explanation-4">Explanation</a></h3>
<p>Rust <a href="https://doc.rust-lang.org/edition-guide/">editions</a> allow the language to evolve without breaking
backwards compatibility. This lint catches code that uses new keywords
that are added to the language that are used as identifiers (such as a
variable name, function name, etc.). If you switch the compiler to a
new edition without updating the code, then it will fail to compile if
you are using a new keyword as an identifier.</p>
<p>You can manually change the identifiers to a non-keyword, or use a
<a href="https://doc.rust-lang.org/reference/identifiers.html">raw identifier</a>, for example <code>r#dyn</code>, to transition to a new edition.</p>
<p>This lint solves the problem automatically. It is &quot;allow&quot; by default
because the code is perfectly valid in older editions. The <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag will switch this lint to &quot;warn&quot;
and automatically apply the suggested fix from the compiler (which is
to use a raw identifier). This provides a completely automated way to
update old code for a new edition.</p>
<h2 id="macro-use-extern-crate"><a class="header" href="#macro-use-extern-crate">macro-use-extern-crate</a></h2>
<p>The <code>macro_use_extern_crate</code> lint detects the use of the
<a href="https://doc.rust-lang.org/reference/macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> attribute</a>.</p>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<pre><code class="language-rust ignore (needs extern crate)">#![deny(macro_use_extern_crate)]

#[macro_use]
extern crate serde_json;

fn main() {
    let _ = json!{{}};
}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: deprecated `#[macro_use]` attribute used to import macros should be replaced at use sites with a `use` item to import the macro instead
 --&gt; src/main.rs:3:1
  |
3 | #[macro_use]
  | ^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; src/main.rs:1:9
  |
1 | #![deny(macro_use_extern_crate)]
  |         ^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<h3 id="explanation-5"><a class="header" href="#explanation-5">Explanation</a></h3>
<p>The <a href="https://doc.rust-lang.org/reference/macros-by-example.html#the-macro_use-attribute"><code>macro_use</code> attribute</a> on an <a href="https://doc.rust-lang.org/reference/items/extern-crates.html"><code>extern crate</code></a> item causes
macros in that external crate to be brought into the prelude of the
crate, making the macros in scope everywhere. As part of the efforts
to simplify handling of dependencies in the <a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html#no-more-extern-crate">2018 edition</a>, the use of
<code>extern crate</code> is being phased out. To bring macros from extern crates
into scope, it is recommended to use a <a href="https://doc.rust-lang.org/reference/items/use-declarations.html"><code>use</code> import</a>.</p>
<p>This lint is &quot;allow&quot; by default because this is a stylistic choice
that has not been settled, see <a href="https://github.com/rust-lang/rust/issues/52043">issue #52043</a> for more information.</p>
<h2 id="meta-variable-misuse"><a class="header" href="#meta-variable-misuse">meta-variable-misuse</a></h2>
<p>The <code>meta_variable_misuse</code> lint detects possible meta-variable misuse
in macro definitions.</p>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(meta_variable_misuse)]

macro_rules! foo {
    () =&gt; {};
    ($( $i:ident = $($j:ident),+ );*) =&gt; { $( $( $i = $k; )+ )* };
}

fn main() {
    foo!();
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unknown macro variable `k`
 --&gt; lint_example.rs:5:55
  |
5 |     ($( $i:ident = $($j:ident),+ );*) =&gt; { $( $( $i = $k; )+ )* };
  |                                                       ^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(meta_variable_misuse)]
  |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-6"><a class="header" href="#explanation-6">Explanation</a></h3>
<p>There are quite a few different ways a <a href="https://doc.rust-lang.org/reference/macros-by-example.html"><code>macro_rules</code></a> macro can be
improperly defined. Many of these errors were previously only detected
when the macro was expanded or not at all. This lint is an attempt to
catch some of these problems when the macro is <em>defined</em>.</p>
<p>This lint is &quot;allow&quot; by default because it may have false positives
and other issues. See <a href="https://github.com/rust-lang/rust/issues/61053">issue #61053</a> for more details.</p>
<h2 id="missing-abi"><a class="header" href="#missing-abi">missing-abi</a></h2>
<p>The <code>missing_abi</code> lint detects cases where the ABI is omitted from
extern declarations.</p>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(missing_abi)]

<span class="boring">fn main() {
</span>extern fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: extern declarations without an explicit ABI are deprecated
 --&gt; lint_example.rs:4:1
  |
4 | extern fn foo() {}
  | ^^^^^^^^^^^^^^^ ABI should be specified here
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_abi)]
  |         ^^^^^^^^^^^
  = help: the default ABI is C

</code></pre>
<h3 id="explanation-7"><a class="header" href="#explanation-7">Explanation</a></h3>
<p>Historically, Rust implicitly selected C as the ABI for extern
declarations. We expect to add new ABIs, like <code>C-unwind</code>, in the future,
though this has not yet happened, and especially with their addition
seeing the ABI easily will make code review easier.</p>
<h2 id="missing-copy-implementations"><a class="header" href="#missing-copy-implementations">missing-copy-implementations</a></h2>
<p>The <code>missing_copy_implementations</code> lint detects potentially-forgotten
implementations of <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>.</p>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(missing_copy_implementations)]
pub struct Foo {
    pub field: i32
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type could implement `Copy`; consider adding `impl Copy`
 --&gt; lint_example.rs:2:1
  |
2 | / pub struct Foo {
3 | |     pub field: i32
4 | | }
  | |_^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_copy_implementations)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-8"><a class="header" href="#explanation-8">Explanation</a></h3>
<p>Historically (before 1.0), types were automatically marked as <code>Copy</code>
if possible. This was changed so that it required an explicit opt-in
by implementing the <code>Copy</code> trait. As part of this change, a lint was
added to alert if a copyable type was not marked <code>Copy</code>.</p>
<p>This lint is &quot;allow&quot; by default because this code isn't bad; it is
common to write newtypes like this specifically so that a <code>Copy</code> type
is no longer <code>Copy</code>. <code>Copy</code> types can result in unintended copies of
large data which can impact performance.</p>
<h2 id="missing-debug-implementations"><a class="header" href="#missing-debug-implementations">missing-debug-implementations</a></h2>
<p>The <code>missing_debug_implementations</code> lint detects missing
implementations of <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>fmt::Debug</code></a>.</p>
<h3 id="example-9"><a class="header" href="#example-9">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(missing_debug_implementations)]
pub struct Foo;
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: type does not implement `Debug`; consider adding `#[derive(Debug)]` or a manual implementation
 --&gt; lint_example.rs:2:1
  |
2 | pub struct Foo;
  | ^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_debug_implementations)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-9"><a class="header" href="#explanation-9">Explanation</a></h3>
<p>Having a <code>Debug</code> implementation on all types can assist with
debugging, as it provides a convenient way to format and display a
value. Using the <code>#[derive(Debug)]</code> attribute will automatically
generate a typical implementation, or a custom implementation can be
added by manually implementing the <code>Debug</code> trait.</p>
<p>This lint is &quot;allow&quot; by default because adding <code>Debug</code> to all types can
have a negative impact on compile time and code size. It also requires
boilerplate to be added to every type, which can be an impediment.</p>
<h2 id="missing-docs"><a class="header" href="#missing-docs">missing-docs</a></h2>
<p>The <code>missing_docs</code> lint detects missing documentation for public items.</p>
<h3 id="example-10"><a class="header" href="#example-10">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(missing_docs)]
<span class="boring">fn main() {
</span>pub fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: missing documentation for the crate
 --&gt; lint_example.rs:1:1
  |
1 | / #![deny(missing_docs)]
2 | | fn main() {
3 | | pub fn foo() {}
4 | | }
  | |_^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(missing_docs)]
  |         ^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-10"><a class="header" href="#explanation-10">Explanation</a></h3>
<p>This lint is intended to ensure that a library is well-documented.
Items without documentation can be difficult for users to understand
how to use properly.</p>
<p>This lint is &quot;allow&quot; by default because it can be noisy, and not all
projects may want to enforce everything to be documented.</p>
<h2 id="must-not-suspend"><a class="header" href="#must-not-suspend">must-not-suspend</a></h2>
<p>The <code>must_not_suspend</code> lint guards against values that shouldn't be held across suspend points
(<code>.await</code>)</p>
<h3 id="example-11"><a class="header" href="#example-11">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(must_not_suspend)]
#![warn(must_not_suspend)]

<span class="boring">fn main() {
</span>#[must_not_suspend]
struct SyncThing {}

async fn yield_now() {}

pub async fn uhoh() {
    let guard = SyncThing {};
    yield_now().await;
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `SyncThing` held across a suspend point, but should not be
  --&gt; lint_example.rs:11:9
   |
11 |     let guard = SyncThing {};
   |         ^^^^^
12 |     yield_now().await;
   |                ------ the value is held across this suspend point
   |
note: the lint level is defined here
  --&gt; lint_example.rs:2:9
   |
2  | #![warn(must_not_suspend)]
   |         ^^^^^^^^^^^^^^^^
help: consider using a block (`{ ... }`) to shrink the value's scope, ending before the suspend point
  --&gt; lint_example.rs:11:9
   |
11 |     let guard = SyncThing {};
   |         ^^^^^

</code></pre>
<h3 id="explanation-11"><a class="header" href="#explanation-11">Explanation</a></h3>
<p>The <code>must_not_suspend</code> lint detects values that are marked with the <code>#[must_not_suspend]</code>
attribute being held across suspend points. A &quot;suspend&quot; point is usually a <code>.await</code> in an async
function.</p>
<p>This attribute can be used to mark values that are semantically incorrect across suspends
(like certain types of timers), values that have async alternatives, and values that
regularly cause problems with the <code>Send</code>-ness of async fn's returned futures (like
<code>MutexGuard</code>'s)</p>
<h2 id="non-ascii-idents"><a class="header" href="#non-ascii-idents">non-ascii-idents</a></h2>
<p>The <code>non_ascii_idents</code> lint detects non-ASCII identifiers.</p>
<h3 id="example-12"><a class="header" href="#example-12">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span>#![deny(non_ascii_idents)]
fn main() {
    let föö = 1;
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: identifier contains non-ASCII characters
 --&gt; lint_example.rs:4:9
  |
4 |     let föö = 1;
  |         ^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![deny(non_ascii_idents)]
  |         ^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-12"><a class="header" href="#explanation-12">Explanation</a></h3>
<p>This lint allows projects that wish to retain the limit of only using
ASCII characters to switch this lint to &quot;forbid&quot; (for example to ease
collaboration or for security reasons).
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2457-non-ascii-idents.md">RFC 2457</a> for more details.</p>
<h2 id="non-exhaustive-omitted-patterns"><a class="header" href="#non-exhaustive-omitted-patterns">non-exhaustive-omitted-patterns</a></h2>
<p>The <code>non_exhaustive_omitted_patterns</code> lint detects when a wildcard (<code>_</code> or <code>..</code>) in a
pattern for a <code>#[non_exhaustive]</code> struct or enum is reachable.</p>
<h3 id="example-13"><a class="header" href="#example-13">Example</a></h3>
<pre><code class="language-rust ignore (needs separate crate)">// crate A
#[non_exhaustive]
pub enum Bar {
    A,
    B, // added variant in non breaking change
}

// in crate B
#![feature(non_exhaustive_omitted_patterns_lint)]

match Bar::A {
    Bar::A =&gt; {},
    #[warn(non_exhaustive_omitted_patterns)]
    _ =&gt; {},
}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: reachable patterns not covered of non exhaustive enum
   --&gt; $DIR/reachable-patterns.rs:70:9
   |
LL |         _ =&gt; {}
   |         ^ pattern `B` not covered
   |
 note: the lint level is defined here
  --&gt; $DIR/reachable-patterns.rs:69:16
   |
LL |         #[warn(non_exhaustive_omitted_patterns)]
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: ensure that all possible cases are being handled by adding the suggested match arms
   = note: the matched value is of type `Bar` and the `non_exhaustive_omitted_patterns` attribute was found
</code></pre>
<h3 id="explanation-13"><a class="header" href="#explanation-13">Explanation</a></h3>
<p>Structs and enums tagged with <code>#[non_exhaustive]</code> force the user to add a
(potentially redundant) wildcard when pattern-matching, to allow for future
addition of fields or variants. The <code>non_exhaustive_omitted_patterns</code> lint
detects when such a wildcard happens to actually catch some fields/variants.
In other words, when the match without the wildcard would not be exhaustive.
This lets the user be informed if new fields/variants were added.</p>
<h2 id="noop-method-call"><a class="header" href="#noop-method-call">noop-method-call</a></h2>
<p>The <code>noop_method_call</code> lint detects specific calls to noop methods
such as a calling <code>&lt;&amp;T as Clone&gt;::clone</code> where <code>T: !Clone</code>.</p>
<h3 id="example-14"><a class="header" href="#example-14">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(unused)]
</span>#![warn(noop_method_call)]
struct Foo;
let foo = &amp;Foo;
let clone: &amp;Foo = foo.clone();
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: call to `.clone()` on a reference in this situation does nothing
 --&gt; lint_example.rs:6:22
  |
6 | let clone: &amp;Foo = foo.clone();
  |                      ^^^^^^^^ unnecessary method call
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:9
  |
2 | #![warn(noop_method_call)]
  |         ^^^^^^^^^^^^^^^^
  = note: the type `&amp;main::Foo` which `clone` is being called on is the same as the type returned from `clone`, so the method call does not do anything and can be removed

</code></pre>
<h3 id="explanation-14"><a class="header" href="#explanation-14">Explanation</a></h3>
<p>Some method calls are noops meaning that they do nothing. Usually such methods
are the result of blanket implementations that happen to create some method invocations
that end up not doing anything. For instance, <code>Clone</code> is implemented on all <code>&amp;T</code>, but
calling <code>clone</code> on a <code>&amp;T</code> where <code>T</code> does not implement clone, actually doesn't do anything
as references are copy. This lint detects these calls and warns the user about them.</p>
<h2 id="pointer-structural-match"><a class="header" href="#pointer-structural-match">pointer-structural-match</a></h2>
<p>The <code>pointer_structural_match</code> lint detects pointers used in patterns whose behaviour
cannot be relied upon across compiler versions and optimization levels.</p>
<h3 id="example-15"><a class="header" href="#example-15">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(pointer_structural_match)]
fn foo(a: usize, b: usize) -&gt; usize { a + b }
const FOO: fn(usize, usize) -&gt; usize = foo;
fn main() {
    match FOO {
        FOO =&gt; {},
        _ =&gt; {},
    }
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.
 --&gt; lint_example.rs:6:9
  |
6 |         FOO =&gt; {},
  |         ^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(pointer_structural_match)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #62411 &lt;https://github.com/rust-lang/rust/issues/70861&gt;

</code></pre>
<h3 id="explanation-15"><a class="header" href="#explanation-15">Explanation</a></h3>
<p>Previous versions of Rust allowed function pointers and wide raw pointers in patterns.
While these work in many cases as expected by users, it is possible that due to
optimizations pointers are &quot;not equal to themselves&quot; or pointers to different functions
compare as equal during runtime. This is because LLVM optimizations can deduplicate
functions if their bodies are the same, thus also making pointers to these functions point
to the same location. Additionally functions may get duplicated if they are instantiated
in different crates and not deduplicated again via LTO.</p>
<h2 id="rust-2021-incompatible-closure-captures"><a class="header" href="#rust-2021-incompatible-closure-captures">rust-2021-incompatible-closure-captures</a></h2>
<p>The <code>rust_2021_incompatible_closure_captures</code> lint detects variables that aren't completely
captured in Rust 2021, such that the <code>Drop</code> order of their fields may differ between
Rust 2018 and 2021.</p>
<p>It can also detect when a variable implements a trait like <code>Send</code>, but one of its fields does not,
and the field is captured by a closure and used with the assumption that said field implements
the same trait as the root variable.</p>
<h3 id="example-of-drop-reorder"><a class="header" href="#example-of-drop-reorder">Example of drop reorder</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(rust_2021_incompatible_closure_captures)]
<span class="boring">#![allow(unused)]
</span>
struct FancyInteger(i32);

impl Drop for FancyInteger {
    fn drop(&amp;mut self) {
        println!(&quot;Just dropped {}&quot;, self.0);
    }
}

struct Point { x: FancyInteger, y: FancyInteger }

fn main() {
  let p = Point { x: FancyInteger(10), y: FancyInteger(20) };

  let c = || {
     let x = p.x;
  };

  c();

  // ... More code ...
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: changes to closure capture in Rust 2021 will affect drop order
  --&gt; lint_example.rs:17:11
   |
17 |   let c = || {
   |           ^^
18 |      let x = p.x;
   |              --- in Rust 2018, this closure captures all of `p`, but in Rust 2021, it will only capture `p.x`
...
24 | }
   | - in Rust 2018, `p` is dropped here, but in Rust 2021, only `p.x` will be dropped here as part of the closure
   |
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
1  | #![deny(rust_2021_incompatible_closure_captures)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html&gt;
help: add a dummy let to cause `p` to be fully captured
   |
17 ~   let c = || {
18 +      let _ = &amp;p;
   |

</code></pre>
<h3 id="explanation-16"><a class="header" href="#explanation-16">Explanation</a></h3>
<p>In the above example, <code>p.y</code> will be dropped at the end of <code>f</code> instead of
with <code>c</code> in Rust 2021.</p>
<h3 id="example-of-auto-trait"><a class="header" href="#example-of-auto-trait">Example of auto-trait</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(rust_2021_incompatible_closure_captures)]
use std::thread;

struct Pointer(*mut i32);
unsafe impl Send for Pointer {}

fn main() {
    let mut f = 10;
    let fptr = Pointer(&amp;mut f as *mut i32);
    thread::spawn(move || unsafe {
        *fptr.0 = 20;
    });
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: changes to closure capture in Rust 2021 will affect which traits the closure implements
  --&gt; lint_example.rs:10:19
   |
10 |     thread::spawn(move || unsafe {
   |                   ^^^^^^^^^^^^^^ in Rust 2018, this closure implements `Send` as `fptr` implements `Send`, but in Rust 2021, this closure will no longer implement `Send` because `fptr` is not fully captured and `fptr.0` does not implement `Send`
11 |         *fptr.0 = 20;
   |         ------- in Rust 2018, this closure captures all of `fptr`, but in Rust 2021, it will only capture `fptr.0`
   |
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
1  | #![deny(rust_2021_incompatible_closure_captures)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html&gt;
help: add a dummy let to cause `fptr` to be fully captured
   |
10 ~     thread::spawn(move || { let _ = &amp;fptr; unsafe {
11 |         *fptr.0 = 20;
12 ~     } });
   |

</code></pre>
<h3 id="explanation-17"><a class="header" href="#explanation-17">Explanation</a></h3>
<p>In the above example, only <code>fptr.0</code> is captured in Rust 2021.
The field is of type <code>*mut i32</code>, which doesn't implement <code>Send</code>,
making the code invalid as the field cannot be sent between threads safely.</p>
<h2 id="rust-2021-incompatible-or-patterns"><a class="header" href="#rust-2021-incompatible-or-patterns">rust-2021-incompatible-or-patterns</a></h2>
<p>The <code>rust_2021_incompatible_or_patterns</code> lint detects usage of old versions of or-patterns.</p>
<h3 id="example-16"><a class="header" href="#example-16">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(rust_2021_incompatible_or_patterns)]

macro_rules! match_any {
    ( $expr:expr , $( $( $pat:pat )|+ =&gt; $expr_arm:expr ),+ ) =&gt; {
        match $expr {
            $(
                $( $pat =&gt; $expr_arm, )+
            )+
        }
    };
}

fn main() {
    let result: Result&lt;i64, i32&gt; = Err(42);
    let int: i64 = match_any!(result, Ok(i) | Err(i) =&gt; i.into());
    assert_eq!(int, 42);
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: the meaning of the `pat` fragment specifier is changing in Rust 2021, which may affect this macro
 --&gt; lint_example.rs:4:26
  |
4 |     ( $expr:expr , $( $( $pat:pat )|+ =&gt; $expr_arm:expr ),+ ) =&gt; {
  |                          ^^^^^^^^ help: use pat_param to preserve semantics: `$pat:pat_param`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(rust_2021_incompatible_or_patterns)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/or-patterns-macro-rules.html&gt;

</code></pre>
<h3 id="explanation-18"><a class="header" href="#explanation-18">Explanation</a></h3>
<p>In Rust 2021, the <code>pat</code> matcher will match additional patterns, which include the <code>|</code> character.</p>
<h2 id="rust-2021-prefixes-incompatible-syntax"><a class="header" href="#rust-2021-prefixes-incompatible-syntax">rust-2021-prefixes-incompatible-syntax</a></h2>
<p>The <code>rust_2021_prefixes_incompatible_syntax</code> lint detects identifiers that will be parsed as a
prefix instead in Rust 2021.</p>
<h3 id="example-17"><a class="header" href="#example-17">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018 compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(rust_2021_prefixes_incompatible_syntax)]

<span class="boring">fn main() {
</span>macro_rules! m {
    (z $x:expr) =&gt; ();
}

m!(z&quot;hey&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: prefix `z` is unknown
 --&gt; lint_example.rs:8:4
  |
8 | m!(z&quot;hey&quot;);
  |    ^ unknown prefix
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(rust_2021_prefixes_incompatible_syntax)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/reserving-syntax.html&gt;
help: insert whitespace here to avoid this being parsed as a prefix in Rust 2021
  |
8 - m!(z&quot;hey&quot;);
8 + m!(z &quot;hey&quot;);
  | 

</code></pre>
<h3 id="explanation-19"><a class="header" href="#explanation-19">Explanation</a></h3>
<p>In Rust 2015 and 2018, <code>z&quot;hey&quot;</code> is two tokens: the identifier <code>z</code>
followed by the string literal <code>&quot;hey&quot;</code>. In Rust 2021, the <code>z</code> is
considered a prefix for <code>&quot;hey&quot;</code>.</p>
<p>This lint suggests to add whitespace between the <code>z</code> and <code>&quot;hey&quot;</code> tokens
to keep them separated in Rust 2021.</p>
<h2 id="rust-2021-prelude-collisions"><a class="header" href="#rust-2021-prelude-collisions">rust-2021-prelude-collisions</a></h2>
<p>The <code>rust_2021_prelude_collisions</code> lint detects the usage of trait methods which are ambiguous
with traits added to the prelude in future editions.</p>
<h3 id="example-18"><a class="header" href="#example-18">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(rust_2021_prelude_collisions)]

trait Foo {
    fn try_into(self) -&gt; Result&lt;String, !&gt;;
}

impl Foo for &amp;str {
    fn try_into(self) -&gt; Result&lt;String, !&gt; {
        Ok(String::from(self))
    }
}

fn main() {
    let x: String = &quot;3&quot;.try_into().unwrap();
    //                  ^^^^^^^^
    // This call to try_into matches both Foo:try_into and TryInto::try_into as
    // `TryInto` has been added to the Rust prelude in 2021 edition.
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trait method `try_into` will become ambiguous in Rust 2021
  --&gt; lint_example.rs:14:21
   |
14 |     let x: String = &quot;3&quot;.try_into().unwrap();
   |                     ^^^^^^^^^^^^^^ help: disambiguate the associated function: `Foo::try_into(&amp;*&quot;3&quot;)`
   |
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
1  | #![deny(rust_2021_prelude_collisions)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
   = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/prelude.html&gt;

</code></pre>
<h3 id="explanation-20"><a class="header" href="#explanation-20">Explanation</a></h3>
<p>In Rust 2021, one of the important introductions is the <a href="https://blog.rust-lang.org/inside-rust/2021/03/04/planning-rust-2021.html#prelude-changes">prelude changes</a>, which add
<code>TryFrom</code>, <code>TryInto</code>, and <code>FromIterator</code> into the standard library's prelude. Since this
results in an ambiguity as to which method/function to call when an existing <code>try_into</code>
method is called via dot-call syntax or a <code>try_from</code>/<code>from_iter</code> associated function
is called directly on a type.</p>
<h2 id="single-use-lifetimes"><a class="header" href="#single-use-lifetimes">single-use-lifetimes</a></h2>
<p>The <code>single_use_lifetimes</code> lint detects lifetimes that are only used
once.</p>
<h3 id="example-19"><a class="header" href="#example-19">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(single_use_lifetimes)]

<span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(x: &amp;'a u32) {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: lifetime parameter `'a` only used once
 --&gt; lint_example.rs:4:8
  |
4 | fn foo&lt;'a&gt;(x: &amp;'a u32) {}
  |        ^^      -- ...is used only here
  |        |
  |        this lifetime...
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(single_use_lifetimes)]
  |         ^^^^^^^^^^^^^^^^^^^^
help: elide the single-use lifetime
  |
4 - fn foo&lt;'a&gt;(x: &amp;'a u32) {}
4 + fn foo(x: &amp;u32) {}
  | 

</code></pre>
<h3 id="explanation-21"><a class="header" href="#explanation-21">Explanation</a></h3>
<p>Specifying an explicit lifetime like <code>'a</code> in a function or <code>impl</code>
should only be used to link together two things. Otherwise, you should
just use <code>'_</code> to indicate that the lifetime is not linked to anything,
or elide the lifetime altogether if possible.</p>
<p>This lint is &quot;allow&quot; by default because it was introduced at a time
when <code>'_</code> and elided lifetimes were first being introduced, and this
lint would be too noisy. Also, there are some known false positives
that it produces. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2115-argument-lifetimes.md">RFC 2115</a> for historical context, and <a href="https://github.com/rust-lang/rust/issues/44752">issue
#44752</a> for more details.</p>
<h2 id="trivial-casts"><a class="header" href="#trivial-casts">trivial-casts</a></h2>
<p>The <code>trivial_casts</code> lint detects trivial casts which could be replaced
with coercion, which may require <a href="https://github.com/rust-lang/rust/issues/23416">type ascription</a> or a temporary
variable.</p>
<h3 id="example-20"><a class="header" href="#example-20">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(trivial_casts)]
<span class="boring">fn main() {
</span>let x: &amp;u32 = &amp;42;
let y = x as *const u32;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trivial cast: `&amp;u32` as `*const u32`
 --&gt; lint_example.rs:4:9
  |
4 | let y = x as *const u32;
  |         ^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(trivial_casts)]
  |         ^^^^^^^^^^^^^
  = help: cast can be replaced by coercion; this might require a temporary variable

</code></pre>
<h3 id="explanation-22"><a class="header" href="#explanation-22">Explanation</a></h3>
<p>A trivial cast is a cast <code>e as T</code> where <code>e</code> has type <code>U</code> and <code>U</code> is a
subtype of <code>T</code>. This type of cast is usually unnecessary, as it can be
usually be inferred.</p>
<p>This lint is &quot;allow&quot; by default because there are situations, such as
with FFI interfaces or complex type aliases, where it triggers
incorrectly, or in situations where it will be more difficult to
clearly express the intent. It may be possible that this will become a
warning in the future, possibly with <a href="https://github.com/rust-lang/rust/issues/23416">type ascription</a> providing a
convenient way to work around the current issues. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a> for
historical context.</p>
<h2 id="trivial-numeric-casts"><a class="header" href="#trivial-numeric-casts">trivial-numeric-casts</a></h2>
<p>The <code>trivial_numeric_casts</code> lint detects trivial numeric casts of types
which could be removed.</p>
<h3 id="example-21"><a class="header" href="#example-21">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(trivial_numeric_casts)]
<span class="boring">fn main() {
</span>let x = 42_i32 as i32;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trivial numeric cast: `i32` as `i32`
 --&gt; lint_example.rs:3:9
  |
3 | let x = 42_i32 as i32;
  |         ^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(trivial_numeric_casts)]
  |         ^^^^^^^^^^^^^^^^^^^^^
  = help: cast can be replaced by coercion; this might require a temporary variable

</code></pre>
<h3 id="explanation-23"><a class="header" href="#explanation-23">Explanation</a></h3>
<p>A trivial numeric cast is a cast of a numeric type to the same numeric
type. This type of cast is usually unnecessary.</p>
<p>This lint is &quot;allow&quot; by default because there are situations, such as
with FFI interfaces or complex type aliases, where it triggers
incorrectly, or in situations where it will be more difficult to
clearly express the intent. It may be possible that this will become a
warning in the future, possibly with <a href="https://github.com/rust-lang/rust/issues/23416">type ascription</a> providing a
convenient way to work around the current issues. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md">RFC 401</a> for
historical context.</p>
<h2 id="unreachable-pub"><a class="header" href="#unreachable-pub">unreachable-pub</a></h2>
<p>The <code>unreachable_pub</code> lint triggers for <code>pub</code> items not reachable from
the crate root.</p>
<h3 id="example-22"><a class="header" href="#example-22">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(unreachable_pub)]
<span class="boring">fn main() {
</span>mod foo {
    pub mod bar {

    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unreachable `pub` item
 --&gt; lint_example.rs:4:5
  |
4 |     pub mod bar {
  |     ---^^^^^^^^
  |     |
  |     help: consider restricting its visibility: `pub(crate)`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unreachable_pub)]
  |         ^^^^^^^^^^^^^^^
  = help: or consider exporting it for use by other crates

</code></pre>
<h3 id="explanation-24"><a class="header" href="#explanation-24">Explanation</a></h3>
<p>A bare <code>pub</code> visibility may be misleading if the item is not actually
publicly exported from the crate. The <code>pub(crate)</code> visibility is
recommended to be used instead, which more clearly expresses the intent
that the item is only visible within its own crate.</p>
<p>This lint is &quot;allow&quot; by default because it will trigger for a large
amount existing Rust code, and has some false-positives. Eventually it
is desired for this to become warn-by-default.</p>
<h2 id="unsafe-code"><a class="header" href="#unsafe-code">unsafe-code</a></h2>
<p>The <code>unsafe_code</code> lint catches usage of <code>unsafe</code> code.</p>
<h3 id="example-23"><a class="header" href="#example-23">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(unsafe_code)]
fn main() {
    unsafe {

    }
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: usage of an `unsafe` block
 --&gt; lint_example.rs:3:5
  |
3 | /     unsafe {
4 | |
5 | |     }
  | |_____^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unsafe_code)]
  |         ^^^^^^^^^^^

</code></pre>
<h3 id="explanation-25"><a class="header" href="#explanation-25">Explanation</a></h3>
<p>This lint is intended to restrict the usage of <code>unsafe</code>, which can be
difficult to use correctly.</p>
<h2 id="unsafe-op-in-unsafe-fn"><a class="header" href="#unsafe-op-in-unsafe-fn">unsafe-op-in-unsafe-fn</a></h2>
<p>The <code>unsafe_op_in_unsafe_fn</code> lint detects unsafe operations in unsafe
functions without an explicit unsafe block.</p>
<h3 id="example-24"><a class="header" href="#example-24">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(unsafe_op_in_unsafe_fn)]

unsafe fn foo() {}

unsafe fn bar() {
    foo();
}

fn main() {}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: call to unsafe function is unsafe and requires unsafe block (error E0133)
 --&gt; lint_example.rs:6:5
  |
6 |     foo();
  |     ^^^^^ call to unsafe function
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unsafe_op_in_unsafe_fn)]
  |         ^^^^^^^^^^^^^^^^^^^^^^
  = note: consult the function's documentation for information on how to avoid undefined behavior

</code></pre>
<h3 id="explanation-26"><a class="header" href="#explanation-26">Explanation</a></h3>
<p>Currently, an <a href="https://doc.rust-lang.org/reference/unsafe-functions.html"><code>unsafe fn</code></a> allows any <a href="https://doc.rust-lang.org/reference/unsafety.html">unsafe</a> operation within its
body. However, this can increase the surface area of code that needs
to be scrutinized for proper behavior. The <a href="https://doc.rust-lang.org/reference/expressions/block-expr.html#unsafe-blocks"><code>unsafe</code> block</a> provides a
convenient way to make it clear exactly which parts of the code are
performing unsafe operations. In the future, it is desired to change
it so that unsafe operations cannot be performed in an <code>unsafe fn</code>
without an <code>unsafe</code> block.</p>
<p>The fix to this is to wrap the unsafe code in an <code>unsafe</code> block.</p>
<p>This lint is &quot;allow&quot; by default since this will affect a large amount
of existing code, and the exact plan for increasing the severity is
still being considered. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2585-unsafe-block-in-unsafe-fn.md">RFC #2585</a> and <a href="https://github.com/rust-lang/rust/issues/71668">issue #71668</a> for more
details.</p>
<h2 id="unstable-features"><a class="header" href="#unstable-features">unstable-features</a></h2>
<p>The <code>unstable_features</code> is deprecated and should no longer be used.</p>
<h2 id="unused-crate-dependencies"><a class="header" href="#unused-crate-dependencies">unused-crate-dependencies</a></h2>
<p>The <code>unused_crate_dependencies</code> lint detects crate dependencies that
are never used.</p>
<h3 id="example-25"><a class="header" href="#example-25">Example</a></h3>
<pre><code class="language-rust ignore (needs extern crate)">#![deny(unused_crate_dependencies)]
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: external crate `regex` unused in `lint_example`: remove the dependency or add `use regex as _;`
  |
note: the lint level is defined here
 --&gt; src/lib.rs:1:9
  |
1 | #![deny(unused_crate_dependencies)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
<h3 id="explanation-27"><a class="header" href="#explanation-27">Explanation</a></h3>
<p>After removing the code that uses a dependency, this usually also
requires removing the dependency from the build configuration.
However, sometimes that step can be missed, which leads to time wasted
building dependencies that are no longer used. This lint can be
enabled to detect dependencies that are never used (more specifically,
any dependency passed with the <code>--extern</code> command-line flag that is
never referenced via <a href="https://doc.rust-lang.org/reference/items/use-declarations.html"><code>use</code></a>, <a href="https://doc.rust-lang.org/reference/items/extern-crates.html"><code>extern crate</code></a>, or in any <a href="https://doc.rust-lang.org/reference/paths.html">path</a>).</p>
<p>This lint is &quot;allow&quot; by default because it can provide false positives
depending on how the build system is configured. For example, when
using Cargo, a &quot;package&quot; consists of multiple crates (such as a
library and a binary), but the dependencies are defined for the
package as a whole. If there is a dependency that is only used in the
binary, but not the library, then the lint will be incorrectly issued
in the library.</p>
<h2 id="unused-extern-crates"><a class="header" href="#unused-extern-crates">unused-extern-crates</a></h2>
<p>The <code>unused_extern_crates</code> lint guards against <code>extern crate</code> items
that are never used.</p>
<h3 id="example-26"><a class="header" href="#example-26">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(unused_extern_crates)]
<span class="boring">fn main() {
</span>extern crate proc_macro;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unused extern crate
 --&gt; lint_example.rs:3:1
  |
3 | extern crate proc_macro;
  | ^^^^^^^^^^^^^^^^^^^^^^^^ help: remove it
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_extern_crates)]
  |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-28"><a class="header" href="#explanation-28">Explanation</a></h3>
<p><code>extern crate</code> items that are unused have no effect and should be
removed. Note that there are some cases where specifying an <code>extern crate</code> is desired for the side effect of ensuring the given crate is
linked, even though it is not otherwise directly referenced. The lint
can be silenced by aliasing the crate to an underscore, such as
<code>extern crate foo as _</code>. Also note that it is no longer idiomatic to
use <code>extern crate</code> in the <a href="https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html#no-more-extern-crate">2018 edition</a>, as extern crates are now
automatically added in scope.</p>
<p>This lint is &quot;allow&quot; by default because it can be noisy, and produce
false-positives. If a dependency is being removed from a project, it
is recommended to remove it from the build configuration (such as
<code>Cargo.toml</code>) to ensure stale build entries aren't left behind.</p>
<h2 id="unused-import-braces"><a class="header" href="#unused-import-braces">unused-import-braces</a></h2>
<p>The <code>unused_import_braces</code> lint catches unnecessary braces around an
imported item.</p>
<h3 id="example-27"><a class="header" href="#example-27">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(unused_import_braces)]
use test::{A};

pub mod test {
    pub struct A;
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: braces around A is unnecessary
 --&gt; lint_example.rs:2:1
  |
2 | use test::{A};
  | ^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_import_braces)]
  |         ^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-29"><a class="header" href="#explanation-29">Explanation</a></h3>
<p>If there is only a single item, then remove the braces (<code>use test::A;</code>
for example).</p>
<p>This lint is &quot;allow&quot; by default because it is only enforcing a
stylistic choice.</p>
<h2 id="unused-lifetimes"><a class="header" href="#unused-lifetimes">unused-lifetimes</a></h2>
<p>The <code>unused_lifetimes</code> lint detects lifetime parameters that are never
used.</p>
<h3 id="example-28"><a class="header" href="#example-28">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deny(unused_lifetimes)]

pub fn foo&lt;'a&gt;() {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: lifetime parameter `'a` never used
 --&gt; lint_example.rs:4:12
  |
4 | pub fn foo&lt;'a&gt;() {}
  |           -^^- help: elide the unused lifetime
  |
note: the lint level is defined here
 --&gt; lint_example.rs:2:8
  |
2 | #[deny(unused_lifetimes)]
  |        ^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-30"><a class="header" href="#explanation-30">Explanation</a></h3>
<p>Unused lifetime parameters may signal a mistake or unfinished code.
Consider removing the parameter.</p>
<h2 id="unused-qualifications"><a class="header" href="#unused-qualifications">unused-qualifications</a></h2>
<p>The <code>unused_qualifications</code> lint detects unnecessarily qualified
names.</p>
<h3 id="example-29"><a class="header" href="#example-29">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(unused_qualifications)]
mod foo {
    pub fn bar() {}
}

fn main() {
    use foo::bar;
    foo::bar();
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unnecessary qualification
 --&gt; lint_example.rs:8:5
  |
8 |     foo::bar();
  |     ^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_qualifications)]
  |         ^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-31"><a class="header" href="#explanation-31">Explanation</a></h3>
<p>If an item from another module is already brought into scope, then
there is no need to qualify it in this case. You can call <code>bar()</code>
directly, without the <code>foo::</code>.</p>
<p>This lint is &quot;allow&quot; by default because it is somewhat pedantic, and
doesn't indicate an actual problem, but rather a stylistic choice, and
can be noisy when refactoring or moving around code.</p>
<h2 id="unused-results"><a class="header" href="#unused-results">unused-results</a></h2>
<p>The <code>unused_results</code> lint checks for the unused result of an
expression in a statement.</p>
<h3 id="example-30"><a class="header" href="#example-30">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(unused_results)]
fn foo&lt;T&gt;() -&gt; T { panic!() }

fn main() {
    foo::&lt;usize&gt;();
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unused result of type `usize`
 --&gt; lint_example.rs:5:5
  |
5 |     foo::&lt;usize&gt;();
  |     ^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(unused_results)]
  |         ^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-32"><a class="header" href="#explanation-32">Explanation</a></h3>
<p>Ignoring the return value of a function may indicate a mistake. In
cases were it is almost certain that the result should be used, it is
recommended to annotate the function with the <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute"><code>must_use</code> attribute</a>.
Failure to use such a return value will trigger the <a href="lints/listing/warn-by-default.html#unused-must-use"><code>unused_must_use</code>
lint</a> which is warn-by-default. The <code>unused_results</code> lint is
essentially the same, but triggers for <em>all</em> return values.</p>
<p>This lint is &quot;allow&quot; by default because it can be noisy, and may not be
an actual problem. For example, calling the <code>remove</code> method of a <code>Vec</code>
or <code>HashMap</code> returns the previous value, which you may not care about.
Using this lint would require explicitly ignoring or discarding such
values.</p>
<h2 id="variant-size-differences"><a class="header" href="#variant-size-differences">variant-size-differences</a></h2>
<p>The <code>variant_size_differences</code> lint detects enums with widely varying
variant sizes.</p>
<h3 id="example-31"><a class="header" href="#example-31">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(variant_size_differences)]
<span class="boring">fn main() {
</span>enum En {
    V0(u8),
    VBig([u8; 1024]),
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: enum variant is more than three times larger (1024 bytes) than the next largest
 --&gt; lint_example.rs:5:5
  |
5 |     VBig([u8; 1024]),
  |     ^^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(variant_size_differences)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-33"><a class="header" href="#explanation-33">Explanation</a></h3>
<p>It can be a mistake to add a variant to an enum that is much larger
than the other variants, bloating the overall size required for all
variants. This can impact performance and memory usage. This is
triggered if one variant is more than 3 times larger than the
second-largest variant.</p>
<p>Consider placing the large variant's contents on the heap (for example
via <a href="https://doc.rust-lang.org/std/boxed/index.html"><code>Box</code></a>) to keep the overall size of the enum itself down.</p>
<p>This lint is &quot;allow&quot; by default because it can be noisy, and may not be
an actual problem. Decisions about this should be guided with
profiling and benchmarking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="warn-by-default-lints"><a class="header" href="#warn-by-default-lints">Warn-by-default lints</a></h1>
<p>These lints are all set to the 'warn' level by default.</p>
<ul>
<li><a href="lints/listing/warn-by-default.html#anonymous-parameters"><code>anonymous_parameters</code></a></li>
<li><a href="lints/listing/warn-by-default.html#array-into-iter"><code>array_into_iter</code></a></li>
<li><a href="lints/listing/warn-by-default.html#asm-sub-register"><code>asm_sub_register</code></a></li>
<li><a href="lints/listing/warn-by-default.html#bad-asm-style"><code>bad_asm_style</code></a></li>
<li><a href="lints/listing/warn-by-default.html#bare-trait-objects"><code>bare_trait_objects</code></a></li>
<li><a href="lints/listing/warn-by-default.html#bindings-with-variant-name"><code>bindings_with_variant_name</code></a></li>
<li><a href="lints/listing/warn-by-default.html#break-with-label-and-loop"><code>break_with_label_and_loop</code></a></li>
<li><a href="lints/listing/warn-by-default.html#cenum-impl-drop-cast"><code>cenum_impl_drop_cast</code></a></li>
<li><a href="lints/listing/warn-by-default.html#clashing-extern-declarations"><code>clashing_extern_declarations</code></a></li>
<li><a href="lints/listing/warn-by-default.html#coherence-leak-check"><code>coherence_leak_check</code></a></li>
<li><a href="lints/listing/warn-by-default.html#confusable-idents"><code>confusable_idents</code></a></li>
<li><a href="lints/listing/warn-by-default.html#const-evaluatable-unchecked"><code>const_evaluatable_unchecked</code></a></li>
<li><a href="lints/listing/warn-by-default.html#const-item-mutation"><code>const_item_mutation</code></a></li>
<li><a href="lints/listing/warn-by-default.html#dead-code"><code>dead_code</code></a></li>
<li><a href="lints/listing/warn-by-default.html#deprecated"><code>deprecated</code></a></li>
<li><a href="lints/listing/warn-by-default.html#deprecated-cfg-attr-crate-type-name"><code>deprecated_cfg_attr_crate_type_name</code></a></li>
<li><a href="lints/listing/warn-by-default.html#deref-into-dyn-supertrait"><code>deref_into_dyn_supertrait</code></a></li>
<li><a href="lints/listing/warn-by-default.html#deref-nullptr"><code>deref_nullptr</code></a></li>
<li><a href="lints/listing/warn-by-default.html#drop-bounds"><code>drop_bounds</code></a></li>
<li><a href="lints/listing/warn-by-default.html#duplicate-macro-attributes"><code>duplicate_macro_attributes</code></a></li>
<li><a href="lints/listing/warn-by-default.html#dyn-drop"><code>dyn_drop</code></a></li>
<li><a href="lints/listing/warn-by-default.html#ellipsis-inclusive-range-patterns"><code>ellipsis_inclusive_range_patterns</code></a></li>
<li><a href="lints/listing/warn-by-default.html#exported-private-dependencies"><code>exported_private_dependencies</code></a></li>
<li><a href="lints/listing/warn-by-default.html#forbidden-lint-groups"><code>forbidden_lint_groups</code></a></li>
<li><a href="lints/listing/warn-by-default.html#function-item-references"><code>function_item_references</code></a></li>
<li><a href="lints/listing/warn-by-default.html#illegal-floating-point-literal-pattern"><code>illegal_floating_point_literal_pattern</code></a></li>
<li><a href="lints/listing/warn-by-default.html#improper-ctypes"><code>improper_ctypes</code></a></li>
<li><a href="lints/listing/warn-by-default.html#improper-ctypes-definitions"><code>improper_ctypes_definitions</code></a></li>
<li><a href="lints/listing/warn-by-default.html#incomplete-features"><code>incomplete_features</code></a></li>
<li><a href="lints/listing/warn-by-default.html#indirect-structural-match"><code>indirect_structural_match</code></a></li>
<li><a href="lints/listing/warn-by-default.html#inline-no-sanitize"><code>inline_no_sanitize</code></a></li>
<li><a href="lints/listing/warn-by-default.html#invalid-doc-attributes"><code>invalid_doc_attributes</code></a></li>
<li><a href="lints/listing/warn-by-default.html#invalid-value"><code>invalid_value</code></a></li>
<li><a href="lints/listing/warn-by-default.html#irrefutable-let-patterns"><code>irrefutable_let_patterns</code></a></li>
<li><a href="lints/listing/warn-by-default.html#large-assignments"><code>large_assignments</code></a></li>
<li><a href="lints/listing/warn-by-default.html#late-bound-lifetime-arguments"><code>late_bound_lifetime_arguments</code></a></li>
<li><a href="lints/listing/warn-by-default.html#legacy-derive-helpers"><code>legacy_derive_helpers</code></a></li>
<li><a href="lints/listing/warn-by-default.html#mixed-script-confusables"><code>mixed_script_confusables</code></a></li>
<li><a href="lints/listing/warn-by-default.html#mutable-borrow-reservation-conflict"><code>mutable_borrow_reservation_conflict</code></a></li>
<li><a href="lints/listing/warn-by-default.html#no-mangle-generic-items"><code>no_mangle_generic_items</code></a></li>
<li><a href="lints/listing/warn-by-default.html#non-camel-case-types"><code>non_camel_case_types</code></a></li>
<li><a href="lints/listing/warn-by-default.html#non-fmt-panics"><code>non_fmt_panics</code></a></li>
<li><a href="lints/listing/warn-by-default.html#non-shorthand-field-patterns"><code>non_shorthand_field_patterns</code></a></li>
<li><a href="lints/listing/warn-by-default.html#non-snake-case"><code>non_snake_case</code></a></li>
<li><a href="lints/listing/warn-by-default.html#non-upper-case-globals"><code>non_upper_case_globals</code></a></li>
<li><a href="lints/listing/warn-by-default.html#nontrivial-structural-match"><code>nontrivial_structural_match</code></a></li>
<li><a href="lints/listing/warn-by-default.html#overlapping-range-endpoints"><code>overlapping_range_endpoints</code></a></li>
<li><a href="lints/listing/warn-by-default.html#path-statements"><code>path_statements</code></a></li>
<li><a href="lints/listing/warn-by-default.html#private-in-public"><code>private_in_public</code></a></li>
<li><a href="lints/listing/warn-by-default.html#redundant-semicolons"><code>redundant_semicolons</code></a></li>
<li><a href="lints/listing/warn-by-default.html#renamed-and-removed-lints"><code>renamed_and_removed_lints</code></a></li>
<li><a href="lints/listing/warn-by-default.html#semicolon-in-expressions-from-macros"><code>semicolon_in_expressions_from_macros</code></a></li>
<li><a href="lints/listing/warn-by-default.html#stable-features"><code>stable_features</code></a></li>
<li><a href="lints/listing/warn-by-default.html#temporary-cstring-as-ptr"><code>temporary_cstring_as_ptr</code></a></li>
<li><a href="lints/listing/warn-by-default.html#trivial-bounds"><code>trivial_bounds</code></a></li>
<li><a href="lints/listing/warn-by-default.html#type-alias-bounds"><code>type_alias_bounds</code></a></li>
<li><a href="lints/listing/warn-by-default.html#tyvar-behind-raw-pointer"><code>tyvar_behind_raw_pointer</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unaligned-references"><code>unaligned_references</code></a></li>
<li><a href="lints/listing/warn-by-default.html#uncommon-codepoints"><code>uncommon_codepoints</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unconditional-recursion"><code>unconditional_recursion</code></a></li>
<li><a href="lints/listing/warn-by-default.html#undefined-naked-function-abi"><code>undefined_naked_function_abi</code></a></li>
<li><a href="lints/listing/warn-by-default.html#uninhabited-static"><code>uninhabited_static</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unknown-lints"><code>unknown_lints</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unnameable-test-items"><code>unnameable_test_items</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unreachable-code"><code>unreachable_code</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unreachable-patterns"><code>unreachable_patterns</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unstable-name-collisions"><code>unstable_name_collisions</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unsupported-calling-conventions"><code>unsupported_calling_conventions</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unsupported-naked-functions"><code>unsupported_naked_functions</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-allocation"><code>unused_allocation</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-assignments"><code>unused_assignments</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-attributes"><code>unused_attributes</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-braces"><code>unused_braces</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-comparisons"><code>unused_comparisons</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-doc-comments"><code>unused_doc_comments</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-features"><code>unused_features</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-imports"><code>unused_imports</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-labels"><code>unused_labels</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-macros"><code>unused_macros</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-must-use"><code>unused_must_use</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-mut"><code>unused_mut</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-parens"><code>unused_parens</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-unsafe"><code>unused_unsafe</code></a></li>
<li><a href="lints/listing/warn-by-default.html#unused-variables"><code>unused_variables</code></a></li>
<li><a href="lints/listing/warn-by-default.html#warnings"><code>warnings</code></a></li>
<li><a href="lints/listing/warn-by-default.html#where-clauses-object-safety"><code>where_clauses_object_safety</code></a></li>
<li><a href="lints/listing/warn-by-default.html#while-true"><code>while_true</code></a></li>
</ul>
<h2 id="anonymous-parameters"><a class="header" href="#anonymous-parameters">anonymous-parameters</a></h2>
<p>The <code>anonymous_parameters</code> lint detects anonymous parameters in trait
definitions.</p>
<h3 id="example-32"><a class="header" href="#example-32">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2015 compile_fail">#![deny(anonymous_parameters)]
// edition 2015
pub trait Foo {
    fn foo(usize);
}
fn main() {}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: anonymous parameters are deprecated and will be removed in the next edition
 --&gt; lint_example.rs:4:12
  |
4 |     fn foo(usize);
  |            ^^^^^ help: try naming the parameter or explicitly ignoring it: `_: usize`
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(anonymous_parameters)]
  |         ^^^^^^^^^^^^^^^^^^^^
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see issue #41686 &lt;https://github.com/rust-lang/rust/issues/41686&gt;

</code></pre>
<h3 id="explanation-34"><a class="header" href="#explanation-34">Explanation</a></h3>
<p>This syntax is mostly a historical accident, and can be worked around
quite easily by adding an <code>_</code> pattern or a descriptive identifier:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(_: usize);
}
<span class="boring">}
</span></code></pre></pre>
<p>This syntax is now a hard error in the 2018 edition. In the 2015
edition, this lint is &quot;warn&quot; by default. This lint
enables the <a href="https://doc.rust-lang.org/cargo/commands/cargo-fix.html"><code>cargo fix</code></a> tool with the <code>--edition</code> flag to
automatically transition old code from the 2015 edition to 2018. The
tool will run this lint and automatically apply the
suggested fix from the compiler (which is to add <code>_</code> to each
parameter). This provides a completely automated way to update old
code for a new edition. See <a href="https://github.com/rust-lang/rust/issues/41686">issue #41686</a> for more details.</p>
<h2 id="array-into-iter"><a class="header" href="#array-into-iter">array-into-iter</a></h2>
<p>The <code>array_into_iter</code> lint detects calling <code>into_iter</code> on arrays.</p>
<h3 id="example-33"><a class="header" href="#example-33">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(unused)]
</span>[1, 2, 3].into_iter().for_each(|n| { *n; });
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this method call resolves to `&lt;&amp;[T; N] as IntoIterator&gt;::into_iter` (due to backwards compatibility), but will resolve to &lt;[T; N] as IntoIterator&gt;::into_iter in Rust 2021
 --&gt; lint_example.rs:3:11
  |
3 | [1, 2, 3].into_iter().for_each(|n| { *n; });
  |           ^^^^^^^^^
  |
  = note: `#[warn(array_into_iter)]` on by default
  = warning: this changes meaning in Rust 2021
  = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html&gt;
help: use `.iter()` instead of `.into_iter()` to avoid ambiguity
  |
3 | [1, 2, 3].iter().for_each(|n| { *n; });
  |           ~~~~
help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value
  |
3 | IntoIterator::into_iter([1, 2, 3]).for_each(|n| { *n; });
  | ++++++++++++++++++++++++         ~

</code></pre>
<h3 id="explanation-35"><a class="header" href="#explanation-35">Explanation</a></h3>
<p>Since Rust 1.53, arrays implement <code>IntoIterator</code>. However, to avoid
breakage, <code>array.into_iter()</code> in Rust 2015 and 2018 code will still
behave as <code>(&amp;array).into_iter()</code>, returning an iterator over
references, just like in Rust 1.52 and earlier.
This only applies to the method call syntax <code>array.into_iter()</code>, not to
any other syntax such as <code>for _ in array</code> or <code>IntoIterator::into_iter(array)</code>.</p>
<h2 id="asm-sub-register"><a class="header" href="#asm-sub-register">asm-sub-register</a></h2>
<p>The <code>asm_sub_register</code> lint detects using only a subset of a register
for inline asm inputs.</p>
<h3 id="example-34"><a class="header" href="#example-34">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-x86_64)">#[cfg(target_arch=&quot;x86_64&quot;)]
use std::arch::asm;

fn main() {
    #[cfg(target_arch=&quot;x86_64&quot;)]
    unsafe {
        asm!(&quot;mov {0}, {0}&quot;, in(reg) 0i16);
    }
}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: formatting may not be suitable for sub-register argument
 --&gt; src/main.rs:7:19
  |
7 |         asm!(&quot;mov {0}, {0}&quot;, in(reg) 0i16);
  |                   ^^^  ^^^           ---- for this argument
  |
  = note: `#[warn(asm_sub_register)]` on by default
  = help: use the `x` modifier to have the register formatted as `ax`
  = help: or use the `r` modifier to keep the default formatting of `rax`
</code></pre>
<h3 id="explanation-36"><a class="header" href="#explanation-36">Explanation</a></h3>
<p>Registers on some architectures can use different names to refer to a
subset of the register. By default, the compiler will use the name for
the full register size. To explicitly use a subset of the register,
you can override the default by using a modifier on the template
string operand to specify when subregister to use. This lint is issued
if you pass in a value with a smaller data type than the default
register size, to alert you of possibly using the incorrect width. To
fix this, add the suggested modifier to the template, or cast the
value to the correct size.</p>
<h2 id="bad-asm-style"><a class="header" href="#bad-asm-style">bad-asm-style</a></h2>
<p>The <code>bad_asm_style</code> lint detects the use of the <code>.intel_syntax</code> and
<code>.att_syntax</code> directives.</p>
<h3 id="example-35"><a class="header" href="#example-35">Example</a></h3>
<pre><code class="language-rust ignore (fails on non-x86_64)">#[cfg(target_arch=&quot;x86_64&quot;)]
use std::arch::asm;

fn main() {
    #[cfg(target_arch=&quot;x86_64&quot;)]
    unsafe {
        asm!(
            &quot;.att_syntax&quot;,
            &quot;movq %{0}, %{0}&quot;, in(reg) 0usize
        );
    }
}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: avoid using `.att_syntax`, prefer using `options(att_syntax)` instead
 --&gt; src/main.rs:8:14
  |
8 |             &quot;.att_syntax&quot;,
  |              ^^^^^^^^^^^
  |
  = note: `#[warn(bad_asm_style)]` on by default
</code></pre>
<h3 id="explanation-37"><a class="header" href="#explanation-37">Explanation</a></h3>
<p>On x86, <code>asm!</code> uses the intel assembly syntax by default. While this
can be switched using assembler directives like <code>.att_syntax</code>, using the
<code>att_syntax</code> option is recommended instead because it will also properly
prefix register placeholders with <code>%</code> as required by AT&amp;T syntax.</p>
<h2 id="bare-trait-objects"><a class="header" href="#bare-trait-objects">bare-trait-objects</a></h2>
<p>The <code>bare_trait_objects</code> lint suggests using <code>dyn Trait</code> for trait
objects.</p>
<h3 id="example-36"><a class="header" href="#example-36">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait { }

fn takes_trait_object(_: Box&lt;Trait&gt;) {
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: trait objects without an explicit `dyn` are deprecated
 --&gt; lint_example.rs:4:30
  |
4 | fn takes_trait_object(_: Box&lt;Trait&gt;) {
  |                              ^^^^^
  |
  = note: `#[warn(bare_trait_objects)]` on by default
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html&gt;
help: use `dyn`
  |
4 - fn takes_trait_object(_: Box&lt;Trait&gt;) {
4 + fn takes_trait_object(_: Box&lt;dyn Trait&gt;) {
  | 

</code></pre>
<h3 id="explanation-38"><a class="header" href="#explanation-38">Explanation</a></h3>
<p>Without the <code>dyn</code> indicator, it can be ambiguous or confusing when
reading code as to whether or not you are looking at a trait object.
The <code>dyn</code> keyword makes it explicit, and adds a symmetry to contrast
with <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters"><code>impl Trait</code></a>.</p>
<h2 id="bindings-with-variant-name"><a class="header" href="#bindings-with-variant-name">bindings-with-variant-name</a></h2>
<p>The <code>bindings_with_variant_name</code> lint detects pattern bindings with
the same name as one of the matched variants.</p>
<h3 id="example-37"><a class="header" href="#example-37">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Enum {
    Foo,
    Bar,
}

pub fn foo(x: Enum) {
    match x {
        Foo =&gt; {}
        Bar =&gt; {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning[E0170]: pattern binding `Foo` is named the same as one of the variants of the type `Enum`
 --&gt; lint_example.rs:9:9
  |
9 |         Foo =&gt; {}
  |         ^^^ help: to match on the variant, qualify the path: `Enum::Foo`
  |
  = note: `#[warn(bindings_with_variant_name)]` on by default

</code></pre>
<h3 id="explanation-39"><a class="header" href="#explanation-39">Explanation</a></h3>
<p>It is usually a mistake to specify an enum variant name as an
<a href="https://doc.rust-lang.org/reference/patterns.html#identifier-patterns">identifier pattern</a>. In the example above, the <code>match</code> arms are
specifying a variable name to bind the value of <code>x</code> to. The second arm
is ignored because the first one matches <em>all</em> values. The likely
intent is that the arm was intended to match on the enum variant.</p>
<p>Two possible solutions are:</p>
<ul>
<li>Specify the enum variant using a <a href="https://doc.rust-lang.org/reference/patterns.html#path-patterns">path pattern</a>, such as
<code>Enum::Foo</code>.</li>
<li>Bring the enum variants into local scope, such as adding <code>use Enum::*;</code> to the beginning of the <code>foo</code> function in the example
above.</li>
</ul>
<h2 id="break-with-label-and-loop"><a class="header" href="#break-with-label-and-loop">break-with-label-and-loop</a></h2>
<p>The <code>break_with_label_and_loop</code> lint detects labeled <code>break</code> expressions with
an unlabeled loop as their value expression.</p>
<h3 id="example-38"><a class="header" href="#example-38">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'label: loop {
    break 'label loop { break 42; };
};
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: this labeled break expression is easy to confuse with an unlabeled break with a labeled value expression
 --&gt; lint_example.rs:3:5
  |
3 |     break 'label loop { break 42; };
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(break_with_label_and_loop)]` on by default
help: wrap this expression in parentheses
  |
3 |     break 'label (loop { break 42; });
  |                  +                  +

</code></pre>
<h3 id="explanation-40"><a class="header" href="#explanation-40">Explanation</a></h3>
<p>In Rust, loops can have a label, and <code>break</code> expressions can refer to that label to
break out of specific loops (and not necessarily the innermost one). <code>break</code> expressions
can also carry a value expression, which can be another loop. A labeled <code>break</code> with an
unlabeled loop as its value expression is easy to confuse with an unlabeled break with
a labeled loop and is thus discouraged (but allowed for compatibility); use parentheses
around the loop expression to silence this warning. Unlabeled <code>break</code> expressions with
labeled loops yield a hard error, which can also be silenced by wrapping the expression
in parentheses.</p>
<h2 id="cenum-impl-drop-cast"><a class="header" href="#cenum-impl-drop-cast">cenum-impl-drop-cast</a></h2>
<p>The <code>cenum_impl_drop_cast</code> lint detects an <code>as</code> cast of a field-less
<code>enum</code> that implements <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>.</p>
<h3 id="example-39"><a class="header" href="#example-39">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>enum E {
    A,
}

impl Drop for E {
    fn drop(&amp;mut self) {
        println!(&quot;Drop&quot;);
    }
}

fn main() {
    let e = E::A;
    let i = e as u32;
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot cast enum `E` into integer `u32` because it implements `Drop`
  --&gt; lint_example.rs:14:13
   |
14 |     let i = e as u32;
   |             ^^^^^^^^
   |
   = note: `#[warn(cenum_impl_drop_cast)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #73333 &lt;https://github.com/rust-lang/rust/issues/73333&gt;

</code></pre>
<h3 id="explanation-41"><a class="header" href="#explanation-41">Explanation</a></h3>
<p>Casting a field-less <code>enum</code> that does not implement <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> to an
integer moves the value without calling <code>drop</code>. This can result in
surprising behavior if it was expected that <code>drop</code> should be called.
Calling <code>drop</code> automatically would be inconsistent with other move
operations. Since neither behavior is clear or consistent, it was
decided that a cast of this nature will no longer be allowed.</p>
<p>This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error
in the future. See <a href="https://github.com/rust-lang/rust/issues/73333">issue #73333</a> for more details.</p>
<h2 id="clashing-extern-declarations"><a class="header" href="#clashing-extern-declarations">clashing-extern-declarations</a></h2>
<p>The <code>clashing_extern_declarations</code> lint detects when an <code>extern fn</code>
has been declared with the same name but different types.</p>
<h3 id="example-40"><a class="header" href="#example-40">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod m {
    extern &quot;C&quot; {
        fn foo();
    }
}

extern &quot;C&quot; {
    fn foo(_: u32);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `foo` redeclared with a different signature
 --&gt; lint_example.rs:9:5
  |
4 |         fn foo();
  |         --------- `foo` previously declared here
...
9 |     fn foo(_: u32);
  |     ^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration
  |
  = note: `#[warn(clashing_extern_declarations)]` on by default
  = note: expected `unsafe extern &quot;C&quot; fn()`
             found `unsafe extern &quot;C&quot; fn(u32)`

</code></pre>
<h3 id="explanation-42"><a class="header" href="#explanation-42">Explanation</a></h3>
<p>Because two symbols of the same name cannot be resolved to two
different functions at link time, and one function cannot possibly
have two types, a clashing extern declaration is almost certainly a
mistake. Check to make sure that the <code>extern</code> definitions are correct
and equivalent, and possibly consider unifying them in one location.</p>
<p>This lint does not run between crates because a project may have
dependencies which both rely on the same extern function, but declare
it in a different (but valid) way. For example, they may both declare
an opaque type for one or more of the arguments (which would end up
distinct types), or use types that are valid conversions in the
language the <code>extern fn</code> is defined in. In these cases, the compiler
can't say that the clashing declaration is incorrect.</p>
<h2 id="coherence-leak-check"><a class="header" href="#coherence-leak-check">coherence-leak-check</a></h2>
<p>The <code>coherence_leak_check</code> lint detects conflicting implementations of
a trait that are only distinguished by the old leak-check code.</p>
<h3 id="example-41"><a class="header" href="#example-41">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait SomeTrait { }
impl SomeTrait for for&lt;'a&gt; fn(&amp;'a u8) { }
impl&lt;'a&gt; SomeTrait for fn(&amp;'a u8) { }
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: conflicting implementations of trait `main::SomeTrait` for type `for&lt;'a&gt; fn(&amp;'a u8)`
 --&gt; lint_example.rs:4:1
  |
3 | impl SomeTrait for for&lt;'a&gt; fn(&amp;'a u8) { }
  | ------------------------------------- first implementation here
4 | impl&lt;'a&gt; SomeTrait for fn(&amp;'a u8) { }
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for&lt;'a&gt; fn(&amp;'a u8)`
  |
  = note: `#[warn(coherence_leak_check)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #56105 &lt;https://github.com/rust-lang/rust/issues/56105&gt;
  = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details

</code></pre>
<h3 id="explanation-43"><a class="header" href="#explanation-43">Explanation</a></h3>
<p>In the past, the compiler would accept trait implementations for
identical functions that differed only in where the lifetime binder
appeared. Due to a change in the borrow checker implementation to fix
several bugs, this is no longer allowed. However, since this affects
existing code, this is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this
to a hard error in the future.</p>
<p>Code relying on this pattern should introduce &quot;<a href="https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction">newtypes</a>&quot;,
like <code>struct Foo(for&lt;'a&gt; fn(&amp;'a u8))</code>.</p>
<p>See <a href="https://github.com/rust-lang/rust/issues/56105">issue #56105</a> for more details.</p>
<h2 id="confusable-idents"><a class="header" href="#confusable-idents">confusable-idents</a></h2>
<p>The <code>confusable_idents</code> lint detects visually confusable pairs between
identifiers.</p>
<h3 id="example-42"><a class="header" href="#example-42">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Latin Capital Letter E With Caron
pub const Ě: i32 = 1;
// Latin Capital Letter E With Breve
pub const Ĕ: i32 = 2;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: identifier pair considered confusable between `Ě` and `Ĕ`
 --&gt; lint_example.rs:5:11
  |
3 | pub const Ě: i32 = 1;
  |           - this is where the previous identifier occurred
4 | // Latin Capital Letter E With Breve
5 | pub const Ĕ: i32 = 2;
  |           ^
  |
  = note: `#[warn(confusable_idents)]` on by default

</code></pre>
<h3 id="explanation-44"><a class="header" href="#explanation-44">Explanation</a></h3>
<p>This lint warns when different identifiers may appear visually similar,
which can cause confusion.</p>
<p>The confusable detection algorithm is based on <a href="https://www.unicode.org/reports/tr39/#Confusable_Detection">Unicode® Technical
Standard #39 Unicode Security Mechanisms Section 4 Confusable
Detection</a>. For every distinct identifier X execute
the function <code>skeleton(X)</code>. If there exist two distinct identifiers X
and Y in the same crate where <code>skeleton(X) = skeleton(Y)</code> report it.
The compiler uses the same mechanism to check if an identifier is too
similar to a keyword.</p>
<p>Note that the set of confusable characters may change over time.
Beware that if you &quot;forbid&quot; this lint that existing code may fail in
the future.</p>
<h2 id="const-evaluatable-unchecked"><a class="header" href="#const-evaluatable-unchecked">const-evaluatable-unchecked</a></h2>
<p>The <code>const_evaluatable_unchecked</code> lint detects a generic constant used
in a type.</p>
<h3 id="example-43"><a class="header" href="#example-43">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn foo&lt;T&gt;() -&gt; usize {
    if std::mem::size_of::&lt;*mut T&gt;() &lt; 8 { // size of *mut T does not depend on T
        4
    } else {
        8
    }
}

fn test&lt;T&gt;() {
    let _ = [0; foo::&lt;T&gt;()];
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot use constants which depend on generic parameters in types
  --&gt; lint_example.rs:11:17
   |
11 |     let _ = [0; foo::&lt;T&gt;()];
   |                 ^^^^^^^^^^
   |
   = note: `#[warn(const_evaluatable_unchecked)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #76200 &lt;https://github.com/rust-lang/rust/issues/76200&gt;

</code></pre>
<h3 id="explanation-45"><a class="header" href="#explanation-45">Explanation</a></h3>
<p>In the 1.43 release, some uses of generic parameters in array repeat
expressions were accidentally allowed. This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a>
lint to transition this to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/76200">issue
#76200</a> for a more detailed description and possible fixes.</p>
<h2 id="const-item-mutation"><a class="header" href="#const-item-mutation">const-item-mutation</a></h2>
<p>The <code>const_item_mutation</code> lint detects attempts to mutate a <code>const</code>
item.</p>
<h3 id="example-44"><a class="header" href="#example-44">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">const FOO: [i32; 1] = [0];

fn main() {
    FOO[0] = 1;
    // This will print &quot;[0]&quot;.
    println!(&quot;{:?}&quot;, FOO);
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: attempting to modify a `const` item
 --&gt; lint_example.rs:4:5
  |
4 |     FOO[0] = 1;
  |     ^^^^^^^^^^
  |
  = note: `#[warn(const_item_mutation)]` on by default
  = note: each usage of a `const` item creates a new temporary; the original `const` item will not be modified
note: `const` item defined here
 --&gt; lint_example.rs:1:1
  |
1 | const FOO: [i32; 1] = [0];
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-46"><a class="header" href="#explanation-46">Explanation</a></h3>
<p>Trying to directly mutate a <code>const</code> item is almost always a mistake.
What is happening in the example above is that a temporary copy of the
<code>const</code> is mutated, but the original <code>const</code> is not. Each time you
refer to the <code>const</code> by name (such as <code>FOO</code> in the example above), a
separate copy of the value is inlined at that location.</p>
<p>This lint checks for writing directly to a field (<code>FOO.field = some_value</code>) or array entry (<code>FOO[0] = val</code>), or taking a mutable
reference to the const item (<code>&amp;mut FOO</code>), including through an
autoderef (<code>FOO.some_mut_self_method()</code>).</p>
<p>There are various alternatives depending on what you are trying to
accomplish:</p>
<ul>
<li>First, always reconsider using mutable globals, as they can be
difficult to use correctly, and can make the code more difficult to
use or understand.</li>
<li>If you are trying to perform a one-time initialization of a global:
<ul>
<li>If the value can be computed at compile-time, consider using
const-compatible values (see <a href="https://doc.rust-lang.org/reference/const_eval.html">Constant Evaluation</a>).</li>
<li>For more complex single-initialization cases, consider using a
third-party crate, such as <a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a> or <a href="https://crates.io/crates/once_cell"><code>once_cell</code></a>.</li>
<li>If you are using the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>, consider the new
<a href="https://doc.rust-lang.org/nightly/std/lazy/index.html"><code>lazy</code></a> module in the standard library.</li>
</ul>
</li>
<li>If you truly need a mutable global, consider using a <a href="https://doc.rust-lang.org/reference/items/static-items.html"><code>static</code></a>,
which has a variety of options:
<ul>
<li>Simple data types can be directly defined and mutated with an
<a href="https://doc.rust-lang.org/std/sync/atomic/index.html"><code>atomic</code></a> type.</li>
<li>More complex types can be placed in a synchronization primitive
like a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>, which can be initialized with one of the options
listed above.</li>
<li>A <a href="https://doc.rust-lang.org/reference/items/static-items.html#mutable-statics">mutable <code>static</code></a> is a low-level primitive, requiring unsafe.
Typically This should be avoided in preference of something
higher-level like one of the above.</li>
</ul>
</li>
</ul>
<h2 id="dead-code"><a class="header" href="#dead-code">dead-code</a></h2>
<p>The <code>dead_code</code> lint detects unused, unexported items.</p>
<h3 id="example-45"><a class="header" href="#example-45">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function is never used: `foo`
 --&gt; lint_example.rs:2:4
  |
2 | fn foo() {}
  |    ^^^
  |
  = note: `#[warn(dead_code)]` on by default

</code></pre>
<h3 id="explanation-47"><a class="header" href="#explanation-47">Explanation</a></h3>
<p>Dead code may signal a mistake or unfinished code. To silence the
warning for individual items, prefix the name with an underscore such
as <code>_foo</code>. If it was intended to expose the item outside of the crate,
consider adding a visibility modifier like <code>pub</code>. Otherwise consider
removing the unused code.</p>
<h2 id="deprecated"><a class="header" href="#deprecated">deprecated</a></h2>
<p>The <code>deprecated</code> lint detects use of deprecated items.</p>
<h3 id="example-46"><a class="header" href="#example-46">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[deprecated]
fn foo() {}

fn bar() {
    foo();
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of deprecated function `main::foo`
 --&gt; lint_example.rs:6:5
  |
6 |     foo();
  |     ^^^
  |
  = note: `#[warn(deprecated)]` on by default

</code></pre>
<h3 id="explanation-48"><a class="header" href="#explanation-48">Explanation</a></h3>
<p>Items may be marked &quot;deprecated&quot; with the <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-deprecated-attribute"><code>deprecated</code> attribute</a> to
indicate that they should no longer be used. Usually the attribute
should include a note on what to use instead, or check the
documentation.</p>
<h2 id="deprecated-cfg-attr-crate-type-name"><a class="header" href="#deprecated-cfg-attr-crate-type-name">deprecated-cfg-attr-crate-type-name</a></h2>
<p>The <code>deprecated_cfg_attr_crate_type_name</code> lint detects uses of the
<code>#![cfg_attr(..., crate_type = &quot;...&quot;)]</code> and
<code>#![cfg_attr(..., crate_name = &quot;...&quot;)]</code> attributes to conditionally
specify the crate type and name in the source code.</p>
<h3 id="example-47"><a class="header" href="#example-47">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(debug_assertions, crate_type = &quot;lib&quot;)]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `crate_type` within an `#![cfg_attr] attribute is deprecated`
 --&gt; lint_example.rs:1:31
  |
1 | #![cfg_attr(debug_assertions, crate_type = &quot;lib&quot;)]
  |                               ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(deprecated_cfg_attr_crate_type_name)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #91632 &lt;https://github.com/rust-lang/rust/issues/91632&gt;

</code></pre>
<h3 id="explanation-49"><a class="header" href="#explanation-49">Explanation</a></h3>
<p>The <code>#![crate_type]</code> and <code>#![crate_name]</code> attributes require a hack in
the compiler to be able to change the used crate type and crate name
after macros have been expanded. Neither attribute works in combination
with Cargo as it explicitly passes <code>--crate-type</code> and <code>--crate-name</code> on
the commandline. These values must match the value used in the source
code to prevent an error.</p>
<p>To fix the warning use <code>--crate-type</code> on the commandline when running
rustc instead of <code>#![cfg_attr(..., crate_type = &quot;...&quot;)]</code> and
<code>--crate-name</code> instead of <code>#![cfg_attr(..., crate_name = &quot;...&quot;)]</code>.</p>
<h2 id="deref-into-dyn-supertrait"><a class="header" href="#deref-into-dyn-supertrait">deref-into-dyn-supertrait</a></h2>
<p>The <code>deref_into_dyn_supertrait</code> lint is output whenever there is a use of the
<code>Deref</code> implementation with a <code>dyn SuperTrait</code> type as <code>Output</code>.</p>
<p>These implementations will become shadowed when the <code>trait_upcasting</code> feature is stablized.
The <code>deref</code> functions will no longer be called implicitly, so there might be behavior change.</p>
<h3 id="example-48"><a class="header" href="#example-48">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(deref_into_dyn_supertrait)]
#![allow(dead_code)]

<span class="boring">fn main() {
</span>use core::ops::Deref;

trait A {}
trait B: A {}
impl&lt;'a&gt; Deref for dyn 'a + B {
    type Target = dyn A;
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        todo!()
    }
}

fn take_a(_: &amp;dyn A) { }

fn take_b(b: &amp;dyn B) {
    take_a(b);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: `dyn B` implements `Deref` with supertrait `(dyn A + 'static)` as output
  --&gt; lint_example.rs:19:12
   |
19 |     take_a(b);
   |            ^
   |
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
1  | #![deny(deref_into_dyn_supertrait)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #89460 &lt;https://github.com/rust-lang/rust/issues/89460&gt;

</code></pre>
<h3 id="explanation-50"><a class="header" href="#explanation-50">Explanation</a></h3>
<p>The dyn upcasting coercion feature adds new coercion rules, taking priority
over certain other coercion rules, which will cause some behavior change.</p>
<h2 id="deref-nullptr"><a class="header" href="#deref-nullptr">deref-nullptr</a></h2>
<p>The <code>deref_nullptr</code> lint detects when an null pointer is dereferenced,
which causes <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a>.</p>
<h3 id="example-49"><a class="header" href="#example-49">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(unused)]
</span>use std::ptr;
unsafe {
    let x = &amp;*ptr::null::&lt;i32&gt;();
    let x = ptr::addr_of!(*ptr::null::&lt;i32&gt;());
    let x = *(0 as *const i32);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: dereferencing a null pointer
 --&gt; lint_example.rs:5:14
  |
5 |     let x = &amp;*ptr::null::&lt;i32&gt;();
  |              ^^^^^^^^^^^^^^^^^^^ this code causes undefined behavior when executed
  |
  = note: `#[warn(deref_nullptr)]` on by default

</code></pre>
<h3 id="explanation-51"><a class="header" href="#explanation-51">Explanation</a></h3>
<p>Dereferencing a null pointer causes <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a> even as a place expression,
like <code>&amp;*(0 as *const i32)</code> or <code>addr_of!(*(0 as *const i32))</code>.</p>
<h2 id="drop-bounds"><a class="header" href="#drop-bounds">drop-bounds</a></h2>
<p>The <code>drop_bounds</code> lint checks for generics with <code>std::ops::Drop</code> as
bounds.</p>
<h3 id="example-50"><a class="header" href="#example-50">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Drop&gt;() {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: bounds on `T: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped
 --&gt; lint_example.rs:2:11
  |
2 | fn foo&lt;T: Drop&gt;() {}
  |           ^^^^
  |
  = note: `#[warn(drop_bounds)]` on by default

</code></pre>
<h3 id="explanation-52"><a class="header" href="#explanation-52">Explanation</a></h3>
<p>A generic trait bound of the form <code>T: Drop</code> is most likely misleading
and not what the programmer intended (they probably should have used
<code>std::mem::needs_drop</code> instead).</p>
<p><code>Drop</code> bounds do not actually indicate whether a type can be trivially
dropped or not, because a composite type containing <code>Drop</code> types does
not necessarily implement <code>Drop</code> itself. Naïvely, one might be tempted
to write an implementation that assumes that a type can be trivially
dropped while also supplying a specialization for <code>T: Drop</code> that
actually calls the destructor. However, this breaks down e.g. when <code>T</code>
is <code>String</code>, which does not implement <code>Drop</code> itself but contains a
<code>Vec</code>, which does implement <code>Drop</code>, so assuming <code>T</code> can be trivially
dropped would lead to a memory leak here.</p>
<p>Furthermore, the <code>Drop</code> trait only contains one method, <code>Drop::drop</code>,
which may not be called explicitly in user code (<code>E0040</code>), so there is
really no use case for using <code>Drop</code> in trait bounds, save perhaps for
some obscure corner cases, which can use <code>#[allow(drop_bounds)]</code>.</p>
<h2 id="duplicate-macro-attributes"><a class="header" href="#duplicate-macro-attributes">duplicate-macro-attributes</a></h2>
<p>The <code>duplicate_macro_attributes</code> lint detects when a <code>#[test]</code>-like built-in macro
attribute is duplicated on an item. This lint may trigger on <code>bench</code>, <code>cfg_eval</code>, <code>test</code>
and <code>test_case</code>.</p>
<h3 id="example-51"><a class="header" href="#example-51">Example</a></h3>
<pre><code class="language-rust ignore (needs --test)">#[test]
#[test]
fn foo() {}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: duplicated attribute
 --&gt; src/lib.rs:2:1
  |
2 | #[test]
  | ^^^^^^^
  |
  = note: `#[warn(duplicate_macro_attributes)]` on by default
</code></pre>
<h3 id="explanation-53"><a class="header" href="#explanation-53">Explanation</a></h3>
<p>A duplicated attribute may erroneously originate from a copy-paste and the effect of it
being duplicated may not be obvious or desireable.</p>
<p>For instance, doubling the <code>#[test]</code> attributes registers the test to be run twice with no
change to its environment.</p>
<h2 id="dyn-drop"><a class="header" href="#dyn-drop">dyn-drop</a></h2>
<p>The <code>dyn_drop</code> lint checks for trait objects with <code>std::ops::Drop</code>.</p>
<h3 id="example-52"><a class="header" href="#example-52">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(_x: Box&lt;dyn Drop&gt;) {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: types that do not implement `Drop` can still have drop glue, consider instead using `std::mem::needs_drop` to detect whether a type is trivially dropped
 --&gt; lint_example.rs:2:20
  |
2 | fn foo(_x: Box&lt;dyn Drop&gt;) {}
  |                    ^^^^
  |
  = note: `#[warn(dyn_drop)]` on by default

</code></pre>
<h3 id="explanation-54"><a class="header" href="#explanation-54">Explanation</a></h3>
<p>A trait object bound of the form <code>dyn Drop</code> is most likely misleading
and not what the programmer intended.</p>
<p><code>Drop</code> bounds do not actually indicate whether a type can be trivially
dropped or not, because a composite type containing <code>Drop</code> types does
not necessarily implement <code>Drop</code> itself. Naïvely, one might be tempted
to write a deferred drop system, to pull cleaning up memory out of a
latency-sensitive code path, using <code>dyn Drop</code> trait objects. However,
this breaks down e.g. when <code>T</code> is <code>String</code>, which does not implement
<code>Drop</code>, but should probably be accepted.</p>
<p>To write a trait object bound that accepts anything, use a placeholder
trait with a blanket implementation.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Placeholder {}
impl&lt;T&gt; Placeholder for T {}
fn foo(_x: Box&lt;dyn Placeholder&gt;) {}
<span class="boring">}
</span></code></pre></pre>
<h2 id="ellipsis-inclusive-range-patterns"><a class="header" href="#ellipsis-inclusive-range-patterns">ellipsis-inclusive-range-patterns</a></h2>
<p>The <code>ellipsis_inclusive_range_patterns</code> lint detects the <a href="https://doc.rust-lang.org/reference/patterns.html#range-patterns"><code>...</code> range
pattern</a>, which is deprecated.</p>
<h3 id="example-53"><a class="header" href="#example-53">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 123;
match x {
    0...100 =&gt; {}
    _ =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `...` range patterns are deprecated
 --&gt; lint_example.rs:4:6
  |
4 |     0...100 =&gt; {}
  |      ^^^ help: use `..=` for an inclusive range
  |
  = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default
  = warning: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!
  = note: for more information, see &lt;https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html&gt;

</code></pre>
<h3 id="explanation-55"><a class="header" href="#explanation-55">Explanation</a></h3>
<p>The <code>...</code> range pattern syntax was changed to <code>..=</code> to avoid potential
confusion with the <a href="https://doc.rust-lang.org/reference/expressions/range-expr.html"><code>..</code> range expression</a>. Use the new form instead.</p>
<h2 id="exported-private-dependencies"><a class="header" href="#exported-private-dependencies">exported-private-dependencies</a></h2>
<p>The <code>exported_private_dependencies</code> lint detects private dependencies
that are exposed in a public interface.</p>
<h3 id="example-54"><a class="header" href="#example-54">Example</a></h3>
<pre><code class="language-rust ignore (needs-dependency)">pub fn foo() -&gt; Option&lt;some_private_dependency::Thing&gt; {
    None
}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type `bar::Thing` from private dependency 'bar' in public interface
 --&gt; src/lib.rs:3:1
  |
3 | pub fn foo() -&gt; Option&lt;bar::Thing&gt; {
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(exported_private_dependencies)]` on by default
</code></pre>
<h3 id="explanation-56"><a class="header" href="#explanation-56">Explanation</a></h3>
<p>Dependencies can be marked as &quot;private&quot; to indicate that they are not
exposed in the public interface of a crate. This can be used by Cargo
to independently resolve those dependencies because it can assume it
does not need to unify them with other packages using that same
dependency. This lint is an indication of a violation of that
contract.</p>
<p>To fix this, avoid exposing the dependency in your public interface.
Or, switch the dependency to a public dependency.</p>
<p>Note that support for this is only available on the nightly channel.
See <a href="https://github.com/rust-lang/rfcs/blob/master/text/1977-public-private-dependencies.md">RFC 1977</a> for more details, as well as the <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#public-dependency">Cargo documentation</a>.</p>
<h2 id="forbidden-lint-groups"><a class="header" href="#forbidden-lint-groups">forbidden-lint-groups</a></h2>
<p>The <code>forbidden_lint_groups</code> lint detects violations of
<code>forbid</code> applied to a lint group. Due to a bug in the compiler,
these used to be overlooked entirely. They now generate a warning.</p>
<h3 id="example-55"><a class="header" href="#example-55">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">#![forbid(warnings)]
#![deny(bad_style)]

fn main() {}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: deny(bad_style) incompatible with previous forbid
 --&gt; lint_example.rs:2:9
  |
1 | #![forbid(warnings)]
  |           -------- `forbid` level set here
2 | #![deny(bad_style)]
  |         ^^^^^^^^^ overruled by previous forbid
  |
  = note: `#[warn(forbidden_lint_groups)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #81670 &lt;https://github.com/rust-lang/rust/issues/81670&gt;

</code></pre>
<h3 id="recommended-fix"><a class="header" href="#recommended-fix">Recommended fix</a></h3>
<p>If your crate is using <code>#![forbid(warnings)]</code>,
we recommend that you change to <code>#![deny(warnings)]</code>.</p>
<h3 id="explanation-57"><a class="header" href="#explanation-57">Explanation</a></h3>
<p>Due to a compiler bug, applying <code>forbid</code> to lint groups
previously had no effect. The bug is now fixed but instead of
enforcing <code>forbid</code> we issue this future-compatibility warning
to avoid breaking existing crates.</p>
<h2 id="function-item-references"><a class="header" href="#function-item-references">function-item-references</a></h2>
<p>The <code>function_item_references</code> lint detects function references that are
formatted with <a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>fmt::Pointer</code></a> or transmuted.</p>
<h3 id="example-56"><a class="header" href="#example-56">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">fn foo() { }

fn main() {
    println!(&quot;{:p}&quot;, &amp;foo);
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: taking a reference to a function item does not give a function pointer
 --&gt; lint_example.rs:4:22
  |
4 |     println!(&quot;{:p}&quot;, &amp;foo);
  |                      ^^^^ help: cast `foo` to obtain a function pointer: `foo as fn()`
  |
  = note: `#[warn(function_item_references)]` on by default

</code></pre>
<h3 id="explanation-58"><a class="header" href="#explanation-58">Explanation</a></h3>
<p>Taking a reference to a function may be mistaken as a way to obtain a
pointer to that function. This can give unexpected results when
formatting the reference as a pointer or transmuting it. This lint is
issued when function references are formatted as pointers, passed as
arguments bound by <a href="https://doc.rust-lang.org/std/fmt/trait.Pointer.html"><code>fmt::Pointer</code></a> or transmuted.</p>
<h2 id="illegal-floating-point-literal-pattern"><a class="header" href="#illegal-floating-point-literal-pattern">illegal-floating-point-literal-pattern</a></h2>
<p>The <code>illegal_floating_point_literal_pattern</code> lint detects
floating-point literals used in patterns.</p>
<h3 id="example-57"><a class="header" href="#example-57">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42.0;

match x {
    5.0 =&gt; {}
    _ =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: floating-point types cannot be used in patterns
 --&gt; lint_example.rs:5:5
  |
5 |     5.0 =&gt; {}
  |     ^^^
  |
  = note: `#[warn(illegal_floating_point_literal_pattern)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #41620 &lt;https://github.com/rust-lang/rust/issues/41620&gt;

</code></pre>
<h3 id="explanation-59"><a class="header" href="#explanation-59">Explanation</a></h3>
<p>Previous versions of the compiler accepted floating-point literals in
patterns, but it was later determined this was a mistake. The
semantics of comparing floating-point values may not be clear in a
pattern when contrasted with &quot;structural equality&quot;. Typically you can
work around this by using a <a href="https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards">match guard</a>, such as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let x = 42.0;
</span>
match x {
    y if y == 5.0 =&gt; {}
    _ =&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard
error in the future. See <a href="https://github.com/rust-lang/rust/issues/41620">issue #41620</a> for more details.</p>
<h2 id="improper-ctypes"><a class="header" href="#improper-ctypes">improper-ctypes</a></h2>
<p>The <code>improper_ctypes</code> lint detects incorrect use of types in foreign
modules.</p>
<h3 id="example-58"><a class="header" href="#example-58">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    static STATIC: String;
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `extern` block uses type `String`, which is not FFI-safe
 --&gt; lint_example.rs:3:20
  |
3 |     static STATIC: String;
  |                    ^^^^^^ not FFI-safe
  |
  = note: `#[warn(improper_ctypes)]` on by default
  = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct
  = note: this struct has unspecified layout

</code></pre>
<h3 id="explanation-60"><a class="header" href="#explanation-60">Explanation</a></h3>
<p>The compiler has several checks to verify that types used in <code>extern</code>
blocks are safe and follow certain rules to ensure proper
compatibility with the foreign interfaces. This lint is issued when it
detects a probable mistake in a definition. The lint usually should
provide a description of the issue, along with possibly a hint on how
to resolve it.</p>
<h2 id="improper-ctypes-definitions"><a class="header" href="#improper-ctypes-definitions">improper-ctypes-definitions</a></h2>
<p>The <code>improper_ctypes_definitions</code> lint detects incorrect use of
<a href="https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier"><code>extern</code> function</a> definitions.</p>
<h3 id="example-59"><a class="header" href="#example-59">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(unused)]
</span>pub extern &quot;C&quot; fn str_type(p: &amp;str) { }
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `extern` fn uses type `str`, which is not FFI-safe
 --&gt; lint_example.rs:3:31
  |
3 | pub extern &quot;C&quot; fn str_type(p: &amp;str) { }
  |                               ^^^^ not FFI-safe
  |
  = note: `#[warn(improper_ctypes_definitions)]` on by default
  = help: consider using `*const u8` and a length instead
  = note: string slices have no C equivalent

</code></pre>
<h3 id="explanation-61"><a class="header" href="#explanation-61">Explanation</a></h3>
<p>There are many parameter and return types that may be specified in an
<code>extern</code> function that are not compatible with the given ABI. This
lint is an alert that these types should not be used. The lint usually
should provide a description of the issue, along with possibly a hint
on how to resolve it.</p>
<h2 id="incomplete-features"><a class="header" href="#incomplete-features">incomplete-features</a></h2>
<p>The <code>incomplete_features</code> lint detects unstable features enabled with
the <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a> that may function improperly in some or all
cases.</p>
<h3 id="example-60"><a class="header" href="#example-60">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(generic_const_exprs)]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the feature `generic_const_exprs` is incomplete and may not be safe to use and/or cause compiler crashes
 --&gt; lint_example.rs:1:12
  |
1 | #![feature(generic_const_exprs)]
  |            ^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(incomplete_features)]` on by default
  = note: see issue #76560 &lt;https://github.com/rust-lang/rust/issues/76560&gt; for more information

</code></pre>
<h3 id="explanation-62"><a class="header" href="#explanation-62">Explanation</a></h3>
<p>Although it is encouraged for people to experiment with unstable
features, some of them are known to be incomplete or faulty. This lint
is a signal that the feature has not yet been finished, and you may
experience problems with it.</p>
<h2 id="indirect-structural-match"><a class="header" href="#indirect-structural-match">indirect-structural-match</a></h2>
<p>The <code>indirect_structural_match</code> lint detects a <code>const</code> in a pattern
that manually implements <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> and <a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>.</p>
<h3 id="example-61"><a class="header" href="#example-61">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(indirect_structural_match)]

struct NoDerive(i32);
impl PartialEq for NoDerive { fn eq(&amp;self, _: &amp;Self) -&gt; bool { false } }
impl Eq for NoDerive { }
#[derive(PartialEq, Eq)]
struct WrapParam&lt;T&gt;(T);
const WRAP_INDIRECT_PARAM: &amp; &amp;WrapParam&lt;NoDerive&gt; = &amp; &amp;WrapParam(NoDerive(0));
fn main() {
    match WRAP_INDIRECT_PARAM {
        WRAP_INDIRECT_PARAM =&gt; { }
        _ =&gt; { }
    }
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`
  --&gt; lint_example.rs:11:9
   |
11 |         WRAP_INDIRECT_PARAM =&gt; { }
   |         ^^^^^^^^^^^^^^^^^^^
   |
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
1  | #![deny(indirect_structural_match)]
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #62411 &lt;https://github.com/rust-lang/rust/issues/62411&gt;

</code></pre>
<h3 id="explanation-63"><a class="header" href="#explanation-63">Explanation</a></h3>
<p>The compiler unintentionally accepted this form in the past. This is a
<a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the
future. See <a href="https://github.com/rust-lang/rust/issues/62411">issue #62411</a> for a complete description of the problem,
and some possible solutions.</p>
<h2 id="inline-no-sanitize"><a class="header" href="#inline-no-sanitize">inline-no-sanitize</a></h2>
<p>The <code>inline_no_sanitize</code> lint detects incompatible use of
<a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>#[inline(always)]</code></a> and <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html"><code>#[no_sanitize(...)]</code></a>.</p>
<h3 id="example-62"><a class="header" href="#example-62">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">#![feature(no_sanitize)]

#[inline(always)]
#[no_sanitize(address)]
fn x() {}

fn main() {
    x()
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `no_sanitize` will have no effect after inlining
 --&gt; lint_example.rs:4:1
  |
4 | #[no_sanitize(address)]
  | ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(inline_no_sanitize)]` on by default
note: inlining requested here
 --&gt; lint_example.rs:3:1
  |
3 | #[inline(always)]
  | ^^^^^^^^^^^^^^^^^

</code></pre>
<h3 id="explanation-64"><a class="header" href="#explanation-64">Explanation</a></h3>
<p>The use of the <a href="https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute"><code>#[inline(always)]</code></a> attribute prevents the
the <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html"><code>#[no_sanitize(...)]</code></a> attribute from working.
Consider temporarily removing <code>inline</code> attribute.</p>
<h2 id="invalid-doc-attributes"><a class="header" href="#invalid-doc-attributes">invalid-doc-attributes</a></h2>
<p>The <code>invalid_doc_attributes</code> lint detects when the <code>#[doc(...)]</code> is
misused.</p>
<h3 id="example-63"><a class="header" href="#example-63">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(warnings)]

<span class="boring">fn main() {
</span>pub mod submodule {
    #![doc(test(no_crate_inject))]
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: this attribute can only be applied at the crate level
 --&gt; lint_example.rs:5:12
  |
5 |     #![doc(test(no_crate_inject))]
  |            ^^^^^^^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(warnings)]
  |         ^^^^^^^^
  = note: `#[deny(invalid_doc_attributes)]` implied by `#[deny(warnings)]`
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #82730 &lt;https://github.com/rust-lang/rust/issues/82730&gt;
  = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information

</code></pre>
<h3 id="explanation-65"><a class="header" href="#explanation-65">Explanation</a></h3>
<p>Previously, there were very like checks being performed on <code>#[doc(..)]</code>
unlike the other attributes. It'll now catch all the issues that it
silently ignored previously.</p>
<h2 id="invalid-value"><a class="header" href="#invalid-value">invalid-value</a></h2>
<p>The <code>invalid_value</code> lint detects creating a value that is not valid,
such as a null reference.</p>
<h3 id="example-64"><a class="header" href="#example-64">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(unused)]
</span>unsafe {
    let x: &amp;'static i32 = std::mem::zeroed();
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the type `&amp;i32` does not permit zero-initialization
 --&gt; lint_example.rs:4:27
  |
4 |     let x: &amp;'static i32 = std::mem::zeroed();
  |                           ^^^^^^^^^^^^^^^^^^
  |                           |
  |                           this code causes undefined behavior when executed
  |                           help: use `MaybeUninit&lt;T&gt;` instead, and only call `assume_init` after initialization is done
  |
  = note: `#[warn(invalid_value)]` on by default
  = note: references must be non-null

</code></pre>
<h3 id="explanation-66"><a class="header" href="#explanation-66">Explanation</a></h3>
<p>In some situations the compiler can detect that the code is creating
an invalid value, which should be avoided.</p>
<p>In particular, this lint will check for improper use of
<a href="https://doc.rust-lang.org/std/mem/fn.zeroed.html"><code>mem::zeroed</code></a>, <a href="https://doc.rust-lang.org/std/mem/fn.uninitialized.html"><code>mem::uninitialized</code></a>, <a href="https://doc.rust-lang.org/std/mem/fn.transmute.html"><code>mem::transmute</code></a>, and
<a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#method.assume_init"><code>MaybeUninit::assume_init</code></a> that can cause <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a>. The
lint should provide extra information to indicate what the problem is
and a possible solution.</p>
<h2 id="irrefutable-let-patterns"><a class="header" href="#irrefutable-let-patterns">irrefutable-let-patterns</a></h2>
<p>The <code>irrefutable_let_patterns</code> lint detects <a href="https://doc.rust-lang.org/reference/patterns.html#refutability">irrefutable patterns</a>
in <a href="https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions"><code>if let</code></a>s, <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops"><code>while let</code></a>s, and <code>if let</code> guards.</p>
<h3 id="example-65"><a class="header" href="#example-65">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let _ = 123 {
    println!(&quot;always runs!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: irrefutable `if let` pattern
 --&gt; lint_example.rs:2:4
  |
2 | if let _ = 123 {
  |    ^^^^^^^^^^^
  |
  = note: `#[warn(irrefutable_let_patterns)]` on by default
  = note: this pattern will always match, so the `if let` is useless
  = help: consider replacing the `if let` with a `let`

</code></pre>
<h3 id="explanation-67"><a class="header" href="#explanation-67">Explanation</a></h3>
<p>There usually isn't a reason to have an irrefutable pattern in an
<code>if let</code> or <code>while let</code> statement, because the pattern will always match
successfully. A <a href="https://doc.rust-lang.org/reference/statements.html#let-statements"><code>let</code></a> or <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops"><code>loop</code></a> statement will suffice. However,
when generating code with a macro, forbidding irrefutable patterns
would require awkward workarounds in situations where the macro
doesn't know if the pattern is refutable or not. This lint allows
macros to accept this form, while alerting for a possibly incorrect
use in normal code.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2086-allow-if-let-irrefutables.md">RFC 2086</a> for more details.</p>
<h2 id="large-assignments"><a class="header" href="#large-assignments">large-assignments</a></h2>
<p>The <code>large_assignments</code> lint detects when objects of large
types are being moved around.</p>
<h3 id="example-66"><a class="header" href="#example-66">Example</a></h3>
<pre><code class="language-rust ignore (can crash on some platforms)">let x = [0; 50000];
let y = x;
</code></pre>
<p>produces:</p>
<pre><code class="language-text">warning: moving a large value
  --&gt; $DIR/move-large.rs:1:3
  let y = x;
          - Copied large value here
</code></pre>
<h3 id="explanation-68"><a class="header" href="#explanation-68">Explanation</a></h3>
<p>When using a large type in a plain assignment or in a function
argument, idiomatic code can be inefficient.
Ideally appropriate optimizations would resolve this, but such
optimizations are only done in a best-effort manner.
This lint will trigger on all sites of large moves and thus allow the
user to resolve them in code.</p>
<h2 id="late-bound-lifetime-arguments"><a class="header" href="#late-bound-lifetime-arguments">late-bound-lifetime-arguments</a></h2>
<p>The <code>late_bound_lifetime_arguments</code> lint detects generic lifetime
arguments in path segments with late bound lifetime parameters.</p>
<h3 id="example-67"><a class="header" href="#example-67">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">struct S;

impl S {
    fn late&lt;'a, 'b&gt;(self, _: &amp;'a u8, _: &amp;'b u8) {}
}

fn main() {
    S.late::&lt;'static&gt;(&amp;0, &amp;0);
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present
 --&gt; lint_example.rs:8:14
  |
4 |     fn late&lt;'a, 'b&gt;(self, _: &amp;'a u8, _: &amp;'b u8) {}
  |             -- the late bound lifetime parameter is introduced here
...
8 |     S.late::&lt;'static&gt;(&amp;0, &amp;0);
  |              ^^^^^^^
  |
  = note: `#[warn(late_bound_lifetime_arguments)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #42868 &lt;https://github.com/rust-lang/rust/issues/42868&gt;

</code></pre>
<h3 id="explanation-69"><a class="header" href="#explanation-69">Explanation</a></h3>
<p>It is not clear how to provide arguments for early-bound lifetime
parameters if they are intermixed with late-bound parameters in the
same list. For now, providing any explicit arguments will trigger this
lint if late-bound parameters are present, so in the future a solution
can be adopted without hitting backward compatibility issues. This is
a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the
future. See <a href="https://github.com/rust-lang/rust/issues/42868">issue #42868</a> for more details, along with a description
of the difference between early and late-bound parameters.</p>
<h2 id="legacy-derive-helpers"><a class="header" href="#legacy-derive-helpers">legacy-derive-helpers</a></h2>
<p>The <code>legacy_derive_helpers</code> lint detects derive helper attributes
that are used before they are introduced.</p>
<h3 id="example-68"><a class="header" href="#example-68">Example</a></h3>
<pre><code class="language-rust ignore (needs extern crate)">#[serde(rename_all = &quot;camelCase&quot;)]
#[derive(Deserialize)]
struct S { /* fields */ }
</code></pre>
<p>produces:</p>
<pre><code class="language-text">warning: derive helper attribute is used before it is introduced
  --&gt; $DIR/legacy-derive-helpers.rs:1:3
   |
 1 | #[serde(rename_all = &quot;camelCase&quot;)]
   |   ^^^^^
...
 2 | #[derive(Deserialize)]
   |          ----------- the attribute is introduced here
</code></pre>
<h3 id="explanation-70"><a class="header" href="#explanation-70">Explanation</a></h3>
<p>Attributes like this work for historical reasons, but attribute expansion works in
left-to-right order in general, so, to resolve <code>#[serde]</code>, compiler has to try to &quot;look
into the future&quot; at not yet expanded part of the item , but such attempts are not always
reliable.</p>
<p>To fix the warning place the helper attribute after its corresponding derive.</p>
<pre><code class="language-rust ignore (needs extern crate)">#[derive(Deserialize)]
#[serde(rename_all = &quot;camelCase&quot;)]
struct S { /* fields */ }
</code></pre>
<h2 id="mixed-script-confusables"><a class="header" href="#mixed-script-confusables">mixed-script-confusables</a></h2>
<p>The <code>mixed_script_confusables</code> lint detects visually confusable
characters in identifiers between different <a href="https://en.wikipedia.org/wiki/Script_(Unicode)">scripts</a>.</p>
<h3 id="example-69"><a class="header" href="#example-69">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The Japanese katakana character エ can be confused with the Han character 工.
const エ: &amp;'static str = &quot;アイウ&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the usage of Script Group `Japanese, Katakana` in this crate consists solely of mixed script confusables
 --&gt; lint_example.rs:3:7
  |
3 | const エ: &amp;'static str = &quot;アイウ&quot;;
  |       ^^
  |
  = note: `#[warn(mixed_script_confusables)]` on by default
  = note: the usage includes 'エ' (U+30A8)
  = note: please recheck to make sure their usages are indeed what you want

</code></pre>
<h3 id="explanation-71"><a class="header" href="#explanation-71">Explanation</a></h3>
<p>This lint warns when characters between different scripts may appear
visually similar, which can cause confusion.</p>
<p>If the crate contains other identifiers in the same script that have
non-confusable characters, then this lint will <em>not</em> be issued. For
example, if the example given above has another identifier with
katakana characters (such as <code>let カタカナ = 123;</code>), then this indicates
that you are intentionally using katakana, and it will not warn about
it.</p>
<p>Note that the set of confusable characters may change over time.
Beware that if you &quot;forbid&quot; this lint that existing code may fail in
the future.</p>
<h2 id="mutable-borrow-reservation-conflict"><a class="header" href="#mutable-borrow-reservation-conflict">mutable-borrow-reservation-conflict</a></h2>
<p>The <code>mutable_borrow_reservation_conflict</code> lint detects the reservation
of a two-phased borrow that conflicts with other shared borrows.</p>
<h3 id="example-70"><a class="header" href="#example-70">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![0, 1, 2];
let shared = &amp;v;
v.push(shared.len());
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; lint_example.rs:4:1
  |
3 | let shared = &amp;v;
  |              -- immutable borrow occurs here
4 | v.push(shared.len());
  | ^^^^^^^------------^
  | |      |
  | |      immutable borrow later used here
  | mutable borrow occurs here
  |
  = note: `#[warn(mutable_borrow_reservation_conflict)]` on by default
  = warning: this borrowing pattern was not meant to be accepted, and may become a hard error in the future
  = note: for more information, see issue #59159 &lt;https://github.com/rust-lang/rust/issues/59159&gt;

</code></pre>
<h3 id="explanation-72"><a class="header" href="#explanation-72">Explanation</a></h3>
<p>This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error
in the future. See <a href="https://github.com/rust-lang/rust/issues/59159">issue #59159</a> for a complete description of the
problem, and some possible solutions.</p>
<h2 id="no-mangle-generic-items"><a class="header" href="#no-mangle-generic-items">no-mangle-generic-items</a></h2>
<p>The <code>no_mangle_generic_items</code> lint detects generic items that must be
mangled.</p>
<h3 id="example-71"><a class="header" href="#example-71">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
fn foo&lt;T&gt;(t: T) {

}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: functions generic over types or consts must be mangled
 --&gt; lint_example.rs:3:1
  |
2 |   #[no_mangle]
  |   ------------ help: remove this attribute
3 | / fn foo&lt;T&gt;(t: T) {
4 | |
5 | | }
  | |_^
  |
  = note: `#[warn(no_mangle_generic_items)]` on by default

</code></pre>
<h3 id="explanation-73"><a class="header" href="#explanation-73">Explanation</a></h3>
<p>A function with generics must have its symbol mangled to accommodate
the generic parameter. The <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>no_mangle</code> attribute</a> has no effect in
this situation, and should be removed.</p>
<h2 id="non-camel-case-types"><a class="header" href="#non-camel-case-types">non-camel-case-types</a></h2>
<p>The <code>non_camel_case_types</code> lint detects types, variants, traits and
type parameters that don't have camel case names.</p>
<h3 id="example-72"><a class="header" href="#example-72">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct my_struct;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type `my_struct` should have an upper camel case name
 --&gt; lint_example.rs:2:8
  |
2 | struct my_struct;
  |        ^^^^^^^^^ help: convert the identifier to upper camel case: `MyStruct`
  |
  = note: `#[warn(non_camel_case_types)]` on by default

</code></pre>
<h3 id="explanation-74"><a class="header" href="#explanation-74">Explanation</a></h3>
<p>The preferred style for these identifiers is to use &quot;camel case&quot;, such
as <code>MyStruct</code>, where the first letter should not be lowercase, and
should not use underscores between letters. Underscores are allowed at
the beginning and end of the identifier, as well as between
non-letters (such as <code>X86_64</code>).</p>
<h2 id="non-fmt-panics"><a class="header" href="#non-fmt-panics">non-fmt-panics</a></h2>
<p>The <code>non_fmt_panics</code> lint detects <code>panic!(..)</code> invocations where the first
argument is not a formatting string.</p>
<h3 id="example-73"><a class="header" href="#example-73">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>panic!(&quot;{}&quot;);
panic!(123);
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: panic message contains an unused formatting placeholder
 --&gt; lint_example.rs:2:9
  |
2 | panic!(&quot;{}&quot;);
  |         ^^
  |
  = note: `#[warn(non_fmt_panics)]` on by default
  = note: this message is not used as a format string when given without arguments, but will be in Rust 2021
help: add the missing argument
  |
2 | panic!(&quot;{}&quot;, ...);
  |            +++++
help: or add a &quot;{}&quot; format string to use the message literally
  |
2 | panic!(&quot;{}&quot;, &quot;{}&quot;);
  |        +++++

</code></pre>
<h3 id="explanation-75"><a class="header" href="#explanation-75">Explanation</a></h3>
<p>In Rust 2018 and earlier, <code>panic!(x)</code> directly uses <code>x</code> as the message.
That means that <code>panic!(&quot;{}&quot;)</code> panics with the message <code>&quot;{}&quot;</code> instead
of using it as a formatting string, and <code>panic!(123)</code> will panic with
an <code>i32</code> as message.</p>
<p>Rust 2021 always interprets the first argument as format string.</p>
<h2 id="non-shorthand-field-patterns"><a class="header" href="#non-shorthand-field-patterns">non-shorthand-field-patterns</a></h2>
<p>The <code>non_shorthand_field_patterns</code> lint detects using <code>Struct { x: x }</code>
instead of <code>Struct { x }</code> in a pattern.</p>
<h3 id="example-74"><a class="header" href="#example-74">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}


fn main() {
    let p = Point {
        x: 5,
        y: 5,
    };

    match p {
        Point { x: x, y: y } =&gt; (),
    }
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the `x:` in this pattern is redundant
  --&gt; lint_example.rs:14:17
   |
14 |         Point { x: x, y: y } =&gt; (),
   |                 ^^^^ help: use shorthand field pattern: `x`
   |
   = note: `#[warn(non_shorthand_field_patterns)]` on by default

</code></pre>
<h3 id="explanation-76"><a class="header" href="#explanation-76">Explanation</a></h3>
<p>The preferred style is to avoid the repetition of specifying both the
field name and the binding name if both identifiers are the same.</p>
<h2 id="non-snake-case"><a class="header" href="#non-snake-case">non-snake-case</a></h2>
<p>The <code>non_snake_case</code> lint detects variables, methods, functions,
lifetime parameters and modules that don't have snake case names.</p>
<h3 id="example-75"><a class="header" href="#example-75">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let MY_VALUE = 5;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: variable `MY_VALUE` should have a snake case name
 --&gt; lint_example.rs:2:5
  |
2 | let MY_VALUE = 5;
  |     ^^^^^^^^ help: convert the identifier to snake case: `my_value`
  |
  = note: `#[warn(non_snake_case)]` on by default

</code></pre>
<h3 id="explanation-77"><a class="header" href="#explanation-77">Explanation</a></h3>
<p>The preferred style for these identifiers is to use &quot;snake case&quot;,
where all the characters are in lowercase, with words separated with a
single underscore, such as <code>my_value</code>.</p>
<h2 id="non-upper-case-globals"><a class="header" href="#non-upper-case-globals">non-upper-case-globals</a></h2>
<p>The <code>non_upper_case_globals</code> lint detects static items that don't have
uppercase identifiers.</p>
<h3 id="example-76"><a class="header" href="#example-76">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static max_points: i32 = 5;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: static variable `max_points` should have an upper case name
 --&gt; lint_example.rs:2:8
  |
2 | static max_points: i32 = 5;
  |        ^^^^^^^^^^ help: convert the identifier to upper case: `MAX_POINTS`
  |
  = note: `#[warn(non_upper_case_globals)]` on by default

</code></pre>
<h3 id="explanation-78"><a class="header" href="#explanation-78">Explanation</a></h3>
<p>The preferred style is for static item names to use all uppercase
letters such as <code>MAX_POINTS</code>.</p>
<h2 id="nontrivial-structural-match"><a class="header" href="#nontrivial-structural-match">nontrivial-structural-match</a></h2>
<p>The <code>nontrivial_structural_match</code> lint detects constants that are used in patterns,
whose type is not structural-match and whose initializer body actually uses values
that are not structural-match. So <code>Option&lt;NotStruturalMatch&gt;</code> is ok if the constant
is just <code>None</code>.</p>
<h3 id="example-77"><a class="header" href="#example-77">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(nontrivial_structural_match)]

#[derive(Copy, Clone, Debug)]
struct NoDerive(u32);
impl PartialEq for NoDerive { fn eq(&amp;self, _: &amp;Self) -&gt; bool { false } }
impl Eq for NoDerive { }
fn main() {
    const INDEX: Option&lt;NoDerive&gt; = [None, Some(NoDerive(10))][0];
    match None { Some(_) =&gt; panic!(&quot;whoops&quot;), INDEX =&gt; dbg!(INDEX), };
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: to use a constant of type `NoDerive` in a pattern, the constant's initializer must be trivial or `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`
 --&gt; lint_example.rs:9:47
  |
9 |     match None { Some(_) =&gt; panic!(&quot;whoops&quot;), INDEX =&gt; dbg!(INDEX), };
  |                                               ^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(nontrivial_structural_match)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #73448 &lt;https://github.com/rust-lang/rust/issues/73448&gt;

</code></pre>
<h3 id="explanation-79"><a class="header" href="#explanation-79">Explanation</a></h3>
<p>Previous versions of Rust accepted constants in patterns, even if those constants's types
did not have <code>PartialEq</code> derived. Thus the compiler falls back to runtime execution of
<code>PartialEq</code>, which can report that two constants are not equal even if they are
bit-equivalent.</p>
<h2 id="overlapping-range-endpoints"><a class="header" href="#overlapping-range-endpoints">overlapping-range-endpoints</a></h2>
<p>The <code>overlapping_range_endpoints</code> lint detects <code>match</code> arms that have <a href="https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns">range patterns</a> that
overlap on their endpoints.</p>
<h3 id="example-78"><a class="header" href="#example-78">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 123u8;
match x {
    0..=100 =&gt; { println!(&quot;small&quot;); }
    100..=255 =&gt; { println!(&quot;large&quot;); }
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: multiple patterns overlap on their endpoints
 --&gt; lint_example.rs:5:5
  |
4 |     0..=100 =&gt; { println!(&quot;small&quot;); }
  |     ------- this range overlaps on `100_u8`...
5 |     100..=255 =&gt; { println!(&quot;large&quot;); }
  |     ^^^^^^^^^ ... with this range
  |
  = note: `#[warn(overlapping_range_endpoints)]` on by default
  = note: you likely meant to write mutually exclusive ranges

</code></pre>
<h3 id="explanation-80"><a class="header" href="#explanation-80">Explanation</a></h3>
<p>It is likely a mistake to have range patterns in a match expression that overlap in this
way. Check that the beginning and end values are what you expect, and keep in mind that
with <code>..=</code> the left and right bounds are inclusive.</p>
<h2 id="path-statements"><a class="header" href="#path-statements">path-statements</a></h2>
<p>The <code>path_statements</code> lint detects path statements with no effect.</p>
<h3 id="example-79"><a class="header" href="#example-79">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;

x;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: path statement with no effect
 --&gt; lint_example.rs:4:1
  |
4 | x;
  | ^^
  |
  = note: `#[warn(path_statements)]` on by default

</code></pre>
<h3 id="explanation-81"><a class="header" href="#explanation-81">Explanation</a></h3>
<p>It is usually a mistake to have a statement that has no effect.</p>
<h2 id="private-in-public"><a class="header" href="#private-in-public">private-in-public</a></h2>
<p>The <code>private_in_public</code> lint detects private items in public
interfaces not caught by the old implementation.</p>
<h3 id="example-80"><a class="header" href="#example-80">Example</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>struct SemiPriv;

mod m1 {
    struct Priv;
    impl super::SemiPriv {
        pub fn f(_: Priv) {}
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: private type `Priv` in public interface (error E0446)
 --&gt; lint_example.rs:7:9
  |
7 |         pub fn f(_: Priv) {}
  |         ^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(private_in_public)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #34537 &lt;https://github.com/rust-lang/rust/issues/34537&gt;

</code></pre>
<h3 id="explanation-82"><a class="header" href="#explanation-82">Explanation</a></h3>
<p>The visibility rules are intended to prevent exposing private items in
public interfaces. This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition
this to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/34537">issue #34537</a> for more
details.</p>
<h2 id="redundant-semicolons"><a class="header" href="#redundant-semicolons">redundant-semicolons</a></h2>
<p>The <code>redundant_semicolons</code> lint detects unnecessary trailing
semicolons.</p>
<h3 id="example-81"><a class="header" href="#example-81">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = 123;;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary trailing semicolon
 --&gt; lint_example.rs:2:13
  |
2 | let _ = 123;;
  |             ^ help: remove this semicolon
  |
  = note: `#[warn(redundant_semicolons)]` on by default

</code></pre>
<h3 id="explanation-83"><a class="header" href="#explanation-83">Explanation</a></h3>
<p>Extra semicolons are not needed, and may be removed to avoid confusion
and visual clutter.</p>
<h2 id="renamed-and-removed-lints"><a class="header" href="#renamed-and-removed-lints">renamed-and-removed-lints</a></h2>
<p>The <code>renamed_and_removed_lints</code> lint detects lints that have been
renamed or removed.</p>
<h3 id="example-82"><a class="header" href="#example-82">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![deny(raw_pointer_derive)]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: lint `raw_pointer_derive` has been removed: using derive with raw pointers is ok
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(raw_pointer_derive)]
  |         ^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(renamed_and_removed_lints)]` on by default

</code></pre>
<h3 id="explanation-84"><a class="header" href="#explanation-84">Explanation</a></h3>
<p>To fix this, either remove the lint or use the new name. This can help
avoid confusion about lints that are no longer valid, and help
maintain consistency for renamed lints.</p>
<h2 id="semicolon-in-expressions-from-macros"><a class="header" href="#semicolon-in-expressions-from-macros">semicolon-in-expressions-from-macros</a></h2>
<p>The <code>semicolon_in_expressions_from_macros</code> lint detects trailing semicolons
in macro bodies when the macro is invoked in expression position.
This was previous accepted, but is being phased out.</p>
<h3 id="example-83"><a class="header" href="#example-83">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(semicolon_in_expressions_from_macros)]
macro_rules! foo {
    () =&gt; { true; }
}

fn main() {
    let val = match true {
        true =&gt; false,
        _ =&gt; foo!()
    };
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: trailing semicolon in macro used in expression position
 --&gt; lint_example.rs:3:17
  |
3 |     () =&gt; { true; }
  |                 ^
...
9 |         _ =&gt; foo!()
  |              ------ in this macro invocation
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(semicolon_in_expressions_from_macros)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #79813 &lt;https://github.com/rust-lang/rust/issues/79813&gt;
  = note: this error originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)

</code></pre>
<h3 id="explanation-85"><a class="header" href="#explanation-85">Explanation</a></h3>
<p>Previous, Rust ignored trailing semicolon in a macro
body when a macro was invoked in expression position.
However, this makes the treatment of semicolons in the language
inconsistent, and could lead to unexpected runtime behavior
in some circumstances (e.g. if the macro author expects
a value to be dropped).</p>
<p>This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this
to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/79813">issue #79813</a> for more details.</p>
<h2 id="stable-features"><a class="header" href="#stable-features">stable-features</a></h2>
<p>The <code>stable_features</code> lint detects a <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a> that
has since been made stable.</p>
<h3 id="example-84"><a class="header" href="#example-84">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">#![feature(test_accepted_feature)]
fn main() {}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the feature `test_accepted_feature` has been stable since 1.0.0 and no longer requires an attribute to enable
 --&gt; lint_example.rs:1:12
  |
1 | #![feature(test_accepted_feature)]
  |            ^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(stable_features)]` on by default

</code></pre>
<h3 id="explanation-86"><a class="header" href="#explanation-86">Explanation</a></h3>
<p>When a feature is stabilized, it is no longer necessary to include a
<code>#![feature]</code> attribute for it. To fix, simply remove the
<code>#![feature]</code> attribute.</p>
<h2 id="temporary-cstring-as-ptr"><a class="header" href="#temporary-cstring-as-ptr">temporary-cstring-as-ptr</a></h2>
<p>The <code>temporary_cstring_as_ptr</code> lint detects getting the inner pointer of
a temporary <code>CString</code>.</p>
<h3 id="example-85"><a class="header" href="#example-85">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(unused)]
</span><span class="boring">use std::ffi::CString;
</span>let c_str = CString::new(&quot;foo&quot;).unwrap().as_ptr();
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: getting the inner pointer of a temporary `CString`
 --&gt; lint_example.rs:4:42
  |
4 | let c_str = CString::new(&quot;foo&quot;).unwrap().as_ptr();
  |             ---------------------------- ^^^^^^ this pointer will be invalid
  |             |
  |             this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime
  |
  = note: `#[warn(temporary_cstring_as_ptr)]` on by default
  = note: pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned
  = help: for more information, see https://doc.rust-lang.org/reference/destructors.html

</code></pre>
<h3 id="explanation-87"><a class="header" href="#explanation-87">Explanation</a></h3>
<p>The inner pointer of a <code>CString</code> lives only as long as the <code>CString</code> it
points to. Getting the inner pointer of a <em>temporary</em> <code>CString</code> allows the <code>CString</code>
to be dropped at the end of the statement, as it is not being referenced as far as the typesystem
is concerned. This means outside of the statement the pointer will point to freed memory, which
causes undefined behavior if the pointer is later dereferenced.</p>
<h2 id="trivial-bounds"><a class="header" href="#trivial-bounds">trivial-bounds</a></h2>
<p>The <code>trivial_bounds</code> lint detects trait bounds that don't depend on
any type parameters.</p>
<h3 id="example-86"><a class="header" href="#example-86">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(trivial_bounds)]
<span class="boring">fn main() {
</span>pub struct A where i32: Copy;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: trait bound i32: Copy does not depend on any type or lifetime parameters
 --&gt; lint_example.rs:3:25
  |
3 | pub struct A where i32: Copy;
  |                         ^^^^
  |
  = note: `#[warn(trivial_bounds)]` on by default

</code></pre>
<h3 id="explanation-88"><a class="header" href="#explanation-88">Explanation</a></h3>
<p>Usually you would not write a trait bound that you know is always
true, or never true. However, when using macros, the macro may not
know whether or not the constraint would hold or not at the time when
generating the code. Currently, the compiler does not alert you if the
constraint is always true, and generates an error if it is never true.
The <code>trivial_bounds</code> feature changes this to be a warning in both
cases, giving macros more freedom and flexibility to generate code,
while still providing a signal when writing non-macro code that
something is amiss.</p>
<p>See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2056-allow-trivial-where-clause-constraints.md">RFC 2056</a> for more details. This feature is currently only
available on the nightly channel, see <a href="https://github.com/rust-lang/rust/issues/48214">tracking issue #48214</a>.</p>
<h2 id="type-alias-bounds"><a class="header" href="#type-alias-bounds">type-alias-bounds</a></h2>
<p>The <code>type_alias_bounds</code> lint detects bounds in type aliases.</p>
<h3 id="example-87"><a class="header" href="#example-87">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: bounds on generic parameters are not enforced in type aliases
 --&gt; lint_example.rs:2:17
  |
2 | type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;
  |                 ^^^^
  |
  = note: `#[warn(type_alias_bounds)]` on by default
help: the bound will not be checked when the type alias is used, and should be removed
  |
2 - type SendVec&lt;T: Send&gt; = Vec&lt;T&gt;;
2 + type SendVec&lt;T&gt; = Vec&lt;T&gt;;
  | 

</code></pre>
<h3 id="explanation-89"><a class="header" href="#explanation-89">Explanation</a></h3>
<p>The trait bounds in a type alias are currently ignored, and should not
be included to avoid confusion. This was previously allowed
unintentionally; this may become a hard error in the future.</p>
<h2 id="tyvar-behind-raw-pointer"><a class="header" href="#tyvar-behind-raw-pointer">tyvar-behind-raw-pointer</a></h2>
<p>The <code>tyvar_behind_raw_pointer</code> lint detects raw pointer to an
inference variable.</p>
<h3 id="example-88"><a class="header" href="#example-88">Example</a></h3>
<pre><pre class="playground"><code class="language-rust edition2015">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// edition 2015
let data = std::ptr::null();
let _ = &amp;data as *const *const ();

if data.is_null() {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: type annotations needed
 --&gt; lint_example.rs:6:9
  |
6 | if data.is_null() {}
  |         ^^^^^^^
  |
  = note: `#[warn(tyvar_behind_raw_pointer)]` on by default
  = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2018!
  = note: for more information, see issue #46906 &lt;https://github.com/rust-lang/rust/issues/46906&gt;

</code></pre>
<h3 id="explanation-90"><a class="header" href="#explanation-90">Explanation</a></h3>
<p>This kind of inference was previously allowed, but with the future
arrival of <a href="https://github.com/rust-lang/rust/issues/44874">arbitrary self types</a>, this can introduce ambiguity. To
resolve this, use an explicit type instead of relying on type
inference.</p>
<p>This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard
error in the 2018 edition. See <a href="https://github.com/rust-lang/rust/issues/46906">issue #46906</a> for more details. This
is currently a hard-error on the 2018 edition, and is &quot;warn&quot; by
default in the 2015 edition.</p>
<h2 id="unaligned-references"><a class="header" href="#unaligned-references">unaligned-references</a></h2>
<p>The <code>unaligned_references</code> lint detects unaligned references to fields
of <a href="https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers">packed</a> structs.</p>
<h3 id="example-89"><a class="header" href="#example-89">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(unaligned_references)]

#[repr(packed)]
pub struct Foo {
    field1: u64,
    field2: u8,
}

fn main() {
    unsafe {
        let foo = Foo { field1: 0, field2: 0 };
        let _ = &amp;foo.field1;
        println!(&quot;{}&quot;, foo.field1); // An implicit `&amp;` is added here, triggering the lint.
    }
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: reference to packed field is unaligned
  --&gt; lint_example.rs:12:17
   |
12 |         let _ = &amp;foo.field1;
   |                 ^^^^^^^^^^^
   |
note: the lint level is defined here
  --&gt; lint_example.rs:1:9
   |
1  | #![deny(unaligned_references)]
   |         ^^^^^^^^^^^^^^^^^^^^
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #82523 &lt;https://github.com/rust-lang/rust/issues/82523&gt;
   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)
   = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)

</code></pre>
<h3 id="explanation-91"><a class="header" href="#explanation-91">Explanation</a></h3>
<p>Creating a reference to an insufficiently aligned packed field is <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a> and
should be disallowed. Using an <code>unsafe</code> block does not change anything about this. Instead,
the code should do a copy of the data in the packed field or use raw pointers and unaligned
accesses. See <a href="https://github.com/rust-lang/rust/issues/82523">issue #82523</a> for more information.</p>
<h2 id="uncommon-codepoints"><a class="header" href="#uncommon-codepoints">uncommon-codepoints</a></h2>
<p>The <code>uncommon_codepoints</code> lint detects uncommon Unicode codepoints in
identifiers.</p>
<h3 id="example-90"><a class="header" href="#example-90">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(unused)]
</span>const µ: f64 = 0.000001;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: identifier contains uncommon Unicode codepoints
 --&gt; lint_example.rs:3:7
  |
3 | const µ: f64 = 0.000001;
  |       ^
  |
  = note: `#[warn(uncommon_codepoints)]` on by default

</code></pre>
<h3 id="explanation-92"><a class="header" href="#explanation-92">Explanation</a></h3>
<p>This lint warns about using characters which are not commonly used, and may
cause visual confusion.</p>
<p>This lint is triggered by identifiers that contain a codepoint that is
not part of the set of &quot;Allowed&quot; codepoints as described by <a href="https://www.unicode.org/reports/tr39/#General_Security_Profile">Unicode®
Technical Standard #39 Unicode Security Mechanisms Section 3.1 General
Security Profile for Identifiers</a>.</p>
<p>Note that the set of uncommon codepoints may change over time. Beware
that if you &quot;forbid&quot; this lint that existing code may fail in the
future.</p>
<h2 id="unconditional-recursion"><a class="header" href="#unconditional-recursion">unconditional-recursion</a></h2>
<p>The <code>unconditional_recursion</code> lint detects functions that cannot
return without calling themselves.</p>
<h3 id="example-91"><a class="header" href="#example-91">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() {
    foo();
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: function cannot return without recursing
 --&gt; lint_example.rs:2:1
  |
2 | fn foo() {
  | ^^^^^^^^ cannot return without recursing
3 |     foo();
  |     ----- recursive call site
  |
  = note: `#[warn(unconditional_recursion)]` on by default
  = help: a `loop` may express intention better if this is on purpose

</code></pre>
<h3 id="explanation-93"><a class="header" href="#explanation-93">Explanation</a></h3>
<p>It is usually a mistake to have a recursive call that does not have
some condition to cause it to terminate. If you really intend to have
an infinite loop, using a <code>loop</code> expression is recommended.</p>
<h2 id="undefined-naked-function-abi"><a class="header" href="#undefined-naked-function-abi">undefined-naked-function-abi</a></h2>
<p>The <code>undefined_naked_function_abi</code> lint detects naked function definitions that
either do not specify an ABI or specify the Rust ABI.</p>
<h3 id="example-92"><a class="header" href="#example-92">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(naked_functions)]

<span class="boring">fn main() {
</span>use std::arch::asm;

#[naked]
pub fn default_abi() -&gt; u32 {
    unsafe { asm!(&quot;&quot;, options(noreturn)); }
}

#[naked]
pub extern &quot;Rust&quot; fn rust_abi() -&gt; u32 {
    unsafe { asm!(&quot;&quot;, options(noreturn)); }
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: Rust ABI is unsupported in naked functions
 --&gt; lint_example.rs:7:8
  |
7 | pub fn default_abi() -&gt; u32 {
  |        ^^^^^^^^^^^
  |
  = note: `#[warn(undefined_naked_function_abi)]` on by default

</code></pre>
<h3 id="explanation-94"><a class="header" href="#explanation-94">Explanation</a></h3>
<p>The Rust ABI is currently undefined. Therefore, naked functions should
specify a non-Rust ABI.</p>
<h2 id="uninhabited-static"><a class="header" href="#uninhabited-static">uninhabited-static</a></h2>
<p>The <code>uninhabited_static</code> lint detects uninhabited statics.</p>
<h3 id="example-93"><a class="header" href="#example-93">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Void {}
extern {
    static EXTERN: Void;
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: static of uninhabited type
 --&gt; lint_example.rs:4:5
  |
4 |     static EXTERN: Void;
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(uninhabited_static)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #74840 &lt;https://github.com/rust-lang/rust/issues/74840&gt;
  = note: uninhabited statics cannot be initialized, and any access would be an immediate error

</code></pre>
<h3 id="explanation-95"><a class="header" href="#explanation-95">Explanation</a></h3>
<p>Statics with an uninhabited type can never be initialized, so they are impossible to define.
However, this can be side-stepped with an <code>extern static</code>, leading to problems later in the
compiler which assumes that there are no initialized uninhabited places (such as locals or
statics). This was accidentally allowed, but is being phased out.</p>
<h2 id="unknown-lints"><a class="header" href="#unknown-lints">unknown-lints</a></h2>
<p>The <code>unknown_lints</code> lint detects unrecognized lint attribute.</p>
<h3 id="example-94"><a class="header" href="#example-94">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![allow(not_a_real_lint)]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unknown lint: `not_a_real_lint`
 --&gt; lint_example.rs:1:10
  |
1 | #![allow(not_a_real_lint)]
  |          ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unknown_lints)]` on by default

</code></pre>
<h3 id="explanation-96"><a class="header" href="#explanation-96">Explanation</a></h3>
<p>It is usually a mistake to specify a lint that does not exist. Check
the spelling, and check the lint listing for the correct name. Also
consider if you are using an old version of the compiler, and the lint
is only available in a newer version.</p>
<h2 id="unnameable-test-items"><a class="header" href="#unnameable-test-items">unnameable-test-items</a></h2>
<p>The <code>unnameable_test_items</code> lint detects <a href="https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a> functions
that are not able to be run by the test harness because they are in a
position where they are not nameable.</p>
<h3 id="example-95"><a class="header" href="#example-95">Example</a></h3>
<pre><pre class="playground"><code class="language-rust test">fn main() {
    #[test]
    fn foo() {
        // This test will not fail because it does not run.
        assert_eq!(1, 2);
    }
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot test inner items
 --&gt; lint_example.rs:2:5
  |
2 |     #[test]
  |     ^^^^^^^
  |
  = note: `#[warn(unnameable_test_items)]` on by default
  = note: this warning originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)

</code></pre>
<h3 id="explanation-97"><a class="header" href="#explanation-97">Explanation</a></h3>
<p>In order for the test harness to run a test, the test function must be
located in a position where it can be accessed from the crate root.
This generally means it must be defined in a module, and not anywhere
else such as inside another function. The compiler previously allowed
this without an error, so a lint was added as an alert that a test is
not being used. Whether or not this should be allowed has not yet been
decided, see <a href="https://github.com/rust-lang/rfcs/pull/2471#issuecomment-397414443">RFC 2471</a> and <a href="https://github.com/rust-lang/rust/issues/36629">issue #36629</a>.</p>
<h2 id="unreachable-code"><a class="header" href="#unreachable-code">unreachable-code</a></h2>
<p>The <code>unreachable_code</code> lint detects unreachable code paths.</p>
<h3 id="example-96"><a class="header" href="#example-96">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>panic!(&quot;we never go past here!&quot;);

let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unreachable statement
 --&gt; lint_example.rs:4:1
  |
2 | panic!(&quot;we never go past here!&quot;);
  | -------------------------------- any code following this expression is unreachable
3 | 
4 | let x = 5;
  | ^^^^^^^^^^ unreachable statement
  |
  = note: `#[warn(unreachable_code)]` on by default

</code></pre>
<h3 id="explanation-98"><a class="header" href="#explanation-98">Explanation</a></h3>
<p>Unreachable code may signal a mistake or unfinished code. If the code
is no longer in use, consider removing it.</p>
<h2 id="unreachable-patterns"><a class="header" href="#unreachable-patterns">unreachable-patterns</a></h2>
<p>The <code>unreachable_patterns</code> lint detects unreachable patterns.</p>
<h3 id="example-97"><a class="header" href="#example-97">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
match x {
    y =&gt; (),
    5 =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unreachable pattern
 --&gt; lint_example.rs:5:5
  |
4 |     y =&gt; (),
  |     - matches any value
5 |     5 =&gt; (),
  |     ^ unreachable pattern
  |
  = note: `#[warn(unreachable_patterns)]` on by default

</code></pre>
<h3 id="explanation-99"><a class="header" href="#explanation-99">Explanation</a></h3>
<p>This usually indicates a mistake in how the patterns are specified or
ordered. In this example, the <code>y</code> pattern will always match, so the
five is impossible to reach. Remember, match arms match in order, you
probably wanted to put the <code>5</code> case above the <code>y</code> case.</p>
<h2 id="unstable-name-collisions"><a class="header" href="#unstable-name-collisions">unstable-name-collisions</a></h2>
<p>The <code>unstable_name_collisions</code> lint detects that you have used a name
that the standard library plans to add in the future.</p>
<h3 id="example-98"><a class="header" href="#example-98">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyIterator : Iterator {
    // is_sorted is an unstable method that already exists on the Iterator trait
    fn is_sorted(self) -&gt; bool where Self: Sized {true}
}

impl&lt;T: ?Sized&gt; MyIterator for T where T: Iterator { }

let x = vec![1, 2, 3];
let _ = x.iter().is_sorted();
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: an associated function with this name may be added to the standard library in the future
  --&gt; lint_example.rs:10:18
   |
10 | let _ = x.iter().is_sorted();
   |                  ^^^^^^^^^
   |
   = note: `#[warn(unstable_name_collisions)]` on by default
   = warning: once this associated item is added to the standard library, the ambiguity may cause an error or change in behavior!
   = note: for more information, see issue #48919 &lt;https://github.com/rust-lang/rust/issues/48919&gt;
   = help: call with fully qualified syntax `MyIterator::is_sorted(...)` to keep using the current method
   = help: add `#![feature(is_sorted)]` to the crate attributes to enable `is_sorted`

</code></pre>
<h3 id="explanation-100"><a class="header" href="#explanation-100">Explanation</a></h3>
<p>When new methods are added to traits in the standard library, they are
usually added in an &quot;unstable&quot; form which is only available on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a> with a <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attribute</a>. If there is any
pre-existing code which extends a trait to have a method with the same
name, then the names will collide. In the future, when the method is
stabilized, this will cause an error due to the ambiguity. This lint
is an early-warning to let you know that there may be a collision in
the future. This can be avoided by adding type annotations to
disambiguate which trait method you intend to call, such as
<code>MyIterator::is_sorted(my_iter)</code> or renaming or removing the method.</p>
<h2 id="unsupported-calling-conventions"><a class="header" href="#unsupported-calling-conventions">unsupported-calling-conventions</a></h2>
<p>The <code>unsupported_calling_conventions</code> lint is output whenever there is a use of the
<code>stdcall</code>, <code>fastcall</code>, <code>thiscall</code>, <code>vectorcall</code> calling conventions (or their unwind
variants) on targets that cannot meaningfully be supported for the requested target.</p>
<p>For example <code>stdcall</code> does not make much sense for a x86_64 or, more apparently, powerpc
code, because this calling convention was never specified for those targets.</p>
<p>Historically MSVC toolchains have fallen back to the regular C calling convention for
targets other than x86, but Rust doesn't really see a similar need to introduce a similar
hack across many more targets.</p>
<h3 id="example-99"><a class="header" href="#example-99">Example</a></h3>
<pre><code class="language-rust ignore (needs specific targets)">extern &quot;stdcall&quot; fn stdcall() {}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: use of calling convention not supported on this target
  --&gt; $DIR/unsupported.rs:39:1
   |
LL | extern &quot;stdcall&quot; fn stdcall() {}
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unsupported_calling_conventions)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out;
              it will become a hard error in a future release!
   = note: for more information, see issue ...
</code></pre>
<h3 id="explanation-101"><a class="header" href="#explanation-101">Explanation</a></h3>
<p>On most of the targets the behaviour of <code>stdcall</code> and similar calling conventions is not
defined at all, but was previously accepted due to a bug in the implementation of the
compiler.</p>
<h2 id="unsupported-naked-functions"><a class="header" href="#unsupported-naked-functions">unsupported-naked-functions</a></h2>
<p>The <code>unsupported_naked_functions</code> lint detects naked function
definitions that are unsupported but were previously accepted.</p>
<h3 id="example-100"><a class="header" href="#example-100">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(naked_functions)]

<span class="boring">fn main() {
</span>#[naked]
pub extern &quot;C&quot; fn f() -&gt; u32 {
    42
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: naked functions must contain a single asm block
 --&gt; lint_example.rs:5:1
  |
5 | / pub extern &quot;C&quot; fn f() -&gt; u32 {
6 | |     42
  | |     -- non-asm is unsupported in naked functions
7 | | }
  | |_^
  |
  = note: `#[warn(unsupported_naked_functions)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #32408 &lt;https://github.com/rust-lang/rust/issues/32408&gt;

</code></pre>
<h3 id="explanation-102"><a class="header" href="#explanation-102">Explanation</a></h3>
<p>The naked functions must be defined using a single inline assembly
block.</p>
<p>The execution must never fall through past the end of the assembly
code so the block must use <code>noreturn</code> option. The asm block can also
use <code>att_syntax</code> option, but other options are not allowed.</p>
<p>The asm block must not contain any operands other than <code>const</code> and
<code>sym</code>. Additionally, naked function should specify a non-Rust ABI.</p>
<p>Naked functions cannot be inlined. All forms of the <code>inline</code> attribute
are prohibited.</p>
<p>While other definitions of naked functions were previously accepted,
they are unsupported and might not work reliably. This is a
<a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint that will transition into hard error in
the future.</p>
<h2 id="unused-allocation"><a class="header" href="#unused-allocation">unused-allocation</a></h2>
<p>The <code>unused_allocation</code> lint detects unnecessary allocations that can
be eliminated.</p>
<h3 id="example-101"><a class="header" href="#example-101">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">#![feature(box_syntax)]
fn main() {
    let a = (box [1, 2, 3]).len();
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary allocation, use `&amp;` instead
 --&gt; lint_example.rs:3:13
  |
3 |     let a = (box [1, 2, 3]).len();
  |             ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_allocation)]` on by default

</code></pre>
<h3 id="explanation-103"><a class="header" href="#explanation-103">Explanation</a></h3>
<p>When a <code>box</code> expression is immediately coerced to a reference, then
the allocation is unnecessary, and a reference (using <code>&amp;</code> or <code>&amp;mut</code>)
should be used instead to avoid the allocation.</p>
<h2 id="unused-assignments"><a class="header" href="#unused-assignments">unused-assignments</a></h2>
<p>The <code>unused_assignments</code> lint detects assignments that will never be read.</p>
<h3 id="example-102"><a class="header" href="#example-102">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
x = 6;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: value assigned to `x` is never read
 --&gt; lint_example.rs:3:1
  |
3 | x = 6;
  | ^
  |
  = note: `#[warn(unused_assignments)]` on by default
  = help: maybe it is overwritten before being read?

</code></pre>
<h3 id="explanation-104"><a class="header" href="#explanation-104">Explanation</a></h3>
<p>Unused assignments may signal a mistake or unfinished code. If the
variable is never used after being assigned, then the assignment can
be removed. Variables with an underscore prefix such as <code>_x</code> will not
trigger this lint.</p>
<h2 id="unused-attributes"><a class="header" href="#unused-attributes">unused-attributes</a></h2>
<p>The <code>unused_attributes</code> lint detects attributes that were not used by
the compiler.</p>
<h3 id="example-103"><a class="header" href="#example-103">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![ignore]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: `#[ignore]` only has an effect on functions
 --&gt; lint_example.rs:1:1
  |
1 | #![ignore]
  | ^^^^^^^^^^
  |
  = note: `#[warn(unused_attributes)]` on by default

</code></pre>
<h3 id="explanation-105"><a class="header" href="#explanation-105">Explanation</a></h3>
<p>Unused <a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a> may indicate the attribute is placed in the wrong
position. Consider removing it, or placing it in the correct position.
Also consider if you intended to use an <em>inner attribute</em> (with a <code>!</code>
such as <code>#![allow(unused)]</code>) which applies to the item the attribute
is within, or an <em>outer attribute</em> (without a <code>!</code> such as
<code>#[allow(unused)]</code>) which applies to the item <em>following</em> the
attribute.</p>
<h2 id="unused-braces"><a class="header" href="#unused-braces">unused-braces</a></h2>
<p>The <code>unused_braces</code> lint detects unnecessary braces around an
expression.</p>
<h3 id="example-104"><a class="header" href="#example-104">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if { true } {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary braces around `if` condition
 --&gt; lint_example.rs:2:4
  |
2 | if { true } {
  |    ^^    ^^
  |
  = note: `#[warn(unused_braces)]` on by default
help: remove these braces
  |
2 - if { true } {
2 + if true {
  | 

</code></pre>
<h3 id="explanation-106"><a class="header" href="#explanation-106">Explanation</a></h3>
<p>The braces are not needed, and should be removed. This is the
preferred style for writing these expressions.</p>
<h2 id="unused-comparisons"><a class="header" href="#unused-comparisons">unused-comparisons</a></h2>
<p>The <code>unused_comparisons</code> lint detects comparisons made useless by
limits of the types involved.</p>
<h3 id="example-105"><a class="header" href="#example-105">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo(x: u8) {
    x &gt;= 0;
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: comparison is useless due to type limits
 --&gt; lint_example.rs:3:5
  |
3 |     x &gt;= 0;
  |     ^^^^^^
  |
  = note: `#[warn(unused_comparisons)]` on by default

</code></pre>
<h3 id="explanation-107"><a class="header" href="#explanation-107">Explanation</a></h3>
<p>A useless comparison may indicate a mistake, and should be fixed or
removed.</p>
<h2 id="unused-doc-comments"><a class="header" href="#unused-doc-comments">unused-doc-comments</a></h2>
<p>The <code>unused_doc_comments</code> lint detects doc comments that aren't used
by <code>rustdoc</code>.</p>
<h3 id="example-106"><a class="header" href="#example-106">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// docs for x
let x = 12;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused doc comment
 --&gt; lint_example.rs:2:1
  |
2 | /// docs for x
  | ^^^^^^^^^^^^^^
3 | let x = 12;
  | ----------- rustdoc does not generate documentation for statements
  |
  = note: `#[warn(unused_doc_comments)]` on by default
  = help: use `//` for a plain comment

</code></pre>
<h3 id="explanation-108"><a class="header" href="#explanation-108">Explanation</a></h3>
<p><code>rustdoc</code> does not use doc comments in all positions, and so the doc
comment will be ignored. Try changing it to a normal comment with <code>//</code>
to avoid the warning.</p>
<h2 id="unused-features"><a class="header" href="#unused-features">unused-features</a></h2>
<p>The <code>unused_features</code> lint detects unused or unknown features found in
crate-level <a href="https://doc.rust-lang.org/nightly/unstable-book/"><code>feature</code> attributes</a>.</p>
<p>Note: This lint is currently not functional, see <a href="https://github.com/rust-lang/rust/issues/44232">issue #44232</a> for
more details.</p>
<h2 id="unused-imports"><a class="header" href="#unused-imports">unused-imports</a></h2>
<p>The <code>unused_imports</code> lint detects imports that are never used.</p>
<h3 id="example-107"><a class="header" href="#example-107">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused import: `std::collections::HashMap`
 --&gt; lint_example.rs:2:5
  |
2 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

</code></pre>
<h3 id="explanation-109"><a class="header" href="#explanation-109">Explanation</a></h3>
<p>Unused imports may signal a mistake or unfinished code, and clutter
the code, and should be removed. If you intended to re-export the item
to make it available outside of the module, add a visibility modifier
like <code>pub</code>.</p>
<h2 id="unused-labels"><a class="header" href="#unused-labels">unused-labels</a></h2>
<p>The <code>unused_labels</code> lint detects <a href="https://doc.rust-lang.org/reference/expressions/loop-expr.html#loop-labels">labels</a> that are never used.</p>
<h3 id="example-108"><a class="header" href="#example-108">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>'unused_label: loop {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused label
 --&gt; lint_example.rs:2:1
  |
2 | 'unused_label: loop {}
  | ^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_labels)]` on by default

</code></pre>
<h3 id="explanation-110"><a class="header" href="#explanation-110">Explanation</a></h3>
<p>Unused labels may signal a mistake or unfinished code. To silence the
warning for the individual label, prefix it with an underscore such as
<code>'_my_label:</code>.</p>
<h2 id="unused-macros"><a class="header" href="#unused-macros">unused-macros</a></h2>
<p>The <code>unused_macros</code> lint detects macros that were not used.</p>
<h3 id="example-109"><a class="header" href="#example-109">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">macro_rules! unused {
    () =&gt; {};
}

fn main() {
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused macro definition: `unused`
 --&gt; lint_example.rs:1:14
  |
1 | macro_rules! unused {
  |              ^^^^^^
  |
  = note: `#[warn(unused_macros)]` on by default

</code></pre>
<h3 id="explanation-111"><a class="header" href="#explanation-111">Explanation</a></h3>
<p>Unused macros may signal a mistake or unfinished code. To silence the
warning for the individual macro, prefix the name with an underscore
such as <code>_my_macro</code>. If you intended to export the macro to make it
available outside of the crate, use the <a href="https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope"><code>macro_export</code> attribute</a>.</p>
<h2 id="unused-must-use"><a class="header" href="#unused-must-use">unused-must-use</a></h2>
<p>The <code>unused_must_use</code> lint detects unused result of a type flagged as
<code>#[must_use]</code>.</p>
<h3 id="example-110"><a class="header" href="#example-110">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">fn returns_result() -&gt; Result&lt;(), ()&gt; {
    Ok(())
}

fn main() {
    returns_result();
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused `Result` that must be used
 --&gt; lint_example.rs:6:5
  |
6 |     returns_result();
  |     ^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_must_use)]` on by default
  = note: this `Result` may be an `Err` variant, which should be handled

</code></pre>
<h3 id="explanation-112"><a class="header" href="#explanation-112">Explanation</a></h3>
<p>The <code>#[must_use]</code> attribute is an indicator that it is a mistake to
ignore the value. See <a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute">the reference</a> for more details.</p>
<h2 id="unused-mut"><a class="header" href="#unused-mut">unused-mut</a></h2>
<p>The <code>unused_mut</code> lint detects mut variables which don't need to be
mutable.</p>
<h3 id="example-111"><a class="header" href="#example-111">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: variable does not need to be mutable
 --&gt; lint_example.rs:2:5
  |
2 | let mut x = 5;
  |     ----^
  |     |
  |     help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

</code></pre>
<h3 id="explanation-113"><a class="header" href="#explanation-113">Explanation</a></h3>
<p>The preferred style is to only mark variables as <code>mut</code> if it is
required.</p>
<h2 id="unused-parens"><a class="header" href="#unused-parens">unused-parens</a></h2>
<p>The <code>unused_parens</code> lint detects <code>if</code>, <code>match</code>, <code>while</code> and <code>return</code>
with parentheses; they do not need them.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if(true) {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary parentheses around `if` condition
 --&gt; lint_example.rs:2:3
  |
2 | if(true) {}
  |   ^    ^
  |
  = note: `#[warn(unused_parens)]` on by default
help: remove these parentheses
  |
2 - if(true) {}
2 + if true {}
  | 

</code></pre>
<h3 id="explanation-114"><a class="header" href="#explanation-114">Explanation</a></h3>
<p>The parentheses are not needed, and should be removed. This is the
preferred style for writing these expressions.</p>
<h2 id="unused-unsafe"><a class="header" href="#unused-unsafe">unused-unsafe</a></h2>
<p>The <code>unused_unsafe</code> lint detects unnecessary use of an <code>unsafe</code> block.</p>
<h3 id="example-112"><a class="header" href="#example-112">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unnecessary `unsafe` block
 --&gt; lint_example.rs:2:1
  |
2 | unsafe {}
  | ^^^^^^ unnecessary `unsafe` block
  |
  = note: `#[warn(unused_unsafe)]` on by default

</code></pre>
<h3 id="explanation-115"><a class="header" href="#explanation-115">Explanation</a></h3>
<p>If nothing within the block requires <code>unsafe</code>, then remove the
<code>unsafe</code> marker because it is not required and may cause confusion.</p>
<h2 id="unused-variables"><a class="header" href="#unused-variables">unused-variables</a></h2>
<p>The <code>unused_variables</code> lint detects variables which are not used in
any way.</p>
<h3 id="example-113"><a class="header" href="#example-113">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: unused variable: `x`
 --&gt; lint_example.rs:2:5
  |
2 | let x = 5;
  |     ^ help: if this is intentional, prefix it with an underscore: `_x`
  |
  = note: `#[warn(unused_variables)]` on by default

</code></pre>
<h3 id="explanation-116"><a class="header" href="#explanation-116">Explanation</a></h3>
<p>Unused variables may signal a mistake or unfinished code. To silence
the warning for the individual variable, prefix it with an underscore
such as <code>_x</code>.</p>
<h2 id="warnings"><a class="header" href="#warnings">warnings</a></h2>
<p>The <code>warnings</code> lint allows you to change the level of other
lints which produce warnings.</p>
<h3 id="example-114"><a class="header" href="#example-114">Example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![deny(warnings)]
<span class="boring">fn main() {
</span>fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: function is never used: `foo`
 --&gt; lint_example.rs:3:4
  |
3 | fn foo() {}
  |    ^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(warnings)]
  |         ^^^^^^^^
  = note: `#[deny(dead_code)]` implied by `#[deny(warnings)]`

</code></pre>
<h3 id="explanation-117"><a class="header" href="#explanation-117">Explanation</a></h3>
<p>The <code>warnings</code> lint is a bit special; by changing its level, you
change every other warning that would produce a warning to whatever
value you'd like. As such, you won't ever trigger this lint in your
code directly.</p>
<h2 id="where-clauses-object-safety"><a class="header" href="#where-clauses-object-safety">where-clauses-object-safety</a></h2>
<p>The <code>where_clauses_object_safety</code> lint detects for <a href="https://doc.rust-lang.org/reference/items/traits.html#object-safety">object safety</a> of
<a href="https://doc.rust-lang.org/reference/items/generics.html#where-clauses">where clauses</a>.</p>
<h3 id="example-115"><a class="header" href="#example-115">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run">trait Trait {}

trait X { fn foo(&amp;self) where Self: Trait; }

impl X for () { fn foo(&amp;self) {} }

impl Trait for dyn X {}

// Segfault at opt-level 0, SIGILL otherwise.
pub fn main() { &lt;dyn X as X&gt;::foo(&amp;()); }
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: the trait `X` cannot be made into an object
 --&gt; lint_example.rs:3:14
  |
3 | trait X { fn foo(&amp;self) where Self: Trait; }
  |              ^^^
  |
  = note: `#[warn(where_clauses_object_safety)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #51443 &lt;https://github.com/rust-lang/rust/issues/51443&gt;
note: for a trait to be &quot;object safe&quot; it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit &lt;https://doc.rust-lang.org/reference/items/traits.html#object-safety&gt;
 --&gt; lint_example.rs:3:14
  |
3 | trait X { fn foo(&amp;self) where Self: Trait; }
  |       -      ^^^ ...because method `foo` references the `Self` type in its `where` clause
  |       |
  |       this trait cannot be made into an object...
  = help: consider moving `foo` to another trait

</code></pre>
<h3 id="explanation-118"><a class="header" href="#explanation-118">Explanation</a></h3>
<p>The compiler previously allowed these object-unsafe bounds, which was
incorrect. This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to
a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/51443">issue #51443</a> for more details.</p>
<h2 id="while-true"><a class="header" href="#while-true">while-true</a></h2>
<p>The <code>while_true</code> lint detects <code>while true { }</code>.</p>
<h3 id="example-116"><a class="header" href="#example-116">Example</a></h3>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while true {

}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: denote infinite loops with `loop { ... }`
 --&gt; lint_example.rs:2:1
  |
2 | while true {
  | ^^^^^^^^^^ help: use `loop`
  |
  = note: `#[warn(while_true)]` on by default

</code></pre>
<h3 id="explanation-119"><a class="header" href="#explanation-119">Explanation</a></h3>
<p><code>while true</code> should be replaced with <code>loop</code>. A <code>loop</code> expression is
the preferred way to write an infinite loop because it more directly
expresses the intent of the loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deny-by-default-lints"><a class="header" href="#deny-by-default-lints">Deny-by-default lints</a></h1>
<p>These lints are all set to the 'deny' level by default.</p>
<ul>
<li><a href="lints/listing/deny-by-default.html#ambiguous-associated-items"><code>ambiguous_associated_items</code></a></li>
<li><a href="lints/listing/deny-by-default.html#arithmetic-overflow"><code>arithmetic_overflow</code></a></li>
<li><a href="lints/listing/deny-by-default.html#conflicting-repr-hints"><code>conflicting_repr_hints</code></a></li>
<li><a href="lints/listing/deny-by-default.html#const-err"><code>const_err</code></a></li>
<li><a href="lints/listing/deny-by-default.html#enum-intrinsics-non-enums"><code>enum_intrinsics_non_enums</code></a></li>
<li><a href="lints/listing/deny-by-default.html#ill-formed-attribute-input"><code>ill_formed_attribute_input</code></a></li>
<li><a href="lints/listing/deny-by-default.html#incomplete-include"><code>incomplete_include</code></a></li>
<li><a href="lints/listing/deny-by-default.html#ineffective-unstable-trait-impl"><code>ineffective_unstable_trait_impl</code></a></li>
<li><a href="lints/listing/deny-by-default.html#invalid-atomic-ordering"><code>invalid_atomic_ordering</code></a></li>
<li><a href="lints/listing/deny-by-default.html#invalid-type-param-default"><code>invalid_type_param_default</code></a></li>
<li><a href="lints/listing/deny-by-default.html#macro-expanded-macro-exports-accessed-by-absolute-paths"><code>macro_expanded_macro_exports_accessed_by_absolute_paths</code></a></li>
<li><a href="lints/listing/deny-by-default.html#missing-fragment-specifier"><code>missing_fragment_specifier</code></a></li>
<li><a href="lints/listing/deny-by-default.html#mutable-transmutes"><code>mutable_transmutes</code></a></li>
<li><a href="lints/listing/deny-by-default.html#named-asm-labels"><code>named_asm_labels</code></a></li>
<li><a href="lints/listing/deny-by-default.html#no-mangle-const-items"><code>no_mangle_const_items</code></a></li>
<li><a href="lints/listing/deny-by-default.html#order-dependent-trait-objects"><code>order_dependent_trait_objects</code></a></li>
<li><a href="lints/listing/deny-by-default.html#overflowing-literals"><code>overflowing_literals</code></a></li>
<li><a href="lints/listing/deny-by-default.html#patterns-in-fns-without-body"><code>patterns_in_fns_without_body</code></a></li>
<li><a href="lints/listing/deny-by-default.html#proc-macro-back-compat"><code>proc_macro_back_compat</code></a></li>
<li><a href="lints/listing/deny-by-default.html#proc-macro-derive-resolution-fallback"><code>proc_macro_derive_resolution_fallback</code></a></li>
<li><a href="lints/listing/deny-by-default.html#pub-use-of-private-extern-crate"><code>pub_use_of_private_extern_crate</code></a></li>
<li><a href="lints/listing/deny-by-default.html#soft-unstable"><code>soft_unstable</code></a></li>
<li><a href="lints/listing/deny-by-default.html#text-direction-codepoint-in-comment"><code>text_direction_codepoint_in_comment</code></a></li>
<li><a href="lints/listing/deny-by-default.html#text-direction-codepoint-in-literal"><code>text_direction_codepoint_in_literal</code></a></li>
<li><a href="lints/listing/deny-by-default.html#unconditional-panic"><code>unconditional_panic</code></a></li>
<li><a href="lints/listing/deny-by-default.html#unknown-crate-types"><code>unknown_crate_types</code></a></li>
<li><a href="lints/listing/deny-by-default.html#useless-deprecated"><code>useless_deprecated</code></a></li>
</ul>
<h2 id="ambiguous-associated-items"><a class="header" href="#ambiguous-associated-items">ambiguous-associated-items</a></h2>
<p>The <code>ambiguous_associated_items</code> lint detects ambiguity between
<a href="https://doc.rust-lang.org/reference/items/associated-items.html">associated items</a> and <a href="https://doc.rust-lang.org/reference/items/enumerations.html">enum variants</a>.</p>
<h3 id="example-117"><a class="header" href="#example-117">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum E {
    V
}

trait Tr {
    type V;
    fn foo() -&gt; Self::V;
}

impl Tr for E {
    type V = u8;
    // `Self::V` is ambiguous because it may refer to the associated type or
    // the enum variant.
    fn foo() -&gt; Self::V { 0 }
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: ambiguous associated item
  --&gt; lint_example.rs:15:17
   |
15 |     fn foo() -&gt; Self::V { 0 }
   |                 ^^^^^^^ help: use fully-qualified syntax: `&lt;E as Tr&gt;::V`
   |
   = note: `#[deny(ambiguous_associated_items)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #57644 &lt;https://github.com/rust-lang/rust/issues/57644&gt;
note: `V` could refer to the variant defined here
  --&gt; lint_example.rs:3:5
   |
3  |     V
   |     ^
note: `V` could also refer to the associated type defined here
  --&gt; lint_example.rs:7:5
   |
7  |     type V;
   |     ^^^^^^^

</code></pre>
<h3 id="explanation-120"><a class="header" href="#explanation-120">Explanation</a></h3>
<p>Previous versions of Rust did not allow accessing enum variants
through <a href="https://doc.rust-lang.org/reference/items/type-aliases.html#type-aliases">type aliases</a>. When this ability was added (see <a href="https://github.com/rust-lang/rfcs/blob/master/text/2338-type-alias-enum-variants.md">RFC 2338</a>), this
introduced some situations where it can be ambiguous what a type
was referring to.</p>
<p>To fix this ambiguity, you should use a <a href="https://doc.rust-lang.org/reference/paths.html#qualified-paths">qualified path</a> to explicitly
state which type to use. For example, in the above example the
function can be written as <code>fn f() -&gt; &lt;Self as Tr&gt;::V { 0 }</code> to
specifically refer to the associated type.</p>
<p>This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard
error in the future. See <a href="https://github.com/rust-lang/rust/issues/57644">issue #57644</a> for more details.</p>
<h2 id="arithmetic-overflow"><a class="header" href="#arithmetic-overflow">arithmetic-overflow</a></h2>
<p>The <code>arithmetic_overflow</code> lint detects that an arithmetic operation
will <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow">overflow</a>.</p>
<h3 id="example-118"><a class="header" href="#example-118">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1_i32 &lt;&lt; 32;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: this arithmetic operation will overflow
 --&gt; lint_example.rs:2:1
  |
2 | 1_i32 &lt;&lt; 32;
  | ^^^^^^^^^^^ attempt to shift left by `32_i32`, which would overflow
  |
  = note: `#[deny(arithmetic_overflow)]` on by default

</code></pre>
<h3 id="explanation-121"><a class="header" href="#explanation-121">Explanation</a></h3>
<p>It is very likely a mistake to perform an arithmetic operation that
overflows its value. If the compiler is able to detect these kinds of
overflows at compile-time, it will trigger this lint. Consider
adjusting the expression to avoid overflow, or use a data type that
will not overflow.</p>
<h2 id="conflicting-repr-hints"><a class="header" href="#conflicting-repr-hints">conflicting-repr-hints</a></h2>
<p>The <code>conflicting_repr_hints</code> lint detects <a href="https://doc.rust-lang.org/reference/type-layout.html#representations"><code>repr</code> attributes</a> with
conflicting hints.</p>
<h3 id="example-119"><a class="header" href="#example-119">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(u32, u64)]
enum Foo {
    Variant1,
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error[E0566]: conflicting representation hints
 --&gt; lint_example.rs:2:8
  |
2 | #[repr(u32, u64)]
  |        ^^^  ^^^
  |
  = note: `#[deny(conflicting_repr_hints)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #68585 &lt;https://github.com/rust-lang/rust/issues/68585&gt;

</code></pre>
<h3 id="explanation-122"><a class="header" href="#explanation-122">Explanation</a></h3>
<p>The compiler incorrectly accepted these conflicting representations in
the past. This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/68585">issue #68585</a> for more details.</p>
<p>To correct the issue, remove one of the conflicting hints.</p>
<h2 id="const-err"><a class="header" href="#const-err">const-err</a></h2>
<p>The <code>const_err</code> lint detects an erroneous expression while doing
constant evaluation.</p>
<h3 id="example-120"><a class="header" href="#example-120">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![allow(unconditional_panic)]
<span class="boring">fn main() {
</span>const C: i32 = 1/0;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: any use of this value will cause an error
 --&gt; lint_example.rs:3:16
  |
3 | const C: i32 = 1/0;
  | ---------------^^^-
  |                |
  |                attempt to divide `1_i32` by zero
  |
  = note: `#[deny(const_err)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #71800 &lt;https://github.com/rust-lang/rust/issues/71800&gt;

</code></pre>
<h3 id="explanation-123"><a class="header" href="#explanation-123">Explanation</a></h3>
<p>This lint detects constants that fail to evaluate. Allowing the lint will accept the
constant declaration, but any use of this constant will still lead to a hard error. This is
a future incompatibility lint; the plan is to eventually entirely forbid even declaring
constants that cannot be evaluated.  See <a href="https://github.com/rust-lang/rust/issues/71800">issue #71800</a> for more details.</p>
<h2 id="enum-intrinsics-non-enums"><a class="header" href="#enum-intrinsics-non-enums">enum-intrinsics-non-enums</a></h2>
<p>The <code>enum_intrinsics_non_enums</code> lint detects calls to
intrinsic functions that require an enum (<a href="https://doc.rust-lang.org/core/mem/fn.discriminant.html"><code>core::mem::discriminant</code></a>,
<a href="https://doc.rust-lang.org/core/mem/fn.variant_count.html"><code>core::mem::variant_count</code></a>), but are called with a non-enum type.</p>
<h3 id="example-121"><a class="header" href="#example-121">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![deny(enum_intrinsics_non_enums)]
<span class="boring">fn main() {
</span>core::mem::discriminant::&lt;i32&gt;(&amp;123);
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: the return value of `mem::discriminant` is unspecified when called with a non-enum type
 --&gt; lint_example.rs:3:1
  |
3 | core::mem::discriminant::&lt;i32&gt;(&amp;123);
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(enum_intrinsics_non_enums)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^
note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.
 --&gt; lint_example.rs:3:32
  |
3 | core::mem::discriminant::&lt;i32&gt;(&amp;123);
  |                                ^^^^

</code></pre>
<h3 id="explanation-124"><a class="header" href="#explanation-124">Explanation</a></h3>
<p>In order to accept any enum, the <code>mem::discriminant</code> and
<code>mem::variant_count</code> functions are generic over a type <code>T</code>.
This makes it technically possible for <code>T</code> to be a non-enum,
in which case the return value is unspecified.</p>
<p>This lint prevents such incorrect usage of these functions.</p>
<h2 id="ill-formed-attribute-input"><a class="header" href="#ill-formed-attribute-input">ill-formed-attribute-input</a></h2>
<p>The <code>ill_formed_attribute_input</code> lint detects ill-formed attribute
inputs that were previously accepted and used in practice.</p>
<h3 id="example-122"><a class="header" href="#example-122">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline = &quot;this is not valid&quot;]
fn foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: attribute must be of the form `#[inline]` or `#[inline(always|never)]`
 --&gt; lint_example.rs:2:1
  |
2 | #[inline = &quot;this is not valid&quot;]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[deny(ill_formed_attribute_input)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #57571 &lt;https://github.com/rust-lang/rust/issues/57571&gt;

</code></pre>
<h3 id="explanation-125"><a class="header" href="#explanation-125">Explanation</a></h3>
<p>Previously, inputs for many built-in attributes weren't validated and
nonsensical attribute inputs were accepted. After validation was
added, it was determined that some existing projects made use of these
invalid forms. This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this
to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/57571">issue #57571</a> for more details.</p>
<p>Check the <a href="https://doc.rust-lang.org/nightly/reference/attributes.html">attribute reference</a> for details on the valid inputs for
attributes.</p>
<h2 id="incomplete-include"><a class="header" href="#incomplete-include">incomplete-include</a></h2>
<p>The <code>incomplete_include</code> lint detects the use of the <a href="https://doc.rust-lang.org/std/macro.include.html"><code>include!</code></a>
macro with a file that contains more than one expression.</p>
<h3 id="example-123"><a class="header" href="#example-123">Example</a></h3>
<pre><code class="language-rust ignore (needs separate file)">fn main() {
    include!(&quot;foo.txt&quot;);
}
</code></pre>
<p>where the file <code>foo.txt</code> contains:</p>
<pre><code class="language-text">println!(&quot;hi!&quot;);
</code></pre>
<p>produces:</p>
<pre><code class="language-text">error: include macro expected single expression in source
 --&gt; foo.txt:1:14
  |
1 | println!(&quot;1&quot;);
  |              ^
  |
  = note: `#[deny(incomplete_include)]` on by default
</code></pre>
<h3 id="explanation-126"><a class="header" href="#explanation-126">Explanation</a></h3>
<p>The <a href="https://doc.rust-lang.org/std/macro.include.html"><code>include!</code></a> macro is currently only intended to be used to
include a single <a href="https://doc.rust-lang.org/reference/expressions.html">expression</a> or multiple <a href="https://doc.rust-lang.org/reference/items.html">items</a>. Historically it
would ignore any contents after the first expression, but that can be
confusing. In the example above, the <code>println!</code> expression ends just
before the semicolon, making the semicolon &quot;extra&quot; information that is
ignored. Perhaps even more surprising, if the included file had
multiple print statements, the subsequent ones would be ignored!</p>
<p>One workaround is to place the contents in braces to create a <a href="https://doc.rust-lang.org/reference/expressions/block-expr.html">block
expression</a>. Also consider alternatives, like using functions to
encapsulate the expressions, or use <a href="https://doc.rust-lang.org/reference/procedural-macros.html">proc-macros</a>.</p>
<p>This is a lint instead of a hard error because existing projects were
found to hit this error. To be cautious, it is a lint for now. The
future semantics of the <code>include!</code> macro are also uncertain, see
<a href="https://github.com/rust-lang/rust/issues/35560">issue #35560</a>.</p>
<h2 id="ineffective-unstable-trait-impl"><a class="header" href="#ineffective-unstable-trait-impl">ineffective-unstable-trait-impl</a></h2>
<p>The <code>ineffective_unstable_trait_impl</code> lint detects <code>#[unstable]</code> attributes which are not used.</p>
<h3 id="example-124"><a class="header" href="#example-124">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span>#![feature(staged_api)]

<span class="boring">fn main() {
</span>#[derive(Clone)]
#[stable(feature = &quot;x&quot;, since = &quot;1&quot;)]
struct S {}

#[unstable(feature = &quot;y&quot;, issue = &quot;none&quot;)]
impl Copy for S {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: an `#[unstable]` annotation here has no effect
 --&gt; lint_example.rs:8:1
  |
8 | #[unstable(feature = &quot;y&quot;, issue = &quot;none&quot;)]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[deny(ineffective_unstable_trait_impl)]` on by default
  = note: see issue #55436 &lt;https://github.com/rust-lang/rust/issues/55436&gt; for more information

</code></pre>
<h3 id="explanation-127"><a class="header" href="#explanation-127">Explanation</a></h3>
<p><code>staged_api</code> does not currently support using a stability attribute on <code>impl</code> blocks.
<code>impl</code>s are always stable if both the type and trait are stable, and always unstable otherwise.</p>
<h2 id="invalid-atomic-ordering"><a class="header" href="#invalid-atomic-ordering">invalid-atomic-ordering</a></h2>
<p>The <code>invalid_atomic_ordering</code> lint detects passing an <code>Ordering</code>
to an atomic operation that does not support that ordering.</p>
<h3 id="example-125"><a class="header" href="#example-125">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::sync::atomic::{AtomicU8, Ordering};
</span>let atom = AtomicU8::new(0);
let value = atom.load(Ordering::Release);
<span class="boring">let _ = value;
</span><span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: atomic loads cannot have `Release` or `AcqRel` ordering
 --&gt; lint_example.rs:4:23
  |
4 | let value = atom.load(Ordering::Release);
  |                       ^^^^^^^^^^^^^^^^^
  |
  = note: `#[deny(invalid_atomic_ordering)]` on by default
  = help: consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`

</code></pre>
<h3 id="explanation-128"><a class="header" href="#explanation-128">Explanation</a></h3>
<p>Some atomic operations are only supported for a subset of the
<code>atomic::Ordering</code> variants. Passing an unsupported variant will cause
an unconditional panic at runtime, which is detected by this lint.</p>
<p>This lint will trigger in the following cases: (where <code>AtomicType</code> is an
atomic type from <code>core::sync::atomic</code>, such as <code>AtomicBool</code>,
<code>AtomicPtr</code>, <code>AtomicUsize</code>, or any of the other integer atomics).</p>
<ul>
<li>
<p>Passing <code>Ordering::Acquire</code> or <code>Ordering::AcqRel</code> to
<code>AtomicType::store</code>.</p>
</li>
<li>
<p>Passing <code>Ordering::Release</code> or <code>Ordering::AcqRel</code> to
<code>AtomicType::load</code>.</p>
</li>
<li>
<p>Passing <code>Ordering::Relaxed</code> to <code>core::sync::atomic::fence</code> or
<code>core::sync::atomic::compiler_fence</code>.</p>
</li>
<li>
<p>Passing <code>Ordering::Release</code> or <code>Ordering::AcqRel</code> as the failure
ordering for any of <code>AtomicType::compare_exchange</code>,
<code>AtomicType::compare_exchange_weak</code>, or <code>AtomicType::fetch_update</code>.</p>
</li>
<li>
<p>Passing in a pair of orderings to <code>AtomicType::compare_exchange</code>,
<code>AtomicType::compare_exchange_weak</code>, or <code>AtomicType::fetch_update</code>
where the failure ordering is stronger than the success ordering.</p>
</li>
</ul>
<h2 id="invalid-type-param-default"><a class="header" href="#invalid-type-param-default">invalid-type-param-default</a></h2>
<p>The <code>invalid_type_param_default</code> lint detects type parameter defaults
erroneously allowed in an invalid location.</p>
<h3 id="example-126"><a class="header" href="#example-126">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T=i32&gt;(t: T) {}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: defaults for type parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions
 --&gt; lint_example.rs:2:8
  |
2 | fn foo&lt;T=i32&gt;(t: T) {}
  |        ^
  |
  = note: `#[deny(invalid_type_param_default)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #36887 &lt;https://github.com/rust-lang/rust/issues/36887&gt;

</code></pre>
<h3 id="explanation-129"><a class="header" href="#explanation-129">Explanation</a></h3>
<p>Default type parameters were only intended to be allowed in certain
situations, but historically the compiler allowed them everywhere.
This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard
error in the future. See <a href="https://github.com/rust-lang/rust/issues/36887">issue #36887</a> for more details.</p>
<h2 id="macro-expanded-macro-exports-accessed-by-absolute-paths"><a class="header" href="#macro-expanded-macro-exports-accessed-by-absolute-paths">macro-expanded-macro-exports-accessed-by-absolute-paths</a></h2>
<p>The <code>macro_expanded_macro_exports_accessed_by_absolute_paths</code> lint
detects macro-expanded <a href="https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope"><code>macro_export</code></a> macros from the current crate
that cannot be referred to by absolute paths.</p>
<h3 id="example-127"><a class="header" href="#example-127">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">macro_rules! define_exported {
    () =&gt; {
        #[macro_export]
        macro_rules! exported {
            () =&gt; {};
        }
    };
}

define_exported!();

fn main() {
    crate::exported!();
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: macro-expanded `macro_export` macros from the current crate cannot be referred to by absolute paths
  --&gt; lint_example.rs:13:5
   |
13 |     crate::exported!();
   |     ^^^^^^^^^^^^^^^
   |
   = note: `#[deny(macro_expanded_macro_exports_accessed_by_absolute_paths)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #52234 &lt;https://github.com/rust-lang/rust/issues/52234&gt;
note: the macro is defined here
  --&gt; lint_example.rs:4:9
   |
4  | /         macro_rules! exported {
5  | |             () =&gt; {};
6  | |         }
   | |_________^
...
10 |   define_exported!();
   |   ------------------ in this macro invocation
   = note: this error originates in the macro `define_exported` (in Nightly builds, run with -Z macro-backtrace for more info)

</code></pre>
<h3 id="explanation-130"><a class="header" href="#explanation-130">Explanation</a></h3>
<p>The intent is that all macros marked with the <code>#[macro_export]</code>
attribute are made available in the root of the crate. However, when a
<code>macro_rules!</code> definition is generated by another macro, the macro
expansion is unable to uphold this rule. This is a
<a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the
future. See <a href="https://github.com/rust-lang/rust/issues/53495">issue #53495</a> for more details.</p>
<h2 id="missing-fragment-specifier"><a class="header" href="#missing-fragment-specifier">missing-fragment-specifier</a></h2>
<p>The <code>missing_fragment_specifier</code> lint is issued when an unused pattern in a
<code>macro_rules!</code> macro definition has a meta-variable (e.g. <code>$e</code>) that is not
followed by a fragment specifier (e.g. <code>:expr</code>).</p>
<p>This warning can always be fixed by removing the unused pattern in the
<code>macro_rules!</code> macro definition.</p>
<h3 id="example-128"><a class="header" href="#example-128">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">macro_rules! foo {
   () =&gt; {};
   ($name) =&gt; { };
}

fn main() {
   foo!();
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: missing fragment specifier
 --&gt; lint_example.rs:3:5
  |
3 |    ($name) =&gt; { };
  |     ^^^^^
  |
  = note: `#[deny(missing_fragment_specifier)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #40107 &lt;https://github.com/rust-lang/rust/issues/40107&gt;

</code></pre>
<h3 id="explanation-131"><a class="header" href="#explanation-131">Explanation</a></h3>
<p>To fix this, remove the unused pattern from the <code>macro_rules!</code> macro definition:</p>
<pre><pre class="playground"><code class="language-rust">macro_rules! foo {
    () =&gt; {};
}
fn main() {
    foo!();
}
</code></pre></pre>
<h2 id="mutable-transmutes"><a class="header" href="#mutable-transmutes">mutable-transmutes</a></h2>
<p>The <code>mutable_transmutes</code> lint catches transmuting from <code>&amp;T</code> to <code>&amp;mut T</code> because it is <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a>.</p>
<h3 id="example-129"><a class="header" href="#example-129">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    let y = std::mem::transmute::&lt;&amp;i32, &amp;mut i32&gt;(&amp;5);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: mutating transmuted &amp;mut T from &amp;T may cause undefined behavior, consider instead using an UnsafeCell
 --&gt; lint_example.rs:3:13
  |
3 |     let y = std::mem::transmute::&lt;&amp;i32, &amp;mut i32&gt;(&amp;5);
  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[deny(mutable_transmutes)]` on by default

</code></pre>
<h3 id="explanation-132"><a class="header" href="#explanation-132">Explanation</a></h3>
<p>Certain assumptions are made about aliasing of data, and this transmute
violates those assumptions. Consider using <a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a> instead.</p>
<h2 id="named-asm-labels"><a class="header" href="#named-asm-labels">named-asm-labels</a></h2>
<p>The <code>named_asm_labels</code> lint detects the use of named labels in the
inline <code>asm!</code> macro.</p>
<h3 id="example-130"><a class="header" href="#example-130">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">use std::arch::asm;

fn main() {
    unsafe {
        asm!(&quot;foo: bar&quot;);
    }
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: avoid using named labels in inline assembly
 --&gt; lint_example.rs:5:15
  |
5 |         asm!(&quot;foo: bar&quot;);
  |               ^^^
  |
  = note: `#[deny(named_asm_labels)]` on by default
  = help: only local labels of the form `&lt;number&gt;:` should be used in inline asm

</code></pre>
<h3 id="explanation-133"><a class="header" href="#explanation-133">Explanation</a></h3>
<p>LLVM is allowed to duplicate inline assembly blocks for any
reason, for example when it is in a function that gets inlined. Because
of this, GNU assembler <a href="https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels">local labels</a> <em>must</em> be used instead of labels
with a name. Using named labels might cause assembler or linker errors.</p>
<h2 id="no-mangle-const-items"><a class="header" href="#no-mangle-const-items">no-mangle-const-items</a></h2>
<p>The <code>no_mangle_const_items</code> lint detects any <code>const</code> items with the
<a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>no_mangle</code> attribute</a>.</p>
<h3 id="example-131"><a class="header" href="#example-131">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
const FOO: i32 = 5;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: const items should never be `#[no_mangle]`
 --&gt; lint_example.rs:3:1
  |
3 | const FOO: i32 = 5;
  | -----^^^^^^^^^^^^^^
  | |
  | help: try a static value: `pub static`
  |
  = note: `#[deny(no_mangle_const_items)]` on by default

</code></pre>
<h3 id="explanation-134"><a class="header" href="#explanation-134">Explanation</a></h3>
<p>Constants do not have their symbols exported, and therefore, this
probably means you meant to use a <a href="https://doc.rust-lang.org/reference/items/static-items.html"><code>static</code></a>, not a <a href="https://doc.rust-lang.org/reference/items/constant-items.html"><code>const</code></a>.</p>
<h2 id="order-dependent-trait-objects"><a class="header" href="#order-dependent-trait-objects">order-dependent-trait-objects</a></h2>
<p>The <code>order_dependent_trait_objects</code> lint detects a trait coherency
violation that would allow creating two trait impls for the same
dynamic trait object involving marker traits.</p>
<h3 id="example-132"><a class="header" href="#example-132">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Trait {}

impl Trait for dyn Send + Sync { }
impl Trait for dyn Sync + Send { }
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: conflicting implementations of trait `main::Trait` for type `(dyn std::marker::Send + std::marker::Sync + 'static)`: (E0119)
 --&gt; lint_example.rs:5:1
  |
4 | impl Trait for dyn Send + Sync { }
  | ------------------------------ first implementation here
5 | impl Trait for dyn Sync + Send { }
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `(dyn std::marker::Send + std::marker::Sync + 'static)`
  |
  = note: `#[deny(order_dependent_trait_objects)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #56484 &lt;https://github.com/rust-lang/rust/issues/56484&gt;

</code></pre>
<h3 id="explanation-135"><a class="header" href="#explanation-135">Explanation</a></h3>
<p>A previous bug caused the compiler to interpret traits with different
orders (such as <code>Send + Sync</code> and <code>Sync + Send</code>) as distinct types
when they were intended to be treated the same. This allowed code to
define separate trait implementations when there should be a coherence
error. This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a
hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/56484">issue #56484</a> for more details.</p>
<h2 id="overflowing-literals"><a class="header" href="#overflowing-literals">overflowing-literals</a></h2>
<p>The <code>overflowing_literals</code> lint detects literal out of range for its
type.</p>
<h3 id="example-133"><a class="header" href="#example-133">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u8 = 1000;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: literal out of range for `u8`
 --&gt; lint_example.rs:2:13
  |
2 | let x: u8 = 1000;
  |             ^^^^
  |
  = note: `#[deny(overflowing_literals)]` on by default
  = note: the literal `1000` does not fit into the type `u8` whose range is `0..=255`

</code></pre>
<h3 id="explanation-136"><a class="header" href="#explanation-136">Explanation</a></h3>
<p>It is usually a mistake to use a literal that overflows the type where
it is used. Either use a literal that is within range, or change the
type to be within the range of the literal.</p>
<h2 id="patterns-in-fns-without-body"><a class="header" href="#patterns-in-fns-without-body">patterns-in-fns-without-body</a></h2>
<p>The <code>patterns_in_fns_without_body</code> lint detects <code>mut</code> identifier
patterns as a parameter in functions without a body.</p>
<h3 id="example-134"><a class="header" href="#example-134">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(mut arg: u8);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: patterns aren't allowed in functions without bodies
 --&gt; lint_example.rs:3:12
  |
3 |     fn foo(mut arg: u8);
  |            ^^^^^^^ help: remove `mut` from the parameter: `arg`
  |
  = note: `#[deny(patterns_in_fns_without_body)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #35203 &lt;https://github.com/rust-lang/rust/issues/35203&gt;

</code></pre>
<h3 id="explanation-137"><a class="header" href="#explanation-137">Explanation</a></h3>
<p>To fix this, remove <code>mut</code> from the parameter in the trait definition;
it can be used in the implementation. That is, the following is OK:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(arg: u8); // Removed `mut` here
}

impl Trait for i32 {
    fn foo(mut arg: u8) { // `mut` here is OK

    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Trait definitions can define functions without a body to specify a
function that implementors must define. The parameter names in the
body-less functions are only allowed to be <code>_</code> or an <a href="https://doc.rust-lang.org/reference/identifiers.html">identifier</a> for
documentation purposes (only the type is relevant). Previous versions
of the compiler erroneously allowed <a href="https://doc.rust-lang.org/reference/patterns.html#identifier-patterns">identifier patterns</a> with the
<code>mut</code> keyword, but this was not intended to be allowed. This is a
<a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in the
future. See <a href="https://github.com/rust-lang/rust/issues/35203">issue #35203</a> for more details.</p>
<h2 id="proc-macro-back-compat"><a class="header" href="#proc-macro-back-compat">proc-macro-back-compat</a></h2>
<p>The <code>proc_macro_back_compat</code> lint detects uses of old versions of certain
proc-macro crates, which have hardcoded workarounds in the compiler.</p>
<h3 id="example-135"><a class="header" href="#example-135">Example</a></h3>
<pre><code class="language-rust ignore (needs-dependency)">
use time_macros_impl::impl_macros;
struct Foo;
impl_macros!(Foo);
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: using an old version of `time-macros-impl`
  ::: $DIR/group-compat-hack.rs:27:5
   |
LL |     impl_macros!(Foo);
   |     ------------------ in this macro invocation
   |
   = note: `#[warn(proc_macro_back_compat)]` on by default
   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
   = note: for more information, see issue #83125 &lt;https://github.com/rust-lang/rust/issues/83125&gt;
   = note: the `time-macros-impl` crate will stop compiling in futures version of Rust. Please update to the latest version of the `time` crate to avoid breakage
   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<h3 id="explanation-138"><a class="header" href="#explanation-138">Explanation</a></h3>
<p>Eventually, the backwards-compatibility hacks present in the compiler will be removed,
causing older versions of certain crates to stop compiling.
This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to ease the transition to an error.
See <a href="https://github.com/rust-lang/rust/issues/83125">issue #83125</a> for more details.</p>
<h2 id="proc-macro-derive-resolution-fallback"><a class="header" href="#proc-macro-derive-resolution-fallback">proc-macro-derive-resolution-fallback</a></h2>
<p>The <code>proc_macro_derive_resolution_fallback</code> lint detects proc macro
derives using inaccessible names from parent modules.</p>
<h3 id="example-136"><a class="header" href="#example-136">Example</a></h3>
<pre><code class="language-rust ignore (proc-macro)">// foo.rs
#![crate_type = &quot;proc-macro&quot;]

extern crate proc_macro;

use proc_macro::*;

#[proc_macro_derive(Foo)]
pub fn foo1(a: TokenStream) -&gt; TokenStream {
    drop(a);
    &quot;mod __bar { static mut BAR: Option&lt;Something&gt; = None; }&quot;.parse().unwrap()
}
</code></pre>
<pre><code class="language-rust ignore (needs-dependency)">// bar.rs
#[macro_use]
extern crate foo;

struct Something;

#[derive(Foo)]
struct Another;

fn main() {}
</code></pre>
<p>This will produce:</p>
<pre><code class="language-text">warning: cannot find type `Something` in this scope
 --&gt; src/main.rs:8:10
  |
8 | #[derive(Foo)]
  |          ^^^ names from parent modules are not accessible without an explicit import
  |
  = note: `#[warn(proc_macro_derive_resolution_fallback)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #50504 &lt;https://github.com/rust-lang/rust/issues/50504&gt;
</code></pre>
<h3 id="explanation-139"><a class="header" href="#explanation-139">Explanation</a></h3>
<p>If a proc-macro generates a module, the compiler unintentionally
allowed items in that module to refer to items in the crate root
without importing them. This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to
transition this to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/50504">issue #50504</a> for
more details.</p>
<h2 id="pub-use-of-private-extern-crate"><a class="header" href="#pub-use-of-private-extern-crate">pub-use-of-private-extern-crate</a></h2>
<p>The <code>pub_use_of_private_extern_crate</code> lint detects a specific
situation of re-exporting a private <code>extern crate</code>.</p>
<h3 id="example-137"><a class="header" href="#example-137">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate core;
pub use core as reexported_core;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: extern crate `core` is private, and cannot be re-exported (error E0365), consider declaring with `pub`
 --&gt; lint_example.rs:3:9
  |
3 | pub use core as reexported_core;
  |         ^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[deny(pub_use_of_private_extern_crate)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #34537 &lt;https://github.com/rust-lang/rust/issues/34537&gt;

</code></pre>
<h3 id="explanation-140"><a class="header" href="#explanation-140">Explanation</a></h3>
<p>A public <code>use</code> declaration should not be used to publicly re-export a
private <code>extern crate</code>. <code>pub extern crate</code> should be used instead.</p>
<p>This was historically allowed, but is not the intended behavior
according to the visibility rules. This is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a>
lint to transition this to a hard error in the future. See <a href="https://github.com/rust-lang/rust/issues/34537">issue
#34537</a> for more details.</p>
<h2 id="soft-unstable"><a class="header" href="#soft-unstable">soft-unstable</a></h2>
<p>The <code>soft_unstable</code> lint detects unstable features that were
unintentionally allowed on stable.</p>
<h3 id="example-138"><a class="header" href="#example-138">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
extern crate test;

#[bench]
fn name(b: &amp;mut test::Bencher) {
    b.iter(|| 123)
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: use of unstable library feature 'test': `bench` is a part of custom test frameworks which are unstable
 --&gt; lint_example.rs:5:3
  |
5 | #[bench]
  |   ^^^^^
  |
  = note: `#[deny(soft_unstable)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #64266 &lt;https://github.com/rust-lang/rust/issues/64266&gt;

</code></pre>
<h3 id="explanation-141"><a class="header" href="#explanation-141">Explanation</a></h3>
<p>The <a href="https://doc.rust-lang.org/nightly/unstable-book/library-features/test.html"><code>bench</code> attribute</a> was accidentally allowed to be specified on
the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">stable release channel</a>. Turning this to a hard error would have
broken some projects. This lint allows those projects to continue to
build correctly when <a href="https://doc.rust-lang.org/rustc/lints/levels.html#capping-lints"><code>--cap-lints</code></a> is used, but otherwise signal an
error that <code>#[bench]</code> should not be used on the stable channel. This
is a <a href="lints/listing/../index.html#future-incompatible-lints">future-incompatible</a> lint to transition this to a hard error in
the future. See <a href="https://github.com/rust-lang/rust/issues/64266">issue #64266</a> for more details.</p>
<h2 id="text-direction-codepoint-in-comment"><a class="header" href="#text-direction-codepoint-in-comment">text-direction-codepoint-in-comment</a></h2>
<p>The <code>text_direction_codepoint_in_comment</code> lint detects Unicode codepoints in comments that
change the visual representation of text on screen in a way that does not correspond to
their on memory representation.</p>
<h3 id="example-139"><a class="header" href="#example-139">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(text_direction_codepoint_in_comment)]
fn main() {
    println!(&quot;{:?}&quot;); // '‮');
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unicode codepoint changing visible direction of text present in comment
 --&gt; lint_example.rs:3:23
  |
3 |     println!(&quot;{:?}&quot;); // '');
  |                       ^^^^-^^
  |                       |   |
  |                       |   '\u{202e}'
  |                       this comment contains an invisible unicode text flow control codepoint
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(text_direction_codepoint_in_comment)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen
  = help: if their presence wasn't intentional, you can remove them

</code></pre>
<h3 id="explanation-142"><a class="header" href="#explanation-142">Explanation</a></h3>
<p>Unicode allows changing the visual flow of text on screen in order to support scripts that
are written right-to-left, but a specially crafted comment can make code that will be
compiled appear to be part of a comment, depending on the software used to read the code.
To avoid potential problems or confusion, such as in CVE-2021-42574, by default we deny
their use.</p>
<h2 id="text-direction-codepoint-in-literal"><a class="header" href="#text-direction-codepoint-in-literal">text-direction-codepoint-in-literal</a></h2>
<p>The <code>text_direction_codepoint_in_literal</code> lint detects Unicode codepoints that change the
visual representation of text on screen in a way that does not correspond to their on
memory representation.</p>
<h3 id="explanation-143"><a class="header" href="#explanation-143">Explanation</a></h3>
<p>The unicode characters <code>\u{202A}</code>, <code>\u{202B}</code>, <code>\u{202D}</code>, <code>\u{202E}</code>, <code>\u{2066}</code>,
<code>\u{2067}</code>, <code>\u{2068}</code>, <code>\u{202C}</code> and <code>\u{2069}</code> make the flow of text on screen change
its direction on software that supports these codepoints. This makes the text &quot;abc&quot; display
as &quot;cba&quot; on screen. By leveraging software that supports these, people can write specially
crafted literals that make the surrounding code seem like it's performing one action, when
in reality it is performing another. Because of this, we proactively lint against their
presence to avoid surprises.</p>
<h3 id="example-140"><a class="header" href="#example-140">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![deny(text_direction_codepoint_in_literal)]
fn main() {
    println!(&quot;{:?}&quot;, '‮');
}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: unicode codepoint changing visible direction of text present in literal
 --&gt; lint_example.rs:3:22
  |
3 |     println!(&quot;{:?}&quot;, '');
  |                      ^-
  |                      ||
  |                      |'\u{202e}'
  |                      this literal contains an invisible unicode text flow control codepoint
  |
note: the lint level is defined here
 --&gt; lint_example.rs:1:9
  |
1 | #![deny(text_direction_codepoint_in_literal)]
  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  = note: these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen
  = help: if their presence wasn't intentional, you can remove them
help: if you want to keep them but make them visible in your source code, you can escape them
  |
3 |     println!(&quot;{:?}&quot;, '\u{202e}');
  |                       ~~~~~~~~

</code></pre>
<h2 id="unconditional-panic"><a class="header" href="#unconditional-panic">unconditional-panic</a></h2>
<p>The <code>unconditional_panic</code> lint detects an operation that will cause a
panic at runtime.</p>
<h3 id="example-141"><a class="header" href="#example-141">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">#![allow(unused)]
</span>let x = 1 / 0;
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: this operation will panic at runtime
 --&gt; lint_example.rs:3:9
  |
3 | let x = 1 / 0;
  |         ^^^^^ attempt to divide `1_i32` by zero
  |
  = note: `#[deny(unconditional_panic)]` on by default

</code></pre>
<h3 id="explanation-144"><a class="header" href="#explanation-144">Explanation</a></h3>
<p>This lint detects code that is very likely incorrect because it will
always panic, such as division by zero and out-of-bounds array
accesses. Consider adjusting your code if this is a bug, or using the
<code>panic!</code> or <code>unreachable!</code> macro instead in case the panic is intended.</p>
<h2 id="unknown-crate-types"><a class="header" href="#unknown-crate-types">unknown-crate-types</a></h2>
<p>The <code>unknown_crate_types</code> lint detects an unknown crate type found in
a <a href="https://doc.rust-lang.org/reference/linkage.html"><code>crate_type</code> attribute</a>.</p>
<h3 id="example-142"><a class="header" href="#example-142">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">#![crate_type=&quot;lol&quot;]
fn main() {}
</code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: invalid `crate_type` value
 --&gt; lint_example.rs:1:15
  |
1 | #![crate_type=&quot;lol&quot;]
  |               ^^^^^
  |
  = note: `#[deny(unknown_crate_types)]` on by default

</code></pre>
<h3 id="explanation-145"><a class="header" href="#explanation-145">Explanation</a></h3>
<p>An unknown value give to the <code>crate_type</code> attribute is almost
certainly a mistake.</p>
<h2 id="useless-deprecated"><a class="header" href="#useless-deprecated">useless-deprecated</a></h2>
<p>The <code>useless_deprecated</code> lint detects deprecation attributes with no effect.</p>
<h3 id="example-143"><a class="header" href="#example-143">Example</a></h3>
<pre><pre class="playground"><code class="language-rust compile_fail">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct X;

#[deprecated = &quot;message&quot;]
impl Default for X {
    fn default() -&gt; Self {
        X
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This will produce:</p>
<pre><code class="language-text">error: this `#[deprecated]` annotation has no effect
 --&gt; lint_example.rs:4:1
  |
4 | #[deprecated = &quot;message&quot;]
  | ^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove the unnecessary deprecation attribute
  |
  = note: `#[deny(useless_deprecated)]` on by default

</code></pre>
<h3 id="explanation-146"><a class="header" href="#explanation-146">Explanation</a></h3>
<p>Deprecation attributes have no effect on trait implementations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="codegen-options"><a class="header" href="#codegen-options">Codegen options</a></h1>
<p>All of these options are passed to <code>rustc</code> via the <code>-C</code> flag, short for &quot;codegen.&quot; You can see
a version of this list for your exact compiler by running <code>rustc -C help</code>.</p>
<h2 id="ar"><a class="header" href="#ar">ar</a></h2>
<p>This option is deprecated and does nothing.</p>
<h2 id="code-model"><a class="header" href="#code-model">code-model</a></h2>
<p>This option lets you choose which code model to use. <br />
Code models put constraints on address ranges that the program and its symbols may use. <br />
With smaller address ranges machine instructions
may be able to use more compact addressing modes.</p>
<p>The specific ranges depend on target architectures and addressing modes available to them. <br />
For x86 more detailed description of its code models can be found in
<a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf">System V Application Binary Interface</a>
specification.</p>
<p>Supported values for this option are:</p>
<ul>
<li><code>tiny</code> - Tiny code model.</li>
<li><code>small</code> - Small code model. This is the default model for majority of supported targets.</li>
<li><code>kernel</code> - Kernel code model.</li>
<li><code>medium</code> - Medium code model.</li>
<li><code>large</code> - Large code model.</li>
</ul>
<p>Supported values can also be discovered by running <code>rustc --print code-models</code>.</p>
<h2 id="codegen-units"><a class="header" href="#codegen-units">codegen-units</a></h2>
<p>This flag controls how many code generation units the crate is split into. It
takes an integer greater than 0.</p>
<p>When a crate is split into multiple codegen units, LLVM is able to process
them in parallel. Increasing parallelism may speed up compile times, but may
also produce slower code. Setting this to 1 may improve the performance of
generated code, but may be slower to compile.</p>
<p>The default value, if not specified, is 16 for non-incremental builds. For
incremental builds the default is 256 which allows caching to be more granular.</p>
<h2 id="control-flow-guard"><a class="header" href="#control-flow-guard">control-flow-guard</a></h2>
<p>This flag controls whether LLVM enables the Windows <a href="https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard">Control Flow
Guard</a>
platform security feature. This flag is currently ignored for non-Windows targets.
It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>checks</code>, or no value: enable Control Flow Guard.</li>
<li><code>nochecks</code>: emit Control Flow Guard metadata without runtime enforcement checks (this
should only be used for testing purposes as it does not provide security enforcement).</li>
<li><code>n</code>, <code>no</code>, <code>off</code>: do not enable Control Flow Guard (the default).</li>
</ul>
<h2 id="debug-assertions"><a class="header" href="#debug-assertions">debug-assertions</a></h2>
<p>This flag lets you turn <code>cfg(debug_assertions)</code> <a href="codegen-options/../../reference/conditional-compilation.html#debug_assertions">conditional
compilation</a> on
or off. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: enable debug-assertions.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: disable debug-assertions.</li>
</ul>
<p>If not specified, debug assertions are automatically enabled only if the
<a href="codegen-options/index.html#opt-level">opt-level</a> is 0.</p>
<h2 id="debuginfo"><a class="header" href="#debuginfo">debuginfo</a></h2>
<p>This flag controls the generation of debug information. It takes one of the
following values:</p>
<ul>
<li><code>0</code>: no debug info at all (the default).</li>
<li><code>1</code>: line tables only.</li>
<li><code>2</code>: full debug info.</li>
</ul>
<p>Note: The <a href="codegen-options/../command-line-arguments.html#option-g-debug"><code>-g</code> flag</a> is an alias for <code>-C debuginfo=2</code>.</p>
<h2 id="default-linker-libraries"><a class="header" href="#default-linker-libraries">default-linker-libraries</a></h2>
<p>This flag controls whether or not the linker includes its default libraries.
It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: include default libraries (the default).</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: exclude default libraries.</li>
</ul>
<p>For example, for gcc flavor linkers, this issues the <code>-nodefaultlibs</code> flag to
the linker.</p>
<h2 id="embed-bitcode"><a class="header" href="#embed-bitcode">embed-bitcode</a></h2>
<p>This flag controls whether or not the compiler embeds LLVM bitcode into object
files. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: put bitcode in rlibs (the default).</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: omit bitcode from rlibs.</li>
</ul>
<p>LLVM bitcode is required when rustc is performing link-time optimization (LTO).
It is also required on some targets like iOS ones where vendors look for LLVM
bitcode. Embedded bitcode will appear in rustc-generated object files inside of
a section whose name is defined by the target platform. Most of the time this is
<code>.llvmbc</code>.</p>
<p>The use of <code>-C embed-bitcode=no</code> can significantly improve compile times and
reduce generated file sizes if your compilation does not actually need bitcode
(e.g. if you're not compiling for iOS or you're not performing LTO). For these
reasons, Cargo uses <code>-C embed-bitcode=no</code> whenever possible. Likewise, if you
are building directly with <code>rustc</code> we recommend using <code>-C embed-bitcode=no</code>
whenever you are not using LTO.</p>
<p>If combined with <code>-C lto</code>, <code>-C embed-bitcode=no</code> will cause <code>rustc</code> to abort
at start-up, because the combination is invalid.</p>
<blockquote>
<p><strong>Note</strong>: if you're building Rust code with LTO then you probably don't even
need the <code>embed-bitcode</code> option turned on. You'll likely want to use
<code>-Clinker-plugin-lto</code> instead which skips generating object files entirely and
simply replaces object files with LLVM bitcode. The only purpose for
<code>-Cembed-bitcode</code> is when you're generating an rlib that is both being used
with and without LTO. For example Rust's standard library ships with embedded
bitcode since users link to it both with and without LTO.</p>
<p>This also may make you wonder why the default is <code>yes</code> for this option. The
reason for that is that it's how it was for rustc 1.44 and prior. In 1.45 this
option was added to turn off what had always been the default.</p>
</blockquote>
<h2 id="extra-filename"><a class="header" href="#extra-filename">extra-filename</a></h2>
<p>This option allows you to put extra data in each output filename. It takes a
string to add as a suffix to the filename. See the <a href="codegen-options/../command-line-arguments.html#option-emit"><code>--emit</code>
flag</a> for more information.</p>
<h2 id="force-frame-pointers"><a class="header" href="#force-frame-pointers">force-frame-pointers</a></h2>
<p>This flag forces the use of frame pointers. It takes one of the following
values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: force-enable frame pointers.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: do not force-enable frame pointers. This does
not necessarily mean frame pointers will be removed.</li>
</ul>
<p>The default behaviour, if frame pointers are not force-enabled, depends on the
target.</p>
<h2 id="force-unwind-tables"><a class="header" href="#force-unwind-tables">force-unwind-tables</a></h2>
<p>This flag forces the generation of unwind tables. It takes one of the following
values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: Unwind tables are forced to be generated.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: Unwind tables are not forced to be generated. If unwind
tables are required by the target an error will be emitted.</li>
</ul>
<p>The default if not specified depends on the target.</p>
<h2 id="incremental"><a class="header" href="#incremental">incremental</a></h2>
<p>This flag allows you to enable incremental compilation, which allows <code>rustc</code>
to save information after compiling a crate to be reused when recompiling the
crate, improving re-compile times. This takes a path to a directory where
incremental files will be stored.</p>
<h2 id="inline-threshold"><a class="header" href="#inline-threshold">inline-threshold</a></h2>
<p>This option lets you set the default threshold for inlining a function. It
takes an unsigned integer as a value. Inlining is based on a cost model, where
a higher threshold will allow more inlining.</p>
<p>The default depends on the <a href="codegen-options/index.html#opt-level">opt-level</a>:</p>
<table><thead><tr><th>opt-level</th><th>Threshold</th></tr></thead><tbody>
<tr><td>0</td><td>N/A, only inlines always-inline functions</td></tr>
<tr><td>1</td><td>N/A, only inlines always-inline functions and LLVM lifetime intrinsics</td></tr>
<tr><td>2</td><td>225</td></tr>
<tr><td>3</td><td>275</td></tr>
<tr><td>s</td><td>75</td></tr>
<tr><td>z</td><td>25</td></tr>
</tbody></table>
<h2 id="link-arg"><a class="header" href="#link-arg">link-arg</a></h2>
<p>This flag lets you append a single extra argument to the linker invocation.</p>
<p>&quot;Append&quot; is significant; you can pass this flag multiple times to add multiple arguments.</p>
<h2 id="link-args"><a class="header" href="#link-args">link-args</a></h2>
<p>This flag lets you append multiple extra arguments to the linker invocation. The
options should be separated by spaces.</p>
<h2 id="link-dead-code"><a class="header" href="#link-dead-code">link-dead-code</a></h2>
<p>This flag controls whether the linker will keep dead code. It takes one of
the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: keep dead code.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: remove dead code (the default).</li>
</ul>
<p>An example of when this flag might be useful is when trying to construct code coverage
metrics.</p>
<h2 id="link-self-contained"><a class="header" href="#link-self-contained">link-self-contained</a></h2>
<p>On targets that support it this flag controls whether the linker will use libraries and objects
shipped with Rust instead or those in the system.
It takes one of the following values:</p>
<ul>
<li>no value: rustc will use heuristic to disable self-contained mode if system has necessary tools.</li>
<li><code>y</code>, <code>yes</code>, <code>on</code>: use only libraries/objects shipped with Rust.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: rely on the user or the linker to provide non-Rust libraries/objects.</li>
</ul>
<p>This allows overriding cases when detection fails or user wants to use shipped libraries.</p>
<h2 id="linker"><a class="header" href="#linker">linker</a></h2>
<p>This flag controls which linker <code>rustc</code> invokes to link your code. It takes a
path to the linker executable. If this flag is not specified, the linker will
be inferred based on the target. See also the <a href="codegen-options/index.html#linker-flavor">linker-flavor</a>
flag for another way to specify the linker.</p>
<h2 id="linker-flavor"><a class="header" href="#linker-flavor">linker-flavor</a></h2>
<p>This flag controls the linker flavor used by <code>rustc</code>. If a linker is given with
the <a href="codegen-options/index.html#linker"><code>-C linker</code> flag</a>, then the linker flavor is inferred from the
value provided. If no linker is given then the linker flavor is used to
determine the linker to use. Every <code>rustc</code> target defaults to some linker
flavor. Valid options are:</p>
<ul>
<li><code>em</code>: use <a href="https://emscripten.org/docs/tools_reference/emcc.html">Emscripten <code>emcc</code></a>.</li>
<li><code>gcc</code>: use the <code>cc</code> executable, which is typically gcc or clang on many systems.</li>
<li><code>ld</code>: use the <code>ld</code> executable.</li>
<li><code>msvc</code>: use the <code>link.exe</code> executable from Microsoft Visual Studio MSVC.</li>
<li><code>ptx-linker</code>: use
<a href="https://github.com/denzp/rust-ptx-linker"><code>rust-ptx-linker</code></a> for Nvidia
NVPTX GPGPU support.</li>
<li><code>bpf-linker</code>: use
<a href="https://github.com/alessandrod/bpf-linker"><code>bpf-linker</code></a> for eBPF support.</li>
<li><code>wasm-ld</code>: use the <a href="https://lld.llvm.org/WebAssembly.html"><code>wasm-ld</code></a>
executable, a port of LLVM <code>lld</code> for WebAssembly.</li>
<li><code>ld64.lld</code>: use the LLVM <code>lld</code> executable with the <a href="https://lld.llvm.org/Driver.html"><code>-flavor darwin</code>
flag</a> for Apple's <code>ld</code>.</li>
<li><code>ld.lld</code>: use the LLVM <code>lld</code> executable with the <a href="https://lld.llvm.org/Driver.html"><code>-flavor gnu</code>
flag</a> for GNU binutils' <code>ld</code>.</li>
<li><code>lld-link</code>: use the LLVM <code>lld</code> executable with the <a href="https://lld.llvm.org/Driver.html"><code>-flavor link</code>
flag</a> for Microsoft's <code>link.exe</code>.</li>
</ul>
<h2 id="linker-plugin-lto"><a class="header" href="#linker-plugin-lto">linker-plugin-lto</a></h2>
<p>This flag defers LTO optimizations to the linker. See
<a href="codegen-options/../linker-plugin-lto.html">linker-plugin-LTO</a> for more details. It takes one of
the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: enable linker plugin LTO.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: disable linker plugin LTO (the default).</li>
<li>A path to the linker plugin.</li>
</ul>
<p>More specifically this flag will cause the compiler to replace its typical
object file output with LLVM bitcode files. For example an rlib produced with
<code>-Clinker-plugin-lto</code> will still have <code>*.o</code> files in it, but they'll all be LLVM
bitcode instead of actual machine code. It is expected that the native platform
linker is capable of loading these LLVM bitcode files and generating code at
link time (typically after performing optimizations).</p>
<p>Note that rustc can also read its own object files produced with
<code>-Clinker-plugin-lto</code>. If an rlib is only ever going to get used later with a
<code>-Clto</code> compilation then you can pass <code>-Clinker-plugin-lto</code> to speed up
compilation and avoid generating object files that aren't used.</p>
<h2 id="llvm-args"><a class="header" href="#llvm-args">llvm-args</a></h2>
<p>This flag can be used to pass a list of arguments directly to LLVM.</p>
<p>The list must be separated by spaces.</p>
<p>Pass <code>--help</code> to see a list of options.</p>
<h2 id="lto"><a class="header" href="#lto">lto</a></h2>
<p>This flag controls whether LLVM uses <a href="https://llvm.org/docs/LinkTimeOptimization.html">link time
optimizations</a> to produce
better optimized code, using whole-program analysis, at the cost of longer
linking time. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, <code>fat</code>, or no value: perform &quot;fat&quot; LTO which attempts to
perform optimizations across all crates within the dependency graph.</li>
<li><code>n</code>, <code>no</code>, <code>off</code>: disables LTO.</li>
<li><code>thin</code>: perform <a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">&quot;thin&quot;
LTO</a>.
This is similar to &quot;fat&quot;, but takes substantially less time to run while
still achieving performance gains similar to &quot;fat&quot;.</li>
</ul>
<p>If <code>-C lto</code> is not specified, then the compiler will attempt to perform &quot;thin
local LTO&quot; which performs &quot;thin&quot; LTO on the local crate only across its
<a href="codegen-options/index.html#codegen-units">codegen units</a>. When <code>-C lto</code> is not specified, LTO is
disabled if codegen units is 1 or optimizations are disabled (<a href="codegen-options/index.html#opt-level"><code>-C opt-level=0</code></a>). That is:</p>
<ul>
<li>When <code>-C lto</code> is not specified:
<ul>
<li><code>codegen-units=1</code>: disable LTO.</li>
<li><code>opt-level=0</code>: disable LTO.</li>
</ul>
</li>
<li>When <code>-C lto</code> is specified:
<ul>
<li><code>lto</code>: 16 codegen units, perform fat LTO across crates.</li>
<li><code>codegen-units=1</code> + <code>lto</code>: 1 codegen unit, fat LTO across crates.</li>
</ul>
</li>
</ul>
<p>See also <a href="codegen-options/index.html#linker-plugin-lto">linker-plugin-lto</a> for cross-language LTO.</p>
<h2 id="metadata"><a class="header" href="#metadata">metadata</a></h2>
<p>This option allows you to control the metadata used for symbol mangling. This
takes a space-separated list of strings. Mangled symbols will incorporate a
hash of the metadata. This may be used, for example, to differentiate symbols
between two different versions of the same crate being linked.</p>
<h2 id="no-prepopulate-passes"><a class="header" href="#no-prepopulate-passes">no-prepopulate-passes</a></h2>
<p>This flag tells the pass manager to use an empty list of passes, instead of the
usual pre-populated list of passes.</p>
<h2 id="no-redzone"><a class="header" href="#no-redzone">no-redzone</a></h2>
<p>This flag allows you to disable <a href="https://en.wikipedia.org/wiki/Red_zone_(computing)">the
red zone</a>. It takes one
of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: disable the red zone.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: enable the red zone.</li>
</ul>
<p>The default behaviour, if the flag is not specified, depends on the target.</p>
<h2 id="no-stack-check"><a class="header" href="#no-stack-check">no-stack-check</a></h2>
<p>This option is deprecated and does nothing.</p>
<h2 id="no-vectorize-loops"><a class="header" href="#no-vectorize-loops">no-vectorize-loops</a></h2>
<p>This flag disables <a href="https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer">loop
vectorization</a>.</p>
<h2 id="no-vectorize-slp"><a class="header" href="#no-vectorize-slp">no-vectorize-slp</a></h2>
<p>This flag disables vectorization using
<a href="https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer">superword-level
parallelism</a>.</p>
<h2 id="opt-level"><a class="header" href="#opt-level">opt-level</a></h2>
<p>This flag controls the optimization level.</p>
<ul>
<li><code>0</code>: no optimizations, also turns on
<a href="codegen-options/index.html#debug-assertions"><code>cfg(debug_assertions)</code></a> (the default).</li>
<li><code>1</code>: basic optimizations.</li>
<li><code>2</code>: some optimizations.</li>
<li><code>3</code>: all optimizations.</li>
<li><code>s</code>: optimize for binary size.</li>
<li><code>z</code>: optimize for binary size, but also turn off loop vectorization.</li>
</ul>
<p>Note: The <a href="codegen-options/../command-line-arguments.html#option-o-optimize"><code>-O</code> flag</a> is an alias for <code>-C opt-level=2</code>.</p>
<p>The default is <code>0</code>.</p>
<h2 id="overflow-checks"><a class="header" href="#overflow-checks">overflow-checks</a></h2>
<p>This flag allows you to control the behavior of <a href="codegen-options/../../reference/expressions/operator-expr.html#overflow">runtime integer
overflow</a>. When
overflow-checks are enabled, a panic will occur on overflow. This flag takes
one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: enable overflow checks.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: disable overflow checks.</li>
</ul>
<p>If not specified, overflow checks are enabled if
<a href="codegen-options/index.html#debug-assertions">debug-assertions</a> are enabled, disabled otherwise.</p>
<h2 id="panic"><a class="header" href="#panic">panic</a></h2>
<p>This option lets you control what happens when the code panics.</p>
<ul>
<li><code>abort</code>: terminate the process upon panic</li>
<li><code>unwind</code>: unwind the stack upon panic</li>
</ul>
<p>If not specified, the default depends on the target.</p>
<h2 id="passes"><a class="header" href="#passes">passes</a></h2>
<p>This flag can be used to add extra <a href="http://llvm.org/docs/Passes.html">LLVM
passes</a> to the compilation.</p>
<p>The list must be separated by spaces.</p>
<p>See also the <a href="codegen-options/index.html#no-prepopulate-passes"><code>no-prepopulate-passes</code></a> flag.</p>
<h2 id="prefer-dynamic"><a class="header" href="#prefer-dynamic">prefer-dynamic</a></h2>
<p>By default, <code>rustc</code> prefers to statically link dependencies. This option will
indicate that dynamic linking should be used if possible if both a static and
dynamic versions of a library are available. There is an internal algorithm
for determining whether or not it is possible to statically or dynamically
link with a dependency. For example, <code>cdylib</code> crate types may only use static
linkage. This flag takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: use dynamic linking.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: use static linking (the default).</li>
</ul>
<h2 id="profile-generate"><a class="header" href="#profile-generate">profile-generate</a></h2>
<p>This flag allows for creating instrumented binaries that will collect
profiling data for use with profile-guided optimization (PGO). The flag takes
an optional argument which is the path to a directory into which the
instrumented binary will emit the collected data. See the chapter on
<a href="codegen-options/../profile-guided-optimization.html">profile-guided optimization</a> for more information.</p>
<h2 id="profile-use"><a class="header" href="#profile-use">profile-use</a></h2>
<p>This flag specifies the profiling data file to be used for profile-guided
optimization (PGO). The flag takes a mandatory argument which is the path
to a valid <code>.profdata</code> file. See the chapter on
<a href="codegen-options/../profile-guided-optimization.html">profile-guided optimization</a> for more information.</p>
<h2 id="relocation-model"><a class="header" href="#relocation-model">relocation-model</a></h2>
<p>This option controls generation of
<a href="https://en.wikipedia.org/wiki/Position-independent_code">position-independent code (PIC)</a>.</p>
<p>Supported values for this option are:</p>
<h4 id="primary-relocation-models"><a class="header" href="#primary-relocation-models">Primary relocation models</a></h4>
<ul>
<li>
<p><code>static</code> - non-relocatable code, machine instructions may use absolute addressing modes.</p>
</li>
<li>
<p><code>pic</code> - fully relocatable position independent code,
machine instructions need to use relative addressing modes.  <br />
Equivalent to the &quot;uppercase&quot; <code>-fPIC</code> or <code>-fPIE</code> options in other compilers,
depending on the produced crate types.  <br />
This is the default model for majority of supported targets.</p>
</li>
<li>
<p><code>pie</code> - position independent executable, relocatable code but without support for symbol
interpositioning (replacing symbols by name using <code>LD_PRELOAD</code> and similar). Equivalent to the &quot;uppercase&quot; <code>-fPIE</code> option in other compilers. <code>pie</code>
code cannot be linked into shared libraries (you'll get a linking error on attempt to do this).</p>
</li>
</ul>
<h4 id="special-relocation-models"><a class="header" href="#special-relocation-models">Special relocation models</a></h4>
<ul>
<li><code>dynamic-no-pic</code> - relocatable external references, non-relocatable code.  <br />
Only makes sense on Darwin and is rarely used.  <br />
If StackOverflow tells you to use this as an opt-out of PIC or PIE, don't believe it,
use <code>-C relocation-model=static</code> instead.</li>
<li><code>ropi</code>, <code>rwpi</code> and <code>ropi-rwpi</code> - relocatable code and read-only data, relocatable read-write data,
and combination of both, respectively.  <br />
Only makes sense for certain embedded ARM targets.</li>
<li><code>default</code> - relocation model default to the current target.  <br />
Only makes sense as an override for some other explicitly specified relocation model
previously set on the command line.</li>
</ul>
<p>Supported values can also be discovered by running <code>rustc --print relocation-models</code>.</p>
<h4 id="linking-effects"><a class="header" href="#linking-effects">Linking effects</a></h4>
<p>In addition to codegen effects, <code>relocation-model</code> has effects during linking.</p>
<p>If the relocation model is <code>pic</code> and the current target supports position-independent executables
(PIE), the linker will be instructed (<code>-pie</code>) to produce one.  <br />
If the target doesn't support both position-independent and statically linked executables,
then <code>-C target-feature=+crt-static</code> &quot;wins&quot; over <code>-C relocation-model=pic</code>,
and the linker is instructed (<code>-static</code>) to produce a statically linked
but not position-independent executable.</p>
<h2 id="remark"><a class="header" href="#remark">remark</a></h2>
<p>This flag lets you print remarks for optimization passes.</p>
<p>The list of passes should be separated by spaces.</p>
<p><code>all</code> will remark on every pass.</p>
<h2 id="rpath"><a class="header" href="#rpath">rpath</a></h2>
<p>This flag controls whether <a href="https://en.wikipedia.org/wiki/Rpath"><code>rpath</code></a> is
enabled. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: enable rpath.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: disable rpath (the default).</li>
</ul>
<h2 id="save-temps"><a class="header" href="#save-temps">save-temps</a></h2>
<p>This flag controls whether temporary files generated during compilation are
deleted once compilation finishes. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: save temporary files.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: delete temporary files (the default).</li>
</ul>
<h2 id="soft-float"><a class="header" href="#soft-float">soft-float</a></h2>
<p>This option controls whether <code>rustc</code> generates code that emulates floating
point instructions in software. It takes one of the following values:</p>
<ul>
<li><code>y</code>, <code>yes</code>, <code>on</code>, or no value: use soft floats.</li>
<li><code>n</code>, <code>no</code>, or <code>off</code>: use hardware floats (the default).</li>
</ul>
<h2 id="split-debuginfo"><a class="header" href="#split-debuginfo">split-debuginfo</a></h2>
<p>This option controls the emission of &quot;split debuginfo&quot; for debug information
that <code>rustc</code> generates. The default behavior of this option is
platform-specific, and not all possible values for this option work on all
platforms. Possible values are:</p>
<ul>
<li>
<p><code>off</code> - This is the default for platforms with ELF binaries and windows-gnu
(not Windows MSVC and not macOS). This typically means that DWARF debug
information can be found in the final artifact in sections of the executable.
This option is not supported on Windows MSVC. On macOS this options prevents
the final execution of <code>dsymutil</code> to generate debuginfo.</p>
</li>
<li>
<p><code>packed</code> - This is the default for Windows MSVC and macOS. The term
&quot;packed&quot; here means that all the debug information is packed into a separate
file from the main executable. On Windows MSVC this is a <code>*.pdb</code> file, on
macOS this is a <code>*.dSYM</code> folder, and on other platforms this is a <code>*.dwp</code>
file.</p>
</li>
<li>
<p><code>unpacked</code> - This means that debug information will be found in separate
files for each compilation unit (object file). This is not supported on
Windows MSVC. On macOS this means the original object files will contain
debug information. On other Unix platforms this means that <code>*.dwo</code> files will
contain debug information.</p>
</li>
</ul>
<p>Note that <code>packed</code> and <code>unpacked</code> are gated behind <code>-Z unstable-options</code> on
non-macOS platforms at this time.</p>
<h2 id="strip"><a class="header" href="#strip">strip</a></h2>
<p>The option <code>-C strip=val</code> controls stripping of debuginfo and similar auxiliary
data from binaries during linking.</p>
<p>Supported values for this option are:</p>
<ul>
<li><code>none</code> - debuginfo and symbols (if they exist) are copied to the produced
binary or separate files depending on the target (e.g. <code>.pdb</code> files in case
of MSVC).</li>
<li><code>debuginfo</code> - debuginfo sections and debuginfo symbols from the symbol table
section are stripped at link time and are not copied to the produced binary
or separate files.</li>
<li><code>symbols</code> - same as <code>debuginfo</code>, but the rest of the symbol table section is
stripped as well if the linker supports it.</li>
</ul>
<h2 id="target-cpu"><a class="header" href="#target-cpu">target-cpu</a></h2>
<p>This instructs <code>rustc</code> to generate code specifically for a particular processor.</p>
<p>You can run <code>rustc --print target-cpus</code> to see the valid options to pass
here. Each target has a default base CPU. Special values include:</p>
<ul>
<li><code>native</code> can be passed to use the processor of the host machine.</li>
<li><code>generic</code> refers to an LLVM target with minimal features but modern tuning.</li>
</ul>
<h2 id="target-feature"><a class="header" href="#target-feature">target-feature</a></h2>
<p>Individual targets will support different features; this flag lets you control
enabling or disabling a feature. Each feature should be prefixed with a <code>+</code> to
enable it or <code>-</code> to disable it.</p>
<p>Features from multiple <code>-C target-feature</code> options are combined. <br />
Multiple features can be specified in a single option by separating them
with commas - <code>-C target-feature=+x,-y</code>. <br />
If some feature is specified more than once with both <code>+</code> and <code>-</code>,
then values passed later override values passed earlier. <br />
For example, <code>-C target-feature=+x,-y,+z -Ctarget-feature=-x,+y</code>
is equivalent to <code>-C target-feature=-x,+y,+z</code>.</p>
<p>To see the valid options and an example of use, run <code>rustc --print target-features</code>.</p>
<p>Using this flag is unsafe and might result in <a href="codegen-options/../targets/known-issues.html">undefined runtime
behavior</a>.</p>
<p>See also the <a href="codegen-options/../../reference/attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code>
attribute</a>
for controlling features per-function.</p>
<p>This also supports the feature <code>+crt-static</code> and <code>-crt-static</code> to control
<a href="codegen-options/../../reference/linkage.html#static-and-dynamic-c-runtimes">static C runtime linkage</a>.</p>
<p>Each target and <a href="codegen-options/index.html#target-cpu"><code>target-cpu</code></a> has a default set of enabled
features.</p>
<h2 id="tune-cpu"><a class="header" href="#tune-cpu">tune-cpu</a></h2>
<p>This instructs <code>rustc</code> to schedule code specifically for a particular
processor. This does not affect the compatibility (instruction sets or ABI),
but should make your code slightly more efficient on the selected CPU.</p>
<p>The valid options are the same as those for <a href="codegen-options/index.html#target-cpu"><code>target-cpu</code></a>.
The default is <code>None</code>, which LLVM translates as the <code>target-cpu</code>.</p>
<p>This is an unstable option. Use <code>-Z tune-cpu=machine</code> to specify a value.</p>
<p>Due to limitations in LLVM (12.0.0-git9218f92), this option is currently
effective only for x86 targets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json-output"><a class="header" href="#json-output">JSON Output</a></h1>
<p>This chapter documents the JSON structures emitted by <code>rustc</code>. JSON may be
enabled with the <a href="command-line-arguments.html#option-error-format"><code>--error-format=json</code> flag</a>. Additional
options may be specified with the <a href="command-line-arguments.html#option-json"><code>--json</code> flag</a> which can
change which messages are generated, and the format of the messages.</p>
<p>JSON messages are emitted one per line to stderr.</p>
<p>If parsing the output with Rust, the
<a href="https://crates.io/crates/cargo_metadata"><code>cargo_metadata</code></a> crate provides
some support for parsing the messages.</p>
<p>When parsing, care should be taken to be forwards-compatible with future changes
to the format. Optional values may be <code>null</code>. New fields may be added. Enumerated
fields like &quot;level&quot; or &quot;suggestion_applicability&quot; may add new values.</p>
<h2 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h2>
<p>Diagnostic messages provide errors or possible concerns generated during
compilation. <code>rustc</code> provides detailed information about where the diagnostic
originates, along with hints and suggestions.</p>
<p>Diagnostics are arranged in a parent/child relationship where the parent
diagnostic value is the core of the diagnostic, and the attached children
provide additional context, help, and information.</p>
<p>Diagnostics have the following format:</p>
<pre><code class="language-javascript">{
    /* The primary message. */
    &quot;message&quot;: &quot;unused variable: `x`&quot;,
    /* The diagnostic code.
       Some messages may set this value to null.
    */
    &quot;code&quot;: {
        /* A unique string identifying which diagnostic triggered. */
        &quot;code&quot;: &quot;unused_variables&quot;,
        /* An optional string explaining more detail about the diagnostic code. */
        &quot;explanation&quot;: null
    },
    /* The severity of the diagnostic.
       Values may be:
       - &quot;error&quot;: A fatal error that prevents compilation.
       - &quot;warning&quot;: A possible error or concern.
       - &quot;note&quot;: Additional information or context about the diagnostic.
       - &quot;help&quot;: A suggestion on how to resolve the diagnostic.
       - &quot;failure-note&quot;: A note attached to the message for further information.
       - &quot;error: internal compiler error&quot;: Indicates a bug within the compiler.
    */
    &quot;level&quot;: &quot;warning&quot;,
    /* An array of source code locations to point out specific details about
       where the diagnostic originates from. This may be empty, for example
       for some global messages, or child messages attached to a parent.

       Character offsets are offsets of Unicode Scalar Values.
    */
    &quot;spans&quot;: [
        {
            /* The file where the span is located.
               Note that this path may not exist. For example, if the path
               points to the standard library, and the rust src is not
               available in the sysroot, then it may point to a non-existent
               file. Beware that this may also point to the source of an
               external crate.
            */
            &quot;file_name&quot;: &quot;lib.rs&quot;,
            /* The byte offset where the span starts (0-based, inclusive). */
            &quot;byte_start&quot;: 21,
            /* The byte offset where the span ends (0-based, exclusive). */
            &quot;byte_end&quot;: 22,
            /* The first line number of the span (1-based, inclusive). */
            &quot;line_start&quot;: 2,
            /* The last line number of the span (1-based, inclusive). */
            &quot;line_end&quot;: 2,
            /* The first character offset of the line_start (1-based, inclusive). */
            &quot;column_start&quot;: 9,
            /* The last character offset of the line_end (1-based, exclusive). */
            &quot;column_end&quot;: 10,
            /* Whether or not this is the &quot;primary&quot; span.

               This indicates that this span is the focal point of the
               diagnostic.

               There are rare cases where multiple spans may be marked as
               primary. For example, &quot;immutable borrow occurs here&quot; and
               &quot;mutable borrow ends here&quot; can be two separate primary spans.

               The top (parent) message should always have at least one
               primary span, unless it has zero spans. Child messages may have
               zero or more primary spans.
            */
            &quot;is_primary&quot;: true,
            /* An array of objects showing the original source code for this
               span. This shows the entire lines of text where the span is
               located. A span across multiple lines will have a separate
               value for each line.
            */
            &quot;text&quot;: [
                {
                    /* The entire line of the original source code. */
                    &quot;text&quot;: &quot;    let x = 123;&quot;,
                    /* The first character offset of the line of
                       where the span covers this line (1-based, inclusive). */
                    &quot;highlight_start&quot;: 9,
                    /* The last character offset of the line of
                       where the span covers this line (1-based, exclusive). */
                    &quot;highlight_end&quot;: 10
                }
            ],
            /* An optional message to display at this span location.
               This is typically null for primary spans.
            */
            &quot;label&quot;: null,
            /* An optional string of a suggested replacement for this span to
               solve the issue. Tools may try to replace the contents of the
               span with this text.
            */
            &quot;suggested_replacement&quot;: null,
            /* An optional string that indicates the confidence of the
               &quot;suggested_replacement&quot;. Tools may use this value to determine
               whether or not suggestions should be automatically applied.

               Possible values may be:
               - &quot;MachineApplicable&quot;: The suggestion is definitely what the
                 user intended. This suggestion should be automatically
                 applied.
               - &quot;MaybeIncorrect&quot;: The suggestion may be what the user
                 intended, but it is uncertain. The suggestion should result
                 in valid Rust code if it is applied.
               - &quot;HasPlaceholders&quot;: The suggestion contains placeholders like
                 `(...)`. The suggestion cannot be applied automatically
                 because it will not result in valid Rust code. The user will
                 need to fill in the placeholders.
               - &quot;Unspecified&quot;: The applicability of the suggestion is unknown.
            */
            &quot;suggestion_applicability&quot;: null,
            /* An optional object indicating the expansion of a macro within
               this span.

               If a message occurs within a macro invocation, this object will
               provide details of where within the macro expansion the message
               is located.
            */
            &quot;expansion&quot;: {
                /* The span of the macro invocation.
                   Uses the same span definition as the &quot;spans&quot; array.
                */
                &quot;span&quot;: {/*...*/}
                /* Name of the macro, such as &quot;foo!&quot; or &quot;#[derive(Eq)]&quot;. */
                &quot;macro_decl_name&quot;: &quot;some_macro!&quot;,
                /* Optional span where the relevant part of the macro is
                  defined. */
                &quot;def_site_span&quot;: {/*...*/},
            }
        }
    ],
    /* Array of attached diagnostic messages.
       This is an array of objects using the same format as the parent
       message. Children are not nested (children do not themselves
       contain &quot;children&quot; definitions).
    */
    &quot;children&quot;: [
        {
            &quot;message&quot;: &quot;`#[warn(unused_variables)]` on by default&quot;,
            &quot;code&quot;: null,
            &quot;level&quot;: &quot;note&quot;,
            &quot;spans&quot;: [],
            &quot;children&quot;: [],
            &quot;rendered&quot;: null
        },
        {
            &quot;message&quot;: &quot;if this is intentional, prefix it with an underscore&quot;,
            &quot;code&quot;: null,
            &quot;level&quot;: &quot;help&quot;,
            &quot;spans&quot;: [
                {
                    &quot;file_name&quot;: &quot;lib.rs&quot;,
                    &quot;byte_start&quot;: 21,
                    &quot;byte_end&quot;: 22,
                    &quot;line_start&quot;: 2,
                    &quot;line_end&quot;: 2,
                    &quot;column_start&quot;: 9,
                    &quot;column_end&quot;: 10,
                    &quot;is_primary&quot;: true,
                    &quot;text&quot;: [
                        {
                            &quot;text&quot;: &quot;    let x = 123;&quot;,
                            &quot;highlight_start&quot;: 9,
                            &quot;highlight_end&quot;: 10
                        }
                    ],
                    &quot;label&quot;: null,
                    &quot;suggested_replacement&quot;: &quot;_x&quot;,
                    &quot;suggestion_applicability&quot;: &quot;MachineApplicable&quot;,
                    &quot;expansion&quot;: null
                }
            ],
            &quot;children&quot;: [],
            &quot;rendered&quot;: null
        }
    ],
    /* Optional string of the rendered version of the diagnostic as displayed
       by rustc. Note that this may be influenced by the `--json` flag.
    */
    &quot;rendered&quot;: &quot;warning: unused variable: `x`\n --&gt; lib.rs:2:9\n  |\n2 |     let x = 123;\n  |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n  |\n  = note: `#[warn(unused_variables)]` on by default\n\n&quot;
}
</code></pre>
<h2 id="artifact-notifications"><a class="header" href="#artifact-notifications">Artifact notifications</a></h2>
<p>Artifact notifications are emitted when the <a href="command-line-arguments.html#option-json"><code>--json=artifacts</code>
flag</a> is used. They indicate that a file artifact has been saved
to disk. More information about emit kinds may be found in the <a href="command-line-arguments.html#option-emit"><code>--emit</code>
flag</a> documentation.</p>
<pre><code class="language-javascript">{
    /* The filename that was generated. */
    &quot;artifact&quot;: &quot;libfoo.rlib&quot;,
    /* The kind of artifact that was generated. Possible values:
       - &quot;link&quot;: The generated crate as specified by the crate-type.
       - &quot;dep-info&quot;: The `.d` file with dependency information in a Makefile-like syntax.
       - &quot;metadata&quot;: The Rust `.rmeta` file containing metadata about the crate.
       - &quot;save-analysis&quot;: A JSON file emitted by the `-Zsave-analysis` feature.
    */
    &quot;emit&quot;: &quot;link&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p><code>rustc</code> has a built-in facility for building and running tests for a crate.
More information about writing and running tests may be found in the <a href="tests/../../book/ch11-00-testing.html">Testing
Chapter</a> of the Rust Programming Language book.</p>
<p>Tests are written as free functions with the <a href="tests/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code>
attribute</a>. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}
<span class="boring">}
</span></code></pre></pre>
<p>Tests &quot;pass&quot; if they return without an error. They &quot;fail&quot; if they <a href="tests/../../book/ch09-01-unrecoverable-errors-with-panic.html">panic</a>, or
return a <a href="tests/../../std/result/index.html"><code>Result</code></a> with an error.</p>
<p>By passing the <a href="tests/../command-line-arguments.html#option-test"><code>--test</code> option</a> to <code>rustc</code>, the compiler will build the crate
in a special mode to construct an executable that will run the tests in the
crate. The <code>--test</code> flag will make the following changes:</p>
<ul>
<li>The crate will be built as a <code>bin</code> <a href="tests/../../reference/linkage.html">crate type</a>, forcing it to be an
executable.</li>
<li>Links the executable with <a href="tests/../../test/index.html"><code>libtest</code></a>, the test harness that is part of the
standard library, which handles running the tests.</li>
<li>Synthesizes a <a href="tests/../../reference/crates-and-source-files.html#main-functions"><code>main</code> function</a> which will process command-line arguments
and run the tests. This new <code>main</code> function will replace any existing <code>main</code>
function as the entry point of the executable, though the existing <code>main</code>
will still be compiled.</li>
<li>Enables the <a href="tests/../../reference/conditional-compilation.html#test"><code>test</code> cfg option</a>, which allows your code to use conditional
compilation to detect if it is being built as a test.</li>
<li>Enables building of functions annotated with the <a href="tests/../../reference/attributes/testing.html#the-test-attribute"><code>test</code></a>
and <a href="tests/index.html#benchmarks"><code>bench</code></a> attributes, which will be run by the test
harness.</li>
</ul>
<p>After the executable is created, you can run it to execute the tests and
receive a report on what passes and fails. If you are using <a href="tests/../../cargo/index.html">Cargo</a> to manage
your project, it has a built-in <a href="tests/../../cargo/commands/cargo-test.html"><code>cargo test</code></a> command which handles all of
this automatically. An example of the output looks like this:</p>
<pre><code class="language-text">running 4 tests
test it_works ... ok
test check_valid_args ... ok
test invalid_characters ... ok
test walks_the_dog ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<blockquote>
<p><strong>Note</strong>: Tests must be built with the <a href="tests/../../book/ch09-01-unrecoverable-errors-with-panic.html"><code>unwind</code> panic
strategy</a>. This is because all tests run in the same
process, and they are intended to catch panics, which is not possible with
the <code>abort</code> strategy. See the unstable <a href="https://github.com/rust-lang/rust/issues/67650"><code>-Z panic-abort-tests</code></a> option for
experimental support of the <code>abort</code> strategy by spawning tests in separate
processes.</p>
</blockquote>
<h2 id="test-attributes"><a class="header" href="#test-attributes">Test attributes</a></h2>
<p>Tests are indicated using attributes on free functions. The following
attributes are used for testing, see the linked documentation for more
details:</p>
<ul>
<li><a href="tests/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a> — Indicates a function is a test to be run.</li>
<li><code>#[bench]</code> — Indicates a function is a benchmark to be
run. Benchmarks are currently unstable and only available in the nightly
channel, see the <a href="tests/../../unstable-book/library-features/test.html">unstable docs</a> for more details.</li>
<li><a href="tests/../../reference/attributes/testing.html#the-should_panic-attribute"><code>#[should_panic]</code></a> — Indicates that the test
function will only pass if the function <a href="tests/../../book/ch09-01-unrecoverable-errors-with-panic.html">panics</a>.</li>
<li><a href="tests/../../reference/attributes/testing.html#the-ignore-attribute"><code>#[ignore]</code></a> — Indicates that the test function will be
compiled, but not run by default. See the <a href="tests/index.html#--ignored"><code>--ignored</code></a> and
<a href="tests/index.html#--include-ignored"><code>--include-ignored</code></a> options to run these tests.</li>
</ul>
<h2 id="cli-arguments"><a class="header" href="#cli-arguments">CLI arguments</a></h2>
<p>The libtest harness has several command-line arguments to control its
behavior.</p>
<blockquote>
<p>Note: When running with <a href="tests/../../cargo/commands/cargo-test.html"><code>cargo test</code></a>, the libtest CLI arguments must be
passed after the <code>--</code> argument to differentiate between flags for Cargo and
those for the harness. For example: <code>cargo test -- --nocapture</code></p>
</blockquote>
<h3 id="filters"><a class="header" href="#filters">Filters</a></h3>
<p>Positional arguments (those without a <code>-</code> prefix) are treated as filters which
will only run tests whose name matches one of those strings. The filter will
match any substring found in the full path of the test function. For example,
if the test function <code>it_works</code> is located in the module
<code>utils::paths::tests</code>, then any of the filters <code>works</code>, <code>path</code>, <code>utils::</code>, or
<code>utils::paths::tests::it_works</code> will match that test.</p>
<p>See <a href="tests/index.html#selection-options">Selection options</a> for more options to control which
tests are run.</p>
<h3 id="action-options"><a class="header" href="#action-options">Action options</a></h3>
<p>The following options perform different actions other than running tests.</p>
<h4 id="--list"><a class="header" href="#--list"><code>--list</code></a></h4>
<p>Prints a list of all tests and benchmarks. Does not run any of the tests.
<a href="tests/index.html#filters">Filters</a> can be used to list only matching tests.</p>
<h4 id="-h---help"><a class="header" href="#-h---help"><code>-h</code>, <code>--help</code></a></h4>
<p>Displays usage information and command-line options.</p>
<h3 id="selection-options"><a class="header" href="#selection-options">Selection options</a></h3>
<p>The following options change how tests are selected.</p>
<h4 id="--test"><a class="header" href="#--test"><code>--test</code></a></h4>
<p>This is the default mode where all tests will be run as well as running all
benchmarks with only a single iteration (to ensure the benchmark works,
without taking the time to actually perform benchmarking). This can be
combined with the <code>--bench</code> flag to run both tests and perform full
benchmarking.</p>
<h4 id="--bench"><a class="header" href="#--bench"><code>--bench</code></a></h4>
<p>This runs in a mode where tests are ignored, and only runs benchmarks. This
can be combined with <code>--test</code> to run both benchmarks and tests.</p>
<h4 id="--exact"><a class="header" href="#--exact"><code>--exact</code></a></h4>
<p>This forces <a href="tests/index.html#filters">filters</a> to match the full path of the test exactly.
For example, if the test <code>it_works</code> is in the module <code>utils::paths::tests</code>,
then only the string <code>utils::paths::tests::it_works</code> will match that test.</p>
<h4 id="--skip-filter"><a class="header" href="#--skip-filter"><code>--skip</code> <em>FILTER</em></a></h4>
<p>Skips any tests whose name contains the given <em>FILTER</em> string. This flag may
be passed multiple times.</p>
<h4 id="--ignored"><a class="header" href="#--ignored"><code>--ignored</code></a></h4>
<p>Runs only tests that are marked with the <a href="tests/../../reference/attributes/testing.html#the-ignore-attribute"><code>ignore</code>
attribute</a>.</p>
<h4 id="--include-ignored"><a class="header" href="#--include-ignored"><code>--include-ignored</code></a></h4>
<p>Runs both <a href="tests/index.html#--ignored">ignored</a> and non-ignored tests.</p>
<h4 id="--exclude-should-panic"><a class="header" href="#--exclude-should-panic"><code>--exclude-should-panic</code></a></h4>
<p>Excludes tests marked with the <a href="tests/../../reference/attributes/testing.html#the-should_panic-attribute"><code>should_panic</code>
attribute</a>.</p>
<p>⚠️ 🚧 This option is <a href="tests/index.html#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/82348">tracking issue
#82348</a> for more information.</p>
<h3 id="execution-options"><a class="header" href="#execution-options">Execution options</a></h3>
<p>The following options affect how tests are executed.</p>
<h4 id="--test-threads-num_threads"><a class="header" href="#--test-threads-num_threads"><code>--test-threads</code> <em>NUM_THREADS</em></a></h4>
<p>Sets the number of threads to use for running tests in parallel. By default,
uses the amount of concurrency available on the hardware as indicated by
<a href="tests/../../std/thread/fn.available_parallelism.html"><code>available_parallelism</code></a>.</p>
<p>This can also be specified with the <code>RUST_TEST_THREADS</code> environment variable.</p>
<h4 id="--force-run-in-process"><a class="header" href="#--force-run-in-process"><code>--force-run-in-process</code></a></h4>
<p>Forces the tests to run in a single process when using the <a href="tests/../../book/ch09-01-unrecoverable-errors-with-panic.html"><code>abort</code> panic
strategy</a>.</p>
<p>⚠️ 🚧 This only works with the unstable <a href="https://github.com/rust-lang/rust/issues/67650"><code>-Z panic-abort-tests</code></a> option, and
requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/67650">tracking issue
#67650</a> for more information.</p>
<h4 id="--ensure-time"><a class="header" href="#--ensure-time"><code>--ensure-time</code></a></h4>
<p>⚠️ 🚧 This option is <a href="tests/index.html#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/64888">tracking issue
#64888</a> and the <a href="tests/../../unstable-book/compiler-flags/report-time.html">unstable
docs</a> for more information.</p>
<h4 id="--shuffle"><a class="header" href="#--shuffle"><code>--shuffle</code></a></h4>
<p>Runs the tests in random order, as opposed to the default alphabetical order.</p>
<p>This may also be specified by setting the <code>RUST_TEST_SHUFFLE</code> environment
variable to anything but <code>0</code>.</p>
<p>The random number generator seed that is output can be passed to
<a href="tests/index.html#--shuffle-seed-seed"><code>--shuffle-seed</code></a> to run the tests in the same order
again.</p>
<p>Note that <code>--shuffle</code> does not affect whether the tests are run in parallel. To
run the tests in random order sequentially, use <code>--shuffle --test-threads 1</code>.</p>
<p>⚠️ 🚧 This option is <a href="tests/index.html#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/89583">tracking issue
#89583</a> for more information.</p>
<h4 id="--shuffle-seed-seed"><a class="header" href="#--shuffle-seed-seed"><code>--shuffle-seed</code> <em>SEED</em></a></h4>
<p>Like <a href="tests/index.html#--shuffle"><code>--shuffle</code></a>, but seeds the random number generator with
<em>SEED</em>. Thus, calling the test harness with <code>--shuffle-seed</code> <em>SEED</em> twice runs
the tests in the same order both times.</p>
<p><em>SEED</em> is any 64-bit unsigned integer, for example, one produced by
<a href="tests/index.html#--shuffle"><code>--shuffle</code></a>.</p>
<p>This can also be specified with the <code>RUST_TEST_SHUFFLE_SEED</code> environment
variable.</p>
<p>⚠️ 🚧 This option is <a href="tests/index.html#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/89583">tracking issue
#89583</a> for more information.</p>
<h3 id="output-options"><a class="header" href="#output-options">Output options</a></h3>
<p>The following options affect the output behavior.</p>
<h4 id="-q---quiet"><a class="header" href="#-q---quiet"><code>-q</code>, <code>--quiet</code></a></h4>
<p>Displays one character per test instead of one line per test. This is an alias
for <a href="tests/index.html#--format-format"><code>--format=terse</code></a>.</p>
<h4 id="--nocapture"><a class="header" href="#--nocapture"><code>--nocapture</code></a></h4>
<p>Does not capture the stdout and stderr of the test, and allows tests to print
to the console. Usually the output is captured, and only displayed if the test
fails.</p>
<p>This may also be specified by setting the <code>RUST_TEST_NOCAPTURE</code> environment
variable to anything but <code>0</code>.</p>
<h4 id="--show-output"><a class="header" href="#--show-output"><code>--show-output</code></a></h4>
<p>Displays the stdout and stderr of successful tests after all tests have run.</p>
<p>Contrast this with <a href="tests/index.html#--nocapture"><code>--nocapture</code></a> which allows tests to print
<em>while they are running</em>, which can cause interleaved output if there are
multiple tests running in parallel, <code>--show-output</code> ensures the output is
contiguous, but requires waiting for all tests to finish.</p>
<h4 id="--color-color"><a class="header" href="#--color-color"><code>--color</code> <em>COLOR</em></a></h4>
<p>Control when colored terminal output is used. Valid options:</p>
<ul>
<li><code>auto</code>: Colorize if stdout is a tty and <a href="tests/index.html#--nocapture"><code>--nocapture</code></a> is not
used. This is the default.</li>
<li><code>always</code>: Always colorize the output.</li>
<li><code>never</code>: Never colorize the output.</li>
</ul>
<h4 id="--format-format"><a class="header" href="#--format-format"><code>--format</code> <em>FORMAT</em></a></h4>
<p>Controls the format of the output. Valid options:</p>
<ul>
<li><code>pretty</code>: This is the default format, with one line per test.</li>
<li><code>terse</code>: Displays only a single character per test. <a href="tests/index.html#-q---quiet"><code>--quiet</code></a>
is an alias for this option.</li>
<li><code>json</code>: Emits JSON objects, one per line. ⚠️ 🚧 This option is
<a href="tests/index.html#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag.
See <a href="https://github.com/rust-lang/rust/issues/49359">tracking issue #49359</a>
for more information.</li>
</ul>
<h4 id="--logfile-path"><a class="header" href="#--logfile-path"><code>--logfile</code> <em>PATH</em></a></h4>
<p>Writes the results of the tests to the given file.</p>
<h4 id="--report-time-format"><a class="header" href="#--report-time-format"><code>--report-time</code> <em>FORMAT</em></a></h4>
<p>⚠️ 🚧 This option is <a href="tests/index.html#unstable-options">unstable</a>, and requires the <code>-Z unstable-options</code> flag. See <a href="https://github.com/rust-lang/rust/issues/64888">tracking issue
#64888</a> and the <a href="tests/../../unstable-book/compiler-flags/report-time.html">unstable
docs</a> for more information.</p>
<h3 id="unstable-options"><a class="header" href="#unstable-options">Unstable options</a></h3>
<p>Some CLI options are added in an &quot;unstable&quot; state, where they are intended for
experimentation and testing to determine if the option works correctly, has
the right design, and is useful. The option may not work correctly, break, or
change at any time. To signal that you acknowledge that you are using an
unstable option, they require passing the <code>-Z unstable-options</code> command-line
flag.</p>
<h2 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h2>
<p>The libtest harness supports running benchmarks for functions annotated with
the <code>#[bench]</code> attribute. Benchmarks are currently unstable, and only
available on the <a href="tests/../../book/appendix-07-nightly-rust.html">nightly channel</a>. More information may be found in the
<a href="tests/../../unstable-book/library-features/test.html">unstable book</a>.</p>
<h2 id="custom-test-frameworks"><a class="header" href="#custom-test-frameworks">Custom test frameworks</a></h2>
<p>Experimental support for using custom test harnesses is available on the
<a href="tests/../../book/appendix-07-nightly-rust.html">nightly channel</a>. See <a href="https://github.com/rust-lang/rust/issues/50297">tracking issue
#50297</a> and the
<a href="tests/../../unstable-book/language-features/custom-test-frameworks.html">custom_test_frameworks documentation</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-support"><a class="header" href="#platform-support">Platform Support</a></h1>
<style type="text/css">
    td code {
        white-space: nowrap;
    }
</style>
<p>Support for different platforms (&quot;targets&quot;) are organized into three tiers,
each with a different set of guarantees. For more information on the policies
for targets at each tier, see the <a href="target-tier-policy.html">Target Tier Policy</a>.</p>
<p>Targets are identified by their &quot;target triple&quot; which is the string to inform
the compiler what kind of output should be produced.</p>
<h2 id="tier-1-with-host-tools"><a class="header" href="#tier-1-with-host-tools">Tier 1 with Host Tools</a></h2>
<p>Tier 1 targets can be thought of as &quot;guaranteed to work&quot;. The Rust project
builds official binary releases for each tier 1 target, and automated testing
ensures that each tier 1 target builds and passes tests after each change.</p>
<p>Tier 1 targets with host tools additionally support running tools like <code>rustc</code>
and <code>cargo</code> natively on the target, and automated testing ensures that tests
pass for the host tools as well. This allows the target to be used as a
development platform, not just a compilation target. For the full requirements,
see <a href="target-tier-policy.html#tier-1-with-host-tools">Tier 1 with Host Tools</a> in
the Target Tier Policy.</p>
<p>All tier 1 targets with host tools support the full standard library.</p>
<table><thead><tr><th>target</th><th>notes</th></tr></thead><tbody>
<tr><td><code>aarch64-unknown-linux-gnu</code></td><td>ARM64 Linux (kernel 4.2, glibc 2.17+) <sup class="footnote-reference"><a href="#missing-stack-probes">1</a></sup></td></tr>
<tr><td><code>i686-pc-windows-gnu</code></td><td>32-bit MinGW (Windows 7+)</td></tr>
<tr><td><code>i686-pc-windows-msvc</code></td><td>32-bit MSVC (Windows 7+)</td></tr>
<tr><td><code>i686-unknown-linux-gnu</code></td><td>32-bit Linux (kernel 2.6.32+, glibc 2.11+)</td></tr>
<tr><td><code>x86_64-apple-darwin</code></td><td>64-bit macOS (10.7+, Lion+)</td></tr>
<tr><td><code>x86_64-pc-windows-gnu</code></td><td>64-bit MinGW (Windows 7+)</td></tr>
<tr><td><code>x86_64-pc-windows-msvc</code></td><td>64-bit MSVC (Windows 7+)</td></tr>
<tr><td><code>x86_64-unknown-linux-gnu</code></td><td>64-bit Linux (kernel 2.6.32+, glibc 2.11+)</td></tr>
</tbody></table>
<div class="footnote-definition" id="missing-stack-probes"><sup class="footnote-definition-label">1</sup>
<p>Stack probes support is missing on
<code>aarch64-unknown-linux-gnu</code>, but it's planned to be implemented in the near
future. The implementation is tracked on <a href="https://github.com/rust-lang/rust/issues/77071">issue #77071</a>.</p>
</div>
<h2 id="tier-1"><a class="header" href="#tier-1">Tier 1</a></h2>
<p>Tier 1 targets can be thought of as &quot;guaranteed to work&quot;. The Rust project
builds official binary releases for each tier 1 target, and automated testing
ensures that each tier 1 target builds and passes tests after each change. For
the full requirements, see <a href="target-tier-policy.html#tier-1-target-policy">Tier 1 target
policy</a> in the Target Tier Policy.</p>
<p>At this time, all Tier 1 targets are <a href="platform-support.html#tier-1-with-host-tools">Tier 1 with Host
Tools</a>.</p>
<h2 id="tier-2-with-host-tools"><a class="header" href="#tier-2-with-host-tools">Tier 2 with Host Tools</a></h2>
<p>Tier 2 targets can be thought of as &quot;guaranteed to build&quot;. The Rust project
builds official binary releases for each tier 2 target, and automated builds
ensure that each tier 2 target builds after each change. Automated tests are
not always run so it's not guaranteed to produce a working build, but tier 2
targets often work to quite a good degree and patches are always welcome!</p>
<p>Tier 2 targets with host tools additionally support running tools like <code>rustc</code>
and <code>cargo</code> natively on the target, and automated builds ensure that the host
tools build as well. This allows the target to be used as a development
platform, not just a compilation target. For the full requirements, see <a href="target-tier-policy.html#tier-2-with-host-tools">Tier 2
with Host Tools</a> in the Target
Tier Policy.</p>
<p>All tier 2 targets with host tools support the full standard library.</p>
<p><strong>NOTE:</strong> Tier 2 targets currently do not build the <code>rust-docs</code> component.</p>
<table><thead><tr><th>target</th><th>notes</th></tr></thead><tbody>
<tr><td><code>aarch64-apple-darwin</code></td><td>ARM64 macOS (11.0+, Big Sur+)</td></tr>
<tr><td><code>aarch64-pc-windows-msvc</code></td><td>ARM64 Windows MSVC</td></tr>
<tr><td><code>aarch64-unknown-linux-musl</code></td><td>ARM64 Linux with MUSL</td></tr>
<tr><td><code>arm-unknown-linux-gnueabi</code></td><td>ARMv6 Linux (kernel 3.2, glibc 2.17)</td></tr>
<tr><td><code>arm-unknown-linux-gnueabihf</code></td><td>ARMv6 Linux, hardfloat (kernel 3.2, glibc 2.17)</td></tr>
<tr><td><code>armv7-unknown-linux-gnueabihf</code></td><td>ARMv7 Linux, hardfloat (kernel 3.2, glibc 2.17)</td></tr>
<tr><td><code>mips-unknown-linux-gnu</code></td><td>MIPS Linux (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>mips64-unknown-linux-gnuabi64</code></td><td>MIPS64 Linux, n64 ABI (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>mips64el-unknown-linux-gnuabi64</code></td><td>MIPS64 (LE) Linux, n64 ABI (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>mipsel-unknown-linux-gnu</code></td><td>MIPS (LE) Linux (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>powerpc-unknown-linux-gnu</code></td><td>PowerPC Linux (kernel 2.6.32, glibc 2.11)</td></tr>
<tr><td><code>powerpc64-unknown-linux-gnu</code></td><td>PPC64 Linux (kernel 2.6.32, glibc 2.11)</td></tr>
<tr><td><code>powerpc64le-unknown-linux-gnu</code></td><td>PPC64LE Linux (kernel 3.10, glibc 2.17)</td></tr>
<tr><td><code>riscv64gc-unknown-linux-gnu</code></td><td>RISC-V Linux (kernel 4.20, glibc 2.29)</td></tr>
<tr><td><code>s390x-unknown-linux-gnu</code></td><td>S390x Linux (kernel 2.6.32, glibc 2.11)</td></tr>
<tr><td><code>x86_64-unknown-freebsd</code></td><td>64-bit FreeBSD</td></tr>
<tr><td><code>x86_64-unknown-illumos</code></td><td>illumos</td></tr>
<tr><td><code>x86_64-unknown-linux-musl</code></td><td>64-bit Linux with MUSL</td></tr>
<tr><td><code>x86_64-unknown-netbsd</code></td><td>NetBSD/amd64</td></tr>
</tbody></table>
<h2 id="tier-2"><a class="header" href="#tier-2">Tier 2</a></h2>
<p>Tier 2 targets can be thought of as &quot;guaranteed to build&quot;. The Rust project
builds official binary releases for each tier 2 target, and automated builds
ensure that each tier 2 target builds after each change. Automated tests are
not always run so it's not guaranteed to produce a working build, but tier 2
targets often work to quite a good degree and patches are always welcome! For
the full requirements, see <a href="target-tier-policy.html#tier-2-target-policy">Tier 2 target
policy</a> in the Target Tier Policy.</p>
<p>The <code>std</code> column in the table below has the following meanings:</p>
<ul>
<li>✓ indicates the full standard library is available.</li>
<li>* indicates the target only supports <a href="https://rust-embedded.github.io/book/intro/no-std.html"><code>no_std</code></a> development.</li>
</ul>
<p><strong>NOTE:</strong> Tier 2 targets currently do not build the <code>rust-docs</code> component.</p>
<table><thead><tr><th>target</th><th align="center">std</th><th>notes</th></tr></thead><tbody>
<tr><td><code>aarch64-apple-ios</code></td><td align="center">✓</td><td>ARM64 iOS</td></tr>
<tr><td><a href="platform-support/aarch64-apple-ios-sim.html"><code>aarch64-apple-ios-sim</code></a></td><td align="center">✓</td><td>Apple iOS Simulator on ARM64</td></tr>
<tr><td><code>aarch64-fuchsia</code></td><td align="center">✓</td><td>ARM64 Fuchsia</td></tr>
<tr><td><code>aarch64-linux-android</code></td><td align="center">✓</td><td>ARM64 Android</td></tr>
<tr><td><code>aarch64-unknown-none-softfloat</code></td><td align="center">*</td><td>Bare ARM64, softfloat</td></tr>
<tr><td><code>aarch64-unknown-none</code></td><td align="center">*</td><td>Bare ARM64, hardfloat</td></tr>
<tr><td><code>arm-linux-androideabi</code></td><td align="center">✓</td><td>ARMv7 Android</td></tr>
<tr><td><code>arm-unknown-linux-musleabi</code></td><td align="center">✓</td><td>ARMv6 Linux with MUSL</td></tr>
<tr><td><code>arm-unknown-linux-musleabihf</code></td><td align="center">✓</td><td>ARMv6 Linux with MUSL, hardfloat</td></tr>
<tr><td><code>armebv7r-none-eabi</code></td><td align="center">*</td><td>Bare ARMv7-R, Big Endian</td></tr>
<tr><td><code>armebv7r-none-eabihf</code></td><td align="center">*</td><td>Bare ARMv7-R, Big Endian, hardfloat</td></tr>
<tr><td><code>armv5te-unknown-linux-gnueabi</code></td><td align="center">✓</td><td>ARMv5TE Linux (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>armv5te-unknown-linux-musleabi</code></td><td align="center">✓</td><td>ARMv5TE Linux with MUSL</td></tr>
<tr><td><code>armv7-linux-androideabi</code></td><td align="center">✓</td><td>ARMv7a Android</td></tr>
<tr><td><code>armv7-unknown-linux-gnueabi</code></td><td align="center">✓</td><td>ARMv7 Linux (kernel 4.15, glibc 2.27)</td></tr>
<tr><td><code>armv7-unknown-linux-musleabi</code></td><td align="center">✓</td><td>ARMv7 Linux with MUSL</td></tr>
<tr><td><code>armv7-unknown-linux-musleabihf</code></td><td align="center">✓</td><td>ARMv7 Linux with MUSL, hardfloat</td></tr>
<tr><td><code>armv7a-none-eabi</code></td><td align="center">*</td><td>Bare ARMv7-A</td></tr>
<tr><td><code>armv7r-none-eabi</code></td><td align="center">*</td><td>Bare ARMv7-R</td></tr>
<tr><td><code>armv7r-none-eabihf</code></td><td align="center">*</td><td>Bare ARMv7-R, hardfloat</td></tr>
<tr><td><code>asmjs-unknown-emscripten</code></td><td align="center">✓</td><td>asm.js via Emscripten</td></tr>
<tr><td><code>i586-pc-windows-msvc</code></td><td align="center">✓</td><td>32-bit Windows w/o SSE</td></tr>
<tr><td><code>i586-unknown-linux-gnu</code></td><td align="center">✓</td><td>32-bit Linux w/o SSE (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>i586-unknown-linux-musl</code></td><td align="center">✓</td><td>32-bit Linux w/o SSE, MUSL</td></tr>
<tr><td><code>i686-linux-android</code></td><td align="center">✓</td><td>32-bit x86 Android</td></tr>
<tr><td><code>i686-unknown-freebsd</code></td><td align="center">✓</td><td>32-bit FreeBSD</td></tr>
<tr><td><code>i686-unknown-linux-musl</code></td><td align="center">✓</td><td>32-bit Linux with MUSL</td></tr>
<tr><td><code>mips-unknown-linux-musl</code></td><td align="center">✓</td><td>MIPS Linux with MUSL</td></tr>
<tr><td><code>mips64-unknown-linux-muslabi64</code></td><td align="center">✓</td><td>MIPS64 Linux, n64 ABI, MUSL</td></tr>
<tr><td><code>mips64el-unknown-linux-muslabi64</code></td><td align="center">✓</td><td>MIPS64 (LE) Linux, n64 ABI, MUSL</td></tr>
<tr><td><code>mipsel-unknown-linux-musl</code></td><td align="center">✓</td><td>MIPS (LE) Linux with MUSL</td></tr>
<tr><td><code>nvptx64-nvidia-cuda</code></td><td align="center">*</td><td>--emit=asm generates PTX code that <a href="https://github.com/japaric-archived/nvptx#targets">runs on NVIDIA GPUs</a></td></tr>
<tr><td><code>riscv32i-unknown-none-elf</code></td><td align="center">*</td><td>Bare RISC-V (RV32I ISA)</td></tr>
<tr><td><code>riscv32imac-unknown-none-elf</code></td><td align="center">*</td><td>Bare RISC-V (RV32IMAC ISA)</td></tr>
<tr><td><code>riscv32imc-unknown-none-elf</code></td><td align="center">*</td><td>Bare RISC-V (RV32IMC ISA)</td></tr>
<tr><td><code>riscv64gc-unknown-none-elf</code></td><td align="center">*</td><td>Bare RISC-V (RV64IMAFDC ISA)</td></tr>
<tr><td><code>riscv64imac-unknown-none-elf</code></td><td align="center">*</td><td>Bare RISC-V (RV64IMAC ISA)</td></tr>
<tr><td><code>sparc64-unknown-linux-gnu</code></td><td align="center">✓</td><td>SPARC Linux (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>sparcv9-sun-solaris</code></td><td align="center">✓</td><td>SPARC Solaris 10/11, illumos</td></tr>
<tr><td><code>thumbv6m-none-eabi</code></td><td align="center">*</td><td>Bare Cortex-M0, M0+, M1</td></tr>
<tr><td><code>thumbv7em-none-eabi</code></td><td align="center">*</td><td>Bare Cortex-M4, M7</td></tr>
<tr><td><code>thumbv7em-none-eabihf</code></td><td align="center">*</td><td>Bare Cortex-M4F, M7F, FPU, hardfloat</td></tr>
<tr><td><code>thumbv7m-none-eabi</code></td><td align="center">*</td><td>Bare Cortex-M3</td></tr>
<tr><td><code>thumbv7neon-linux-androideabi</code></td><td align="center">✓</td><td>Thumb2-mode ARMv7a Android with NEON</td></tr>
<tr><td><code>thumbv7neon-unknown-linux-gnueabihf</code></td><td align="center">✓</td><td>Thumb2-mode ARMv7a Linux with NEON (kernel 4.4, glibc 2.23)</td></tr>
<tr><td><code>thumbv8m.base-none-eabi</code></td><td align="center">*</td><td>ARMv8-M Baseline</td></tr>
<tr><td><code>thumbv8m.main-none-eabi</code></td><td align="center">*</td><td>ARMv8-M Mainline</td></tr>
<tr><td><code>thumbv8m.main-none-eabihf</code></td><td align="center">*</td><td>ARMv8-M Mainline, hardfloat</td></tr>
<tr><td><code>wasm32-unknown-emscripten</code></td><td align="center">✓</td><td>WebAssembly via Emscripten</td></tr>
<tr><td><code>wasm32-unknown-unknown</code></td><td align="center">✓</td><td>WebAssembly</td></tr>
<tr><td><code>wasm32-wasi</code></td><td align="center">✓</td><td>WebAssembly with WASI</td></tr>
<tr><td><code>x86_64-apple-ios</code></td><td align="center">✓</td><td>64-bit x86 iOS</td></tr>
<tr><td><code>x86_64-fortanix-unknown-sgx</code></td><td align="center">✓</td><td><a href="https://edp.fortanix.com/">Fortanix ABI</a> for 64-bit Intel SGX</td></tr>
<tr><td><code>x86_64-fuchsia</code></td><td align="center">✓</td><td>64-bit Fuchsia</td></tr>
<tr><td><code>x86_64-linux-android</code></td><td align="center">✓</td><td>64-bit x86 Android</td></tr>
<tr><td><code>x86_64-pc-solaris</code></td><td align="center">✓</td><td>64-bit Solaris 10/11, illumos</td></tr>
<tr><td><code>x86_64-unknown-linux-gnux32</code></td><td align="center">✓</td><td>64-bit Linux (x32 ABI) (kernel 4.15, glibc 2.27)</td></tr>
<tr><td><code>x86_64-unknown-redox</code></td><td align="center">✓</td><td>Redox OS</td></tr>
</tbody></table>
<h2 id="tier-3"><a class="header" href="#tier-3">Tier 3</a></h2>
<p>Tier 3 targets are those which the Rust codebase has support for, but which the
Rust project does not build or test automatically, so they may or may not work.
Official builds are not available. For the full requirements, see <a href="target-tier-policy.html#tier-3-target-policy">Tier 3
target policy</a> in the Target Tier
Policy.</p>
<p>The <code>std</code> column in the table below has the following meanings:</p>
<ul>
<li>✓ indicates the full standard library is available.</li>
<li>* indicates the target only supports <a href="https://rust-embedded.github.io/book/intro/no-std.html"><code>no_std</code></a> development.</li>
<li>? indicates the standard library support is unknown or a work-in-progress.</li>
</ul>
<p>The <code>host</code> column indicates whether the codebase includes support for building
host tools.</p>
<table><thead><tr><th>target</th><th align="center">std</th><th align="center">host</th><th>notes</th></tr></thead><tbody>
<tr><td><code>aarch64-apple-ios-macabi</code></td><td align="center">?</td><td align="center"></td><td>Apple Catalyst on ARM64</td></tr>
<tr><td><code>aarch64-apple-tvos</code></td><td align="center">*</td><td align="center"></td><td>ARM64 tvOS</td></tr>
<tr><td><a href="platform-support/kmc-solid.html"><code>aarch64-kmc-solid_asp3</code></a></td><td align="center">✓</td><td align="center"></td><td>ARM64 SOLID with TOPPERS/ASP3</td></tr>
<tr><td><code>aarch64-unknown-freebsd</code></td><td align="center">✓</td><td align="center">✓</td><td>ARM64 FreeBSD</td></tr>
<tr><td><code>aarch64-unknown-hermit</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>aarch64-unknown-uefi</code></td><td align="center">*</td><td align="center"></td><td>ARM64 UEFI</td></tr>
<tr><td><code>aarch64-unknown-linux-gnu_ilp32</code></td><td align="center">✓</td><td align="center">✓</td><td>ARM64 Linux (ILP32 ABI)</td></tr>
<tr><td><code>aarch64-unknown-netbsd</code></td><td align="center">✓</td><td align="center">✓</td><td></td></tr>
<tr><td><code>aarch64-unknown-openbsd</code></td><td align="center">✓</td><td align="center">✓</td><td>ARM64 OpenBSD</td></tr>
<tr><td><code>aarch64-unknown-redox</code></td><td align="center">?</td><td align="center"></td><td>ARM64 Redox OS</td></tr>
<tr><td><code>aarch64-uwp-windows-msvc</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>aarch64-wrs-vxworks</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>aarch64_be-unknown-linux-gnu_ilp32</code></td><td align="center">✓</td><td align="center">✓</td><td>ARM64 Linux (big-endian, ILP32 ABI)</td></tr>
<tr><td><code>aarch64_be-unknown-linux-gnu</code></td><td align="center">✓</td><td align="center">✓</td><td>ARM64 Linux (big-endian)</td></tr>
<tr><td><code>armv4t-unknown-linux-gnueabi</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>armv5te-unknown-linux-uclibceabi</code></td><td align="center">?</td><td align="center"></td><td>ARMv5TE Linux with uClibc</td></tr>
<tr><td><code>armv6-unknown-freebsd</code></td><td align="center">✓</td><td align="center">✓</td><td>ARMv6 FreeBSD</td></tr>
<tr><td><code>armv6-unknown-netbsd-eabihf</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>armv6k-nintendo-3ds</code></td><td align="center">*</td><td align="center"></td><td>ARMv6K Nintendo 3DS, Horizon (Requires devkitARM toolchain)</td></tr>
<tr><td><code>armv7-apple-ios</code></td><td align="center">✓</td><td align="center"></td><td>ARMv7 iOS, Cortex-a8</td></tr>
<tr><td><code>armv7-unknown-linux-uclibceabihf</code></td><td align="center">✓</td><td align="center">?</td><td>ARMv7 Linux uClibc</td></tr>
<tr><td><code>armv7-unknown-freebsd</code></td><td align="center">✓</td><td align="center">✓</td><td>ARMv7 FreeBSD</td></tr>
<tr><td><code>armv7-unknown-netbsd-eabihf</code></td><td align="center">✓</td><td align="center">✓</td><td></td></tr>
<tr><td><code>armv7-wrs-vxworks-eabihf</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><a href="platform-support/kmc-solid.html"><code>armv7a-kmc-solid_asp3-eabi</code></a></td><td align="center">✓</td><td align="center"></td><td>ARM SOLID with TOPPERS/ASP3</td></tr>
<tr><td><a href="platform-support/kmc-solid.html"><code>armv7a-kmc-solid_asp3-eabihf</code></a></td><td align="center">✓</td><td align="center"></td><td>ARM SOLID with TOPPERS/ASP3, hardfloat</td></tr>
<tr><td><code>armv7a-none-eabihf</code></td><td align="center">*</td><td align="center"></td><td>ARM Cortex-A, hardfloat</td></tr>
<tr><td><code>armv7s-apple-ios</code></td><td align="center">✓</td><td align="center"></td><td></td></tr>
<tr><td><code>avr-unknown-gnu-atmega328</code></td><td align="center">*</td><td align="center"></td><td>AVR. Requires <code>-Z build-std=core</code></td></tr>
<tr><td><code>bpfeb-unknown-none</code></td><td align="center">*</td><td align="center"></td><td>BPF (big endian)</td></tr>
<tr><td><code>bpfel-unknown-none</code></td><td align="center">*</td><td align="center"></td><td>BPF (little endian)</td></tr>
<tr><td><code>hexagon-unknown-linux-musl</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>i386-apple-ios</code></td><td align="center">✓</td><td align="center"></td><td>32-bit x86 iOS</td></tr>
<tr><td><code>i686-apple-darwin</code></td><td align="center">✓</td><td align="center">✓</td><td>32-bit macOS (10.7+, Lion+)</td></tr>
<tr><td><code>i686-pc-windows-msvc</code></td><td align="center">✓</td><td align="center"></td><td>32-bit Windows XP support</td></tr>
<tr><td><code>i686-unknown-haiku</code></td><td align="center">✓</td><td align="center">✓</td><td>32-bit Haiku</td></tr>
<tr><td><code>i686-unknown-netbsd</code></td><td align="center">✓</td><td align="center">✓</td><td>NetBSD/i386 with SSE2</td></tr>
<tr><td><code>i686-unknown-openbsd</code></td><td align="center">✓</td><td align="center">✓</td><td>32-bit OpenBSD</td></tr>
<tr><td><code>i686-unknown-uefi</code></td><td align="center">*</td><td align="center"></td><td>32-bit UEFI</td></tr>
<tr><td><code>i686-uwp-windows-gnu</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>i686-uwp-windows-msvc</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>i686-wrs-vxworks</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>m68k-unknown-linux-gnu</code></td><td align="center">?</td><td align="center"></td><td>Motorola 680x0 Linux</td></tr>
<tr><td><code>mips-unknown-linux-uclibc</code></td><td align="center">✓</td><td align="center"></td><td>MIPS Linux with uClibc</td></tr>
<tr><td><code>mipsel-sony-psp</code></td><td align="center">*</td><td align="center"></td><td>MIPS (LE) Sony PlayStation Portable (PSP)</td></tr>
<tr><td><code>mipsel-unknown-linux-uclibc</code></td><td align="center">✓</td><td align="center"></td><td>MIPS (LE) Linux with uClibc</td></tr>
<tr><td><code>mipsel-unknown-none</code></td><td align="center">*</td><td align="center"></td><td>Bare MIPS (LE) softfloat</td></tr>
<tr><td><code>mipsisa32r6-unknown-linux-gnu</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>mipsisa32r6el-unknown-linux-gnu</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>mipsisa64r6-unknown-linux-gnuabi64</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>mipsisa64r6el-unknown-linux-gnuabi64</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>msp430-none-elf</code></td><td align="center">*</td><td align="center"></td><td>16-bit MSP430 microcontrollers</td></tr>
<tr><td><code>powerpc-unknown-linux-gnuspe</code></td><td align="center">✓</td><td align="center"></td><td>PowerPC SPE Linux</td></tr>
<tr><td><code>powerpc-unknown-linux-musl</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>powerpc-unknown-netbsd</code></td><td align="center">✓</td><td align="center">✓</td><td></td></tr>
<tr><td><code>powerpc-unknown-openbsd</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>powerpc-wrs-vxworks-spe</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>powerpc-wrs-vxworks</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>powerpc64-unknown-freebsd</code></td><td align="center">✓</td><td align="center">✓</td><td>PPC64 FreeBSD (ELFv1 and ELFv2)</td></tr>
<tr><td><code>powerpc64le-unknown-freebsd</code></td><td align="center"></td><td align="center"></td><td>PPC64LE FreeBSD</td></tr>
<tr><td><code>powerpc-unknown-freebsd</code></td><td align="center"></td><td align="center"></td><td>PowerPC FreeBSD</td></tr>
<tr><td><code>powerpc64-unknown-linux-musl</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>powerpc64-wrs-vxworks</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>powerpc64le-unknown-linux-musl</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>riscv32gc-unknown-linux-gnu</code></td><td align="center"></td><td align="center"></td><td>RISC-V Linux (kernel 5.4, glibc 2.33)</td></tr>
<tr><td><code>riscv32gc-unknown-linux-musl</code></td><td align="center"></td><td align="center"></td><td>RISC-V Linux (kernel 5.4, musl + RISCV32 support patches)</td></tr>
<tr><td><code>riscv32imc-esp-espidf</code></td><td align="center">✓</td><td align="center"></td><td>RISC-V ESP-IDF</td></tr>
<tr><td><code>riscv64gc-unknown-freebsd</code></td><td align="center"></td><td align="center"></td><td>RISC-V FreeBSD</td></tr>
<tr><td><code>riscv64gc-unknown-linux-musl</code></td><td align="center"></td><td align="center"></td><td>RISC-V Linux (kernel 4.20, musl 1.2.0)</td></tr>
<tr><td><code>s390x-unknown-linux-musl</code></td><td align="center"></td><td align="center"></td><td>S390x Linux (kernel 2.6.32, MUSL)</td></tr>
<tr><td><code>sparc-unknown-linux-gnu</code></td><td align="center">✓</td><td align="center"></td><td>32-bit SPARC Linux</td></tr>
<tr><td><code>sparc64-unknown-netbsd</code></td><td align="center">✓</td><td align="center">✓</td><td>NetBSD/sparc64</td></tr>
<tr><td><code>sparc64-unknown-openbsd</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>thumbv4t-none-eabi</code></td><td align="center">*</td><td align="center"></td><td>ARMv4T T32</td></tr>
<tr><td><code>thumbv7a-pc-windows-msvc</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>thumbv7a-uwp-windows-msvc</code></td><td align="center">✓</td><td align="center"></td><td></td></tr>
<tr><td><code>thumbv7neon-unknown-linux-musleabihf</code></td><td align="center">?</td><td align="center"></td><td>Thumb2-mode ARMv7a Linux with NEON, MUSL</td></tr>
<tr><td><a href="platform-support/wasm64-unknown-unknown.html"><code>wasm64-unknown-unknown</code></a></td><td align="center">?</td><td align="center"></td><td>WebAssembly</td></tr>
<tr><td><code>x86_64-apple-ios-macabi</code></td><td align="center">✓</td><td align="center"></td><td>Apple Catalyst on x86_64</td></tr>
<tr><td><code>x86_64-apple-tvos</code></td><td align="center">*</td><td align="center"></td><td>x86 64-bit tvOS</td></tr>
<tr><td><code>x86_64-pc-windows-msvc</code></td><td align="center">✓</td><td align="center"></td><td>64-bit Windows XP support</td></tr>
<tr><td><code>x86_64-sun-solaris</code></td><td align="center">?</td><td align="center"></td><td>Deprecated target for 64-bit Solaris 10/11, illumos</td></tr>
<tr><td><code>x86_64-unknown-dragonfly</code></td><td align="center">✓</td><td align="center">✓</td><td>64-bit DragonFlyBSD</td></tr>
<tr><td><code>x86_64-unknown-haiku</code></td><td align="center">✓</td><td align="center">✓</td><td>64-bit Haiku</td></tr>
<tr><td><code>x86_64-unknown-hermit</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><code>x86_64-unknown-l4re-uclibc</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
<tr><td><a href="platform-support/x86_64-unknown-none.html"><code>x86_64-unknown-none</code></a></td><td align="center">*</td><td align="center"></td><td>Freestanding/bare-metal x86_64, softfloat</td></tr>
<tr><td><code>x86_64-unknown-none-hermitkernel</code></td><td align="center">?</td><td align="center"></td><td>HermitCore kernel</td></tr>
<tr><td><code>x86_64-unknown-none-linuxkernel</code></td><td align="center">*</td><td align="center"></td><td>Linux kernel modules</td></tr>
<tr><td><code>x86_64-unknown-openbsd</code></td><td align="center">✓</td><td align="center">✓</td><td>64-bit OpenBSD</td></tr>
<tr><td><code>x86_64-unknown-uefi</code></td><td align="center">*</td><td align="center"></td><td>64-bit UEFI</td></tr>
<tr><td><code>x86_64-uwp-windows-gnu</code></td><td align="center">✓</td><td align="center"></td><td></td></tr>
<tr><td><code>x86_64-uwp-windows-msvc</code></td><td align="center">✓</td><td align="center"></td><td></td></tr>
<tr><td><code>x86_64-wrs-vxworks</code></td><td align="center">?</td><td align="center"></td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="target-name-here"><a class="header" href="#target-name-here"><code>target-name-here</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>One-sentence description of the target (e.g. CPU, OS)</p>
<h2 id="target-maintainers"><a class="header" href="#target-maintainers">Target maintainers</a></h2>
<ul>
<li>Some Person, <code>email@example.org</code>, https://github.com/...</li>
</ul>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>Does the target support host tools, or only cross-compilation? Does the target
support std, or alloc (either with a default allocator, or if the user supplies
an allocator)?</p>
<p>Document the expectations of binaries built for the target. Do they assume
specific minimum features beyond the baseline of the CPU/environment/etc? What
version of the OS or environment do they expect?</p>
<p>Are there notable <code>#[target_feature(...)]</code> or <code>-C target-feature=</code> values that
programs may wish to use?</p>
<p>What calling convention does <code>extern &quot;C&quot;</code> use on the target?</p>
<p>What format do binaries use by default? ELF, PE, something else?</p>
<h2 id="building-the-target"><a class="header" href="#building-the-target">Building the target</a></h2>
<p>If Rust doesn't build the target by default, how can users build it? Can users
just add it to the <code>target</code> list in <code>config.toml</code>?</p>
<h2 id="building-rust-programs"><a class="header" href="#building-rust-programs">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
&quot;Building the target&quot; above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>Does the target support running binaries, or do binaries have varying
expectations that prevent having a standard way to run them? If users can run
binaries, can they do so in some common emulator, or do they need native
hardware? Does the target support running the Rust testsuite?</p>
<h2 id="cross-compilation-toolchains-and-c-code"><a class="header" href="#cross-compilation-toolchains-and-c-code">Cross-compilation toolchains and C code</a></h2>
<p>Does the target support C code? If so, what toolchain target should users use
to build compatible C code? (This may match the target triple, or it may be a
toolchain for a different target triple, potentially with specific options or
caveats.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aarch64-apple-ios-sim"><a class="header" href="#aarch64-apple-ios-sim">aarch64-apple-ios-sim</a></h1>
<p><strong>Tier: 2</strong></p>
<p>Apple iOS Simulator on ARM64.</p>
<h2 id="designated-developers"><a class="header" href="#designated-developers">Designated Developers</a></h2>
<ul>
<li><a href="https://github.com/badboy">@badboy</a></li>
<li><a href="https://github.com/deg4uss3r">@deg4uss3r</a></li>
</ul>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<p>This target is cross-compiled.
To build this target Xcode 12 or higher on macOS is required.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = [&quot;aarch64-apple-ios-sim&quot;]
</code></pre>
<h2 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-compilation</a></h2>
<p>This target can be cross-compiled from <code>x86_64</code> or <code>aarch64</code> macOS hosts.</p>
<p>Other hosts are not supported for cross-compilation, but might work when also providing the required Xcode SDK.</p>
<h2 id="testing-1"><a class="header" href="#testing-1">Testing</a></h2>
<p>Currently there is no support to run the rustc test suite for this target.</p>
<h2 id="building-rust-programs-1"><a class="header" href="#building-rust-programs-1">Building Rust programs</a></h2>
<p><em>Note: Building for this target requires the corresponding iOS SDK, as provided by Xcode 12+.</em></p>
<p>From Rust Nightly 1.56.0 (2021-08-03) on the artifacts are shipped pre-compiled:</p>
<pre><code class="language-text">rustup target add aarch64-apple-ios-sim --toolchain nightly
</code></pre>
<p>Rust programs can be built for that target:</p>
<pre><code class="language-text">rustc --target aarch64-apple-ios-sim your-code.rs
</code></pre>
<p>There is no easy way to run simple programs in the iOS simulator.
Static library builds can be embedded into iOS applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-kmc-solid_"><a class="header" href="#-kmc-solid_">*-kmc-solid_*</a></h1>
<p><strong>Tier: 3</strong></p>
<p><a href="https://www.kmckk.co.jp/eng/SOLID/">SOLID</a> embedded development platform by Kyoto Microcomputer Co., Ltd.</p>
<p>The target names follow this format: <code>$ARCH-kmc-solid_$KERNEL-$ABI</code>, where <code>$ARCH</code> specifies the target processor architecture, <code>$KERNEL</code> the base kernel, and <code>$ABI</code> the target ABI (optional). The following targets are currently defined:</p>
<table><thead><tr><th>Target name</th><th><code>target_arch</code></th><th><code>target_vendor</code></th><th><code>target_os</code></th></tr></thead><tbody>
<tr><td><code>aarch64-kmc-solid_asp3</code></td><td><code>aarch64</code></td><td><code>kmc</code></td><td><code>solid_asp3</code></td></tr>
<tr><td><code>armv7a-kmc-solid_asp3-eabi</code></td><td><code>arm</code></td><td><code>kmc</code></td><td><code>solid_asp3</code></td></tr>
<tr><td><code>armv7a-kmc-solid_asp3-eabihf</code></td><td><code>arm</code></td><td><code>kmc</code></td><td><code>solid_asp3</code></td></tr>
</tbody></table>
<h2 id="designated-developers-1"><a class="header" href="#designated-developers-1">Designated Developers</a></h2>
<ul>
<li><a href="https://github.com/kawadakk">@kawadakk</a></li>
</ul>
<h2 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h2>
<p>This target is cross-compiled.
A platform-provided C compiler toolchain is required, though it can be substituted by <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm">GNU Arm Embedded Toolchain</a> for the purpose of building Rust and functional binaries.</p>
<h2 id="building-1"><a class="header" href="#building-1">Building</a></h2>
<p>The target can be built by enabling it for a <code>rustc</code> build.</p>
<pre><code class="language-toml">[build]
target = [&quot;aarch64-kmc-solid_asp3&quot;]
</code></pre>
<p>Make sure <code>aarch64-kmc-elf-gcc</code> is included in <code>$PATH</code>. Alternatively, you can use GNU Arm Embedded Toolchain by adding the following to <code>config.toml</code>:</p>
<pre><code class="language-toml">[target.aarch64-kmc-solid_asp3]
cc = &quot;arm-none-eabi-gcc&quot;
</code></pre>
<h2 id="cross-compilation-1"><a class="header" href="#cross-compilation-1">Cross-compilation</a></h2>
<p>This target can be cross-compiled from any hosts.</p>
<h2 id="testing-2"><a class="header" href="#testing-2">Testing</a></h2>
<p>Currently there is no support to run the rustc test suite for this target.</p>
<h2 id="building-rust-programs-2"><a class="header" href="#building-rust-programs-2">Building Rust programs</a></h2>
<p>Building executables is not supported yet.</p>
<p>If <code>rustc</code> has support for that target and the library artifacts are available, then Rust static libraries can be built for that target:</p>
<pre><code class="language-shell">$ rustc --target aarch64-kmc-solid_asp3 your-code.rs --crate-type staticlib
$ ls libyour_code.a
</code></pre>
<p>On Rust Nightly it's possible to build without the target artifacts available:</p>
<pre><code class="language-text">cargo build -Z build-std --target aarch64-kmc-solid_asp3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="x86_64-unknown-none"><a class="header" href="#x86_64-unknown-none"><code>x86_64-unknown-none</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>Freestanding/bare-metal x86-64 binaries in ELF format: firmware, kernels, etc.</p>
<h2 id="target-maintainers-1"><a class="header" href="#target-maintainers-1">Target maintainers</a></h2>
<ul>
<li>Harald Hoyer <code>harald@profian.com</code>, https://github.com/haraldh</li>
<li>Mike Leany, https://github.com/mikeleany</li>
</ul>
<h2 id="requirements-3"><a class="header" href="#requirements-3">Requirements</a></h2>
<p>This target is cross-compiled. There is no support for <code>std</code>. There is no
default allocator, but it's possible to use <code>alloc</code> by supplying an allocator.</p>
<p>By default, Rust code generated for this target does not use any vector or
floating-point registers (e.g. SSE, AVX). This allows the generated code to run
in environments, such as kernels, which may need to avoid the use of such
registers or which may have special considerations about the use of such
registers (e.g. saving and restoring them to avoid breaking userspace code
using the same registers). You can change code generation to use additional CPU
features via the <code>-C target-feature=</code> codegen options to rustc, or via the
<code>#[target_feature]</code> mechanism within Rust code.</p>
<p>By default, code generated with this target should run on any <code>x86_64</code>
hardware; enabling additional target features may raise this baseline.</p>
<p>Code generated with this target will use the <code>kernel</code> code model by default.
You can change this using the <code>-C code-model=</code> option to rustc.</p>
<p>On <code>x86_64-unknown-none</code>, <code>extern &quot;C&quot;</code> uses the <a href="https://gitlab.com/x86-psABIs/x86-64-ABI">standard System V calling
convention</a>, without red zones.</p>
<p>This target generated binaries in the ELF format. Any alternate formats or
special considerations for binary layout will require linker options or linker
scripts.</p>
<h2 id="building-the-target-1"><a class="header" href="#building-the-target-1">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code>
list in <code>config.toml</code>:</p>
<pre><code class="language-toml">[build]
build-stage = 1
target = [&quot;x86_64-unknown-none&quot;]
</code></pre>
<h2 id="building-rust-programs-3"><a class="header" href="#building-rust-programs-3">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
&quot;Building the target&quot; above), or build your own copy of <code>core</code> by using
<code>build-std</code> or similar.</p>
<h2 id="testing-3"><a class="header" href="#testing-3">Testing</a></h2>
<p>As <code>x86_64-unknown-none</code> supports a variety of different environments and does
not support <code>std</code>, this target does not support running the Rust testsuite.</p>
<h2 id="cross-compilation-toolchains-and-c-code-1"><a class="header" href="#cross-compilation-toolchains-and-c-code-1">Cross-compilation toolchains and C code</a></h2>
<p>If you want to compile C code along with Rust (such as for Rust crates with C
dependencies), you will need an appropriate <code>x86_64</code> toolchain.</p>
<p>Rust <em>may</em> be able to use an <code>x86_64-linux-gnu-</code> toolchain with appropriate
standalone flags to build for this toolchain (depending on the assumptions of
that toolchain, see below), or you may wish to use a separate
<code>x86_64-unknown-none</code> (or <code>x86_64-elf-</code>) toolchain.</p>
<p>On some <code>x86_64</code> hosts that use ELF binaries, you <em>may</em> be able to use the host
C toolchain, if it does not introduce assumptions about the host environment
that don't match the expectations of a standalone environment. Otherwise, you
may need a separate toolchain for standalone/freestanding development, just as
when cross-compiling from a non-<code>x86_64</code> platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm64-unknown-unknown"><a class="header" href="#wasm64-unknown-unknown"><code>wasm64-unknown-unknown</code></a></h1>
<p><strong>Tier: 3</strong></p>
<p>WebAssembly target which uses 64-bit memories, relying on the <a href="https://github.com/webassembly/memory64">memory64</a>
WebAssembly proposal.</p>
<h2 id="target-maintainers-2"><a class="header" href="#target-maintainers-2">Target maintainers</a></h2>
<ul>
<li>Alex Crichton, https://github.com/alexcrichton</li>
</ul>
<h2 id="requirements-4"><a class="header" href="#requirements-4">Requirements</a></h2>
<p>This target is cross-compiled. The target supports <code>std</code> in the same manner as
the <code>wasm32-unknown-unknown</code> target which is to say that it comes with the
standard library but many I/O functions such as <code>std::fs</code> and <code>std::net</code> will
simply return error. Additionally I/O operations like <code>println!</code> don't actually
do anything and the prints aren't routed anywhere. This is the same as the
<code>wasm32-unknown-unknown</code> target. This target comes by default with an allocator,
currently <a href="http://gee.cs.oswego.edu/dl/html/malloc.html">dlmalloc</a> which is <a href="https://github.com/alexcrichton/dlmalloc-rs">ported to rust</a>.</p>
<p>The difference of this target with <code>wasm32-unknown-unknown</code> is that it's
compiled for 64-bit memories instead of 32-bit memories. This means that <code>usize</code>
is 8-bytes large as well as pointers. The tradeoff, though, is that the maximum
memory size is now the full 64-bit address space instead of the 4GB as limited
by the 32-bit address space for <code>wasm32-unknown-unknown</code>.</p>
<p>This target is not a stable target. The <a href="https://github.com/webassembly/memory64">memory64</a> WebAssembly proposal is stil
in-progress and not standardized. This means that there are not many engines
which implement the <code>memory64</code> feature and if they do they're likely behind a
flag, for example:</p>
<ul>
<li>Nodejs - <code>--experimental-wasm-memory64</code></li>
<li>Wasmtime - <code>--wasm-features memory64</code></li>
</ul>
<p>Also note that at this time the <code>wasm64-unknown-unknown</code> target assumes the
presence of other merged wasm proposals such as (with their LLVM feature flags):</p>
<ul>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/bulk-memory-operations/Overview.md">Bulk memory</a> - <code>+bulk-memory</code></li>
<li>Mutable imported globals - <code>+mutable-globals</code></li>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/sign-extension-ops/Overview.md">Sign-extending operations</a> - <code>+sign-ext</code></li>
<li><a href="https://github.com/WebAssembly/spec/blob/main/proposals/nontrapping-float-to-int-conversion/Overview.md">Non-trapping fp-to-int operations</a> - <code>+nontrapping-fptoint</code></li>
</ul>
<p>The <code>wasm64-unknown-unknown</code> target intends to match the default Clang targets
for its <code>&quot;C&quot;</code> ABI, which is likely to be the same as Clang's
<code>wasm32-unknown-unknown</code> largely.</p>
<blockquote>
<p><strong>Note</strong>: due to the relatively early-days nature of this target when working
with this target you may encounter LLVM bugs. If an assertion hit or a bug is
found it's recommended to open an issue either with rust-lang/rust or ideally
with LLVM itself.</p>
</blockquote>
<p>This target does not support <code>panic=unwind</code> at this time.</p>
<h2 id="building-the-target-2"><a class="header" href="#building-the-target-2">Building the target</a></h2>
<p>You can build Rust with support for the target by adding it to the <code>target</code>
list in <code>config.toml</code>, and the target also requires <code>lld</code> to be built to work.</p>
<pre><code class="language-toml">[build]
target = [&quot;wasm64-unknown-unknown&quot;]

[rust]
lld = true
</code></pre>
<h2 id="building-rust-programs-4"><a class="header" href="#building-rust-programs-4">Building Rust programs</a></h2>
<p>Rust does not yet ship pre-compiled artifacts for this target. To compile for
this target, you will either need to build Rust with the target enabled (see
&quot;Building the target&quot; above), or build your own copy of <code>std</code> by using
<code>build-std</code> or similar.</p>
<p>Note that the following <code>cfg</code> directives are set for <code>wasm64-unknown-unknown</code>:</p>
<ul>
<li><code>cfg(target_arch = &quot;wasm64&quot;)</code></li>
<li><code>cfg(target_family = &quot;wasm&quot;)</code></li>
</ul>
<h2 id="testing-4"><a class="header" href="#testing-4">Testing</a></h2>
<p>Currently testing is not well supported for <code>wasm64-unknown-unknown</code> and the
Rust project doesn't run any tests for this target. Testing support sort of
works but without <code>println!</code> it's not the most exciting tests to run.</p>
<h2 id="cross-compilation-toolchains-and-c-code-2"><a class="header" href="#cross-compilation-toolchains-and-c-code-2">Cross-compilation toolchains and C code</a></h2>
<p>Compiling Rust code with C code for <code>wasm64-unknown-unknown</code> is theoretically
possible, but there are no known toolchains to do this at this time. At the time
of this writing there is no known &quot;libc&quot; for wasm that works with
<code>wasm64-unknown-unknown</code>, which means that mixing C &amp; Rust with this target
effectively cannot be done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="target-tier-policy"><a class="header" href="#target-tier-policy">Target Tier Policy</a></h1>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="target-tier-policy.html#general">General</a></li>
<li><a href="target-tier-policy.html#tier-3-target-policy">Tier 3 target policy</a></li>
<li><a href="target-tier-policy.html#tier-2-target-policy">Tier 2 target policy</a>
<ul>
<li><a href="target-tier-policy.html#tier-2-with-host-tools">Tier 2 with host tools</a></li>
</ul>
</li>
<li><a href="target-tier-policy.html#tier-1-target-policy">Tier 1 target policy</a>
<ul>
<li><a href="target-tier-policy.html#tier-1-with-host-tools">Tier 1 with host tools</a></li>
</ul>
</li>
</ul>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<p>Rust provides three tiers of target support:</p>
<ul>
<li>Rust provides no guarantees about tier 3 targets; they exist in the codebase,
but may or may not build.</li>
<li>Rust's continuous integration checks that tier 2 targets will always build,
but they may or may not pass tests.</li>
<li>Rust's continuous integration checks that tier 1 targets will always build
and pass tests.</li>
</ul>
<p>Adding a new tier 3 target imposes minimal requirements; we focus primarily on
avoiding disruption to other ongoing Rust development.</p>
<p>Tier 2 and tier 1 targets place work on Rust project developers as a whole, to
avoid breaking the target. The broader Rust community may also feel more
inclined to support higher-tier targets in their crates (though they are not
obligated to do so). Thus, these tiers require commensurate and ongoing efforts
from the maintainers of the target, to demonstrate value and to minimize any
disruptions to ongoing Rust development.</p>
<p>This policy defines the requirements for accepting a proposed target at a given
level of support.</p>
<p>Each tier builds on all the requirements from the previous tier, unless
overridden by a stronger requirement. Targets at tier 2 and tier 1 may also
provide <em>host tools</em> (such as <code>rustc</code> and <code>cargo</code>); each of those tiers
includes a set of supplementary requirements that must be met if supplying host
tools for the target. A target at tier 2 or tier 1 is not required to supply
host tools, but if it does, it must meet the corresponding additional
requirements for host tools.</p>
<p>The policy for each tier also documents the Rust governance teams that must
approve the addition of any target at that tier. Those teams are responsible
for reviewing and evaluating the target, based on these requirements and their
own judgment. Those teams may apply additional requirements, including
subjective requirements, such as to deal with issues not foreseen by this
policy. (Such requirements may subsequently motivate additions to this policy.)</p>
<p>While these criteria attempt to document the policy, that policy still involves
human judgment. Targets must fulfill the spirit of the requirements as well, as
determined by the judgment of the approving teams. Reviewers and team members
evaluating targets and target-specific patches should always use their own best
judgment regarding the quality of work, and the suitability of a target for the
Rust project. Neither this policy nor any decisions made regarding targets
shall create any binding agreement or estoppel by any party.</p>
<p>Before filing an issue or pull request (PR) to introduce or promote a target,
the target should already meet the corresponding tier requirements. This does
not preclude an existing target's maintainers using issues (on the Rust
repository or otherwise) to track requirements that have not yet been met, as
appropriate; however, before officially proposing the introduction or promotion
of a target, it should meet all of the necessary requirements. A target
proposal must quote the corresponding requirements verbatim and respond to them
as part of explaining how the target meets those requirements. (For the
requirements that simply state that the target or the target developers must
not do something, it suffices to acknowledge the requirement.)</p>
<p>For a list of all supported targets and their corresponding tiers (&quot;tier 3&quot;,
&quot;tier 2&quot;, &quot;tier 2 with host tools&quot;, &quot;tier 1&quot;, or &quot;tier 1 with host tools&quot;), see
<a href="platform-support.html">platform support</a>.</p>
<p>Several parts of this policy require providing target-specific documentation.
Such documentation should typically appear in a subdirectory of the
platform-support section of this rustc manual, with a link from the target's
entry in <a href="platform-support.html">platform support</a>. Use
<a href="platform-support/TEMPLATE.html">TEMPLATE.md</a> as a base, and see other
documentation in that directory for examples.</p>
<p>Note that a target must have already received approval for the next lower tier,
and spent a reasonable amount of time at that tier, before making a proposal
for promotion to the next higher tier; this is true even if a target meets the
requirements for several tiers at once. This policy leaves the precise
interpretation of &quot;reasonable amount of time&quot; up to the approving teams; those
teams may scale the amount of time required based on their confidence in the
target and its demonstrated track record at its current tier. At a minimum,
multiple stable releases of Rust should typically occur between promotions of a
target.</p>
<p>The availability or tier of a target in stable Rust is not a hard stability
guarantee about the future availability or tier of that target. Higher-level
target tiers are an increasing commitment to the support of a target, and we
will take that commitment and potential disruptions into account when
evaluating the potential demotion or removal of a target that has been part of
a stable release. The promotion or demotion of a target will not generally
affect existing stable releases, only current development and future releases.</p>
<p>In this policy, the words &quot;must&quot; and &quot;must not&quot; specify absolute requirements
that a target must meet to qualify for a tier. The words &quot;should&quot; and &quot;should
not&quot; specify requirements that apply in almost all cases, but for which the
approving teams may grant an exception for good reason. The word &quot;may&quot;
indicates something entirely optional, and does not indicate guidance or
recommendations. This language is based on <a href="https://tools.ietf.org/html/rfc2119">IETF RFC
2119</a>.</p>
<h2 id="tier-3-target-policy"><a class="header" href="#tier-3-target-policy">Tier 3 target policy</a></h2>
<p>At this tier, the Rust project provides no official support for a target, so we
place minimal requirements on the introduction of targets.</p>
<p>A proposed new tier 3 target must be reviewed and approved by a member of the
compiler team based on these requirements. The reviewer may choose to gauge
broader compiler team consensus via a <a href="https://forge.rust-lang.org/compiler/mcp.html">Major Change Proposal (MCP)</a>.</p>
<p>A proposed target or target-specific patch that substantially changes code
shared with other targets (not just target-specific code) must be reviewed and
approved by the appropriate team for that shared code before acceptance.</p>
<ul>
<li>A tier 3 target must have a designated developer or developers (the &quot;target
maintainers&quot;) on record to be CCed when issues arise regarding the target.
(The mechanism to track and CC such developers may evolve over time.)</li>
<li>Targets must use naming consistent with any existing targets; for instance, a
target for the same CPU or OS as an existing Rust target should use the same
name for that CPU or OS. Targets should normally use the same names and
naming conventions as used elsewhere in the broader ecosystem beyond Rust
(such as in other toolchains), unless they have a very good reason to
diverge. Changing the name of a target can be highly disruptive, especially
once the target reaches a higher tier, so getting the name right is important
even for a tier 3 target.
<ul>
<li>Target names should not introduce undue confusion or ambiguity unless
absolutely necessary to maintain ecosystem compatibility. For example, if
the name of the target makes people extremely likely to form incorrect
beliefs about what it targets, the name should be changed or augmented to
disambiguate it.</li>
</ul>
</li>
<li>Tier 3 targets may have unusual requirements to build or use, but must not
create legal issues or impose onerous legal terms for the Rust project or for
Rust developers or users.
<ul>
<li>The target must not introduce license incompatibilities.</li>
<li>Anything added to the Rust repository must be under the standard Rust
license (<code>MIT OR Apache-2.0</code>).</li>
<li>The target must not cause the Rust tools or libraries built for any other
host (even when supporting cross-compilation to the target) to depend
on any new dependency less permissive than the Rust licensing policy. This
applies whether the dependency is a Rust crate that would require adding
new license exceptions (as specified by the <code>tidy</code> tool in the
rust-lang/rust repository), or whether the dependency is a native library
or binary. In other words, the introduction of the target must not cause a
user installing or running a version of Rust or the Rust tools to be
subject to any new license requirements.</li>
<li>Compiling, linking, and emitting functional binaries, libraries, or other
code for the target (whether hosted on the target itself or cross-compiling
from another target) must not depend on proprietary (non-FOSS) libraries.
Host tools built for the target itself may depend on the ordinary runtime
libraries supplied by the platform and commonly used by other applications
built for the target, but those libraries must not be required for code
generation for the target; cross-compilation to the target must not require
such libraries at all. For instance, <code>rustc</code> built for the target may
depend on a common proprietary C runtime library or console output library,
but must not depend on a proprietary code generation library or code
optimization library. Rust's license permits such combinations, but the
Rust project has no interest in maintaining such combinations within the
scope of Rust itself, even at tier 3.</li>
<li>&quot;onerous&quot; here is an intentionally subjective term. At a minimum, &quot;onerous&quot;
legal/licensing terms include but are <em>not</em> limited to: non-disclosure
requirements, non-compete requirements, contributor license agreements
(CLAs) or equivalent, &quot;non-commercial&quot;/&quot;research-only&quot;/etc terms,
requirements conditional on the employer or employment of any particular
Rust developers, revocable terms, any requirements that create liability
for the Rust project or its developers or users, or any requirements that
adversely affect the livelihood or prospects of the Rust project or its
developers or users.</li>
</ul>
</li>
<li>Neither this policy nor any decisions made regarding targets shall create any
binding agreement or estoppel by any party. If any member of an approving
Rust team serves as one of the maintainers of a target, or has any legal or
employment requirement (explicit or implicit) that might affect their
decisions regarding a target, they must recuse themselves from any approval
decisions regarding the target's tier status, though they may otherwise
participate in discussions.
<ul>
<li>This requirement does not prevent part or all of this policy from being
cited in an explicit contract or work agreement (e.g. to implement or
maintain support for a target). This requirement exists to ensure that a
developer or team responsible for reviewing and approving a target does not
face any legal threats or obligations that would prevent them from freely
exercising their judgment in such approval, even if such judgment involves
subjective matters or goes beyond the letter of these requirements.</li>
</ul>
</li>
<li>Tier 3 targets should attempt to implement as much of the standard libraries
as possible and appropriate (<code>core</code> for most targets, <code>alloc</code> for targets
that can support dynamic memory allocation, <code>std</code> for targets with an
operating system or equivalent layer of system-provided functionality), but
may leave some code unimplemented (either unavailable or stubbed out as
appropriate), whether because the target makes it impossible to implement or
challenging to implement. The authors of pull requests are not obligated to
avoid calling any portions of the standard library on the basis of a tier 3
target not implementing those portions.</li>
<li>The target must provide documentation for the Rust community explaining how
to build for the target, using cross-compilation if possible. If the target
supports running binaries, or running tests (even if they do not pass), the
documentation must explain how to run such binaries or tests for the target,
using emulation if possible or dedicated hardware if necessary.</li>
<li>Tier 3 targets must not impose burden on the authors of pull requests, or
other developers in the community, to maintain the target. In particular,
do not post comments (automated or manual) on a PR that derail or suggest a
block on the PR based on a tier 3 target. Do not send automated messages or
notifications (via any medium, including via <code>@</code>) to a PR author or others
involved with a PR regarding a tier 3 target, unless they have opted into
such messages.
<ul>
<li>Backlinks such as those generated by the issue/PR tracker when linking to
an issue or PR are not considered a violation of this policy, within
reason. However, such messages (even on a separate repository) must not
generate notifications to anyone involved with a PR who has not requested
such notifications.</li>
</ul>
</li>
<li>Patches adding or updating tier 3 targets must not break any existing tier 2
or tier 1 target, and must not knowingly break another tier 3 target without
approval of either the compiler team or the maintainers of the other tier 3
target.
<ul>
<li>In particular, this may come up when working on closely related targets,
such as variations of the same architecture with different features. Avoid
introducing unconditional uses of features that another variation of the
target may not have; use conditional compilation or runtime detection, as
appropriate, to let each target run code supported by that target.</li>
</ul>
</li>
</ul>
<p>If a tier 3 target stops meeting these requirements, or the target maintainers
no longer have interest or time, or the target shows no signs of activity and
has not built for some time, or removing the target would improve the quality
of the Rust codebase, we may post a PR to remove it; any such PR will be CCed
to the target maintainers (and potentially other people who have previously
worked on the target), to check potential interest in improving the situation.</p>
<h2 id="tier-2-target-policy"><a class="header" href="#tier-2-target-policy">Tier 2 target policy</a></h2>
<p>At this tier, the Rust project guarantees that a target builds, and will reject
patches that fail to build on a target. Thus, we place requirements that ensure
the target will not block forward progress of the Rust project.</p>
<p>A proposed new tier 2 target must be reviewed and approved by the compiler team
based on these requirements. Such review and approval may occur via a <a href="https://forge.rust-lang.org/compiler/mcp.html">Major
Change Proposal (MCP)</a>.</p>
<p>In addition, the infrastructure team must approve the integration of the target
into Continuous Integration (CI), and the tier 2 CI-related requirements. This
review and approval may take place in a PR adding the target to CI, or simply
by an infrastructure team member reporting the outcome of a team discussion.</p>
<ul>
<li>A tier 2 target must have value to people other than its maintainers. (It may
still be a niche target, but it must not be exclusively useful for an
inherently closed group.)</li>
<li>A tier 2 target must have a designated team of developers (the &quot;target
maintainers&quot;) available to consult on target-specific build-breaking issues,
or if necessary to develop target-specific language or library implementation
details. This team must have at least 2 developers.
<ul>
<li>The target maintainers should not only fix target-specific issues, but
should use any such issue as an opportunity to educate the Rust community
about portability to their target, and enhance documentation of the target.</li>
</ul>
</li>
<li>The target must not place undue burden on Rust developers not specifically
concerned with that target. Rust developers are expected to not gratuitously
break a tier 2 target, but are not expected to become experts in every tier 2
target, and are not expected to provide target-specific implementations for
every tier 2 target.</li>
<li>The target must provide documentation for the Rust community explaining how
to build for the target using cross-compilation, and explaining how to run
tests for the target. If at all possible, this documentation should show how
to run Rust programs and tests for the target using emulation, to allow
anyone to do so. If the target cannot be feasibly emulated, the documentation
should explain how to obtain and work with physical hardware, cloud systems,
or equivalent.</li>
<li>The target must document its baseline expectations for the features or
versions of CPUs, operating systems, libraries, runtime environments, and
similar.</li>
<li>If introducing a new tier 2 or higher target that is identical to an existing
Rust target except for the baseline expectations for the features or versions
of CPUs, operating systems, libraries, runtime environments, and similar,
then the proposed target must document to the satisfaction of the approving
teams why the specific difference in baseline expectations provides
sufficient value to justify a separate target.
<ul>
<li>Note that in some cases, based on the usage of existing targets within the
Rust community, Rust developers or a target's maintainers may wish to
modify the baseline expectations of a target, or split an existing target
into multiple targets with different baseline expectations. A proposal to
do so will be treated similarly to the analogous promotion, demotion, or
removal of a target, according to this policy, with the same team approvals
required.
<ul>
<li>For instance, if an OS version has become obsolete and unsupported, a
target for that OS may raise its baseline expectations for OS version
(treated as though removing a target corresponding to the older
versions), or a target for that OS may split out support for older OS
versions into a lower-tier target (treated as though demoting a target
corresponding to the older versions, and requiring justification for a
new target at a lower tier for the older OS versions).</li>
</ul>
</li>
</ul>
</li>
<li>Tier 2 targets must not leave any significant portions of <code>core</code> or the
standard library unimplemented or stubbed out, unless they cannot possibly be
supported on the target.
<ul>
<li>The right approach to handling a missing feature from a target may depend
on whether the target seems likely to develop the feature in the future. In
some cases, a target may be co-developed along with Rust support, and Rust
may gain new features on the target as that target gains the capabilities
to support those features.</li>
<li>As an exception, a target identical to an existing tier 1 target except for
lower baseline expectations for the OS, CPU, or similar, may propose to
qualify as tier 2 (but not higher) without support for <code>std</code> if the target
will primarily be used in <code>no_std</code> applications, to reduce the support
burden for the standard library. In this case, evaluation of the proposed
target's value will take this limitation into account.</li>
</ul>
</li>
<li>The code generation backend for the target should not have deficiencies that
invalidate Rust safety properties, as evaluated by the Rust compiler team.
(This requirement does not apply to arbitrary security enhancements or
mitigations provided by code generation backends, only to those properties
needed to ensure safe Rust code cannot cause undefined behavior or other
unsoundness.) If this requirement does not hold, the target must clearly and
prominently document any such limitations as part of the target's entry in
the target tier list, and ideally also via a failing test in the testsuite.
The Rust compiler team must be satisfied with the balance between these
limitations and the difficulty of implementing the necessary features.
<ul>
<li>For example, if Rust relies on a specific code generation feature to ensure
that safe code cannot overflow the stack, the code generation for the
target should support that feature.</li>
<li>If the Rust compiler introduces new safety properties (such as via new
capabilities of a compiler backend), the Rust compiler team will determine
if they consider those new safety properties a best-effort improvement for
specific targets, or a required property for all Rust targets. In the
latter case, the compiler team may require the maintainers of existing
targets to either implement and confirm support for the property or update
the target tier list with documentation of the missing property.</li>
</ul>
</li>
<li>If the target supports C code, and the target has an interoperable calling
convention for C code, the Rust target must support that C calling convention
for the platform via <code>extern &quot;C&quot;</code>. The C calling convention does not need to
be the default Rust calling convention for the target, however.</li>
<li>The target must build reliably in CI, for all components that Rust's CI
considers mandatory.</li>
<li>The approving teams may additionally require that a subset of tests pass in
CI, such as enough to build a functional &quot;hello world&quot; program, <code>./x.py test --no-run</code>, or equivalent &quot;smoke tests&quot;. In particular, this requirement may
apply if the target builds host tools, or if the tests in question provide
substantial value via early detection of critical problems.</li>
<li>Building the target in CI must not take substantially longer than the current
slowest target in CI, and should not substantially raise the maintenance
burden of the CI infrastructure. This requirement is subjective, to be
evaluated by the infrastructure team, and will take the community importance
of the target into account.</li>
<li>Tier 2 targets should, if at all possible, support cross-compiling. Tier 2
targets should not require using the target as the host for builds, even if
the target supports host tools.</li>
<li>In addition to the legal requirements for all targets (specified in the tier
3 requirements), because a tier 2 target typically involves the Rust project
building and supplying various compiled binaries, incorporating the target
and redistributing any resulting compiled binaries (e.g. built libraries,
host tools if any) must not impose any onerous license requirements on any
members of the Rust project, including infrastructure team members and those
operating CI systems. This is a subjective requirement, to be evaluated by
the approving teams.
<ul>
<li>As an exception to this, if the target's primary purpose is to build
components for a Free and Open Source Software (FOSS) project licensed
under &quot;copyleft&quot; terms (terms which require licensing other code under
compatible FOSS terms), such as kernel modules or plugins, then the
standard libraries for the target may potentially be subject to copyleft
terms, as long as such terms are satisfied by Rust's existing practices of
providing full corresponding source code. Note that anything added to the
Rust repository itself must still use Rust's standard license terms.</li>
</ul>
</li>
<li>Tier 2 targets must not impose burden on the authors of pull requests, or
other developers in the community, to ensure that tests pass for the target.
In particular, do not post comments (automated or manual) on a PR that derail
or suggest a block on the PR based on tests failing for the target. Do not
send automated messages or notifications (via any medium, including via <code>@</code>)
to a PR author or others involved with a PR regarding the PR breaking tests
on a tier 2 target, unless they have opted into such messages.
<ul>
<li>Backlinks such as those generated by the issue/PR tracker when linking to
an issue or PR are not considered a violation of this policy, within
reason. However, such messages (even on a separate repository) must not
generate notifications to anyone involved with a PR who has not requested
such notifications.</li>
</ul>
</li>
<li>The target maintainers should regularly run the testsuite for the target, and
should fix any test failures in a reasonably timely fashion.</li>
<li>All requirements for tier 3 apply.</li>
</ul>
<p>A tier 2 target may be demoted or removed if it no longer meets these
requirements. Any proposal for demotion or removal will be CCed to the target
maintainers, and will be communicated widely to the Rust community before being
dropped from a stable release. (The amount of time between such communication
and the next stable release may depend on the nature and severity of the failed
requirement, the timing of its discovery, whether the target has been part of a
stable release yet, and whether the demotion or removal can be a planned and
scheduled action.)</p>
<p>In some circumstances, especially if the target maintainers do not respond in a
timely fashion, Rust teams may land pull requests that temporarily disable some
targets in the nightly compiler, in order to implement a feature not yet
supported by those targets. (As an example, this happened when introducing the
128-bit types <code>u128</code> and <code>i128</code>.) Such a pull request will include notification
and coordination with the maintainers of such targets, and will ideally happen
towards the beginning of a new development cycle to give maintainers time to
update their targets. The maintainers of such targets will then be expected to
implement the corresponding target-specific support in order to re-enable the
target. If the maintainers of such targets cannot provide such support in time
for the next stable release, this may result in demoting or removing the
targets.</p>
<h3 id="tier-2-with-host-tools-1"><a class="header" href="#tier-2-with-host-tools-1">Tier 2 with host tools</a></h3>
<p>Some tier 2 targets may additionally have binaries built to run on them as a
host (such as <code>rustc</code> and <code>cargo</code>). This allows the target to be used as a
development platform, not just a compilation target.</p>
<p>A proposed new tier 2 target with host tools must be reviewed and approved by
the compiler team based on these requirements. Such review and approval may
occur via a <a href="https://forge.rust-lang.org/compiler/mcp.html">Major Change Proposal (MCP)</a>.</p>
<p>In addition, the infrastructure team must approve the integration of the
target's host tools into Continuous Integration (CI), and the CI-related
requirements for host tools. This review and approval may take place in a PR
adding the target's host tools to CI, or simply by an infrastructure team
member reporting the outcome of a team discussion.</p>
<ul>
<li>Depending on the target, its capabilities, its performance, and the
likelihood of use for any given tool, the host tools provided for a tier 2
target may include only <code>rustc</code> and <code>cargo</code>, or may include additional tools
such as <code>clippy</code> and <code>rustfmt</code>.</li>
<li>Approval of host tools will take into account the additional time required to
build the host tools, and the substantial additional storage required for the
host tools.</li>
<li>The host tools must have direct value to people other than the target's
maintainers. (It may still be a niche target, but the host tools must not be
exclusively useful for an inherently closed group.) This requirement will be
evaluated independently from the corresponding tier 2 requirement.
<ul>
<li>The requirement to provide &quot;direct value&quot; means that it does not suffice to
argue that having host tools will help the target's maintainers more easily
provide the target to others. The tools themselves must provide value to
others.</li>
</ul>
</li>
<li>There must be a reasonable expectation that the host tools will be used, for
purposes other than to prove that they can be used.</li>
<li>The host tools must build and run reliably in CI (for all components that
Rust's CI considers mandatory), though they may or may not pass tests.</li>
<li>Building host tools for the target must not take substantially longer than
building host tools for other targets, and should not substantially raise the
maintenance burden of the CI infrastructure.</li>
<li>The host tools must provide a substantively similar experience as on other
targets, subject to reasonable target limitations.
<ul>
<li>Adding a substantively different interface to an existing tool, or a
target-specific interface to the functionality of an existing tool,
requires design and implementation approval (e.g. RFC/MCP) from the
appropriate approving teams for that tool.
<ul>
<li>Such an interface should have a design that could potentially work for
other targets with similar properties.</li>
<li>This should happen separately from the review and approval of the target,
to simplify the target review and approval processes, and to simplify the
review and approval processes for the proposed new interface.</li>
</ul>
</li>
<li>By way of example, a target that runs within a sandbox may need to modify
the handling of files, tool invocation, and similar to meet the
expectations and conventions of the sandbox, but must not introduce a
separate &quot;sandboxed compilation&quot; interface separate from the CLI interface
without going through the normal approval process for such an interface.
Such an interface should take into account potential other targets with
similar sandboxes.</li>
</ul>
</li>
<li>If the host tools for the platform would normally be expected to be signed or
equivalent (e.g. if running unsigned binaries or similar involves a
&quot;developer mode&quot; or an additional prompt), it must be possible for the Rust
project's automated builds to apply the appropriate signature process,
without any manual intervention by either Rust developers, target
maintainers, or a third party. This process must meet the approval of the
infrastructure team.
<ul>
<li>This process may require one-time or semi-regular manual steps by the
infrastructure team, such as registration or renewal of a signing key. Any
such manual process must meet the approval of the infrastructure team.</li>
<li>This process may require the execution of a legal agreement with the
signature provider. Such a legal agreement may be revocable, and may
potentially require a nominal fee, but must not be otherwise onerous. Any
such legal agreement must meet the approval of the infrastructure team.
(The infrastructure team is not expected or required to sign binding legal
agreements on behalf of the Rust project; this review and approval exists
to ensure no terms are onerous or cause problems for infrastructure,
especially if such terms may impose requirements or obligations on people
who have access to target-specific infrastructure.)</li>
<li>Changes to this process, or to any legal agreements involved, may
cause a target to stop meeting this requirement.</li>
<li>This process involved must be available under substantially similar
non-onerous terms to the general public. Making it available exclusively to
the Rust project does not suffice.</li>
<li>This requirement exists to ensure that Rust builds, including nightly
builds, can meet the necessary requirements to allow users to smoothly run
the host tools.</li>
</ul>
</li>
<li>Providing host tools does not exempt a target from requirements to support
cross-compilation if at all possible.</li>
<li>All requirements for tier 2 apply.</li>
</ul>
<p>A target may be promoted directly from tier 3 to tier 2 with host tools if it
meets all the necessary requirements, but doing so may introduce substantial
additional complexity. If in doubt, the target should qualify for tier 2
without host tools first.</p>
<h2 id="tier-1-target-policy"><a class="header" href="#tier-1-target-policy">Tier 1 target policy</a></h2>
<p>At this tier, the Rust project guarantees that a target builds and passes all
tests, and will reject patches that fail to build or pass the testsuite on a
target. We hold tier 1 targets to our highest standard of requirements.</p>
<p>A proposed new tier 1 target must be reviewed and approved by the compiler team
based on these requirements. In addition, the release team must approve the
viability and value of supporting the target. For a tier 1 target, this will
typically take place via a full RFC proposing the target, to be jointly
reviewed and approved by the compiler team and release team.</p>
<p>In addition, the infrastructure team must approve the integration of the target
into Continuous Integration (CI), and the tier 1 CI-related requirements. This
review and approval may take place in a PR adding the target to CI, by an
infrastructure team member reporting the outcome of a team discussion, or by
including the infrastructure team in the RFC proposing the target.</p>
<ul>
<li>Tier 1 targets must have substantial, widespread interest within the
developer community, and must serve the ongoing needs of multiple production
users of Rust across multiple organizations or projects. These requirements
are subjective, and determined by consensus of the approving teams. A tier 1
target may be demoted or removed if it becomes obsolete or no longer meets
this requirement.</li>
<li>The target maintainer team must include at least 3 developers.</li>
<li>The target must build and pass tests reliably in CI, for all components that
Rust's CI considers mandatory.
<ul>
<li>The target must not disable an excessive number of tests or pieces of tests
in the testsuite in order to do so. This is a subjective requirement.</li>
<li>If the target does not have host tools support, or if the target has low
performance, the infrastructure team may choose to have CI cross-compile
the testsuite from another platform, and then run the compiled tests
either natively or via accurate emulation. However, the approving teams may
take such performance considerations into account when determining the
viability of the target or of its host tools.</li>
</ul>
</li>
<li>The target must provide as much of the Rust standard library as is feasible
and appropriate to provide. For instance, if the target can support dynamic
memory allocation, it must provide an implementation of <code>alloc</code> and the
associated data structures.</li>
<li>Building the target and running the testsuite for the target must not take
substantially longer than other targets, and should not substantially raise
the maintenance burden of the CI infrastructure.
<ul>
<li>In particular, if building the target takes a reasonable amount of time,
but the target cannot run the testsuite in a timely fashion due to low
performance of either native code or accurate emulation, that alone may
prevent the target from qualifying as tier 1.</li>
</ul>
</li>
<li>If running the testsuite requires additional infrastructure (such as physical
systems running the target), the target maintainers must arrange to provide
such resources to the Rust project, to the satisfaction and approval of the
Rust infrastructure team.
<ul>
<li>Such resources may be provided via cloud systems, via emulation, or via
physical hardware.</li>
<li>If the target requires the use of emulation to meet any of the tier
requirements, the approving teams for those requirements must have high
confidence in the accuracy of the emulation, such that discrepancies
between emulation and native operation that affect test results will
constitute a high-priority bug in either the emulation or the
implementation of the target.</li>
<li>If it is not possible to run the target via emulation, these resources must
additionally be sufficient for the Rust infrastructure team to make them
available for access by Rust team members, for the purposes of development
and testing. (Note that the responsibility for doing target-specific
development to keep the target well maintained remains with the target
maintainers. This requirement ensures that it is possible for other
Rust developers to test the target, but does not obligate other Rust
developers to make target-specific fixes.)</li>
<li>Resources provided for CI and similar infrastructure must be available for
continuous exclusive use by the Rust project. Resources provided
for access by Rust team members for development and testing must be
available on an exclusive basis when in use, but need not be available on a
continuous basis when not in use.</li>
</ul>
</li>
<li>Tier 1 targets must not have a hard requirement for signed, verified, or
otherwise &quot;approved&quot; binaries. Developers must be able to build, run, and
test binaries for the target on systems they control, or provide such
binaries for others to run. (Doing so may require enabling some appropriate
&quot;developer mode&quot; on such systems, but must not require the payment of any
additional fee or other consideration, or agreement to any onerous legal
agreements.)
<ul>
<li>The Rust project may decide to supply appropriately signed binaries if
doing so provides a smoother experience for developers using the target,
and a tier 2 target with host tools already requires providing appropriate
mechanisms that enable our infrastructure to provide such signed binaries.
However, this additional tier 1 requirement ensures that Rust developers
can develop and test Rust software for the target (including Rust itself),
and that development or testing for the target is not limited.</li>
</ul>
</li>
<li>All requirements for tier 2 apply.</li>
</ul>
<p>A tier 1 target may be demoted if it no longer meets these requirements but
still meets the requirements for a lower tier. Any proposal for demotion of a
tier 1 target requires a full RFC process, with approval by the compiler and
release teams. Any such proposal will be communicated widely to the Rust
community, both when initially proposed and before being dropped from a stable
release. A tier 1 target is highly unlikely to be directly removed without
first being demoted to tier 2 or tier 3. (The amount of time between such
communication and the next stable release may depend on the nature and severity
of the failed requirement, the timing of its discovery, whether the target has
been part of a stable release yet, and whether the demotion or removal can be a
planned and scheduled action.)</p>
<p>Raising the baseline expectations of a tier 1 target (such as the minimum CPU
features or OS version required) requires the approval of the compiler and
release teams, and should be widely communicated as well, but does not
necessarily require a full RFC.</p>
<h3 id="tier-1-with-host-tools-1"><a class="header" href="#tier-1-with-host-tools-1">Tier 1 with host tools</a></h3>
<p>Some tier 1 targets may additionally have binaries built to run on them as a
host (such as <code>rustc</code> and <code>cargo</code>). This allows the target to be used as a
development platform, not just a compilation target.</p>
<p>A proposed new tier 1 target with host tools must be reviewed and approved by
the compiler team based on these requirements. In addition, the release team
must approve the viability and value of supporting host tools for the target.
For a tier 1 target, this will typically take place via a full RFC proposing
the target, to be jointly reviewed and approved by the compiler team and
release team.</p>
<p>In addition, the infrastructure team must approve the integration of the
target's host tools into Continuous Integration (CI), and the CI-related
requirements for host tools. This review and approval may take place in a PR
adding the target's host tools to CI, by an infrastructure team member
reporting the outcome of a team discussion, or by including the infrastructure
team in the RFC proposing the target.</p>
<ul>
<li>Tier 1 targets with host tools should typically include all of the additional
tools such as <code>clippy</code> and <code>rustfmt</code>, unless there is a target-specific
reason why a tool cannot possibly make sense for the target.
<ul>
<li>Unlike with tier 2, for tier 1 we will not exclude specific tools on the
sole basis of them being less likely to be used; rather, we'll take that
into account when considering whether the target should be at tier 1 with
host tools. In general, on any tier 1 target with host tools, people
should be able to expect to find and install all the same components that
they would for any other tier 1 target with host tools.</li>
</ul>
</li>
<li>Approval of host tools will take into account the additional time required to
build the host tools, and the substantial additional storage required for the
host tools.</li>
<li>Host tools for the target must have substantial, widespread interest within
the developer community, and must serve the ongoing needs of multiple
production users of Rust across multiple organizations or projects. These
requirements are subjective, and determined by consensus of the approving
teams. This requirement will be evaluated independently from the
corresponding tier 1 requirement; it is possible for a target to have
sufficient interest for cross-compilation, but not have sufficient interest
for native compilation. The host tools may be dropped if they no longer meet
this requirement, even if the target otherwise qualifies as tier 1.</li>
<li>The host tools must build, run, and pass tests reliably in CI, for all
components that Rust's CI considers mandatory.
<ul>
<li>The target must not disable an excessive number of tests or pieces of tests
in the testsuite in order to do so. This is a subjective requirement.</li>
</ul>
</li>
<li>Building the host tools and running the testsuite for the host tools must not
take substantially longer than other targets, and should not substantially raise
the maintenance burden of the CI infrastructure.
<ul>
<li>In particular, if building the target's host tools takes a reasonable
amount of time, but the target cannot run the testsuite in a timely fashion
due to low performance of either native code or accurate emulation, that
alone may prevent the target from qualifying as tier 1 with host tools.</li>
</ul>
</li>
<li>Providing host tools does not exempt a target from requirements to support
cross-compilation if at all possible.</li>
<li>All requirements for tier 2 targets with host tools apply.</li>
<li>All requirements for tier 1 apply.</li>
</ul>
<p>A target seeking promotion to tier 1 with host tools should typically either be
tier 2 with host tools or tier 1 without host tools, to reduce the number of
requirements to simultaneously review and approve.</p>
<p>In addition to the general process for demoting a tier 1 target, a tier 1
target with host tools may be demoted (including having its host tools dropped,
or being demoted to tier 2 with host tools) if it no longer meets these
requirements but still meets the requirements for a lower tier. Any proposal
for demotion of a tier 1 target (with or without host tools) requires a full
RFC process, with approval by the compiler and release teams. Any such proposal
will be communicated widely to the Rust community, both when initially proposed
and before being dropped from a stable release.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="targets"><a class="header" href="#targets">Targets</a></h1>
<p><code>rustc</code> is a cross-compiler by default. This means that you can use any compiler to build for any
architecture. The list of <em>targets</em> are the possible architectures that you can build for.</p>
<p>To see all the options that you can set with a target, see the docs
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_target/spec/struct.Target.html">here</a>.</p>
<p>To compile to a particular target, use the <code>--target</code> flag:</p>
<pre><code class="language-bash">$ rustc src/main.rs --target=wasm32-unknown-unknown
</code></pre>
<h2 id="target-features"><a class="header" href="#target-features">Target Features</a></h2>
<p><code>x86</code>,  and <code>ARMv8</code> are two popular CPU architectures. Their instruction sets form a common baseline across most CPUs. However, some CPUs extend these with custom instruction sets, e.g. vector (<code>AVX</code>), bitwise manipulation (<code>BMI</code>) or cryptographic (<code>AES</code>).</p>
<p>Developers, who know on which CPUs their compiled code is going to run can choose to add (or remove) CPU specific instruction sets via the <code>-C target-feature=val</code> flag.</p>
<p>Please note, that this flag is generally considered as unsafe. More details can be found in <a href="targets/known-issues.html">this section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-targets"><a class="header" href="#built-in-targets">Built-in Targets</a></h1>
<p><code>rustc</code> ships with the ability to compile to many targets automatically, we
call these &quot;built-in&quot; targets, and they generally correspond to targets that
the team is supporting directly. To see the list of built-in targets, you can
run <code>rustc --print target-list</code>.</p>
<p>Typically, a target needs a compiled copy of the Rust standard library to
work. If using <a href="https://github.com/rust-lang/rustup">rustup</a>, then check out the documentation on
<a href="https://rust-lang.github.io/rustup/cross-compilation.html">Cross-compilation</a> on how to download a pre-built standard
library built by the official Rust distributions. Most targets will need a
system linker, and possibly other things.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-targets"><a class="header" href="#custom-targets">Custom Targets</a></h1>
<p>If you'd like to build for a target that is not yet supported by <code>rustc</code>, you can use a
&quot;custom target specification&quot; to define a target. These target specification files
are JSON. To see the JSON for the host target, you can run:</p>
<pre><code class="language-bash">$ rustc +nightly -Z unstable-options --print target-spec-json
</code></pre>
<p>To see it for a different target, add the <code>--target</code> flag:</p>
<pre><code class="language-bash">$ rustc +nightly -Z unstable-options --target=wasm32-unknown-unknown --print target-spec-json
</code></pre>
<p>To use a custom target, see the (unstable) <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std"><code>build-std</code> feature</a> of <code>cargo</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues"><a class="header" href="#known-issues">Known Issues</a></h1>
<p>This section informs you about known &quot;gotchas&quot;. Keep in mind, that this section is (and always will be) incomplete. For suggestions and amendments, feel free to <a href="targets/../contributing.html">contribute</a> to this guide.</p>
<h2 id="target-features-1"><a class="header" href="#target-features-1">Target Features</a></h2>
<p>Most target-feature problems arise, when mixing code that have the target-feature <em>enabled</em> with code that have it <em>disabled</em>. If you want to avoid undefined behavior, it is recommended to build <em>all code</em> (including the standard library and imported crates) with a common set of target-features.</p>
<p>By default, compiling your code with the <code>-C target-feature</code> flag will not recompile the entire standard library and/or imported crates with matching target features. Therefore, target features are generally considered as unsafe. Using <code>#[target_feature]</code> on individual functions makes the function unsafe.</p>
<p>Examples:</p>
<table><thead><tr><th>Target-Feature</th><th>Issue</th><th>Seen on</th><th>Description</th><th>Details</th></tr></thead><tbody>
<tr><td><code>+soft-float</code> <br> and <br> <code>-sse</code></td><td>Segfaults and ABI mismatches</td><td><code>x86</code> and <code>x86-64</code></td><td>The <code>x86</code> and <code>x86_64</code> architecture uses SSE registers (aka <code>xmm</code>) for floating point operations. Using software emulated floats (&quot;soft-floats&quot;) disables usage of <code>xmm</code> registers, but parts of Rust's core libraries (e.g. <code>std::f32</code> or <code>std::f64</code>) are compiled without soft-floats and expect parameters to be passed in <code>xmm</code> registers. This leads to ABI mismatches. <br><br>  Attempting to compile with disabled SSE causes the same error, too.</td><td><a href="https://github.com/rust-lang/rust/issues/63466">#63466</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profile-guided-optimization"><a class="header" href="#profile-guided-optimization">Profile Guided Optimization</a></h1>
<p><code>rustc</code> supports doing profile-guided optimization (PGO).
This chapter describes what PGO is, what it is good for, and how it can be used.</p>
<h2 id="what-is-profiled-guided-optimization"><a class="header" href="#what-is-profiled-guided-optimization">What Is Profiled-Guided Optimization?</a></h2>
<p>The basic concept of PGO is to collect data about the typical execution of
a program (e.g. which branches it is likely to take) and then use this data
to inform optimizations such as inlining, machine-code layout,
register allocation, etc.</p>
<p>There are different ways of collecting data about a program's execution.
One is to run the program inside a profiler (such as <code>perf</code>) and another
is to create an instrumented binary, that is, a binary that has data
collection built into it, and run that.
The latter usually provides more accurate data and it is also what is
supported by <code>rustc</code>.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Generating a PGO-optimized program involves following a workflow with four steps:</p>
<ol>
<li>Compile the program with instrumentation enabled
(e.g. <code>rustc -Cprofile-generate=/tmp/pgo-data main.rs</code>)</li>
<li>Run the instrumented program (e.g. <code>./main</code>) which generates a
<code>default_&lt;id&gt;.profraw</code> file</li>
<li>Convert the <code>.profraw</code> file into a <code>.profdata</code> file using
LLVM's <code>llvm-profdata</code> tool</li>
<li>Compile the program again, this time making use of the profiling data
(for example <code>rustc -Cprofile-use=merged.profdata main.rs</code>)</li>
</ol>
<p>An instrumented program will create one or more <code>.profraw</code> files, one for each
instrumented binary. E.g. an instrumented executable that loads two instrumented
dynamic libraries at runtime will generate three <code>.profraw</code> files. Running an
instrumented binary multiple times, on the other hand, will re-use the
respective <code>.profraw</code> files, updating them in place.</p>
<p>These <code>.profraw</code> files have to be post-processed before they can be fed back
into the compiler. This is done by the <code>llvm-profdata</code> tool. This tool
is most easily installed via</p>
<pre><code class="language-bash">rustup component add llvm-tools-preview
</code></pre>
<p>Note that installing the <code>llvm-tools-preview</code> component won't add
<code>llvm-profdata</code> to the <code>PATH</code>. Rather, the tool can be found in:</p>
<pre><code class="language-bash">~/.rustup/toolchains/&lt;toolchain&gt;/lib/rustlib/&lt;target-triple&gt;/bin/
</code></pre>
<p>Alternatively, an <code>llvm-profdata</code> coming with a recent LLVM or Clang
version usually works too.</p>
<p>The <code>llvm-profdata</code> tool merges multiple <code>.profraw</code> files into a single
<code>.profdata</code> file that can then be fed back into the compiler via
<code>-Cprofile-use</code>:</p>
<pre><code class="language-bash"># STEP 1: Compile the binary with instrumentation
rustc -Cprofile-generate=/tmp/pgo-data -O ./main.rs

# STEP 2: Run the binary a few times, maybe with common sets of args.
#         Each run will create or update `.profraw` files in /tmp/pgo-data
./main mydata1.csv
./main mydata2.csv
./main mydata3.csv

# STEP 3: Merge and post-process all the `.profraw` files in /tmp/pgo-data
llvm-profdata merge -o ./merged.profdata /tmp/pgo-data

# STEP 4: Use the merged `.profdata` file during optimization. All `rustc`
#         flags have to be the same.
rustc -Cprofile-use=./merged.profdata -O ./main.rs
</code></pre>
<h3 id="a-complete-cargo-workflow"><a class="header" href="#a-complete-cargo-workflow">A Complete Cargo Workflow</a></h3>
<p>Using this feature with Cargo works very similar to using it with <code>rustc</code>
directly. Again, we generate an instrumented binary, run it to produce data,
merge the data, and feed it back into the compiler. Some things of note:</p>
<ul>
<li>
<p>We use the <code>RUSTFLAGS</code> environment variable in order to pass the PGO compiler
flags to the compilation of all crates in the program.</p>
</li>
<li>
<p>We pass the <code>--target</code> flag to Cargo, which prevents the <code>RUSTFLAGS</code>
arguments to be passed to Cargo build scripts. We don't want the build
scripts to generate a bunch of <code>.profraw</code> files.</p>
</li>
<li>
<p>We pass <code>--release</code> to Cargo because that's where PGO makes the most sense.
In theory, PGO can also be done on debug builds but there is little reason
to do so.</p>
</li>
<li>
<p>It is recommended to use <em>absolute paths</em> for the argument of
<code>-Cprofile-generate</code> and <code>-Cprofile-use</code>. Cargo can invoke <code>rustc</code> with
varying working directories, meaning that <code>rustc</code> will not be able to find
the supplied <code>.profdata</code> file. With absolute paths this is not an issue.</p>
</li>
<li>
<p>It is good practice to make sure that there is no left-over profiling data
from previous compilation sessions. Just deleting the directory is a simple
way of doing so (see <code>STEP 0</code> below).</p>
</li>
</ul>
<p>This is what the entire workflow looks like:</p>
<pre><code class="language-bash"># STEP 0: Make sure there is no left-over profiling data from previous runs
rm -rf /tmp/pgo-data

# STEP 1: Build the instrumented binaries
RUSTFLAGS=&quot;-Cprofile-generate=/tmp/pgo-data&quot; \
    cargo build --release --target=x86_64-unknown-linux-gnu

# STEP 2: Run the instrumented binaries with some typical data
./target/x86_64-unknown-linux-gnu/release/myprogram mydata1.csv
./target/x86_64-unknown-linux-gnu/release/myprogram mydata2.csv
./target/x86_64-unknown-linux-gnu/release/myprogram mydata3.csv

# STEP 3: Merge the `.profraw` files into a `.profdata` file
llvm-profdata merge -o /tmp/pgo-data/merged.profdata /tmp/pgo-data

# STEP 4: Use the `.profdata` file for guiding optimizations
RUSTFLAGS=&quot;-Cprofile-use=/tmp/pgo-data/merged.profdata&quot; \
    cargo build --release --target=x86_64-unknown-linux-gnu
</code></pre>
<h3 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h3>
<ul>
<li>
<p>It is recommended to pass <code>-Cllvm-args=-pgo-warn-missing-function</code> during the
<code>-Cprofile-use</code> phase. LLVM by default does not warn if it cannot find
profiling data for a given function. Enabling this warning will make it
easier to spot errors in your setup.</p>
</li>
<li>
<p>There is a <a href="https://github.com/rust-lang/cargo/issues/7416">known issue</a> in
Cargo prior to version 1.39 that will prevent PGO from working correctly. Be
sure to use Cargo 1.39 or newer when doing PGO.</p>
</li>
</ul>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<p><code>rustc</code>'s PGO support relies entirely on LLVM's implementation of the feature
and is equivalent to what Clang offers via the <code>-fprofile-generate</code> /
<code>-fprofile-use</code> flags. The <a href="https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization">Profile Guided Optimization</a> section
in Clang's documentation is therefore an interesting read for anyone who wants
to use PGO with Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linker-plugin-lto-1"><a class="header" href="#linker-plugin-lto-1">Linker-plugin-LTO</a></h1>
<p>The <code>-C linker-plugin-lto</code> flag allows for deferring the LTO optimization
to the actual linking step, which in turn allows for performing
interprocedural optimizations across programming language boundaries if
all the object files being linked were created by LLVM based toolchains.
The prime example here would be linking Rust code together with
Clang-compiled C/C++ code.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>There are two main cases how linker plugin based LTO can be used:</p>
<ul>
<li>compiling a Rust <code>staticlib</code> that is used as a C ABI dependency</li>
<li>compiling a Rust binary where <code>rustc</code> invokes the linker</li>
</ul>
<p>In both cases the Rust code has to be compiled with <code>-C linker-plugin-lto</code> and
the C/C++ code with <code>-flto</code> or <code>-flto=thin</code> so that object files are emitted
as LLVM bitcode.</p>
<h3 id="rust-staticlib-as-dependency-in-cc-program"><a class="header" href="#rust-staticlib-as-dependency-in-cc-program">Rust <code>staticlib</code> as dependency in C/C++ program</a></h3>
<p>In this case the Rust compiler just has to make sure that the object files in
the <code>staticlib</code> are in the right format. For linking, a linker with the
LLVM plugin must be used (e.g. LLD).</p>
<p>Using <code>rustc</code> directly:</p>
<pre><code class="language-bash"># Compile the Rust staticlib
rustc --crate-type=staticlib -Clinker-plugin-lto -Copt-level=2 ./lib.rs
# Compile the C code with `-flto=thin`
clang -c -O2 -flto=thin -o main.o ./main.c
# Link everything, making sure that we use an appropriate linker
clang -flto=thin -fuse-ld=lld -L . -l&quot;name-of-your-rust-lib&quot; -o main -O2 ./cmain.o
</code></pre>
<p>Using <code>cargo</code>:</p>
<pre><code class="language-bash"># Compile the Rust staticlib
RUSTFLAGS=&quot;-Clinker-plugin-lto&quot; cargo build --release
# Compile the C code with `-flto=thin`
clang -c -O2 -flto=thin -o main.o ./main.c
# Link everything, making sure that we use an appropriate linker
clang -flto=thin -fuse-ld=lld -L . -l&quot;name-of-your-rust-lib&quot; -o main -O2 ./cmain.o
</code></pre>
<h3 id="cc-code-as-a-dependency-in-rust"><a class="header" href="#cc-code-as-a-dependency-in-rust">C/C++ code as a dependency in Rust</a></h3>
<p>In this case the linker will be invoked by <code>rustc</code>. We again have to make sure
that an appropriate linker is used.</p>
<p>Using <code>rustc</code> directly:</p>
<pre><code class="language-bash"># Compile C code with `-flto`
clang ./clib.c -flto=thin -c -o ./clib.o -O2
# Create a static library from the C code
ar crus ./libxyz.a ./clib.o

# Invoke `rustc` with the additional arguments
rustc -Clinker-plugin-lto -L. -Copt-level=2 -Clinker=clang -Clink-arg=-fuse-ld=lld ./main.rs
</code></pre>
<p>Using <code>cargo</code> directly:</p>
<pre><code class="language-bash"># Compile C code with `-flto`
clang ./clib.c -flto=thin -c -o ./clib.o -O2
# Create a static library from the C code
ar crus ./libxyz.a ./clib.o

# Set the linking arguments via RUSTFLAGS
RUSTFLAGS=&quot;-Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld&quot; cargo build --release
</code></pre>
<h3 id="explicitly-specifying-the-linker-plugin-to-be-used-by-rustc"><a class="header" href="#explicitly-specifying-the-linker-plugin-to-be-used-by-rustc">Explicitly specifying the linker plugin to be used by <code>rustc</code></a></h3>
<p>If one wants to use a linker other than LLD, the LLVM linker plugin has to be
specified explicitly. Otherwise the linker cannot read the object files. The
path to the plugin is passed as an argument to the <code>-Clinker-plugin-lto</code>
option:</p>
<pre><code class="language-bash">rustc -Clinker-plugin-lto=&quot;/path/to/LLVMgold.so&quot; -L. -Copt-level=2 ./main.rs
</code></pre>
<h2 id="toolchain-compatibility"><a class="header" href="#toolchain-compatibility">Toolchain Compatibility</a></h2>
<!-- NOTE: to update the below table, you can use this shell script:

```sh
rustup toolchain install --profile minimal nightly
MINOR_VERSION=$(rustc +nightly --version | cut -d . -f 2)
LOWER_BOUND=44

llvm_version() {
    toolchain="$1"
    printf "Rust $toolchain    |    Clang "
    rustc +"$toolchain" -Vv | grep LLVM | cut -d ':' -f 2 | tr -d ' '
}

for version in `seq $LOWER_BOUND $((MINOR_VERSION - 2))`; do
    toolchain=1.$version.0
    rustup toolchain install --no-self-update --profile  minimal $toolchain >/dev/null 2>&1
    llvm_version $toolchain
done
```

-->
<p>In order for this kind of LTO to work, the LLVM linker plugin must be able to
handle the LLVM bitcode produced by both <code>rustc</code> and <code>clang</code>.</p>
<p>Best results are achieved by using a <code>rustc</code> and <code>clang</code> that are based on the
exact same version of LLVM. One can use <code>rustc -vV</code> in order to view the LLVM
used by a given <code>rustc</code> version. Note that the version number given
here is only an approximation as Rust sometimes uses unstable revisions of
LLVM. However, the approximation is usually reliable.</p>
<p>The following table shows known good combinations of toolchain versions.</p>
<table><thead><tr><th>Rust Version</th><th>Clang Version</th></tr></thead><tbody>
<tr><td>Rust 1.34</td><td>Clang 8</td></tr>
<tr><td>Rust 1.35</td><td>Clang 8</td></tr>
<tr><td>Rust 1.36</td><td>Clang 8</td></tr>
<tr><td>Rust 1.37</td><td>Clang 8</td></tr>
<tr><td>Rust 1.38</td><td>Clang 9</td></tr>
<tr><td>Rust 1.39</td><td>Clang 9</td></tr>
<tr><td>Rust 1.40</td><td>Clang 9</td></tr>
<tr><td>Rust 1.41</td><td>Clang 9</td></tr>
<tr><td>Rust 1.42</td><td>Clang 9</td></tr>
<tr><td>Rust 1.43</td><td>Clang 9</td></tr>
<tr><td>Rust 1.44</td><td>Clang 9</td></tr>
<tr><td>Rust 1.45</td><td>Clang 10</td></tr>
<tr><td>Rust 1.46</td><td>Clang 10</td></tr>
</tbody></table>
<p>Note that the compatibility policy for this feature might change in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploit-mitigations"><a class="header" href="#exploit-mitigations">Exploit Mitigations</a></h1>
<p>This chapter documents the exploit mitigations supported by the Rust
compiler, and is by no means an extensive survey of the Rust programming
language’s security features.</p>
<p>This chapter is for software engineers working with the Rust programming
language, and assumes prior knowledge of the Rust programming language and
its toolchain.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>The Rust programming language provides memory[1] and thread[2] safety
guarantees via its ownership[3], references and borrowing[4], and slice
types[5] features. However, Unsafe Rust[6] introduces unsafe blocks, unsafe
functions and methods, unsafe traits, and new types that are not subject to
the borrowing rules.</p>
<p>Parts of the Rust standard library are implemented as safe abstractions over
unsafe code (and historically have been vulnerable to memory corruption[7]).
Furthermore, the Rust code and documentation encourage creating safe
abstractions over unsafe code. This can cause a false sense of security if
unsafe code is not properly reviewed and tested.</p>
<p>Unsafe Rust introduces features that do not provide the same memory and
thread safety guarantees. This causes programs or libraries to be
susceptible to memory corruption (CWE-119)[8] and concurrency issues
(CWE-557)[9]. Modern C and C++ compilers provide exploit mitigations to
increase the difficulty to exploit vulnerabilities resulting from these
issues. Therefore, the Rust compiler must also support these exploit
mitigations in order to mitigate vulnerabilities resulting from the use of
Unsafe Rust. This chapter documents these exploit mitigations and how they
apply to Rust.</p>
<p>This chapter does not discuss the effectiveness of these exploit mitigations
as they vary greatly depending on several factors besides their design and
implementation, but rather describe what they do, so their effectiveness can
be understood within a given context.</p>
<h2 id="exploit-mitigations-1"><a class="header" href="#exploit-mitigations-1">Exploit mitigations</a></h2>
<p>This section documents the exploit mitigations applicable to the Rust
compiler when building programs for the Linux operating system on the AMD64
architecture and equivalent.<sup id="fnref:1" role="doc-noteref"><a
href="#fn:1" class="footnote">1</a></sup></p>
<p>The Rust Programming Language currently has no specification. The Rust
compiler (i.e., rustc) is the language reference implementation. All
references to “the Rust compiler” in this chapter refer to the language
reference implementation.</p>
<p>Table I <br />
Summary of exploit mitigations supported by the Rust compiler when building
programs for the Linux operating system on the AMD64 architecture and
equivalent.</p>
<table class="table">
  <tr>
   <td><strong>Exploit mitigation</strong>
   </td>
   <td><strong>Supported and enabled by default</strong>
   </td>
   <td><strong>Since</strong>
   </td>
  </tr>
  <tr>
   <td>Position-independent executable
   </td>
   <td>Yes
   </td>
   <td>0.12.0 (2014-10-09)
   </td>
  </tr>
  <tr>
   <td>Integer overflow checks
   </td>
   <td>Yes (enabled when debug assertions are enabled, and disabled when debug assertions are disabled)
   </td>
   <td>1.1.0 (2015-06-25)
   </td>
  </tr>
  <tr>
   <td>Non-executable memory regions
   </td>
   <td>Yes
   </td>
   <td>1.8.0 (2016-04-14)
   </td>
  </tr>
  <tr>
   <td>Stack clashing protection
   </td>
   <td>Yes
   </td>
   <td>1.20.0 (2017-08-31)
   </td>
  </tr>
  <tr>
   <td>Read-only relocations and immediate binding
   </td>
   <td>Yes
   </td>
   <td>1.21.0 (2017-10-12)
   </td>
  </tr>
  <tr>
   <td>Heap corruption protection
   </td>
   <td>Yes
   </td>
   <td>1.32.0 (2019-01-17) (via operating system default or specified allocator)
   </td>
  </tr>
  <tr>
   <td>Stack smashing protection
   </td>
   <td>No
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td>Forward-edge control flow protection
   </td>
   <td>Yes
   </td>
   <td>Nightly
   </td>
  </tr>
  <tr>
   <td>Backward-edge control flow protection (e.g., shadow and safe stack)
   </td>
   <td>No
   </td>
   <td>
   </td>
  </tr>
</table>
<p><small id="fn:1">1. See
<a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_target/src/spec">https://github.com/rust-lang/rust/tree/master/compiler/rustc_target/src/spec</a>
for a list of targets and their default options. <a href="exploit-mitigations.html#fnref:1"
class="reversefootnote" role="doc-backlink">↩</a></small></p>
<h3 id="position-independent-executable"><a class="header" href="#position-independent-executable">Position-independent executable</a></h3>
<p>Position-independent executable increases the difficulty of the use of code
reuse exploitation techniques, such as return-oriented programming (ROP) and
variants, by generating position-independent code for the executable, and
instructing the dynamic linker to load it similarly to a shared object at a
random load address, thus also benefiting from address-space layout
randomization (ASLR). This is also referred to as “full ASLR”.</p>
<p>The Rust compiler supports position-independent executable, and enables it
by default since version 0.12.0 (2014-10-09)[10]–[13].</p>
<pre><code class="language-text">$ readelf -h target/release/hello-rust | grep Type:
  Type:                              DYN (Shared object file)
</code></pre>
<p>Fig. 1. Checking if an executable is a position-independent executable.</p>
<p>An executable with an object type of <code>ET_DYN</code> (i.e., shared object) and not
<code>ET_EXEC</code> (i.e., executable) is a position-independent executable (see Fig.
1).</p>
<h3 id="integer-overflow-checks"><a class="header" href="#integer-overflow-checks">Integer overflow checks</a></h3>
<p>Integer overflow checks protects programs from undefined and unintended
behavior (which may cause vulnerabilities) by checking for results of signed
and unsigned integer computations that cannot be represented in their type,
resulting in an overflow or wraparound.</p>
<p>The Rust compiler supports integer overflow checks, and enables it when
debug assertions are enabled since version 1.1.0 (2015-06-25)[14]–[20].</p>
<pre><code class="language-compile_fail">fn main() {
    let u: u8 = 255;
    println!(&quot;u: {}&quot;, u + 1);
}
</code></pre>
<p>Fig. 2. hello-rust-integer program.</p>
<pre><code class="language-text">$ cargo run
   Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer)
    Finished dev [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/hello-rust-integer`
thread 'main' panicked at 'attempt to add with overflow', src/main.rs:3:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Fig. 3. Build and execution of hello-rust-integer with debug assertions
enabled.</p>
<pre><code class="language-text">$ cargo run --release
   Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer)
    Finished release [optimized] target(s) in 0.23s
     Running `target/release/hello-rust-integer`
u: 0
</code></pre>
<p>Fig. 4. Build and execution of hello-rust-integer with debug assertions
disabled.</p>
<p>Integer overflow checks are enabled when debug assertions are enabled (see
Fig. 3), and disabled when debug assertions are disabled (see Fig. 4). To
enable integer overflow checks independently, use the option to control
integer overflow checks, scoped attributes, or explicit checking methods
such as <code>checked_add</code><sup id="fnref:2" role="doc-noteref"><a href="exploit-mitigations.html#fn:2"
class="footnote">2</a></sup>.</p>
<p>It is recommended that explicit wrapping methods such as <code>wrapping_add</code> be
used when wrapping semantics are intended, and that explicit checking and
wrapping methods always be used when using Unsafe Rust.</p>
<p><small id="fn:2">2. See <a href="https://doc.rust-lang.org/std/primitive.u32.html">https://doc.rust-lang.org/std/primitive.u32.html</a>
for more information on the checked, overflowing, saturating, and wrapping
methods (using u32 as an example). <a href="exploit-mitigations.html#fnref:2"
class="reversefootnote" role="doc-backlink">↩</a></small></p>
<h3 id="non-executable-memory-regions"><a class="header" href="#non-executable-memory-regions">Non-executable memory regions</a></h3>
<p>Non-executable memory regions increase the difficulty of exploitation by
limiting the memory regions that can be used to execute arbitrary code. Most
modern processors provide support for the operating system to mark memory
regions as non executable, but it was previously emulated by software, such
as in grsecurity/PaX's
<a href="https://pax.grsecurity.net/docs/pageexec.txt">PAGEEXEC</a> and
<a href="https://pax.grsecurity.net/docs/segmexec.txt">SEGMEXEC</a>, on processors that
did not provide support for it. This is also known as “No Execute (NX) Bit”,
“Execute Disable (XD) Bit”, “Execute Never (XN) Bit”, and others.</p>
<p>The Rust compiler supports non-executable memory regions, and enables it by
default since its initial release, version 0.1 (2012-01-20)[21], [22], but
has regressed since then[23]–[25], and enforced by default since version
1.8.0 (2016-04-14)[25].</p>
<pre><code class="language-text">$ readelf -l target/release/hello-rust | grep -A 1 GNU_STACK
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
</code></pre>
<p>Fig. 5. Checking if non-executable memory regions are enabled for a given
binary.</p>
<p>The presence of an element of type <code>PT_GNU_STACK</code> in the program header
table with the <code>PF_X</code> (i.e., executable) flag unset indicates non-executable
memory regions<sup id="fnref:3" role="doc-noteref"><a href="exploit-mitigations.html#fn:3"
class="footnote">3</a></sup> are enabled for a given binary (see Fig. 5).
Conversely, the presence of an element of type <code>PT_GNU_STACK</code> in the program
header table with the <code>PF_X</code> flag set or the absence of an element of type
<code>PT_GNU_STACK</code> in the program header table indicates non-executable memory
regions are not enabled for a given binary.</p>
<p><small id="fn:3">3. See the Appendix section for more information on why it
affects other memory regions besides the stack. <a href="exploit-mitigations.html#fnref:3"
class="reversefootnote" role="doc-backlink">↩</a></small></p>
<h3 id="stack-clashing-protection"><a class="header" href="#stack-clashing-protection">Stack clashing protection</a></h3>
<p>Stack clashing protection protects the stack from overlapping with another
memory region—allowing arbitrary data in both to be overwritten using each
other—by reading from the stack pages as the stack grows to cause a page
fault when attempting to read from the guard page/region. This is also
referred to as “stack probes” or “stack probing”.</p>
<p>The Rust compiler supports stack clashing protection via stack probing, and
enables it by default since version 1.20.0 (2017-08-31)[26]–[29].</p>
<p><img src="images/image1.png" alt="Screenshot of IDA Pro listing cross references to __rust_probestack in hello-rust." title="Cross references to __rust_probestack in hello-rust." />
Fig. 6. IDA Pro listing cross references to <code>__rust_probestack</code> in
hello-rust.</p>
<pre><pre class="playground"><code class="language-rust">fn hello() {
    println!(&quot;Hello, world!&quot;);
}

fn main() {
    let _: [u64; 1024] = [0; 1024];
    hello();
}
</code></pre></pre>
<p>Fig 7. Modified hello-rust.</p>
<p><img src="images/image2.png" alt="Screenshot of IDA Pro listing cross references to __rust_probestack in modified hello-rust." title="Cross references to __rust_probestack in modified hello-rust." />
Fig. 8. IDA Pro listing cross references to <code>__rust_probestack</code> in modified
hello-rust.</p>
<p>To check if stack clashing protection is enabled for a given binary, search
for cross references to <code>__rust_probestack</code>. The <code>__rust_probestack</code> is
called in the prologue of functions whose stack size is larger than a page
size (see Fig. 6), and can be forced for illustration purposes by modifying
the hello-rust example as seen in Fig. 7 and Fig. 8.</p>
<h3 id="read-only-relocations-and-immediate-binding"><a class="header" href="#read-only-relocations-and-immediate-binding">Read-only relocations and immediate binding</a></h3>
<p><strong>Read-only relocations</strong> protect segments containing relocations and
relocation information (i.e., <code>.init_array</code>, <code>.fini_array</code>, <code>.dynamic</code>, and
<code>.got</code>) from being overwritten by marking these segments read only. This is
also referred to as “partial RELRO”.</p>
<p>The Rust compiler supports read-only relocations, and enables it by default
since version 1.21.0 (2017-10-12)[30], [31].</p>
<pre><code class="language-text">$ readelf -l target/release/hello-rust | grep GNU_RELRO
  GNU_RELRO      0x000000000002ee00 0x000000000002fe00 0x000000000002fe00
</code></pre>
<p>Fig. 9. Checking if read-only relocations is enabled for a given binary.</p>
<p>The presence of an element of type <code>PT_GNU_RELRO</code> in the program header
table indicates read-only relocations are enabled for a given binary (see
Fig. 9). Conversely, the absence of an element of type <code>PT_GNU_RELRO</code> in the
program header table indicates read-only relocations are not enabled for a
given binary.</p>
<p><strong>Immediate binding</strong> protects additional segments containing relocations
(i.e., <code>.got.plt</code>) from being overwritten by instructing the dynamic linker
to perform all relocations before transferring control to the program during
startup, so all segments containing relocations can be marked read only
(when combined with read-only relocations). This is also referred to as
“full RELRO”.</p>
<p>The Rust compiler supports immediate binding, and enables it by default
since version 1.21.0 (2017-10-12)[30], [31].</p>
<pre><code class="language-text">$ readelf -d target/release/hello-rust | grep BIND_NOW
 0x000000000000001e (FLAGS)              BIND_NOW
</code></pre>
<p>Fig. 10. Checking if immediate binding is enabled for a given binary.</p>
<p>The presence of an element with the <code>DT_BIND_NOW</code> tag and the <code>DF_BIND_NOW</code>
flag<sup id="fnref:4" role="doc-noteref"><a href="exploit-mitigations.html#fn:4"
class="footnote">4</a></sup> in the dynamic section indicates immediate
binding is enabled for a given binary (see Fig. 10). Conversely, the absence
of an element with the <code>DT_BIND_NOW</code> tag and the <code>DF_BIND_NOW</code> flag in the
dynamic section indicates immediate binding is not enabled for a given
binary.</p>
<p>The presence of both an element of type <code>PT_GNU_RELRO</code> in the program header
table and of an element with the <code>DT_BIND_NOW</code> tag and the <code>DF_BIND_NOW</code>
flag in the dynamic section indicates full RELRO is enabled for a given
binary (see Fig. 9 and Fig. 10).</p>
<p><small id="fn:4">4. And the <code>DF_1_NOW</code> flag for some link editors. <a
href="#fnref:4" class="reversefootnote" role="doc-backlink">↩</a></small></p>
<h3 id="heap-corruption-protection"><a class="header" href="#heap-corruption-protection">Heap corruption protection</a></h3>
<p>Heap corruption protection protects memory allocated dynamically by
performing several checks, such as checks for corrupted links between list
elements, invalid pointers, invalid sizes, double/multiple “frees” of the
same memory allocated, and many corner cases of these. These checks are
implementation specific, and vary per allocator.</p>
<p><a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/enhancing-memory-safety">ARM Memory Tagging Extension
(MTE)</a>,
when available, will provide hardware assistance for a probabilistic
mitigation to detect memory safety violations by tagging memory allocations,
and automatically checking that the correct tag is used on every memory
access.</p>
<p>Rust’s default allocator has historically been
<a href="http://jemalloc.net/">jemalloc</a>, and it has long been the cause of issues
and the subject of much discussion[32]–[38]. Consequently, it has been
removed as the default allocator in favor of the operating system’s standard
C library default allocator<sup id="fnref:5" role="doc-noteref"><a
href="#fn:5" class="footnote">5</a></sup> since version 1.32.0
(2019-01-17)[39].</p>
<pre><pre class="playground"><code class="language-rust no_run">fn main() {
    let mut x = Box::new([0; 1024]);

    for i in 0..1026 {
        unsafe {
            let elem = x.get_unchecked_mut(i);
            *elem = 0x4141414141414141u64;
        }
    }
}
</code></pre></pre>
<p>Fig. 11. hello-rust-heap program.</p>
<pre><code class="language-text">$ cargo run
   Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/hello-rust-heap`
free(): invalid next size (normal)
Aborted
</code></pre>
<p>Fig. 12. Build and execution of hello-rust-heap with debug assertions
enabled.</p>
<pre><code class="language-text">$ cargo run --release
   Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap)
    Finished release [optimized] target(s) in 0.25s
     Running `target/release/hello-rust-heap`
free(): invalid next size (normal)
Aborted
</code></pre>
<p>Fig. 13. Build and execution of hello-rust-heap with debug assertions
disabled.</p>
<p>Heap corruption checks are being performed when using the default allocator
(i.e., the GNU Allocator) as seen in Fig. 12 and Fig. 13.</p>
<p><small id="fn:5">5. Linux's standard C library default allocator is the GNU
Allocator, which is derived from ptmalloc (pthreads malloc) by Wolfram
Gloger, which in turn is derived from dlmalloc (Doug Lea malloc) by Doug
Lea. <a href="exploit-mitigations.html#fnref:5" class="reversefootnote"
role="doc-backlink">↩</a></small></p>
<h3 id="stack-smashing-protection"><a class="header" href="#stack-smashing-protection">Stack smashing protection</a></h3>
<p>Stack smashing protection protects programs from stack-based buffer
overflows by inserting a random guard value between local variables and the
saved return instruction pointer, and checking if this value has changed
when returning from a function. This is also known as “Stack Protector” or
“Stack Smashing Protector (SSP)”.</p>
<p>The Rust compiler does not support stack smashing protection. However, more
comprehensive alternatives to stack smashing protection exist, such as
shadow and safe stack (see backward-edge control flow protection).</p>
<p><img src="images/image3.png" alt="Screenshot of IDA Pro listing cross references to __stack_chk_fail in hello-rust." title="Cross references to __stack_chk_fail in hello-rust." />
Fig. 14. IDA Pro listing cross references to <code>__stack_chk_fail</code> in
hello-rust.</p>
<p>To check if stack smashing protection is enabled for a given binary, search
for cross references to <code>__stack_chk_fail</code>. The only cross references to
<code>__stack_chk_fail</code> in hello-rust are from the statically-linked libbacktrace
library (see Fig. 14).</p>
<h3 id="forward-edge-control-flow-protection"><a class="header" href="#forward-edge-control-flow-protection">Forward-edge control flow protection</a></h3>
<p>Forward-edge control flow protection protects programs from having its
control flow changed/hijacked by performing checks to ensure that
destinations of indirect branches are one of their valid destinations in the
control flow graph. The comprehensiveness of these checks vary per
implementation. This is also known as “forward-edge control flow integrity
(CFI)”.</p>
<p>Newer processors provide hardware assistance for forward-edge control flow
protection, such as ARM Branch Target Identification (BTI), ARM Pointer
Authentication, and Intel Indirect Branch Tracking (IBT) as part of Intel
Control-flow Enforcement Technology (CET). However, ARM BTI and Intel IBT
-based implementations are less comprehensive than software-based
implementations such as <a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">LLVM ControlFlowIntegrity
(CFI)</a>, and the
commercially available <a href="https://grsecurity.net/rap_faq">grsecurity/PaX Reuse Attack Protector
(RAP)</a>.</p>
<p>The Rust compiler supports forward-edge control flow protection on nightly
builds[40]-[41] <sup id="fnref:6" role="doc-noteref"><a href="exploit-mitigations.html#fn:6"
class="footnote">6</a></sup>.</p>
<pre><code class="language-text">$ readelf -s -W target/debug/rust-cfi | grep &quot;\.cfi&quot;
    12: 0000000000005170    46 FUNC    LOCAL  DEFAULT   14 _RNvCsjaOHoaNjor6_8rust_cfi7add_one.cfi
    15: 00000000000051a0    16 FUNC    LOCAL  DEFAULT   14 _RNvCsjaOHoaNjor6_8rust_cfi7add_two.cfi
    17: 0000000000005270   396 FUNC    LOCAL  DEFAULT   14 _RNvCsjaOHoaNjor6_8rust_cfi4main.cfi
...
</code></pre>
<p>Fig. 15. Checking if LLVM CFI is enabled for a given binary[41].</p>
<p>The presence of symbols suffixed with &quot;.cfi&quot; or the <code>__cfi_init</code> symbol (and
references to <code>__cfi_check</code>) indicates that LLVM CFI (i.e., forward-edge control
flow protection) is enabled for a given binary. Conversely, the absence of
symbols suffixed with &quot;.cfi&quot; or the <code>__cfi_init</code> symbol (and references to
<code>__cfi_check</code>) indicates that LLVM CFI is not enabled for a given binary (see
Fig. 15).</p>
<p><small id="fn:6">6. It also supports Control Flow Guard (CFG) on Windows (see
<a href="https://github.com/rust-lang/rust/issues/68793">https://github.com/rust-lang/rust/issues/68793</a>). <a href="exploit-mitigations.html#fnref:6"
class="reversefootnote" role="doc-backlink">↩</a></small></p>
<h3 id="backward-edge-control-flow-protection"><a class="header" href="#backward-edge-control-flow-protection">Backward-edge control flow protection</a></h3>
<p><strong>Shadow stack</strong> protects saved return instruction pointers from being
overwritten by storing a copy of them on a separate (shadow) stack, and
using these copies as authoritative values when returning from functions.
This is also known as “ShadowCallStack” and “Return Flow Guard”, and is
considered an implementation of backward-edge control flow protection (or
“backward-edge CFI”).</p>
<p><strong>Safe stack</strong> protects not only the saved return instruction pointers, but
also register spills and some local variables from being overwritten by
storing unsafe variables, such as large arrays, on a separate (unsafe)
stack, and using these unsafe variables on the separate stack instead. This
is also known as “SafeStack”, and is also considered an implementation of
backward-edge control flow protection.</p>
<p>Both shadow and safe stack are intended to be a more comprehensive
alternatives to stack smashing protection as they protect the saved return
instruction pointers (and other data in the case of safe stack) from
arbitrary writes and non-linear out-of-bounds writes.</p>
<p>Newer processors provide hardware assistance for backward-edge control flow
protection, such as ARM Pointer Authentication, and Intel Shadow Stack as
part of Intel CET.</p>
<p>The Rust compiler does not support shadow or safe stack. There is work
currently ongoing to add support for the sanitizers[40], which may or may
not include support for safe stack<sup id="fnref:7" role="doc-noteref"><a
href="#fn:7" class="footnote">7</a></sup>.</p>
<pre><code class="language-text">$ readelf -s target/release/hello-rust | grep __safestack_init
</code></pre>
<p>Fig. 16. Checking if LLVM SafeStack is enabled for a given binary.</p>
<p>The presence of the <code>__safestack_init</code> symbol indicates that LLVM SafeStack
is enabled for a given binary. Conversely, the absence of the
<code>__safestack_init</code> symbol indicates that LLVM SafeStack is not enabled for a
given binary (see Fig. 16).</p>
<p><small id="fn:7">7. The shadow stack implementation for the AMD64
architecture and equivalent in LLVM was removed due to performance and
security issues. <a href="exploit-mitigations.html#fnref:7" class="reversefootnote"
role="doc-backlink">↩</a></small></p>
<h2 id="appendix"><a class="header" href="#appendix">Appendix</a></h2>
<p>As of the latest version of the <a href="https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/progheader.html">Linux Standard Base (LSB) Core
Specification</a>,
the <code>PT_GNU_STACK</code> program header indicates whether the stack should be
executable, and the absence of this header indicates that the stack should
be executable. However, the Linux kernel currently sets the
<code>READ_IMPLIES_EXEC</code> personality upon loading any executable with the
<code>PT_GNU_STACK</code> program header and the <code>PF_X </code>flag set or with the absence of
this header, resulting in not only the stack, but also all readable virtual
memory mappings being executable.</p>
<p>An attempt to fix this <a href="https://lore.kernel.org/lkml/f298f914-2239-44e4-8aa1-a51282e7fac0@zmail15.collab.prod.int.phx2.redhat.com/">was made in
2012</a>,
and another <a href="https://lore.kernel.org/kernel-hardening/20200327064820.12602-1-keescook@chromium.org/">was made in
2020</a>.
The former never landed, and the latter partially fixed it, but introduced
other issues—the absence of the <code>PT_GNU_STACK</code> program header still causes
not only the stack, but also all readable virtual memory mappings to be
executable in some architectures, such as IA-32 and equivalent (or causes
the stack to be non-executable in some architectures, such as AMD64 and
equivalent, contradicting the LSB).</p>
<p>The <code>READ_IMPLIES_EXEC</code> personality needs to be completely separated from
the <code>PT_GNU_STACK</code> program header by having a separate option for it (or
setarch -X could just be used whenever <code>READ_IMPLIES_EXEC</code> is needed), and
the absence of the <code>PT_GNU_STACK</code> program header needs to have more secure
defaults (unrelated to <code>READ_IMPLIES_EXEC</code>).</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ol>
<li>
<p>D. Hosfelt. “Fearless security: memory safety.” Mozilla Hacks.
<a href="https://hacks.mozilla.org/2019/01/fearless-security-memory-safety/">https://hacks.mozilla.org/2019/01/fearless-security-memory-safety/</a>.</p>
</li>
<li>
<p>D. Hosfelt. “Fearless security: thread safety.” Mozilla Hacks.
<a href="https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/">https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/</a>.</p>
</li>
<li>
<p>S. Klabnik and C. Nichols. “What Is Ownership?.” The Rust Programming
Language. <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a>.</p>
</li>
<li>
<p>S. Klabnik and C. Nichols. “References and Borrowing.” The Rust
Programming Language.
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html</a>.</p>
</li>
<li>
<p>S. Klabnik and C. Nichols. “The Slice Type.” The Rust Programming
Language. <a href="https://doc.rust-lang.org/book/ch04-03-slices.html">https://doc.rust-lang.org/book/ch04-03-slices.html</a>.</p>
</li>
<li>
<p>S. Klabnik and C. Nichols. “Unsafe Rust.” The Rust Programming Language.
<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html</a>.</p>
</li>
<li>
<p>S. Davidoff. “How Rust’s standard library was vulnerable for years and
nobody noticed.” Medium.
<a href="https://medium.com/@shnatsel/how-rusts-standard-library-was-vulnerable-for-years-and-nobody-noticed-aebf0503c3d6">https://medium.com/@shnatsel/how-rusts-standard-library-was-vulnerable-for-years-and-nobody-noticed-aebf0503c3d6</a>.</p>
</li>
<li>
<p>“Improper restriction of operations within the bounds of a memory buffer
(CWE-119).” MITRE CWE List.
<a href="https://cwe.mitre.org/data/definitions/119.html">https://cwe.mitre.org/data/definitions/119.html</a>.</p>
</li>
<li>
<p>“Concurrency issues (CWE-557).” MITRE CWE List.
<a href="https://cwe.mitre.org/data/definitions/557.html">https://cwe.mitre.org/data/definitions/557.html</a>.</p>
</li>
<li>
<p>K. McAllister. “Memory exploit mitigations #15179.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/15179">https://github.com/rust-lang/rust/issues/15179</a>.</p>
</li>
<li>
<p>K. McAllister. “RFC: Memory exploit mitigation #145.” GitHub.
<a href="https://github.com/rust-lang/rfcs/pull/145">https://github.com/rust-lang/rfcs/pull/145</a>.</p>
</li>
<li>
<p>K. McAllister. “RFC: Memory exploit mitigation.” GitHub.
<a href="https://github.com/kmcallister/rfcs/blob/hardening/active/0000-memory-exploit-mitigation.md">https://github.com/kmcallister/rfcs/blob/hardening/active/0000-memory-exploit-mitigation.md</a>.</p>
</li>
<li>
<p>D. Micay. “Enable PIE by default on Linux for full ASLR #16340.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/16340">https://github.com/rust-lang/rust/pull/16340</a>.</p>
</li>
<li>
<p>N. Matsakis. “Integer overflow #560.” GitHub.
<a href="https://github.com/rust-lang/rfcs/pull/560">https://github.com/rust-lang/rfcs/pull/560</a>.</p>
</li>
<li>
<p>G. Lehel and N. Matsakis. “Integer overflow.” GitHub.
<a href="https://rust-lang.github.io/rfcs/0560-integer-overflow.html">https://rust-lang.github.io/rfcs/0560-integer-overflow.html</a>.</p>
</li>
<li>
<p>A. Turon. “Tracking issue for integer overflow (RFC 560) #22020.”
GitHub. <a href="https://github.com/rust-lang/rust/issues/22020">https://github.com/rust-lang/rust/issues/22020</a>.</p>
</li>
<li>
<p>H. Wilson. “Myths and legends about integer overflow in Rust.” Huon on
the Internet.
<a href="http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/">http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/</a>.</p>
</li>
<li>
<p>B. Anderson. “Stabilize -C overflow-checks #1535.” GitHub.
<a href="https://github.com/rust-lang/rfcs/pull/1535">https://github.com/rust-lang/rfcs/pull/1535</a>.</p>
</li>
<li>
<p>B. Anderson. “Stable overflow checks.” GitHub.
<a href="https://github.com/brson/rfcs/blob/overflow/text/0000-stable-overflow-checks.md">https://github.com/brson/rfcs/blob/overflow/text/0000-stable-overflow-checks.md</a>.</p>
</li>
<li>
<p>N. Froyd. “Add -C overflow-checks option #40037.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/40037">https://github.com/rust-lang/rust/pull/40037</a>.</p>
</li>
<li>
<p>R. Á. de Espíndola. “rustc requires executable stack #798.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/798">https://github.com/rust-lang/rust/issues/798</a>.</p>
</li>
<li>
<p>A. Seipp. “Make sure librustrt.so is linked with a non-executable stack.
#1066.” GitHub. <a href="https://github.com/rust-lang/rust/pull/1066">https://github.com/rust-lang/rust/pull/1066</a>.</p>
</li>
<li>
<p>D. Micay. “Rust binaries should not have an executable stack #5643.”
GitHub. <a href="https://github.com/rust-lang/rust/issues/5643">https://github.com/rust-lang/rust/issues/5643</a>.</p>
</li>
<li>
<p>D. Micay. “Mark the assembly object stacks as non-executable #5647.”
GitHub. <a href="https://github.com/rust-lang/rust/pull/5647">https://github.com/rust-lang/rust/pull/5647</a>.</p>
</li>
<li>
<p>A. Clark. “Explicitly disable stack execution on linux and bsd #30859.”
GitHub. <a href="https://github.com/rust-lang/rust/pull/30859">https://github.com/rust-lang/rust/pull/30859</a>.</p>
</li>
<li>
<p>“Replace stack overflow checking with stack probes #16012.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/16012">https://github.com/rust-lang/rust/issues/16012</a>.</p>
</li>
<li>
<p>B. Striegel. “Extend stack probe support to non-tier-1 platforms, and
clarify policy for mitigating LLVM-dependent unsafety #43241.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/43241">https://github.com/rust-lang/rust/issues/43241</a>.</p>
</li>
<li>
<p>A. Crichton. “rustc: Implement stack probes for x86 #42816.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/42816">https://github.com/rust-lang/rust/pull/42816</a>.</p>
</li>
<li>
<p>A. Crichton. “Add __rust_probestack intrinsic #175.” GitHub.
<a href="https://github.com/rust-lang/compiler-builtins/pull/175">https://github.com/rust-lang/compiler-builtins/pull/175</a>.</p>
</li>
<li>
<p>B. Anderson. “Consider applying -Wl,-z,relro or -Wl,-z,relro,-z,now by
default #29877.” GitHub. <a href="https://github.com/rust-lang/rust/issues/29877">https://github.com/rust-lang/rust/issues/29877</a>.</p>
</li>
<li>
<p>J. Löthberg. “Add support for full RELRO #43170.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/43170">https://github.com/rust-lang/rust/pull/43170</a>.</p>
</li>
<li>
<p>N. Matsakis. “Allocators in Rust.” Baby Steps.
<a href="http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/">http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/</a>.</p>
</li>
<li>
<p>A. Crichton. “RFC: Allow changing the default allocator #1183.” GitHub.
<a href="https://github.com/rust-lang/rfcs/pull/1183">https://github.com/rust-lang/rfcs/pull/1183</a>.</p>
</li>
<li>
<p>A. Crichton. “RFC: Swap out jemalloc.” GitHub.
<a href="https://rust-lang.github.io/rfcs/1183-swap-out-jemalloc.html">https://rust-lang.github.io/rfcs/1183-swap-out-jemalloc.html</a>.</p>
</li>
<li>
<p>A. Crichton. “Tracking issue for changing the global, default allocator
(RFC 1974) #27389.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/27389">https://github.com/rust-lang/rust/issues/27389</a>.</p>
</li>
<li>
<p>S. Fackler. “Prepare global allocators for stabilization #1974.” GitHub.
<a href="https://github.com/rust-lang/rfcs/pull/1974">https://github.com/rust-lang/rfcs/pull/1974</a>.</p>
</li>
<li>
<p>A. Crichton. “RFC: Global allocators.” GitHub.
<a href="https://rust-lang.github.io/rfcs/1974-global-allocators.html">https://rust-lang.github.io/rfcs/1974-global-allocators.html</a>.</p>
</li>
<li>
<p>B. Anderson. “Switch the default global allocator to System, remove
alloc_jemalloc, use jemallocator in rustc #36963.” GitHub.
<a href="https://github.com/rust-lang/rust/issues/36963">https://github.com/rust-lang/rust/issues/36963</a>.</p>
</li>
<li>
<p>A. Crichton. “Remove the alloc_jemalloc crate #55238.” GitHub.
<a href="https://github.com/rust-lang/rust/pull/55238">https://github.com/rust-lang/rust/pull/55238</a>.</p>
</li>
<li>
<p>R. de C Valle. “Tracking Issue for LLVM Control Flow Integrity (CFI) Support
for Rust #89653.” GitHub. <a href="https://github.com/rust-lang/rust/issues/89653">https://github.com/rust-lang/rust/issues/89653</a>.</p>
</li>
<li>
<p>“ControlFlowIntegrity.” The Rust Unstable Book.
<a href="https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#controlflowintegrity">https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#controlflowintegrity</a>.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-rustc"><a class="header" href="#contributing-to-rustc">Contributing to rustc</a></h1>
<p>We'd love to have your help improving <code>rustc</code>! To that end, we've written <a href="https://rustc-dev-guide.rust-lang.org/">a
whole book</a> on its
internals, how it works, and how to get started working on it. To learn
more, you'll want to check that out.</p>
<p>If you would like to contribute to <em>this</em> book, you can find its source in the
rustc source at <a href="https://github.com/rust-lang/rust/tree/master/src/doc/rustc">src/doc/rustc</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
