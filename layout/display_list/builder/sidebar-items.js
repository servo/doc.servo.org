initSidebarItems({"constant":[["INSERTION_POINT_LOGICAL_WIDTH","The logical width of an insertion point: at the moment, a one-pixel-wide line."],["MAX_GLYPHS_PER_TEXT_RUN",""]],"enum":[["BorderPaintingMode","Describes how to paint the borders."]],"fn":[["build_border_radius_for_inner_rect","Get the border radius for the rectangle inside of a rounded border. This is useful for building the clip for the content inside the border."],["convert_text_run_to_glyphs",""],["get_cursor","Gets the cursor to use given the specific ComputedValues.  `default_cursor` specifies the cursor to use if `cursor` is `auto`. Typically, this will be `PointerCursor`, but for text display items it may be `TextCursor` or `VerticalTextCursor`."],["modify_border_width_for_inline_sides","Adjusts borders as appropriate to account for a fragment’s status as the first or last fragment within the range of an element."]],"static":[["THREAD_TINT_COLORS",""]],"struct":[["DisplayListBuildState",""],["IndexableText",""],["IndexableTextItem",""],["InlineNodeBorderInfo",""],["SavedStackingContextCollectionState","This structure manages ensuring that modification to StackingContextCollectionState is only temporary. It’s useful for moving recursively down the flow tree and ensuring that the state is restored for siblings. To use this structure, we must call SavedStackingContextCollectionState::restore in order to restore the state. TODO(mrobinson): It would be nice to use RAII here to avoid having to call restore."],["StackingContextCollectionFlags",""],["StackingContextCollectionState",""],["StackingContextInfo",""]],"trait":[["ToF32Px",""]]});