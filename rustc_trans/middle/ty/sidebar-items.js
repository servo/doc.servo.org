initSidebarItems({"constant":[["HAS_PARAMS",""],["HAS_PROJECTION",""],["HAS_REGIONS",""],["HAS_RE_INFER",""],["HAS_RE_LATE_BOUND",""],["HAS_SELF",""],["HAS_TY_ERR",""],["HAS_TY_INFER",""],["INITIAL_DISCRIMINANT_VALUE",""],["NEEDS_SUBST",""],["NO_TYPE_FLAGS",""]],"enum":[["AutoAdjustment",""],["AutoRef",""],["BorrowKind",""],["BoundRegion",""],["BuiltinBound",""],["ClosureKind",""],["CopyImplementationError",""],["DtorKind",""],["ExplicitSelfCategory","The category of explicit self."],["ExprAdjustment",""],["ExprKind","We categorize expressions into three kinds.  The distinction between lvalue/rvalue is fundamental to the language.  The distinction between the two kinds of rvalues is an artifact of trans which reflects how we will generate code for that kind of expression.  See trans/expr.rs for more information."],["FnOutput",""],["ImplOrTraitItem",""],["ImplOrTraitItemContainer",""],["ImplOrTraitItemId",""],["InferRegion",""],["InferTy",""],["IntVarValue",""],["MethodOrigin",""],["ObjectLifetimeDefault","Default region to use for the bound of objects that are supplied as the value for this type parameter. This is derived from `T:'a` annotations appearing in the type definition.  If this is `None`, then the default is inherited from the surrounding context. See RFC #599 for details."],["Predicate",""],["Region","Representation of regions:"],["Representability","Describes whether a type is representable. For types that are not representable, 'SelfRecursive' and 'ContainsRecursive' are used to distinguish between types that are recursive with themselves and types that contain a different recursive type. These cases can therefore be treated differently when reporting errors."],["UnconstrainedNumeric",""],["UnsizeKind",""],["UpvarCapture","Information describing the capture of an upvar. This is computed during `typeck`, specifically by `regionck`."],["Variance",""],["sty",""],["terr_vstore_kind",""],["type_err",""],["vtable_origin",""]],"type":[["BuiltinBounds",""],["CaptureModeMap",""],["Disr",""],["FreevarMap",""],["GlobMap",""],["MethodMap",""],["ObjectCastMap",""],["PolyEquatePredicate",""],["PolyFnOutput",""],["PolyFnSig",""],["PolyOutlivesPredicate",""],["PolyProjectionPredicate",""],["PolyRegionOutlivesPredicate",""],["PolyTraitPredicate",""],["PolyTraitRef",""],["PolyTypeOutlivesPredicate",""],["TraitMap",""],["Ty",""],["UpvarCaptureMap",""],["vtable_param_res",""],["vtable_res",""]],"trait":[["AsPredicate",""],["ClosureTyper",""],["HasProjectionTypes",""],["ReferencesError",""],["RegionEscape",""],["ToPolyTraitRef",""]],"struct":[["AssociatedType",""],["AutoDerefRef",""],["BareFnTy",""],["Binder","Binder is a binder for higher-ranked lifetimes. It is part of the compiler's representation for things like `for<'a> Fn(&'a int)` (which would be represented by the type `PolyTraitRef == Binder<TraitRef>`). Note that when we skolemize, instantiate, erase, or otherwise \"discharge\" these bound regions, we change the type from `Binder<T>` to just `T` (see e.g. `liberate_late_bound_regions`)."],["ClosureTy",""],["ClosureUpvar",""],["CommonTypes",""],["CrateAnalysis","The complete set of all analyses described in this module. This is produced by the driver and fed to trans and later passes."],["CtxtArenas","Internal storage"],["DebruijnIndex","A [De Bruijn index][dbi] is a standard means of representing regions (and perhaps later types) in a higher-ranked setting. In particular, imagine a type like this:"],["EquatePredicate",""],["ExistentialBounds","Bounds suitable for an existentially quantified type parameter such as those that appear in object types or closure types. The major difference between this case and `ParamBounds` is that general purpose trait bounds are omitted and there must be *exactly one* region."],["FloatVid",""],["FnSig","Signature of a function type, which I have arbitrarily decided to use to refer to the input/output types."],["FreeRegion","A \"free\" region `fr` can be interpreted as \"some region at least as big as the scope `fr.scope`\"."],["Freevar","A free variable referred to in a function."],["GenericPredicates","Bounds on generics."],["Generics","Information about the formal type/lifetime parameters associated with an item or method. Analogous to ast::Generics."],["InstantiatedPredicates","Represents the bounds declared on a particular set of type parameters.  Should eventually be generalized into a flag list of where clauses.  You can obtain a `InstantiatedPredicates` list from a `GenericPredicates` by using the `instantiate` method. Note that this method reflects an important semantic invariant of `InstantiatedPredicates`: while the `GenericPredicates` are expressed in terms of the bound type parameters of the impl/trait/whatever, an `InstantiatedPredicates` instance represented a set of bounds for some particular instantiation, meaning that the generic parameters have been substituted with their values."],["IntVid",""],["InternedTy","An entry in the type interner."],["ItemSubsts","Records the substitutions used to translate the polytype for an item into the monotype of an item reference."],["ItemVariances",""],["Method",""],["MethodCall","With method calls, we store some extra information in side tables (i.e method_map). We use MethodCall as a key to index into these tables instead of just directly using the expression's NodeId. The reason for this being that we may apply adjustments (coercions) with the resulting expression also needing to use the side tables. The problem with this is that we don't assign a separate NodeId to this new expression and so it would clash with the base expression if both needed to add to the side tables. Thus to disambiguate we also keep track of whether there's an adjustment in our key."],["MethodCallee",""],["MethodObject",""],["MethodParam",""],["OutlivesPredicate",""],["ParamBounds","Bounds suitable for a named type parameter like `A` in `fn foo<A>` as well as the existential type parameter in an object type."],["ParamTy",""],["ParameterEnvironment","When type checking, we use the `ParameterEnvironment` to track details about the type/lifetime parameters that are in scope. It primarily stores the bounds information."],["ProjectionPredicate","This kind of predicate has no *direct* correspondent in the syntax, but it roughly corresponds to the syntactic forms:"],["ProjectionTy","Represents the projection of an associated type. In explicit UFCS form this would be written `<T as Trait<..>>::N`."],["RegionParameterDef",""],["RegionVid",""],["TraitDef","As `TypeScheme` but for a trait ref."],["TraitPredicate",""],["TraitRef","A complete reference to a trait. These take numerous guises in syntax, but perhaps the most recognizable form is in a where clause:"],["TransmuteRestriction","A restriction that certain types must be the same size. The use of `transmute` gives rise to these restrictions. These generally cannot be checked until trans; therefore, each call to `transmute` will push one or more such restriction into the `transmute_restrictions` vector during `intrinsicck`. They are then checked during `trans` by the fn `check_intrinsics`."],["TyS",""],["TyTrait",""],["TyVid",""],["TypeContents","Type contents is how the type checker reasons about kinds. They track what kinds of things are found within a type.  You can think of them as kind of an \"anti-kind\".  They track the kinds of values and thinks that are contained in types.  Having a larger contents for a type tends to rule that type *out* from various kinds.  For example, a type that contains a reference is not sendable."],["TypeFlags",""],["TypeParameterDef",""],["TypeScheme","A \"type scheme\", in ML terminology, is a type combined with some set of generic types that the type is, well, generic over. In Rust terms, it is the \"type\" of a fn item or struct -- this type will include various generic parameters that must be substituted when the item/struct is referenced. That is called converting the type scheme to a monotype."],["UpvarBorrow",""],["UpvarId","Upvars do not get their own node-id. Instead, we use the pair of the original var id (that is, the root variable that is referenced by the upvar) and the id of the closure expression."],["VariantInfo",""],["creader_cache_key",""],["ctxt","The data structure to keep track of all the information that typechecker generates so that so that it can be reused and doesn't have to be redone later on."],["expected_found",""],["field",""],["field_ty",""],["mt",""],["param_index",""]],"fn":[["accumulate_lifetimes_in_type","Pushes all the lifetimes in the given type onto the given list. A \"lifetime in a type\" is a lifetime specified by a reference or a lifetime in a list of type substitutions. This does *not* traverse into nominal types, nor does it resolve fictitious types."],["adjust_is_object",""],["adjust_ty","See `expr_ty_adjusted`"],["adjust_ty_for_autoref",""],["adjusted_object_region",""],["all_builtin_bounds",""],["anonymize_late_bound_regions","Rewrite any late-bound regions so that they are anonymous.  Region numbers are assigned starting at 1 and increasing monotonically in the order traversed by the fold operation."],["array_element_ty",""],["associated_type_parameter_index","Returns the parameter index that the given associated type corresponds to."],["binds_late_bound_regions",""],["can_type_implement_copy",""],["closure_upvars",""],["construct_free_substs","Constructs and returns a substitution that can be applied to move from the \"outer\" view of a type or method to the \"inner\" view. In general, this means converting from bound parameters to free parameters. Since we currently represent bound/free type parameters in the same way, this only has an effect on regions."],["construct_parameter_environment","See `ParameterEnvironment` struct def'n for details"],["count_late_bound_regions",""],["deref",""],["each_bound_trait_and_supertraits",""],["empty_builtin_bounds",""],["empty_parameter_environment","Construct a parameter environment suitable for static contexts or other contexts where there are no free type/lifetime parameters in scope."],["enum_is_univariant",""],["enum_variant_with_id",""],["enum_variants",""],["erase_late_bound_regions","Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also method lookup and a few other places where precise region relationships are not required."],["eval_repeat_count",""],["expr_is_lval",""],["expr_kind",""],["expr_span",""],["expr_ty",""],["expr_ty_adjusted","Returns the type of `expr`, considering any `AutoAdjustment` entry recorded for that expression."],["expr_ty_opt",""],["field_idx_strict",""],["fn_is_variadic",""],["fold_ty",""],["free_region_from_def",""],["get_attrs","Get the attributes of a definition."],["get_tydesc_ty",""],["has_attr","Determine whether an item is annotated with an attribute"],["has_dtor",""],["hash_crate_independent","Creates a hash of the type `Ty` which will be the same no matter what crate context it's calculated within. This is used by the `type_id` intrinsic."],["impl_id_to_trait_ref",""],["impl_of_method","If the given def ID describes a method belonging to an impl, return the ID of the impl that the method belongs to. Otherwise, return `None`."],["impl_or_trait_item",""],["impl_or_trait_item_idx",""],["impl_trait_ref",""],["index",""],["is_associated_type","Returns true if the given ID refers to an associated type and false if it refers to anything else."],["is_binopable",""],["is_ffi_safe",""],["is_fn_ty",""],["is_instantiable",""],["is_tuple_struct",""],["is_type_representable","Check whether a type is representable. This means it cannot contain unboxed structural recursion. This check is needed for structs and enums."],["item_path_str",""],["item_variances",""],["liberate_late_bound_regions","Replace any late-bound regions bound in `value` with free variants attached to scope-id `scope_id`."],["local_var_name_str",""],["lookup_field_type",""],["lookup_item_type",""],["lookup_packed","Determine whether an item is annotated with `#[repr(packed)]`"],["lookup_predicates","Given the did of an item, returns its full set of predicates."],["lookup_repr_hints","Obtain the representation annotation for a struct definition."],["lookup_simd","Determine whether an item is annotated with `#[simd]`"],["lookup_struct_fields",""],["lookup_super_predicates","Given the did of a trait, returns its superpredicates."],["lookup_trait_def","Given the did of a trait, returns its canonical trait ref."],["make_substs_for_receiver_types","Substitutes the values for the receiver's type parameters that are found in method, leaving the method's type parameters intact."],["maybe_walk_ty","Walks `ty` and any types appearing within `ty`, invoking the callback `f` on each type. If the callback returns false, then the children of the current type are ignored."],["mk_bare_fn",""],["mk_closure",""],["mk_ctor_fn",""],["mk_ctxt",""],["mk_enum",""],["mk_float_var",""],["mk_imm_ptr",""],["mk_imm_rptr",""],["mk_infer",""],["mk_int_var",""],["mk_mach_float",""],["mk_mach_int",""],["mk_mach_uint",""],["mk_mut_ptr",""],["mk_mut_rptr",""],["mk_nil",""],["mk_nil_ptr",""],["mk_param",""],["mk_param_from_def",""],["mk_projection",""],["mk_ptr",""],["mk_rptr",""],["mk_self_type",""],["mk_slice",""],["mk_str",""],["mk_str_slice",""],["mk_struct",""],["mk_t",""],["mk_trait",""],["mk_tup",""],["mk_uniq",""],["mk_var",""],["mk_vec",""],["named_element_ty","Returns the type of element at field `n` in struct or struct-like type `t`. For an enum `t`, `variant` must be some def id."],["no_late_bound_regions",""],["node_id_item_substs",""],["node_id_to_type",""],["node_id_to_type_opt",""],["note_and_explain_type_err",""],["pat_ty",""],["pat_ty_opt",""],["populate_implementations_for_trait_if_necessary","Populates the type context with all the implementations for the given trait if necessary."],["populate_implementations_for_type_if_necessary","Populates the type context with all the implementations for the given type if necessary."],["positional_element_ty","Returns the type of element at index `i` in tuple or tuple-like type `t`. For an enum `t`, `variant` is None only if `t` is a univariant enum."],["predicates",""],["provided_source",""],["provided_trait_methods",""],["record_trait_has_default_impl","Records a trait-to-implementation mapping."],["record_trait_implementation","Records a trait-to-implementation mapping."],["region_existential_bound","An existential bound that does not implement any traits."],["replace_late_bound_regions","Replaces the late-bound-regions in `value` that are bound by `value`."],["required_region_bounds","Given a set of predicates that apply to an object type, returns the region bounds that the (erased) `Self` type must outlive. Precisely *because* the `Self` type is erased, the parameter `erased_self_ty` must be supplied to indicate what type has been used to represent `Self` in the predicates themselves. This should really be a unique type; `FreshTy(0)` is a popular choice."],["resolve_expr",""],["sequence_element_type",""],["simd_size",""],["simd_type",""],["sort_bounds_list",""],["stmt_node_id",""],["struct_fields",""],["substd_enum_variants",""],["trait_has_default_impl",""],["trait_id_of_impl","Given the def_id of an impl, return the def_id of the trait it implements. If it implements no trait, return `None`."],["trait_impl_polarity",""],["trait_item",""],["trait_item_def_ids",""],["trait_item_of_item","If the given def ID describes an item belonging to a trait, (either a default method or an implementation of a trait method), return the ID of the method inside trait definition (this means that if the given def ID is already that of the original trait method, then the return value is the same). Otherwise, return `None`."],["trait_items",""],["trait_of_item","If the given def ID describes an item belonging to a trait (either a default method or an implementation of a trait method), return the ID of the trait that the method belongs to. Otherwise, return `None`."],["trait_ref_contains_error",""],["trait_ref_to_def_id",""],["try_add_builtin_trait","Checks whether `trait_ref` refers to one of the builtin traits, like `Send`, and adds the corresponding bound to the set `builtin_bounds` if so. Returns true if `trait_ref` is a builtin trait."],["tup_fields",""],["ty_dtor",""],["ty_fn_abi","Returns the ABI of the given function."],["ty_fn_args",""],["ty_fn_ret",""],["ty_fn_sig",""],["ty_region",""],["ty_sort_string",""],["ty_to_def_id",""],["type_content",""],["type_contents",""],["type_err_to_str","Explains the source of a type err in a short, human readable way. This is meant to be placed in parentheses after some larger message. You should also invoke `note_and_explain_type_err()` afterwards to present additional details, particularly when it comes to lifetime-related errors."],["type_escapes_depth",""],["type_has_escaping_regions","An \"escaping region\" is a bound region whose binder is not part of `t`."],["type_has_late_bound_regions",""],["type_has_params",""],["type_has_projection",""],["type_has_self",""],["type_has_ty_infer",""],["type_interior_is_unsafe",""],["type_is_bare_fn",""],["type_is_bare_fn_item",""],["type_is_bool",""],["type_is_c_like_enum",""],["type_is_char",""],["type_is_empty",""],["type_is_error",""],["type_is_floating_point","Returns true if this type is a floating point type and false otherwise."],["type_is_fp",""],["type_is_fresh",""],["type_is_integral",""],["type_is_machine",""],["type_is_nil",""],["type_is_numeric",""],["type_is_region_ptr",""],["type_is_scalar",""],["type_is_self",""],["type_is_signed",""],["type_is_simd",""],["type_is_sized",""],["type_is_structural",""],["type_is_trait",""],["type_is_ty_var",""],["type_is_uint",""],["type_is_unique",""],["type_is_unsafe_ptr",""],["type_is_vec",""],["type_moves_by_default",""],["type_needs_infer",""],["type_needs_subst",""],["type_of_adjust",""],["type_trait_info",""],["unsize_ty",""],["walk_ty",""],["with_freevars",""],["with_path",""]]});