initSidebarItems({"constant":[["MAX_REFCOUNT","A soft limit on the amount of references that may be made to an `Arc`."],["STATIC_REFCOUNT","Special refcount value that means the data is not reference counted, and that the `Arc` is really acting as a read-only static reference."]],"enum":[["ArcUnionBorrow","This represents a borrow of an `ArcUnion`."]],"fn":[["data_offset","Computes the offset of the data field within ArcInner."],["divide_rounding_up",""],["thin_to_thick",""]],"struct":[["Arc","An atomically reference counted shared pointer"],["ArcBorrow","A “borrowed `Arc`”. This is a pointer to a T that is known to have been allocated within an `Arc`."],["ArcInner","The object allocated by an Arc"],["ArcUnion","A tagged union that can represent `Arc<A>` or `Arc<B>` while only consuming a single word. The type is also `NonNull`, and thus can be stored in an Option without increasing size."],["HeaderSlice","Structure to allow Arc-managing some fixed-sized data and a variably-sized slice in a single allocation."],["HeaderWithLength","Header data with an inline length. Consumers that use HeaderWithLength as the Header type in HeaderSlice can take advantage of ThinArc."],["RawOffsetArc","An `Arc`, except it holds a pointer to the T instead of to the entire ArcInner. This struct is FFI-compatible."],["ThinArc","A “thin” `Arc` containing dynamically sized data"],["UniqueArc","An `Arc` that is known to be uniquely owned"]],"type":[["HeaderSliceWithLength",""]]});