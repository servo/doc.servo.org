<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Re-compute the starting state that a DFA should be in after finding a prefilter candidate match at the position `at`."><title>prefilter_restart in regex_automata::hybrid::search - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_automata</a><span class="version">0.4.8</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In regex_automata::hybrid::search</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">hybrid</a>::<wbr><a href="index.html">search</a>::<wbr><a class="fn" href="#">prefilter_restart</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/regex_automata/hybrid/search.rs.html#787-796">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>fn prefilter_restart(
    dfa: &amp;<a class="struct" href="../dfa/struct.DFA.html" title="struct regex_automata::hybrid::dfa::DFA">DFA</a>,
    cache: &amp;mut <a class="struct" href="../dfa/struct.Cache.html" title="struct regex_automata::hybrid::dfa::Cache">Cache</a>,
    input: &amp;<a class="struct" href="../../util/search/struct.Input.html" title="struct regex_automata::util::search::Input">Input</a>&lt;'_&gt;,
    at: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>, <a class="struct" href="../../util/search/struct.MatchError.html" title="struct regex_automata::util::search::MatchError">MatchError</a>&gt;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Re-compute the starting state that a DFA should be in after finding a
prefilter candidate match at the position <code>at</code>.</p>
<p>It is always correct to call this, but not always necessary. Namely,
whenever the DFA has a universal start state, the DFA can remain in the
start state that it was in when it ran the prefilter. Why? Because in that
case, there is only one start state.</p>
<p>When does a DFA have a universal start state? In precisely cases where
it has no look-around assertions in its prefix. So for example, <code>\bfoo</code>
does not have a universal start state because the start state depends on
whether the byte immediately before the start position is a word byte or
not. However, <code>foo\b</code> does have a universal start state because the word
boundary does not appear in the pattern’s prefix.</p>
<p>So… most cases don’t need this, but when a pattern doesn’t have a
universal start state, then after a prefilter candidate has been found, the
current state <em>must</em> be re-litigated as if computing the start state at the
beginning of the search because it might change. That is, not all start
states are created equal.</p>
<p>Why avoid it? Because while it’s not super expensive, it isn’t a trivial
operation to compute the start state. It is much better to avoid it and
just state in the current state if you know it to be correct.</p>
</div></details></section></div></main></body></html>