<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A type that groups methods that require the base NFA/DFA and writable access to the cache."><title>Lazy in regex_automata::hybrid::dfa - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_automata</a><span class="version">0.4.8</span></h2></div><h2 class="location"><a href="#">Lazy</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.cache">cache</a></li><li><a href="#structfield.dfa">dfa</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add_builder_state">add_builder_state</a></li><li><a href="#method.add_state">add_state</a></li><li><a href="#method.as_ref">as_ref</a></li><li><a href="#method.cache_next_state">cache_next_state</a></li><li><a href="#method.cache_start_group">cache_start_group</a></li><li><a href="#method.cache_start_one">cache_start_one</a></li><li><a href="#method.clear_cache">clear_cache</a></li><li><a href="#method.get_state_builder">get_state_builder</a></li><li><a href="#method.init_cache">init_cache</a></li><li><a href="#method.new">new</a></li><li><a href="#method.next_state_id">next_state_id</a></li><li><a href="#method.put_state_builder">put_state_builder</a></li><li><a href="#method.reset_cache">reset_cache</a></li><li><a href="#method.save_state">save_state</a></li><li><a href="#method.saved_state_id">saved_state_id</a></li><li><a href="#method.set_all_transitions">set_all_transitions</a></li><li><a href="#method.set_start_state">set_start_state</a></li><li><a href="#method.set_transition">set_transition</a></li><li><a href="#method.try_clear_cache">try_clear_cache</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-Lazy%3C'i,+'c%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-UnwindSafe-for-Lazy%3C'i,+'c%3E">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-Lazy%3C'i,+'c%3E">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Lazy%3C'i,+'c%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Lazy%3C'i,+'c%3E">Send</a></li><li><a href="#impl-Sync-for-Lazy%3C'i,+'c%3E">Sync</a></li><li><a href="#impl-Unpin-for-Lazy%3C'i,+'c%3E">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::hybrid::dfa</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">hybrid</a>::<wbr><a href="index.html">dfa</a>::<wbr><a class="struct" href="#">Lazy</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/regex_automata/hybrid/dfa.rs.html#2081-2084">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>struct Lazy&lt;'i, 'c&gt; {
    dfa: &amp;'i <a class="struct" href="struct.DFA.html" title="struct regex_automata::hybrid::dfa::DFA">DFA</a>,
    cache: &amp;'c mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::hybrid::dfa::Cache">Cache</a>,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A type that groups methods that require the base NFA/DFA and writable
access to the cache.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.dfa" class="structfield section-header"><a href="#structfield.dfa" class="anchor field">§</a><code>dfa: &amp;'i <a class="struct" href="struct.DFA.html" title="struct regex_automata::hybrid::dfa::DFA">DFA</a></code></span><span id="structfield.cache" class="structfield section-header"><a href="#structfield.cache" class="anchor field">§</a><code>cache: &amp;'c mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::hybrid::dfa::Cache">Cache</a></code></span><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Lazy%3C'i,+'c%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2086-2660">source</a><a href="#impl-Lazy%3C'i,+'c%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'i, 'c&gt; <a class="struct" href="struct.Lazy.html" title="struct regex_automata::hybrid::dfa::Lazy">Lazy</a>&lt;'i, 'c&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2088-2090">source</a><h4 class="code-header">fn <a href="#method.new" class="fn">new</a>(dfa: &amp;'i <a class="struct" href="struct.DFA.html" title="struct regex_automata::hybrid::dfa::DFA">DFA</a>, cache: &amp;'c mut <a class="struct" href="struct.Cache.html" title="struct regex_automata::hybrid::dfa::Cache">Cache</a>) -&gt; <a class="struct" href="struct.Lazy.html" title="struct regex_automata::hybrid::dfa::Lazy">Lazy</a>&lt;'i, 'c&gt;</h4></section></summary><div class="docblock"><p>Creates a new ‘Lazy’ wrapper for a DFA and its corresponding cache.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2094-2096">source</a><h4 class="code-header">fn <a href="#method.as_ref" class="fn">as_ref</a>&lt;'a&gt;(&amp;'a self) -&gt; <a class="struct" href="struct.LazyRef.html" title="struct regex_automata::hybrid::dfa::LazyRef">LazyRef</a>&lt;'i, 'a&gt;</h4></section></summary><div class="docblock"><p>Return an immutable view by downgrading a writable cache to a read-only
cache.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cache_next_state" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2119-2148">source</a><h4 class="code-header">fn <a href="#method.cache_next_state" class="fn">cache_next_state</a>(
    &amp;mut self,
    current: <a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>,
    unit: <a class="struct" href="../../util/alphabet/struct.Unit.html" title="struct regex_automata::util::alphabet::Unit">Unit</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>, <a class="struct" href="../error/struct.CacheError.html" title="struct regex_automata::hybrid::error::CacheError">CacheError</a>&gt;</h4></section></summary><div class="docblock"><p>This is marked as ‘inline(never)’ to avoid bloating methods on ‘DFA’
like ‘next_state’ and ‘next_eoi_state’ that are called in critical
areas. The idea is to let the optimizer focus on the other areas of
those methods as the hot path.</p>
<p>Here’s an example that justifies ‘inline(never)’</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code>regex-cli find <span class="kw">match </span>hybrid \
  --cache-capacity <span class="number">100000000 </span>\
  -p <span class="string">'\pL{100}'
  </span>all-codepoints-utf8-<span class="number">100x</span></code></pre></div>
<p>Where ‘all-codepoints-utf8-100x’ is the UTF-8 encoding of every
codepoint, in sequence, repeated 100 times.</p>
<p>With ‘inline(never)’ hyperfine reports 1.1s per run. With
‘inline(always)’, hyperfine reports 1.23s. So that’s a 10% improvement.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cache_start_group" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2162-2186">source</a><h4 class="code-header">fn <a href="#method.cache_start_group" class="fn">cache_start_group</a>(
    &amp;mut self,
    anchored: <a class="enum" href="../../util/search/enum.Anchored.html" title="enum regex_automata::util::search::Anchored">Anchored</a>,
    start: <a class="enum" href="../../util/start/enum.Start.html" title="enum regex_automata::util::start::Start">Start</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>, <a class="enum" href="../error/enum.StartError.html" title="enum regex_automata::hybrid::error::StartError">StartError</a>&gt;</h4></section></summary><div class="docblock"><p>Compute and cache the starting state for the given pattern ID (if
present) and the starting configuration.</p>
<p>This panics if a pattern ID is given and the DFA isn’t configured to
build anchored start states for each pattern.</p>
<p>This will never return an unknown lazy state ID.</p>
<p>If caching this state would otherwise result in a cache that has been
cleared too many times, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cache_start_one" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2199-2232">source</a><h4 class="code-header">fn <a href="#method.cache_start_one" class="fn">cache_start_one</a>(
    &amp;mut self,
    nfa_start_id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">NFAStateID</a>,
    start: <a class="enum" href="../../util/start/enum.Start.html" title="enum regex_automata::util::start::Start">Start</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>, <a class="struct" href="../error/struct.CacheError.html" title="struct regex_automata::hybrid::error::CacheError">CacheError</a>&gt;</h4></section></summary><div class="docblock"><p>Compute and cache the starting state for the given NFA state ID and the
starting configuration. The NFA state ID might be one of the following:</p>
<ol>
<li>An unanchored start state to match any pattern.</li>
<li>An anchored start state to match any pattern.</li>
<li>An anchored start state for a particular pattern.</li>
</ol>
<p>This will never return an unknown lazy state ID.</p>
<p>If caching this state would otherwise result in a cache that has been
cleared too many times, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_builder_state" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2245-2261">source</a><h4 class="code-header">fn <a href="#method.add_builder_state" class="fn">add_builder_state</a>(
    &amp;mut self,
    builder: <a class="struct" href="../../util/determinize/state/struct.StateBuilderNFA.html" title="struct regex_automata::util::determinize::state::StateBuilderNFA">StateBuilderNFA</a>,
    idmap: impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>) -&gt; <a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>, <a class="struct" href="../error/struct.CacheError.html" title="struct regex_automata::hybrid::error::CacheError">CacheError</a>&gt;</h4></section></summary><div class="docblock"><p>Either add the given builder state to this cache, or return an ID to an
equivalent state already in this cache.</p>
<p>In the case where no equivalent state exists, the idmap function given
may be used to transform the identifier allocated. This is useful if
the caller needs to tag the ID with additional information.</p>
<p>This will never return an unknown lazy state ID.</p>
<p>If caching this state would otherwise result in a cache that has been
cleared too many times, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_state" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2273-2311">source</a><h4 class="code-header">fn <a href="#method.add_state" class="fn">add_state</a>(
    &amp;mut self,
    state: <a class="struct" href="../../util/determinize/state/struct.State.html" title="struct regex_automata::util::determinize::state::State">State</a>,
    idmap: impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>) -&gt; <a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>, <a class="struct" href="../error/struct.CacheError.html" title="struct regex_automata::hybrid::error::CacheError">CacheError</a>&gt;</h4></section></summary><div class="docblock"><p>Allocate a new state ID and add the given state to this cache.</p>
<p>The idmap function given may be used to transform the identifier
allocated. This is useful if the caller needs to tag the ID with
additional information.</p>
<p>This will never return an unknown lazy state ID.</p>
<p>If caching this state would otherwise result in a cache that has been
cleared too many times, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_state_id" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2319-2330">source</a><h4 class="code-header">fn <a href="#method.next_state_id" class="fn">next_state_id</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>, <a class="struct" href="../error/struct.CacheError.html" title="struct regex_automata::hybrid::error::CacheError">CacheError</a>&gt;</h4></section></summary><div class="docblock"><p>Allocate a new state ID.</p>
<p>This will never return an unknown lazy state ID.</p>
<p>If caching this state would otherwise result in a cache that has been
cleared too many times, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_clear_cache" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2348-2415">source</a><h4 class="code-header">fn <a href="#method.try_clear_cache" class="fn">try_clear_cache</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../error/struct.CacheError.html" title="struct regex_automata::hybrid::error::CacheError">CacheError</a>&gt;</h4></section></summary><div class="docblock"><p>Attempt to clear the cache used by this lazy DFA.</p>
<p>If clearing the cache exceeds the minimum number of required cache
clearings, then this will return a cache error. In this case,
callers should bubble this up as the cache can’t be used until it is
reset. Implementations of search should convert this error into a
<a href="../../util/search/struct.MatchError.html#method.gave_up" title="associated function regex_automata::util::search::MatchError::gave_up"><code>MatchError::gave_up</code></a>.</p>
<p>If ‘self.state_saver’ is set to save a state, then this state is
persisted through cache clearing. Otherwise, the cache is returned to
its state after initialization with two exceptions: its clear count
is incremented and some of its memory likely has additional capacity.
That is, clearing a cache does <em>not</em> release memory.</p>
<p>Otherwise, any lazy state ID generated by the cache prior to resetting
it is invalid after the reset.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reset_cache" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2424-2433">source</a><h4 class="code-header">fn <a href="#method.reset_cache" class="fn">reset_cache</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Clears <em>and</em> resets the cache. Resetting the cache means that no
states are persisted and the clear count is reset to 0. No heap memory
is released.</p>
<p>Note that the caller may reset a cache with a different DFA than what
it was created from. In which case, the cache can now be used with the
new DFA (and not the old DFA).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear_cache" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2445-2495">source</a><h4 class="code-header">fn <a href="#method.clear_cache" class="fn">clear_cache</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Clear the cache used by this lazy DFA.</p>
<p>If ‘self.state_saver’ is set to save a state, then this state is
persisted through cache clearing. Otherwise, the cache is returned to
its state after initialization with two exceptions: its clear count
is incremented and some of its memory likely has additional capacity.
That is, clearing a cache does <em>not</em> release memory.</p>
<p>Otherwise, any lazy state ID generated by the cache prior to resetting
it is invalid after the reset.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.init_cache" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2505-2559">source</a><h4 class="code-header">fn <a href="#method.init_cache" class="fn">init_cache</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Initialize this cache from emptiness to a place where it can be used
for search.</p>
<p>This is called both at cache creation time and after the cache has been
cleared.</p>
<p>Primarily, this adds the three sentinel states and allocates some
initial memory.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.save_state" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2566-2569">source</a><h4 class="code-header">fn <a href="#method.save_state" class="fn">save_state</a>(&amp;mut self, id: <a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>)</h4></section></summary><div class="docblock"><p>Save the state corresponding to the ID given such that the state
persists through a cache clearing.</p>
<p>While the state may persist, the ID may not. In order to discover the
new state ID, one must call ‘saved_state_id’ after a cache clearing.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.saved_state_id" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2576-2581">source</a><h4 class="code-header">fn <a href="#method.saved_state_id" class="fn">saved_state_id</a>(&amp;mut self) -&gt; <a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a></h4></section></summary><div class="docblock"><p>Returns the updated lazy state ID for a state that was persisted
through a cache clearing.</p>
<p>It is only correct to call this routine when both a state has been
saved and the cache has just been cleared. Otherwise, this panics.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_all_transitions" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2584-2588">source</a><h4 class="code-header">fn <a href="#method.set_all_transitions" class="fn">set_all_transitions</a>(&amp;mut self, from: <a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>, to: <a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>)</h4></section></summary><div class="docblock"><p>Set all transitions on the state ‘from’ to ‘to’.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_transition" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2595-2606">source</a><h4 class="code-header">fn <a href="#method.set_transition" class="fn">set_transition</a>(&amp;mut self, from: <a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>, unit: <a class="struct" href="../../util/alphabet/struct.Unit.html" title="struct regex_automata::util::alphabet::Unit">Unit</a>, to: <a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>)</h4></section></summary><div class="docblock"><p>Set the transition on ‘from’ for ‘unit’ to ‘to’.</p>
<p>This panics if either ‘from’ or ‘to’ is invalid.</p>
<p>All unit values are OK.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.set_start_state" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2613-2635">source</a><h4 class="code-header">fn <a href="#method.set_start_state" class="fn">set_start_state</a>(&amp;mut self, anchored: <a class="enum" href="../../util/search/enum.Anchored.html" title="enum regex_automata::util::search::Anchored">Anchored</a>, start: <a class="enum" href="../../util/start/enum.Start.html" title="enum regex_automata::util::start::Start">Start</a>, id: <a class="struct" href="../id/struct.LazyStateID.html" title="struct regex_automata::hybrid::id::LazyStateID">LazyStateID</a>)</h4></section></summary><div class="docblock"><p>Set the start ID for the given pattern ID (if given) and starting
configuration to the ID given.</p>
<p>This panics if ‘id’ is not valid or if a pattern ID is given and
‘starts_for_each_pattern’ is not enabled.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_state_builder" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2643-2648">source</a><h4 class="code-header">fn <a href="#method.get_state_builder" class="fn">get_state_builder</a>(&amp;mut self) -&gt; <a class="struct" href="../../util/determinize/state/struct.StateBuilderEmpty.html" title="struct regex_automata::util::determinize::state::StateBuilderEmpty">StateBuilderEmpty</a></h4></section></summary><div class="docblock"><p>Returns a state builder from this DFA that might have existing
capacity. This helps avoid allocs in cases where a state is built that
turns out to already be cached.</p>
<p>Callers must put the state builder back with ‘put_state_builder’,
otherwise the allocation reuse won’t work.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.put_state_builder" class="method"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2654-2659">source</a><h4 class="code-header">fn <a href="#method.put_state_builder" class="fn">put_state_builder</a>(&amp;mut self, builder: <a class="struct" href="../../util/determinize/state/struct.StateBuilderNFA.html" title="struct regex_automata::util::determinize::state::StateBuilderNFA">StateBuilderNFA</a>)</h4></section></summary><div class="docblock"><p>Puts the given state builder back into this DFA for reuse.</p>
<p>Note that building a ‘State’ from a builder always creates a new alloc,
so callers should always put the builder back.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Lazy%3C'i,+'c%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2080">source</a><a href="#impl-Debug-for-Lazy%3C'i,+'c%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'i, 'c&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Lazy.html" title="struct regex_automata::hybrid::dfa::Lazy">Lazy</a>&lt;'i, 'c&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/hybrid/dfa.rs.html#2080">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Lazy%3C'i,+'c%3E" class="impl"><a href="#impl-Freeze-for-Lazy%3C'i,+'c%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'i, 'c&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Lazy.html" title="struct regex_automata::hybrid::dfa::Lazy">Lazy</a>&lt;'i, 'c&gt;</h3></section><section id="impl-RefUnwindSafe-for-Lazy%3C'i,+'c%3E" class="impl"><a href="#impl-RefUnwindSafe-for-Lazy%3C'i,+'c%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'i, 'c&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Lazy.html" title="struct regex_automata::hybrid::dfa::Lazy">Lazy</a>&lt;'i, 'c&gt;</h3></section><section id="impl-Send-for-Lazy%3C'i,+'c%3E" class="impl"><a href="#impl-Send-for-Lazy%3C'i,+'c%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'i, 'c&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Lazy.html" title="struct regex_automata::hybrid::dfa::Lazy">Lazy</a>&lt;'i, 'c&gt;</h3></section><section id="impl-Sync-for-Lazy%3C'i,+'c%3E" class="impl"><a href="#impl-Sync-for-Lazy%3C'i,+'c%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'i, 'c&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Lazy.html" title="struct regex_automata::hybrid::dfa::Lazy">Lazy</a>&lt;'i, 'c&gt;</h3></section><section id="impl-Unpin-for-Lazy%3C'i,+'c%3E" class="impl"><a href="#impl-Unpin-for-Lazy%3C'i,+'c%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'i, 'c&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Lazy.html" title="struct regex_automata::hybrid::dfa::Lazy">Lazy</a>&lt;'i, 'c&gt;</h3></section><section id="impl-UnwindSafe-for-Lazy%3C'i,+'c%3E" class="impl"><a href="#impl-UnwindSafe-for-Lazy%3C'i,+'c%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'i, 'c&gt; !<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Lazy.html" title="struct regex_automata::hybrid::dfa::Lazy">Lazy</a>&lt;'i, 'c&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>