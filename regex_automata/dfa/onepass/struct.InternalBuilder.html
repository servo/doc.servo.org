<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An internal builder for encapsulating the state necessary to build a one-pass DFA. Typical use is just `InternalBuilder::new(..).build()`."><title>InternalBuilder in regex_automata::dfa::onepass - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_automata</a><span class="version">0.4.8</span></h2></div><h2 class="location"><a href="#">InternalBuilder</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.classes">classes</a></li><li><a href="#structfield.config">config</a></li><li><a href="#structfield.dfa">dfa</a></li><li><a href="#structfield.matched">matched</a></li><li><a href="#structfield.nfa">nfa</a></li><li><a href="#structfield.nfa_to_dfa_id">nfa_to_dfa_id</a></li><li><a href="#structfield.seen">seen</a></li><li><a href="#structfield.stack">stack</a></li><li><a href="#structfield.uncompiled_nfa_ids">uncompiled_nfa_ids</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add_dfa_state_for_nfa_state">add_dfa_state_for_nfa_state</a></li><li><a href="#method.add_empty_state">add_empty_state</a></li><li><a href="#method.add_start_state">add_start_state</a></li><li><a href="#method.build">build</a></li><li><a href="#method.compile_transition">compile_transition</a></li><li><a href="#method.new">new</a></li><li><a href="#method.shuffle_states">shuffle_states</a></li><li><a href="#method.stack_push">stack_push</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-InternalBuilder%3C'a%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-InternalBuilder%3C'a%3E">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-InternalBuilder%3C'a%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-InternalBuilder%3C'a%3E">Send</a></li><li><a href="#impl-Sync-for-InternalBuilder%3C'a%3E">Sync</a></li><li><a href="#impl-Unpin-for-InternalBuilder%3C'a%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-InternalBuilder%3C'a%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::dfa::onepass</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">dfa</a>::<wbr><a href="index.html">onepass</a>::<wbr><a class="struct" href="#">InternalBuilder</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/regex_automata/dfa/onepass.rs.html#475-520">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>struct InternalBuilder&lt;'a&gt; {
    dfa: <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::onepass::DFA">DFA</a>,
    uncompiled_nfa_ids: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;,
    nfa_to_dfa_id: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;,
    stack: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;(<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.Epsilons.html" title="struct regex_automata::dfa::onepass::Epsilons">Epsilons</a>)&gt;,
    seen: <a class="struct" href="../../util/sparse_set/struct.SparseSet.html" title="struct regex_automata::util::sparse_set::SparseSet">SparseSet</a>,
    matched: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>,
    config: <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::onepass::Config">Config</a>,
    nfa: &amp;'a <a class="struct" href="../../nfa/thompson/nfa/struct.NFA.html" title="struct regex_automata::nfa::thompson::nfa::NFA">NFA</a>,
    classes: <a class="struct" href="../../util/alphabet/struct.ByteClasses.html" title="struct regex_automata::util::alphabet::ByteClasses">ByteClasses</a>,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An internal builder for encapsulating the state necessary to build a
one-pass DFA. Typical use is just <code>InternalBuilder::new(..).build()</code>.</p>
<p>There is no separate pass for determining whether the NFA is one-pass or
not. We just try to build the DFA. If during construction we discover that
it is not one-pass, we bail out. This is likely to lead to some undesirable
expense in some cases, so it might make sense to try an identify common
patterns in the NFA that make it definitively not one-pass. That way, we
can avoid ever trying to build a one-pass DFA in the first place. For
example, ‘\w*\s’ is not one-pass, and since ‘\w’ is Unicode-aware by
default, it’s probably not a trivial cost to try and build a one-pass DFA
for it and then fail.</p>
<p>Note that some (immutable) fields are duplicated here. For example, the
‘nfa’ and ‘classes’ fields are both in the ‘DFA’. They are the same thing,
but we duplicate them because it makes composition easier below. Otherwise,
since the borrow checker can’t see through method calls, the mutable borrow
we use to mutate the DFA winds up preventing borrowing from any other part
of the DFA, even though we aren’t mutating those parts. We only do this
because the duplication is cheap.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.dfa" class="structfield section-header"><a href="#structfield.dfa" class="anchor field">§</a><code>dfa: <a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::onepass::DFA">DFA</a></code></span><div class="docblock"><p>The DFA we’re building.</p>
</div><span id="structfield.uncompiled_nfa_ids" class="structfield section-header"><a href="#structfield.uncompiled_nfa_ids" class="anchor field">§</a><code>uncompiled_nfa_ids: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;</code></span><div class="docblock"><p>An unordered collection of NFA state IDs that we haven’t yet tried to
build into a DFA state yet.</p>
<p>This collection does not ultimately wind up including every NFA state
ID. Instead, each ID represents a “start” state for a sub-graph of the
NFA. The set of NFA states we then use to build a DFA state consists
of that “start” state and all states reachable from it via epsilon
transitions.</p>
</div><span id="structfield.nfa_to_dfa_id" class="structfield section-header"><a href="#structfield.nfa_to_dfa_id" class="anchor field">§</a><code>nfa_to_dfa_id: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;</code></span><div class="docblock"><p>A map from NFA state ID to DFA state ID. This is useful for easily
determining whether an NFA state has been used as a “starting” point
to build a DFA state yet. If it hasn’t, then it is mapped to DEAD,
and since DEAD is specially added and never corresponds to any NFA
state, it follows that a mapping to DEAD implies the NFA state has
no corresponding DFA state yet.</p>
</div><span id="structfield.stack" class="structfield section-header"><a href="#structfield.stack" class="anchor field">§</a><code>stack: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;(<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.Epsilons.html" title="struct regex_automata::dfa::onepass::Epsilons">Epsilons</a>)&gt;</code></span><div class="docblock"><p>A stack used to traverse the NFA states that make up a single DFA
state. Traversal occurs until the stack is empty, and we only push to
the stack when the state ID isn’t in ‘seen’. Actually, even more than
that, if we try to push something on to this stack that is already in
‘seen’, then we bail out on construction completely, since it implies
that the NFA is not one-pass.</p>
</div><span id="structfield.seen" class="structfield section-header"><a href="#structfield.seen" class="anchor field">§</a><code>seen: <a class="struct" href="../../util/sparse_set/struct.SparseSet.html" title="struct regex_automata::util::sparse_set::SparseSet">SparseSet</a></code></span><div class="docblock"><p>The set of NFA states that we’ve visited via ‘stack’.</p>
</div><span id="structfield.matched" class="structfield section-header"><a href="#structfield.matched" class="anchor field">§</a><code>matched: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></code></span><div class="docblock"><p>Whether a match NFA state has been observed while constructing a
one-pass DFA state. Once a match state is seen, assuming we are using
leftmost-first match semantics, then we don’t add any more transitions
to the DFA state we’re building.</p>
</div><span id="structfield.config" class="structfield section-header"><a href="#structfield.config" class="anchor field">§</a><code>config: <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::onepass::Config">Config</a></code></span><div class="docblock"><p>The config passed to the builder.</p>
<p>This is duplicated in dfa.config.</p>
</div><span id="structfield.nfa" class="structfield section-header"><a href="#structfield.nfa" class="anchor field">§</a><code>nfa: &amp;'a <a class="struct" href="../../nfa/thompson/nfa/struct.NFA.html" title="struct regex_automata::nfa::thompson::nfa::NFA">NFA</a></code></span><div class="docblock"><p>The NFA we’re building a one-pass DFA from.</p>
<p>This is duplicated in dfa.nfa.</p>
</div><span id="structfield.classes" class="structfield section-header"><a href="#structfield.classes" class="anchor field">§</a><code>classes: <a class="struct" href="../../util/alphabet/struct.ByteClasses.html" title="struct regex_automata::util::alphabet::ByteClasses">ByteClasses</a></code></span><div class="docblock"><p>The equivalence classes that make up the alphabet for this DFA&gt;</p>
<p>This is duplicated in dfa.classes.</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-InternalBuilder%3C'a%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#522-922">source</a><a href="#impl-InternalBuilder%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="struct" href="struct.InternalBuilder.html" title="struct regex_automata::dfa::onepass::InternalBuilder">InternalBuilder</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#524-574">source</a><h4 class="code-header">fn <a href="#method.new" class="fn">new</a>(config: <a class="struct" href="struct.Config.html" title="struct regex_automata::dfa::onepass::Config">Config</a>, nfa: &amp;'a <a class="struct" href="../../nfa/thompson/nfa/struct.NFA.html" title="struct regex_automata::nfa::thompson::nfa::NFA">NFA</a>) -&gt; <a class="struct" href="struct.InternalBuilder.html" title="struct regex_automata::dfa::onepass::InternalBuilder">InternalBuilder</a>&lt;'a&gt;</h4></section></summary><div class="docblock"><p>Create a new builder with an initial empty DFA.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#581-726">source</a><h4 class="code-header">fn <a href="#method.build" class="fn">build</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DFA.html" title="struct regex_automata::dfa::onepass::DFA">DFA</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::dfa::onepass::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Build the DFA from the NFA given to this builder. If the NFA is not
one-pass, then return an error. An error may also be returned if a
particular limit is exceeded. (Some limits, like the total heap memory
used, are configurable. Others, like the total patterns or slots, are
hard-coded based on representational limitations.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shuffle_states" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#737-754">source</a><h4 class="code-header">fn <a href="#method.shuffle_states" class="fn">shuffle_states</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Shuffle all match states to the end of the transition table and set
‘min_match_id’ to the ID of the first such match state.</p>
<p>The point of this is to make it extremely cheap to determine whether
a state is a match state or not. We need to check on this on every
transition during a search, so it being cheap is important. This
permits us to check it by simply comparing two state identifiers, as
opposed to looking for the pattern ID in the state’s <code>PatternEpsilons</code>.
(Which requires a memory load and some light arithmetic.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compile_transition" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#767-796">source</a><h4 class="code-header">fn <a href="#method.compile_transition" class="fn">compile_transition</a>(
    &amp;mut self,
    dfa_id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    trans: &amp;<a class="struct" href="../../nfa/thompson/nfa/struct.Transition.html" title="struct regex_automata::nfa::thompson::nfa::Transition">Transition</a>,
    epsilons: <a class="struct" href="struct.Epsilons.html" title="struct regex_automata::dfa::onepass::Epsilons">Epsilons</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::dfa::onepass::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given NFA transition into the DFA state given.</p>
<p>‘Epsilons’ corresponds to any conditional epsilon transitions that need
to be satisfied to follow this transition, and any slots that need to
be saved if the transition is followed.</p>
<p>If this transition indicates that the NFA is not one-pass, then
this returns an error. (This occurs, for example, if the DFA state
already has a transition defined for the same input symbols as the
given transition, <em>and</em> the result of the old and new transitions is
different.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_start_state" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#809-824">source</a><h4 class="code-header">fn <a href="#method.add_start_state" class="fn">add_start_state</a>(
    &amp;mut self,
    pid: <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>&gt;,
    nfa_id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::dfa::onepass::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a start state to the DFA corresponding to the given NFA starting
state ID.</p>
<p>If adding a state would blow any limits (configured or hard-coded),
then an error is returned.</p>
<p>If the starting state is an anchored state for a particular pattern,
then callers must provide the pattern ID for that starting state.
Callers must also ensure that the first starting state added is the
start state for all patterns, and then each anchored starting state for
each pattern (if necessary) added in order. Otherwise, this panics.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_dfa_state_for_nfa_state" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#836-855">source</a><h4 class="code-header">fn <a href="#method.add_dfa_state_for_nfa_state" class="fn">add_dfa_state_for_nfa_state</a>(
    &amp;mut self,
    nfa_id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::dfa::onepass::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a new DFA state corresponding to the given NFA state. If adding a
state would blow any limits (configured or hard-coded), then an error
is returned. If a DFA state already exists for the given NFA state,
then that DFA state’s ID is returned and no new states are added.</p>
<p>It is not expected that this routine is called for every NFA state.
Instead, an NFA state ID will usually correspond to the “start” state
for a sub-graph of the NFA, where all states in the sub-graph are
reachable via epsilon transitions (conditional or unconditional). That
sub-graph of NFA states is ultimately what produces a single DFA state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_empty_state" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#862-892">source</a><h4 class="code-header">fn <a href="#method.add_empty_state" class="fn">add_empty_state</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::dfa::onepass::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Unconditionally add a new empty DFA state. If adding it would exceed
any limits (configured or hard-coded), then an error is returned. The
ID of the new state is returned on success.</p>
<p>The added state is <em>not</em> a match state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.stack_push" class="method"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#901-921">source</a><h4 class="code-header">fn <a href="#method.stack_push" class="fn">stack_push</a>(
    &amp;mut self,
    nfa_id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    epsilons: <a class="struct" href="struct.Epsilons.html" title="struct regex_automata::dfa::onepass::Epsilons">Epsilons</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="struct.BuildError.html" title="struct regex_automata::dfa::onepass::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Push the given NFA state ID and its corresponding epsilons (slots and
conditional epsilon transitions) on to a stack for use in a depth first
traversal of a sub-graph of the NFA.</p>
<p>If the given NFA state ID has already been pushed on to the stack, then
it indicates the regex is not one-pass and this correspondingly returns
an error.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-InternalBuilder%3C'a%3E" class="impl"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#474">source</a><a href="#impl-Debug-for-InternalBuilder%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.InternalBuilder.html" title="struct regex_automata::dfa::onepass::InternalBuilder">InternalBuilder</a>&lt;'a&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/dfa/onepass.rs.html#474">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-InternalBuilder%3C'a%3E" class="impl"><a href="#impl-Freeze-for-InternalBuilder%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.InternalBuilder.html" title="struct regex_automata::dfa::onepass::InternalBuilder">InternalBuilder</a>&lt;'a&gt;</h3></section><section id="impl-RefUnwindSafe-for-InternalBuilder%3C'a%3E" class="impl"><a href="#impl-RefUnwindSafe-for-InternalBuilder%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.InternalBuilder.html" title="struct regex_automata::dfa::onepass::InternalBuilder">InternalBuilder</a>&lt;'a&gt;</h3></section><section id="impl-Send-for-InternalBuilder%3C'a%3E" class="impl"><a href="#impl-Send-for-InternalBuilder%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.InternalBuilder.html" title="struct regex_automata::dfa::onepass::InternalBuilder">InternalBuilder</a>&lt;'a&gt;</h3></section><section id="impl-Sync-for-InternalBuilder%3C'a%3E" class="impl"><a href="#impl-Sync-for-InternalBuilder%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.InternalBuilder.html" title="struct regex_automata::dfa::onepass::InternalBuilder">InternalBuilder</a>&lt;'a&gt;</h3></section><section id="impl-Unpin-for-InternalBuilder%3C'a%3E" class="impl"><a href="#impl-Unpin-for-InternalBuilder%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.InternalBuilder.html" title="struct regex_automata::dfa::onepass::InternalBuilder">InternalBuilder</a>&lt;'a&gt;</h3></section><section id="impl-UnwindSafe-for-InternalBuilder%3C'a%3E" class="impl"><a href="#impl-UnwindSafe-for-InternalBuilder%3C'a%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.InternalBuilder.html" title="struct regex_automata::dfa::onepass::InternalBuilder">InternalBuilder</a>&lt;'a&gt;</h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>