<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Types and routines that support the wire format of finite automata."><title>regex_automata::util::wire - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_automata</a><span class="version">0.4.8</span></h2></div><h2 class="location"><a href="#">Module wire</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In regex_automata::util</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">util</a>::<wbr><a class="mod" href="#">wire</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/regex_automata/util/wire.rs.html#1-958">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Types and routines that support the wire format of finite automata.</p>
<p>Currently, this module just exports a few error types and some small helpers
for deserializing <a href="crate::dfa::dense::DFA">dense DFAs</a> using correct alignment.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AlignAs.html" title="struct regex_automata::util::wire::AlignAs">AlignAs</a></div><div class="desc docblock-short">A hack to align a smaller type <code>B</code> with a bigger type <code>T</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.DeserializeError.html" title="struct regex_automata::util::wire::DeserializeError">DeserializeError</a></div><div class="desc docblock-short">An error that occurs when deserializing an object defined in this crate.</div></li><li><div class="item-name"><a class="struct" href="struct.SerializeError.html" title="struct regex_automata::util::wire::SerializeError">SerializeError</a></div><div class="desc docblock-short">An error that occurs when serializing an object from this crate.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.BE.html" title="enum regex_automata::util::wire::BE">BE</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Big endian writing.</div></li><li><div class="item-name"><a class="enum" href="enum.DeserializeErrorKind.html" title="enum regex_automata::util::wire::DeserializeErrorKind">DeserializeErrorKind</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="enum" href="enum.LE.html" title="enum regex_automata::util::wire::LE">LE</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Little endian writing.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Endian.html" title="trait regex_automata::util::wire::Endian">Endian</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">A simple trait for writing code generic over endianness.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.add.html" title="fn regex_automata::util::wire::add">add</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Add the given numbers, and on overflow, return an error that includes
‘what’ in the error message.</div></li><li><div class="item-name"><a class="fn" href="fn.alloc_aligned_buffer.html" title="fn regex_automata::util::wire::alloc_aligned_buffer">alloc_aligned_buffer</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Allocate a byte buffer of the given size, along with some initial padding
such that <code>buf[padding..]</code> has the same alignment as <code>T</code>, where the
alignment of <code>T</code> must be at most <code>8</code>. In particular, callers should treat
the first N bytes (second return value) as padding bytes that must not be
overwritten. In all cases, the following identity holds:</div></li><li><div class="item-name"><a class="fn" href="fn.check_alignment.html" title="fn regex_automata::util::wire::check_alignment">check_alignment</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Checks that the given slice has an alignment that matches <code>T</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.check_slice_len.html" title="fn regex_automata::util::wire::check_slice_len">check_slice_len</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Checks that the given slice has some minimal length. If it’s smaller than
the bound given, then a “buffer too small” error is returned with <code>what</code>
describing what the buffer represents.</div></li><li><div class="item-name"><a class="fn" href="fn.mul.html" title="fn regex_automata::util::wire::mul">mul</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Multiply the given numbers, and on overflow, return an error that includes
‘what’ in the error message.</div></li><li><div class="item-name"><a class="fn" href="fn.padding_len.html" title="fn regex_automata::util::wire::padding_len">padding_len</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Returns the number of additional bytes required to add to the given length
in order to make the total length a multiple of 4. The return value is
always less than 4.</div></li><li><div class="item-name"><a class="fn" href="fn.read_endianness_check.html" title="fn regex_automata::util::wire::read_endianness_check">read_endianness_check</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Reads the endianness check from the beginning of the given slice and
confirms that the endianness of the serialized object matches the expected
endianness. If the slice is too small or if the endianness check fails,
this returns an error.</div></li><li><div class="item-name"><a class="fn" href="fn.read_label.html" title="fn regex_automata::util::wire::read_label">read_label</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Reads a NUL terminated label starting at the beginning of the given slice.</div></li><li><div class="item-name"><a class="fn" href="fn.read_pattern_id.html" title="fn regex_automata::util::wire::read_pattern_id">read_pattern_id</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Reads a pattern ID from the given slice. If the slice has insufficient
length, then this panics. If the deserialized integer exceeds the pattern
ID limit for the current target, then this returns an error.</div></li><li><div class="item-name"><a class="fn" href="fn.read_pattern_id_unchecked.html" title="fn regex_automata::util::wire::read_pattern_id_unchecked">read_pattern_id_unchecked</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Reads a pattern ID from the given slice. If the slice has insufficient
length, then this panics. Otherwise, the deserialized integer is assumed
to be a valid pattern ID.</div></li><li><div class="item-name"><a class="fn" href="fn.read_state_id.html" title="fn regex_automata::util::wire::read_state_id">read_state_id</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Reads a state ID from the given slice. If the slice has insufficient
length, then this panics. If the deserialized integer exceeds the state ID
limit for the current target, then this returns an error.</div></li><li><div class="item-name"><a class="fn" href="fn.read_state_id_unchecked.html" title="fn regex_automata::util::wire::read_state_id_unchecked">read_state_id_unchecked</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Reads a state ID from the given slice. If the slice has insufficient
length, then this panics. Otherwise, the deserialized integer is assumed
to be a valid state ID.</div></li><li><div class="item-name"><a class="fn" href="fn.read_u16.html" title="fn regex_automata::util::wire::read_u16">read_u16</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Read a u16 from the beginning of the given slice in native endian format.
If the slice has fewer than 2 bytes, then this panics.</div></li><li><div class="item-name"><a class="fn" href="fn.read_u32.html" title="fn regex_automata::util::wire::read_u32">read_u32</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Read a u32 from the beginning of the given slice in native endian format.
If the slice has fewer than 4 bytes, then this panics.</div></li><li><div class="item-name"><a class="fn" href="fn.read_u128.html" title="fn regex_automata::util::wire::read_u128">read_u128</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Read a u128 from the beginning of the given slice in native endian format.
If the slice has fewer than 16 bytes, then this panics.</div></li><li><div class="item-name"><a class="fn" href="fn.read_version.html" title="fn regex_automata::util::wire::read_version">read_version</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Reads a version number from the beginning of the given slice and confirms
that is matches the expected version number given. If the slice is too
small or if the version numbers aren’t equivalent, this returns an error.</div></li><li><div class="item-name"><a class="fn" href="fn.shl.html" title="fn regex_automata::util::wire::shl">shl</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Shift <code>a</code> left by <code>b</code>, and on overflow, return an error that includes
‘what’ in the error message.</div></li><li><div class="item-name"><a class="fn" href="fn.skip_initial_padding.html" title="fn regex_automata::util::wire::skip_initial_padding">skip_initial_padding</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Reads a possibly empty amount of padding, up to 7 bytes, from the beginning
of the given slice. All padding bytes must be NUL bytes.</div></li><li><div class="item-name"><a class="fn" href="fn.try_read_state_id.html" title="fn regex_automata::util::wire::try_read_state_id">try_read_state_id</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Attempts to read a state ID from the given slice. If the slice has an
insufficient number of bytes or if the state ID exceeds the limit for
the current target, then this returns an error.</div></li><li><div class="item-name"><a class="fn" href="fn.try_read_u16.html" title="fn regex_automata::util::wire::try_read_u16">try_read_u16</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Try to read a u16 from the beginning of the given slice in native endian
format. If the slice has fewer than 2 bytes, then this returns an error.
The error message will include the <code>what</code> description of what is being
deserialized, for better error messages. <code>what</code> should be a noun in
singular form.</div></li><li><div class="item-name"><a class="fn" href="fn.try_read_u16_as_usize.html" title="fn regex_automata::util::wire::try_read_u16_as_usize">try_read_u16_as_usize</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Try to read a u16 as a usize from the beginning of the given slice in
native endian format. If the slice has fewer than 2 bytes or if the
deserialized number cannot be represented by usize, then this returns an
error. The error message will include the <code>what</code> description of what is
being deserialized, for better error messages. <code>what</code> should be a noun in
singular form.</div></li><li><div class="item-name"><a class="fn" href="fn.try_read_u32.html" title="fn regex_automata::util::wire::try_read_u32">try_read_u32</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Try to read a u32 from the beginning of the given slice in native endian
format. If the slice has fewer than 4 bytes, then this returns an error.
The error message will include the <code>what</code> description of what is being
deserialized, for better error messages. <code>what</code> should be a noun in
singular form.</div></li><li><div class="item-name"><a class="fn" href="fn.try_read_u32_as_usize.html" title="fn regex_automata::util::wire::try_read_u32_as_usize">try_read_u32_as_usize</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Try to read a u32 as a usize from the beginning of the given slice in
native endian format. If the slice has fewer than 4 bytes or if the
deserialized number cannot be represented by usize, then this returns an
error. The error message will include the <code>what</code> description of what is
being deserialized, for better error messages. <code>what</code> should be a noun in
singular form.</div></li><li><div class="item-name"><a class="fn" href="fn.try_read_u128.html" title="fn regex_automata::util::wire::try_read_u128">try_read_u128</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Try to read a u128 from the beginning of the given slice in native endian
format. If the slice has fewer than 16 bytes, then this returns an error.
The error message will include the <code>what</code> description of what is being
deserialized, for better error messages. <code>what</code> should be a noun in
singular form.</div></li><li><div class="item-name"><a class="fn" href="fn.u32s_to_pattern_ids.html" title="fn regex_automata::util::wire::u32s_to_pattern_ids">u32s_to_pattern_ids</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Safely converts a <code>&amp;[u32]</code> to <code>&amp;[PatternID]</code> with zero cost.</div></li><li><div class="item-name"><a class="fn" href="fn.u32s_to_state_ids.html" title="fn regex_automata::util::wire::u32s_to_state_ids">u32s_to_state_ids</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Safely converts a <code>&amp;[u32]</code> to <code>&amp;[StateID]</code> with zero cost.</div></li><li><div class="item-name"><a class="fn" href="fn.u32s_to_state_ids_mut.html" title="fn regex_automata::util::wire::u32s_to_state_ids_mut">u32s_to_state_ids_mut</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Safely converts a <code>&amp;mut [u32]</code> to <code>&amp;mut [StateID]</code> with zero cost.</div></li><li><div class="item-name"><a class="fn" href="fn.write_endianness_check.html" title="fn regex_automata::util::wire::write_endianness_check">write_endianness_check</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Writes 0xFEFF as an integer using the given endianness.</div></li><li><div class="item-name"><a class="fn" href="fn.write_endianness_check_len.html" title="fn regex_automata::util::wire::write_endianness_check_len">write_endianness_check_len</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Returns the number of bytes written by the endianness check.</div></li><li><div class="item-name"><a class="fn" href="fn.write_label.html" title="fn regex_automata::util::wire::write_label">write_label</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Writes the given label to the buffer as a NUL terminated string. The label
given must not contain NUL, otherwise this will panic. Similarly, the label
must not be longer than 255 bytes, otherwise this will panic.</div></li><li><div class="item-name"><a class="fn" href="fn.write_label_len.html" title="fn regex_automata::util::wire::write_label_len">write_label_len</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Returns the total number of bytes (including padding) that would be written
for the given label. This panics if the given label contains a NUL byte or
is longer than 255 bytes. (The size restriction exists so that searching
for a label during deserialization can be done in small bounded space.)</div></li><li><div class="item-name"><a class="fn" href="fn.write_pattern_id.html" title="fn regex_automata::util::wire::write_pattern_id">write_pattern_id</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Write the given pattern ID to the beginning of the given slice of bytes
using the specified endianness. The given slice must have length at least
<code>PatternID::SIZE</code>, or else this panics. Upon success, the total number of
bytes written is returned.</div></li><li><div class="item-name"><a class="fn" href="fn.write_state_id.html" title="fn regex_automata::util::wire::write_state_id">write_state_id</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Write the given state ID to the beginning of the given slice of bytes
using the specified endianness. The given slice must have length at least
<code>StateID::SIZE</code>, or else this panics. Upon success, the total number of
bytes written is returned.</div></li><li><div class="item-name"><a class="fn" href="fn.write_version.html" title="fn regex_automata::util::wire::write_version">write_version</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Writes the given version number to the beginning of the given slice.</div></li><li><div class="item-name"><a class="fn" href="fn.write_version_len.html" title="fn regex_automata::util::wire::write_version_len">write_version_len</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Returns the number of bytes written by writing the version number.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.NE.html" title="type regex_automata::util::wire::NE">NE</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li></ul></section></div></main></body></html>