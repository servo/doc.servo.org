<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An intermediate NFA state used during construction."><title>State in regex_automata::nfa::thompson::builder - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc enum"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../regex_automata/index.html">regex_automata</a><span class="version">0.4.8</span></h2></div><h2 class="location"><a href="#">State</a></h2><div class="sidebar-elems"><section><h3><a href="#variants">Variants</a></h3><ul class="block variant"><li><a href="#variant.ByteRange">ByteRange</a></li><li><a href="#variant.CaptureEnd">CaptureEnd</a></li><li><a href="#variant.CaptureStart">CaptureStart</a></li><li><a href="#variant.Empty">Empty</a></li><li><a href="#variant.Fail">Fail</a></li><li><a href="#variant.Look">Look</a></li><li><a href="#variant.Match">Match</a></li><li><a href="#variant.Sparse">Sparse</a></li><li><a href="#variant.Union">Union</a></li><li><a href="#variant.UnionReverse">UnionReverse</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.goto">goto</a></li><li><a href="#method.memory_usage">memory_usage</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-State">Clone</a></li><li><a href="#impl-Debug-for-State">Debug</a></li><li><a href="#impl-Eq-for-State">Eq</a></li><li><a href="#impl-PartialEq-for-State">PartialEq</a></li><li><a href="#impl-StructuralPartialEq-for-State">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-State">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-State">RefUnwindSafe</a></li><li><a href="#impl-Send-for-State">Send</a></li><li><a href="#impl-Sync-for-State">Sync</a></li><li><a href="#impl-Unpin-for-State">Unpin</a></li><li><a href="#impl-UnwindSafe-for-State">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::nfa::thompson::builder</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Enum <a href="../../../index.html">regex_automata</a>::<wbr><a href="../../index.html">nfa</a>::<wbr><a href="../index.html">thompson</a>::<wbr><a href="index.html">builder</a>::<wbr><a class="enum" href="#">State</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#28-128">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>enum State {
    Empty {
        next: <a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    },
    ByteRange {
        trans: <a class="struct" href="../nfa/struct.Transition.html" title="struct regex_automata::nfa::thompson::nfa::Transition">Transition</a>,
    },
    Sparse {
        transitions: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../nfa/struct.Transition.html" title="struct regex_automata::nfa::thompson::nfa::Transition">Transition</a>&gt;,
    },
    Look {
        look: <a class="enum" href="../../../util/look/enum.Look.html" title="enum regex_automata::util::look::Look">Look</a>,
        next: <a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    },
    CaptureStart {
        pattern_id: <a class="struct" href="../../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>,
        group_index: <a class="struct" href="../../../util/primitives/struct.SmallIndex.html" title="struct regex_automata::util::primitives::SmallIndex">SmallIndex</a>,
        next: <a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    },
    CaptureEnd {
        pattern_id: <a class="struct" href="../../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>,
        group_index: <a class="struct" href="../../../util/primitives/struct.SmallIndex.html" title="struct regex_automata::util::primitives::SmallIndex">SmallIndex</a>,
        next: <a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>,
    },
    Union {
        alternates: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;,
    },
    UnionReverse {
        alternates: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;,
    },
    Fail,
    Match {
        pattern_id: <a class="struct" href="../../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>,
    },
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An intermediate NFA state used during construction.</p>
<p>During construction of an NFA, it is often convenient to work with states
that are amenable to mutation and other carry more information than we
otherwise need once an NFA has been built. This type represents those
needs.</p>
<p>Once construction is finished, the builder will convert these states to a
<a href="../nfa/enum.State.html" title="enum regex_automata::nfa::thompson::nfa::State"><code>nfa::thompson::State</code></a>. This conversion not
only results in a simpler representation, but in some cases, entire classes
of states are completely removed (such as <a href="enum.State.html#variant.Empty" title="variant regex_automata::nfa::thompson::builder::State::Empty"><code>State::Empty</code></a>).</p>
</div></details><h2 id="variants" class="variants section-header">Variants<a href="#variants" class="anchor">§</a></h2><div class="variants"><section id="variant.Empty" class="variant"><a href="#variant.Empty" class="anchor">§</a><h3 class="code-header">Empty</h3></section><div class="docblock"><p>An empty state whose only purpose is to forward the automaton to
another state via an unconditional epsilon transition.</p>
<p>Unconditional epsilon transitions are quite useful during the
construction of an NFA, as they permit the insertion of no-op
placeholders that make it easier to compose NFA sub-graphs. When
the Thompson NFA builder produces a final NFA, all unconditional
epsilon transitions are removed, and state identifiers are remapped
accordingly.</p>
</div><div class="sub-variant" id="variant.Empty.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Empty.field.next" class="section-header"><a href="#variant.Empty.field.next" class="anchor field">§</a><code>next: <a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></code></span><div class="docblock"><p>The next state that this state should transition to.</p>
</div></div></div><section id="variant.ByteRange" class="variant"><a href="#variant.ByteRange" class="anchor">§</a><h3 class="code-header">ByteRange</h3></section><div class="docblock"><p>A state that only transitions to another state if the current input
byte is in a particular range of bytes.</p>
</div><div class="sub-variant" id="variant.ByteRange.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.ByteRange.field.trans" class="section-header"><a href="#variant.ByteRange.field.trans" class="anchor field">§</a><code>trans: <a class="struct" href="../nfa/struct.Transition.html" title="struct regex_automata::nfa::thompson::nfa::Transition">Transition</a></code></span></div></div><section id="variant.Sparse" class="variant"><a href="#variant.Sparse" class="anchor">§</a><h3 class="code-header">Sparse</h3></section><div class="docblock"><p>A state with possibly many transitions, represented in a sparse
fashion. Transitions must be ordered lexicographically by input range
and be non-overlapping. As such, this may only be used when every
transition has equal priority. (In practice, this is only used for
encoding large UTF-8 automata.) In contrast, a <code>Union</code> state has each
alternate in order of priority. Priority is used to implement greedy
matching and also alternations themselves, e.g., <code>abc|a</code> where <code>abc</code>
has priority over <code>a</code>.</p>
<p>To clarify, it is possible to remove <code>Sparse</code> and represent all things
that <code>Sparse</code> is used for via <code>Union</code>. But this creates a more bloated
NFA with more epsilon transitions than is necessary in the special case
of character classes.</p>
</div><div class="sub-variant" id="variant.Sparse.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Sparse.field.transitions" class="section-header"><a href="#variant.Sparse.field.transitions" class="anchor field">§</a><code>transitions: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../nfa/struct.Transition.html" title="struct regex_automata::nfa::thompson::nfa::Transition">Transition</a>&gt;</code></span></div></div><section id="variant.Look" class="variant"><a href="#variant.Look" class="anchor">§</a><h3 class="code-header">Look</h3></section><div class="docblock"><p>A conditional epsilon transition satisfied via some sort of
look-around.</p>
</div><div class="sub-variant" id="variant.Look.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Look.field.look" class="section-header"><a href="#variant.Look.field.look" class="anchor field">§</a><code>look: <a class="enum" href="../../../util/look/enum.Look.html" title="enum regex_automata::util::look::Look">Look</a></code></span></div><div class="sub-variant-field"><span id="variant.Look.field.next" class="section-header"><a href="#variant.Look.field.next" class="anchor field">§</a><code>next: <a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></code></span></div></div><section id="variant.CaptureStart" class="variant"><a href="#variant.CaptureStart" class="anchor">§</a><h3 class="code-header">CaptureStart</h3></section><div class="docblock"><p>An empty state that records the start of a capture location. This is an
unconditional epsilon transition like <code>Empty</code>, except it can be used to
record position information for a capture group when using the NFA for
search.</p>
</div><div class="sub-variant" id="variant.CaptureStart.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.CaptureStart.field.pattern_id" class="section-header"><a href="#variant.CaptureStart.field.pattern_id" class="anchor field">§</a><code>pattern_id: <a class="struct" href="../../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></code></span><div class="docblock"><p>The ID of the pattern that this capture was defined.</p>
</div></div><div class="sub-variant-field"><span id="variant.CaptureStart.field.group_index" class="section-header"><a href="#variant.CaptureStart.field.group_index" class="anchor field">§</a><code>group_index: <a class="struct" href="../../../util/primitives/struct.SmallIndex.html" title="struct regex_automata::util::primitives::SmallIndex">SmallIndex</a></code></span><div class="docblock"><p>The capture group index that this capture state corresponds to.
The capture group index is always relative to its corresponding
pattern. Therefore, in the presence of multiple patterns, both the
pattern ID and the capture group index are required to uniquely
identify a capturing group.</p>
</div></div><div class="sub-variant-field"><span id="variant.CaptureStart.field.next" class="section-header"><a href="#variant.CaptureStart.field.next" class="anchor field">§</a><code>next: <a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></code></span><div class="docblock"><p>The next state that this state should transition to.</p>
</div></div></div><section id="variant.CaptureEnd" class="variant"><a href="#variant.CaptureEnd" class="anchor">§</a><h3 class="code-header">CaptureEnd</h3></section><div class="docblock"><p>An empty state that records the end of a capture location. This is an
unconditional epsilon transition like <code>Empty</code>, except it can be used to
record position information for a capture group when using the NFA for
search.</p>
</div><div class="sub-variant" id="variant.CaptureEnd.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.CaptureEnd.field.pattern_id" class="section-header"><a href="#variant.CaptureEnd.field.pattern_id" class="anchor field">§</a><code>pattern_id: <a class="struct" href="../../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></code></span><div class="docblock"><p>The ID of the pattern that this capture was defined.</p>
</div></div><div class="sub-variant-field"><span id="variant.CaptureEnd.field.group_index" class="section-header"><a href="#variant.CaptureEnd.field.group_index" class="anchor field">§</a><code>group_index: <a class="struct" href="../../../util/primitives/struct.SmallIndex.html" title="struct regex_automata::util::primitives::SmallIndex">SmallIndex</a></code></span><div class="docblock"><p>The capture group index that this capture state corresponds to.
The capture group index is always relative to its corresponding
pattern. Therefore, in the presence of multiple patterns, both the
pattern ID and the capture group index are required to uniquely
identify a capturing group.</p>
</div></div><div class="sub-variant-field"><span id="variant.CaptureEnd.field.next" class="section-header"><a href="#variant.CaptureEnd.field.next" class="anchor field">§</a><code>next: <a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a></code></span><div class="docblock"><p>The next state that this state should transition to.</p>
</div></div></div><section id="variant.Union" class="variant"><a href="#variant.Union" class="anchor">§</a><h3 class="code-header">Union</h3></section><div class="docblock"><p>An alternation such that there exists an epsilon transition to all
states in <code>alternates</code>, where matches found via earlier transitions
are preferred over later transitions.</p>
</div><div class="sub-variant" id="variant.Union.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Union.field.alternates" class="section-header"><a href="#variant.Union.field.alternates" class="anchor field">§</a><code>alternates: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;</code></span></div></div><section id="variant.UnionReverse" class="variant"><a href="#variant.UnionReverse" class="anchor">§</a><h3 class="code-header">UnionReverse</h3></section><div class="docblock"><p>An alternation such that there exists an epsilon transition to all
states in <code>alternates</code>, where matches found via later transitions are
preferred over earlier transitions.</p>
<p>This “reverse” state exists for convenience during compilation that
permits easy construction of non-greedy combinations of NFA states. At
the end of compilation, Union and UnionReverse states are merged into
one Union type of state, where the latter has its epsilon transitions
reversed to reflect the priority inversion.</p>
<p>The “convenience” here arises from the fact that as new states are
added to the list of <code>alternates</code>, we would like that add operation
to be amortized constant time. But if we used a <code>Union</code>, we’d need to
prepend the state, which takes O(n) time. There are other approaches we
could use to solve this, but this seems simple enough.</p>
</div><div class="sub-variant" id="variant.UnionReverse.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.UnionReverse.field.alternates" class="section-header"><a href="#variant.UnionReverse.field.alternates" class="anchor field">§</a><code>alternates: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;</code></span></div></div><section id="variant.Fail" class="variant"><a href="#variant.Fail" class="anchor">§</a><h3 class="code-header">Fail</h3></section><div class="docblock"><p>A state that cannot be transitioned out of. This is useful for cases
where you want to prevent matching from occurring. For example, if your
regex parser permits empty character classes, then one could choose a
<code>Fail</code> state to represent it.</p>
</div><section id="variant.Match" class="variant"><a href="#variant.Match" class="anchor">§</a><h3 class="code-header">Match</h3></section><div class="docblock"><p>A match state. There is at most one such occurrence of this state in
an NFA for each pattern compiled into the NFA. At time of writing, a
match state is always produced for every pattern given, but in theory,
if a pattern can never lead to a match, then the match state could be
omitted.</p>
<p><code>pattern_id</code> refers to the ID of the pattern itself, which corresponds
to the pattern’s index (starting at 0).</p>
</div><div class="sub-variant" id="variant.Match.fields"><h4>Fields</h4><div class="sub-variant-field"><span id="variant.Match.field.pattern_id" class="section-header"><a href="#variant.Match.field.pattern_id" class="anchor field">§</a><code>pattern_id: <a class="struct" href="../../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a></code></span></div></div></div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-State" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#130-169">source</a><a href="#impl-State" class="anchor">§</a><h3 class="code-header">impl <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.goto" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#133-146">source</a><h4 class="code-header">fn <a href="#method.goto" class="fn">goto</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>&gt;</h4></section></summary><div class="docblock"><p>If this state is an unconditional epsilon transition, then this returns
the target of the transition.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.memory_usage" class="method"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#149-168">source</a><h4 class="code-header">fn <a href="#method.memory_usage" class="fn">memory_usage</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the heap memory usage, in bytes, of this state.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-State" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#27">source</a><a href="#impl-Clone-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#27">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-State" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#27">source</a><a href="#impl-Debug-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#27">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-State" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#27">source</a><a href="#impl-PartialEq-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#27">source</a><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/cmp/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/cmp.rs.html#263">source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/cmp/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason.</div></details></div></details><section id="impl-Eq-for-State" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#27">source</a><a href="#impl-Eq-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section><section id="impl-StructuralPartialEq-for-State" class="impl"><a class="src rightside" href="../../../../src/regex_automata/nfa/thompson/builder.rs.html#27">source</a><a href="#impl-StructuralPartialEq-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-State" class="impl"><a href="#impl-Freeze-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section><section id="impl-RefUnwindSafe-for-State" class="impl"><a href="#impl-RefUnwindSafe-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section><section id="impl-Send-for-State" class="impl"><a href="#impl-Send-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section><section id="impl-Sync-for-State" class="impl"><a href="#impl-Sync-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section><section id="impl-Unpin-for-State" class="impl"><a href="#impl-Unpin-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section><section id="impl-UnwindSafe-for-State" class="impl"><a href="#impl-UnwindSafe-for-State" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="enum" href="enum.State.html" title="enum regex_automata::nfa::thompson::builder::State">State</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>