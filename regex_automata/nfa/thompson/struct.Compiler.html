<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A builder for compiling an NFA from a regex’s high-level intermediate representation (HIR)."><title>Compiler in regex_automata::nfa::thompson - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_automata/index.html">regex_automata</a><span class="version">0.4.8</span></h2></div><h2 class="location"><a href="#">Compiler</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.builder">builder</a></li><li><a href="#structfield.config">config</a></li><li><a href="#structfield.parser">parser</a></li><li><a href="#structfield.trie_state">trie_state</a></li><li><a href="#structfield.utf8_state">utf8_state</a></li><li><a href="#structfield.utf8_suffix">utf8_suffix</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add_capture_end">add_capture_end</a></li><li><a href="#method.add_capture_start">add_capture_start</a></li><li><a href="#method.add_empty">add_empty</a></li><li><a href="#method.add_fail">add_fail</a></li><li><a href="#method.add_look">add_look</a></li><li><a href="#method.add_match">add_match</a></li><li><a href="#method.add_range">add_range</a></li><li><a href="#method.add_sparse">add_sparse</a></li><li><a href="#method.add_union">add_union</a></li><li><a href="#method.add_union_reverse">add_union_reverse</a></li><li><a href="#method.build">build</a></li><li><a href="#method.build_from_hir">build_from_hir</a></li><li><a href="#method.build_many">build_many</a></li><li><a href="#method.build_many_from_hir">build_many_from_hir</a></li><li><a href="#method.c">c</a></li><li><a href="#method.c_alt_iter">c_alt_iter</a></li><li><a href="#method.c_alt_slice">c_alt_slice</a></li><li><a href="#method.c_at_least">c_at_least</a></li><li><a href="#method.c_bounded">c_bounded</a></li><li><a href="#method.c_byte_class">c_byte_class</a></li><li><a href="#method.c_cap">c_cap</a></li><li><a href="#method.c_concat">c_concat</a></li><li><a href="#method.c_empty">c_empty</a></li><li><a href="#method.c_exactly">c_exactly</a></li><li><a href="#method.c_fail">c_fail</a></li><li><a href="#method.c_literal">c_literal</a></li><li><a href="#method.c_look">c_look</a></li><li><a href="#method.c_range">c_range</a></li><li><a href="#method.c_repetition">c_repetition</a></li><li><a href="#method.c_unicode_class">c_unicode_class</a></li><li><a href="#method.c_unicode_class_reverse_with_suffix">c_unicode_class_reverse_with_suffix</a></li><li><a href="#method.c_zero_or_one">c_zero_or_one</a></li><li><a href="#method.compile">compile</a></li><li><a href="#method.configure">configure</a></li><li><a href="#method.finish_pattern">finish_pattern</a></li><li><a href="#method.is_reverse">is_reverse</a></li><li><a href="#method.new">new</a></li><li><a href="#method.patch">patch</a></li><li><a href="#method.start_pattern">start_pattern</a></li><li><a href="#method.syntax">syntax</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Compiler">Clone</a></li><li><a href="#impl-Debug-for-Compiler">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Compiler">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Compiler">!RefUnwindSafe</a></li><li><a href="#impl-Sync-for-Compiler">!Sync</a></li><li><a href="#impl-Send-for-Compiler">Send</a></li><li><a href="#impl-Unpin-for-Compiler">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Compiler">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_automata::nfa::thompson</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">regex_automata</a>::<wbr><a href="../index.html">nfa</a>::<wbr><a href="index.html">thompson</a>::<wbr><a class="struct" href="#">Compiler</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#696-714">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Compiler {
    parser: <a class="struct" href="../../../regex_syntax/parser/struct.ParserBuilder.html" title="struct regex_syntax::parser::ParserBuilder">ParserBuilder</a>,
    config: <a class="struct" href="compiler/struct.Config.html" title="struct regex_automata::nfa::thompson::compiler::Config">Config</a>,
    builder: <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/cell/struct.RefCell.html" title="struct core::cell::RefCell">RefCell</a>&lt;<a class="struct" href="builder/struct.Builder.html" title="struct regex_automata::nfa::thompson::builder::Builder">Builder</a>&gt;,
    utf8_state: <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/cell/struct.RefCell.html" title="struct core::cell::RefCell">RefCell</a>&lt;<a class="struct" href="compiler/struct.Utf8State.html" title="struct regex_automata::nfa::thompson::compiler::Utf8State">Utf8State</a>&gt;,
    trie_state: <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/cell/struct.RefCell.html" title="struct core::cell::RefCell">RefCell</a>&lt;<a class="struct" href="range_trie/struct.RangeTrie.html" title="struct regex_automata::nfa::thompson::range_trie::RangeTrie">RangeTrie</a>&gt;,
    utf8_suffix: <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/cell/struct.RefCell.html" title="struct core::cell::RefCell">RefCell</a>&lt;<a class="struct" href="map/struct.Utf8SuffixMap.html" title="struct regex_automata::nfa::thompson::map::Utf8SuffixMap">Utf8SuffixMap</a>&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A builder for compiling an NFA from a regex’s high-level intermediate
representation (HIR).</p>
<p>This compiler provides a way to translate a parsed regex pattern into an
NFA state graph. The NFA state graph can either be used directly to execute
a search (e.g., with a Pike VM), or it can be further used to build a DFA.</p>
<p>This compiler provides APIs both for compiling regex patterns directly from
their concrete syntax, or via a <a href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir"><code>regex_syntax::hir::Hir</code></a>.</p>
<p>This compiler has various options that may be configured via
<a href="compiler/struct.Config.html" title="struct regex_automata::nfa::thompson::compiler::Config"><code>thompson::Config</code></a>.</p>
<p>Note that a compiler is not the same as a <a href="builder/struct.Builder.html" title="struct regex_automata::nfa::thompson::builder::Builder"><code>thompson::Builder</code></a>.
A <code>Builder</code> provides a lower level API that is uncoupled from a regex
pattern’s concrete syntax or even its HIR. Instead, it permits stitching
together an NFA by hand. See its docs for examples.</p>
<h2 id="example-compilation-from-concrete-syntax"><a class="doc-anchor" href="#example-compilation-from-concrete-syntax">§</a>Example: compilation from concrete syntax</h2>
<p>This shows how to compile an NFA from a pattern string while setting a size
limit on how big the NFA is allowed to be (in terms of bytes of heap used).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{
    nfa::thompson::{NFA, pikevm::PikeVM},
    Match,
};

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build(<span class="string">r"(?-u)\w"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">4</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!@#A#@!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
<h2 id="example-compilation-from-hir"><a class="doc-anchor" href="#example-compilation-from-hir">§</a>Example: compilation from HIR</h2>
<p>This shows how to hand assemble a regular expression via its HIR, and then
compile an NFA directly from it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};
<span class="kw">use </span>regex_syntax::hir::{Hir, Class, ClassBytes, ClassBytesRange};

<span class="kw">let </span>hir = Hir::class(Class::Bytes(ClassBytes::new(<span class="macro">vec!</span>[
    ClassBytesRange::new(<span class="string">b'0'</span>, <span class="string">b'9'</span>),
    ClassBytesRange::new(<span class="string">b'A'</span>, <span class="string">b'Z'</span>),
    ClassBytesRange::new(<span class="string">b'_'</span>, <span class="string">b'_'</span>),
    ClassBytesRange::new(<span class="string">b'a'</span>, <span class="string">b'z'</span>),
])));

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build_from_hir(<span class="kw-2">&amp;</span>hir)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">4</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!@#A#@!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.parser" class="structfield section-header"><a href="#structfield.parser" class="anchor field">§</a><code>parser: <a class="struct" href="../../../regex_syntax/parser/struct.ParserBuilder.html" title="struct regex_syntax::parser::ParserBuilder">ParserBuilder</a></code></span><div class="docblock"><p>A regex parser, used when compiling an NFA directly from a pattern
string.</p>
</div><span id="structfield.config" class="structfield section-header"><a href="#structfield.config" class="anchor field">§</a><code>config: <a class="struct" href="compiler/struct.Config.html" title="struct regex_automata::nfa::thompson::compiler::Config">Config</a></code></span><div class="docblock"><p>The compiler configuration.</p>
</div><span id="structfield.builder" class="structfield section-header"><a href="#structfield.builder" class="anchor field">§</a><code>builder: <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/cell/struct.RefCell.html" title="struct core::cell::RefCell">RefCell</a>&lt;<a class="struct" href="builder/struct.Builder.html" title="struct regex_automata::nfa::thompson::builder::Builder">Builder</a>&gt;</code></span><div class="docblock"><p>The builder for actually constructing an NFA. This provides a
convenient abstraction for writing a compiler.</p>
</div><span id="structfield.utf8_state" class="structfield section-header"><a href="#structfield.utf8_state" class="anchor field">§</a><code>utf8_state: <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/cell/struct.RefCell.html" title="struct core::cell::RefCell">RefCell</a>&lt;<a class="struct" href="compiler/struct.Utf8State.html" title="struct regex_automata::nfa::thompson::compiler::Utf8State">Utf8State</a>&gt;</code></span><div class="docblock"><p>State used for compiling character classes to UTF-8 byte automata.
State is not retained between character class compilations. This just
serves to amortize allocation to the extent possible.</p>
</div><span id="structfield.trie_state" class="structfield section-header"><a href="#structfield.trie_state" class="anchor field">§</a><code>trie_state: <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/cell/struct.RefCell.html" title="struct core::cell::RefCell">RefCell</a>&lt;<a class="struct" href="range_trie/struct.RangeTrie.html" title="struct regex_automata::nfa::thompson::range_trie::RangeTrie">RangeTrie</a>&gt;</code></span><div class="docblock"><p>State used for arranging character classes in reverse into a trie.</p>
</div><span id="structfield.utf8_suffix" class="structfield section-header"><a href="#structfield.utf8_suffix" class="anchor field">§</a><code>utf8_suffix: <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/cell/struct.RefCell.html" title="struct core::cell::RefCell">RefCell</a>&lt;<a class="struct" href="map/struct.Utf8SuffixMap.html" title="struct regex_automata::nfa::thompson::map::Utf8SuffixMap">Utf8SuffixMap</a>&gt;</code></span><div class="docblock"><p>State used for caching common suffixes when compiling reverse UTF-8
automata (for Unicode character classes).</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Compiler" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#716-931">source</a><a href="#impl-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#718-727">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h4></section></summary><div class="docblock"><p>Create a new NFA builder with its default configuration.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#756-758">source</a><h4 class="code-header">pub fn <a href="#method.build" class="fn">build</a>(&amp;self, pattern: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="nfa/struct.NFA.html" title="struct regex_automata::nfa::thompson::nfa::NFA">NFA</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given regular expression pattern into an NFA.</p>
<p>If there was a problem parsing the regex, then that error is returned.</p>
<p>Otherwise, if there was a problem building the NFA, then an error is
returned. The only error that can occur is if the compiled regex would
exceed the size limits configured on this builder, or if any part of
the NFA would exceed the integer representations used. (For example,
too many states might plausibly occur on a 16-bit target.)</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build(<span class="string">r"(?-u)\w"</span>)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">4</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!@#A#@!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build_many" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#785-800">source</a><h4 class="code-header">pub fn <a href="#method.build_many" class="fn">build_many</a>&lt;P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>&gt;&gt;(
    &amp;self,
    patterns: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.slice.html">[P]</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="nfa/struct.NFA.html" title="struct regex_automata::nfa::thompson::nfa::NFA">NFA</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given regular expression patterns into a single NFA.</p>
<p>When matches are returned, the pattern ID corresponds to the index of
the pattern in the slice given.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build_many(<span class="kw-2">&amp;</span>[
    <span class="string">r"(?-u)\s"</span>,
    <span class="string">r"(?-u)\w"</span>,
])<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">1</span>..<span class="number">2</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!A! !A!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build_from_hir" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#836-838">source</a><h4 class="code-header">pub fn <a href="#method.build_from_hir" class="fn">build_from_hir</a>(&amp;self, expr: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="nfa/struct.NFA.html" title="struct regex_automata::nfa::thompson::nfa::NFA">NFA</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given high level intermediate representation of a regular
expression into an NFA.</p>
<p>If there was a problem building the NFA, then an error is returned. The
only error that can occur is if the compiled regex would exceed the
size limits configured on this builder, or if any part of the NFA would
exceed the integer representations used. (For example, too many states
might plausibly occur on a 16-bit target.)</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};
<span class="kw">use </span>regex_syntax::hir::{Hir, Class, ClassBytes, ClassBytesRange};

<span class="kw">let </span>hir = Hir::class(Class::Bytes(ClassBytes::new(<span class="macro">vec!</span>[
    ClassBytesRange::new(<span class="string">b'0'</span>, <span class="string">b'9'</span>),
    ClassBytesRange::new(<span class="string">b'A'</span>, <span class="string">b'Z'</span>),
    ClassBytesRange::new(<span class="string">b'_'</span>, <span class="string">b'_'</span>),
    ClassBytesRange::new(<span class="string">b'a'</span>, <span class="string">b'z'</span>),
])));

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build_from_hir(<span class="kw-2">&amp;</span>hir)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">0</span>, <span class="number">3</span>..<span class="number">4</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!@#A#@!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.build_many_from_hir" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#877-882">source</a><h4 class="code-header">pub fn <a href="#method.build_many_from_hir" class="fn">build_many_from_hir</a>&lt;H: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>&gt;&gt;(
    &amp;self,
    exprs: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.slice.html">[H]</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="nfa/struct.NFA.html" title="struct regex_automata::nfa::thompson::nfa::NFA">NFA</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given high level intermediate representations of regular
expressions into a single NFA.</p>
<p>When matches are returned, the pattern ID corresponds to the index of
the pattern in the slice given.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::{NFA, pikevm::PikeVM}, Match};
<span class="kw">use </span>regex_syntax::hir::{Hir, Class, ClassBytes, ClassBytesRange};

<span class="kw">let </span>hirs = <span class="kw-2">&amp;</span>[
    Hir::class(Class::Bytes(ClassBytes::new(<span class="macro">vec!</span>[
        ClassBytesRange::new(<span class="string">b'\t'</span>, <span class="string">b'\r'</span>),
        ClassBytesRange::new(<span class="string">b' '</span>, <span class="string">b' '</span>),
    ]))),
    Hir::class(Class::Bytes(ClassBytes::new(<span class="macro">vec!</span>[
        ClassBytesRange::new(<span class="string">b'0'</span>, <span class="string">b'9'</span>),
        ClassBytesRange::new(<span class="string">b'A'</span>, <span class="string">b'Z'</span>),
        ClassBytesRange::new(<span class="string">b'_'</span>, <span class="string">b'_'</span>),
        ClassBytesRange::new(<span class="string">b'a'</span>, <span class="string">b'z'</span>),
    ]))),
];

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build_many_from_hir(hirs)<span class="question-mark">?</span>;

<span class="kw">let </span>re = PikeVM::new_from_nfa(nfa)<span class="question-mark">?</span>;
<span class="kw">let </span><span class="kw-2">mut </span>cache = re.create_cache();
<span class="kw">let </span><span class="kw-2">mut </span>caps = re.create_captures();
<span class="kw">let </span>expected = <span class="prelude-val">Some</span>(Match::must(<span class="number">1</span>, <span class="number">1</span>..<span class="number">2</span>));
re.captures(<span class="kw-2">&amp;mut </span>cache, <span class="string">"!A! !A!"</span>, <span class="kw-2">&amp;mut </span>caps);
<span class="macro">assert_eq!</span>(expected, caps.get_match());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.configure" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#897-900">source</a><h4 class="code-header">pub fn <a href="#method.configure" class="fn">configure</a>(&amp;mut self, config: <a class="struct" href="compiler/struct.Config.html" title="struct regex_automata::nfa::thompson::compiler::Config">Config</a>) -&gt; &amp;mut <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h4></section></summary><div class="docblock"><p>Apply the given NFA configuration options to this builder.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::nfa::thompson::NFA;

<span class="kw">let </span>config = NFA::config().nfa_size_limit(<span class="prelude-val">Some</span>(<span class="number">1_000</span>));
<span class="kw">let </span>nfa = NFA::compiler().configure(config).build(<span class="string">r"(?-u)\w"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(nfa.pattern_len(), <span class="number">1</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.syntax" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#924-930">source</a><h4 class="code-header">pub fn <a href="#method.syntax" class="fn">syntax</a>(&amp;mut self, config: <a class="struct" href="../../util/syntax/struct.Config.html" title="struct regex_automata::util::syntax::Config">Config</a>) -&gt; &amp;mut <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h4></section></summary><div class="docblock"><p>Set the syntax configuration for this builder using
<a href="../../util/syntax/struct.Config.html" title="struct regex_automata::util::syntax::Config"><code>syntax::Config</code></a>.</p>
<p>This permits setting things like case insensitivity, Unicode and multi
line mode.</p>
<p>This syntax configuration only applies when an NFA is built directly
from a pattern string. If an NFA is built from an HIR, then all syntax
settings are ignored.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex_automata::{nfa::thompson::NFA, util::syntax};

<span class="kw">let </span>syntax_config = syntax::Config::new().unicode(<span class="bool-val">false</span>);
<span class="kw">let </span>nfa = NFA::compiler().syntax(syntax_config).build(<span class="string">r"\w"</span>)<span class="question-mark">?</span>;
<span class="comment">// If Unicode were enabled, the number of states would be much bigger.
</span><span class="macro">assert!</span>(nfa.states().len() &lt; <span class="number">15</span>);
</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Compiler-1" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#933-1694">source</a><a href="#impl-Compiler-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.compile" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#939-994">source</a><h4 class="code-header">fn <a href="#method.compile" class="fn">compile</a>&lt;H: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>&gt;&gt;(&amp;self, exprs: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.slice.html">[H]</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="nfa/struct.NFA.html" title="struct regex_automata::nfa::thompson::nfa::NFA">NFA</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the sequence of HIR expressions given. Pattern IDs are
allocated starting from 0, in correspondence with the slice given.</p>
<p>It is legal to provide an empty slice. In that case, the NFA returned
has no patterns and will never match anything.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#997-1011">source</a><h4 class="code-header">fn <a href="#method.c" class="fn">c</a>(&amp;self, expr: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile an arbitrary HIR expression.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_concat" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1019-1039">source</a><h4 class="code-header">fn <a href="#method.c_concat" class="fn">c_concat</a>&lt;I&gt;(&amp;self, it: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator">DoubleEndedIterator</a>&lt;Item = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;&gt;,</div></h4></section></summary><div class="docblock"><p>Compile a concatenation of the sub-expressions yielded by the given
iterator. If the iterator yields no elements, then this compiles down
to an “empty” state that always matches.</p>
<p>If the compiler is in reverse mode, then the expressions given are
automatically compiled in reverse.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_alt_slice" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1048-1073">source</a><h4 class="code-header">fn <a href="#method.c_alt_slice" class="fn">c_alt_slice</a>(&amp;self, exprs: &amp;[<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile an alternation of the given HIR values.</p>
<p>This is like ‘c_alt_iter’, but it accepts a slice of HIR values instead
of an iterator of compiled NFA subgraphs. The point of accepting a
slice here is that it opens up some optimization opportunities. For
example, if all of the HIR values are literals, then this routine might
re-shuffle them to make NFA epsilon closures substantially faster.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_alt_iter" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1084-1109">source</a><h4 class="code-header">fn <a href="#method.c_alt_iter" class="fn">c_alt_iter</a>&lt;I&gt;(&amp;self, it: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;<div class="where">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;&gt;,</div></h4></section></summary><div class="docblock"><p>Compile an alternation, where each element yielded by the given
iterator represents an item in the alternation. If the iterator yields
no elements, then this compiles down to a “fail” state.</p>
<p>In an alternation, expressions appearing earlier are “preferred” at
match time over expressions appearing later. At least, this is true
when using “leftmost first” match semantics. (If “leftmost longest” are
ever added in the future, then this preference order of priority would
not apply in that mode.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_cap" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1119-1140">source</a><h4 class="code-header">fn <a href="#method.c_cap" class="fn">c_cap</a>(
    &amp;self,
    index: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>,
    name: <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>&gt;,
    expr: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given capture sub-expression. <code>expr</code> should be the
sub-expression contained inside the capture. If “capture” states are
enabled, then they are added as appropriate.</p>
<p>This accepts the pieces of a capture instead of a <code>hir::Capture</code> so
that it’s easy to manufacture a “fake” group when necessary, e.g., for
adding the entire pattern as if it were a group in order to create
appropriate “capture” states in the NFA.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_repetition" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1144-1154">source</a><h4 class="code-header">fn <a href="#method.c_repetition" class="fn">c_repetition</a>(&amp;self, rep: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.Repetition.html" title="struct regex_syntax::hir::Repetition">Repetition</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given repetition expression. This handles all types of
repetitions and greediness.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_bounded" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1162-1219">source</a><h4 class="code-header">fn <a href="#method.c_bounded" class="fn">c_bounded</a>(
    &amp;self,
    expr: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>,
    greedy: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>,
    min: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>,
    max: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given expression such that it matches at least <code>min</code> times,
but no more than <code>max</code> times.</p>
<p>When <code>greedy</code> is true, then the preference is for the expression to
match as much as possible. Otherwise, it will match as little as
possible.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_at_least" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1228-1301">source</a><h4 class="code-header">fn <a href="#method.c_at_least" class="fn">c_at_least</a>(
    &amp;self,
    expr: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>,
    greedy: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>,
    n: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given expression such that it may be matched <code>n</code> or more
times, where <code>n</code> can be any integer. (Although a particularly large
integer is likely to run afoul of any configured size limits.)</p>
<p>When <code>greedy</code> is true, then the preference is for the expression to
match as much as possible. Otherwise, it will match as little as
possible.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_zero_or_one" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1309-1322">source</a><h4 class="code-header">fn <a href="#method.c_zero_or_one" class="fn">c_zero_or_one</a>(
    &amp;self,
    expr: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>,
    greedy: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given expression such that it may be matched zero or one
times.</p>
<p>When <code>greedy</code> is true, then the preference is for the expression to
match as much as possible. Otherwise, it will match as little as
possible.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_exactly" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1325-1332">source</a><h4 class="code-header">fn <a href="#method.c_exactly" class="fn">c_exactly</a>(&amp;self, expr: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.Hir.html" title="struct regex_syntax::hir::Hir">Hir</a>, n: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given HIR expression exactly <code>n</code> times.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_byte_class" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1344-1358">source</a><h4 class="code-header">fn <a href="#method.c_byte_class" class="fn">c_byte_class</a>(&amp;self, cls: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.ClassBytes.html" title="struct regex_syntax::hir::ClassBytes">ClassBytes</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given byte oriented character class.</p>
<p>This uses “sparse” states to represent an alternation between ranges in
this character class. We can use “sparse” states instead of stitching
together a “union” state because all ranges in a character class have
equal priority <em>and</em> are non-overlapping (thus, only one can match, so
there’s never a question of priority in the first place). This saves a
fair bit of overhead when traversing an NFA.</p>
<p>This routine compiles an empty character class into a “fail” state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_unicode_class" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1373-1492">source</a><h4 class="code-header">fn <a href="#method.c_unicode_class" class="fn">c_unicode_class</a>(&amp;self, cls: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.ClassUnicode.html" title="struct regex_syntax::hir::ClassUnicode">ClassUnicode</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given Unicode character class.</p>
<p>This routine specifically tries to use various types of compression,
since UTF-8 automata of large classes can get quite large. The specific
type of compression used depends on forward vs reverse compilation, and
whether NFA shrinking is enabled or not.</p>
<p>Aside from repetitions causing lots of repeat group, this is like the
single most expensive part of regex compilation. Therefore, a large part
of the expense of compilation may be reduce by disabling Unicode in the
pattern.</p>
<p>This routine compiles an empty character class into a “fail” state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_unicode_class_reverse_with_suffix" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1509-1546">source</a><h4 class="code-header">fn <a href="#method.c_unicode_class_reverse_with_suffix" class="fn">c_unicode_class_reverse_with_suffix</a>(
    &amp;self,
    cls: &amp;<a class="struct" href="../../../regex_syntax/hir/struct.ClassUnicode.html" title="struct regex_syntax::hir::ClassUnicode">ClassUnicode</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given Unicode character class in reverse with suffix
caching.</p>
<p>This is a “quick” way to compile large Unicode classes into reverse
UTF-8 automata while doing a small amount of compression on that
automata by reusing common suffixes.</p>
<p>A more comprehensive compression scheme can be accomplished by using
a range trie to efficiently sort a reverse sequence of UTF-8 byte
rqanges, and then use Daciuk’s algorithm via <code>Utf8Compiler</code>.</p>
<p>This is the technique used when “NFA shrinking” is disabled.</p>
<p>(This also tries to use “sparse” states where possible, just like
<code>c_byte_class</code> does.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_look" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1550-1573">source</a><h4 class="code-header">fn <a href="#method.c_look" class="fn">c_look</a>(&amp;self, anchor: &amp;<a class="enum" href="../../../regex_syntax/hir/enum.Look.html" title="enum regex_syntax::hir::Look">Look</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given HIR look-around assertion to an NFA look-around
assertion.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_literal" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1576-1578">source</a><h4 class="code-header">fn <a href="#method.c_literal" class="fn">c_literal</a>(&amp;self, bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>]) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile the given byte string to a concatenation of bytes.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_range" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1586-1589">source</a><h4 class="code-header">fn <a href="#method.c_range" class="fn">c_range</a>(&amp;self, start: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>, end: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile a “range” state with one transition that may only be followed
if the input byte is in the (inclusive) range given.</p>
<p>Both the <code>start</code> and <code>end</code> locations point to the state created.
Callers will likely want to keep the <code>start</code>, but patch the <code>end</code> to
point to some other state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_empty" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1596-1599">source</a><h4 class="code-header">fn <a href="#method.c_empty" class="fn">c_empty</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile an “empty” state with one unconditional epsilon transition.</p>
<p>Both the <code>start</code> and <code>end</code> locations point to the state created.
Callers will likely want to keep the <code>start</code>, but patch the <code>end</code> to
point to some other state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.c_fail" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1602-1605">source</a><h4 class="code-header">fn <a href="#method.c_fail" class="fn">c_fail</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="compiler/struct.ThompsonRef.html" title="struct regex_automata::nfa::thompson::compiler::ThompsonRef">ThompsonRef</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section></summary><div class="docblock"><p>Compile a “fail” state that can never have any outgoing transitions.</p>
</div></details><section id="method.patch" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1614-1616">source</a><h4 class="code-header">fn <a href="#method.patch" class="fn">patch</a>(&amp;self, from: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, to: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.start_pattern" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1618-1620">source</a><h4 class="code-header">fn <a href="#method.start_pattern" class="fn">start_pattern</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.finish_pattern" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1622-1627">source</a><h4 class="code-header">fn <a href="#method.finish_pattern" class="fn">finish_pattern</a>(&amp;self, start_id: <a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../struct.PatternID.html" title="struct regex_automata::PatternID">PatternID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.add_empty" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1629-1631">source</a><h4 class="code-header">fn <a href="#method.add_empty" class="fn">add_empty</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.add_range" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1633-1639">source</a><h4 class="code-header">fn <a href="#method.add_range" class="fn">add_range</a>(&amp;self, start: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>, end: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.add_sparse" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1641-1646">source</a><h4 class="code-header">fn <a href="#method.add_sparse" class="fn">add_sparse</a>(&amp;self, ranges: <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="nfa/struct.Transition.html" title="struct regex_automata::nfa::thompson::nfa::Transition">Transition</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.add_look" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1648-1653">source</a><h4 class="code-header">fn <a href="#method.add_look" class="fn">add_look</a>(&amp;self, look: <a class="enum" href="../../util/look/enum.Look.html" title="enum regex_automata::util::look::Look">Look</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.add_union" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1655-1657">source</a><h4 class="code-header">fn <a href="#method.add_union" class="fn">add_union</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.add_union_reverse" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1659-1661">source</a><h4 class="code-header">fn <a href="#method.add_union_reverse" class="fn">add_union_reverse</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.add_capture_start" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1663-1674">source</a><h4 class="code-header">fn <a href="#method.add_capture_start" class="fn">add_capture_start</a>(
    &amp;self,
    capture_index: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>,
    name: <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.add_capture_end" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1676-1681">source</a><h4 class="code-header">fn <a href="#method.add_capture_end" class="fn">add_capture_end</a>(&amp;self, capture_index: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.add_fail" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1683-1685">source</a><h4 class="code-header">fn <a href="#method.add_fail" class="fn">add_fail</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.add_match" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1687-1689">source</a><h4 class="code-header">fn <a href="#method.add_match" class="fn">add_match</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../util/primitives/struct.StateID.html" title="struct regex_automata::util::primitives::StateID">StateID</a>, <a class="struct" href="error/struct.BuildError.html" title="struct regex_automata::nfa::thompson::error::BuildError">BuildError</a>&gt;</h4></section><section id="method.is_reverse" class="method"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#1691-1693">source</a><h4 class="code-header">fn <a href="#method.is_reverse" class="fn">is_reverse</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Compiler" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#695">source</a><a href="#impl-Clone-for-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#695">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Compiler" class="impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#695">source</a><a href="#impl-Debug-for-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/regex_automata/nfa/thompson/compiler.rs.html#695">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Compiler" class="impl"><a href="#impl-Freeze-for-Compiler" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h3></section><section id="impl-RefUnwindSafe-for-Compiler" class="impl"><a href="#impl-RefUnwindSafe-for-Compiler" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h3></section><section id="impl-Send-for-Compiler" class="impl"><a href="#impl-Send-for-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h3></section><section id="impl-Sync-for-Compiler" class="impl"><a href="#impl-Sync-for-Compiler" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h3></section><section id="impl-Unpin-for-Compiler" class="impl"><a href="#impl-Unpin-for-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h3></section><section id="impl-UnwindSafe-for-Compiler" class="impl"><a href="#impl-UnwindSafe-for-Compiler" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="compiler/struct.Compiler.html" title="struct regex_automata::nfa::thompson::compiler::Compiler">Compiler</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>