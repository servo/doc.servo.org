initSidebarItems({"constant":[["CorruptionCanaryForStatics_kCanarySet",""],["Vector_InlineLength",""]],"enum":[["LinkedListElement_NodeKind",""],["MemoryOrdering","An enum of memory ordering possibilities for atomics."],["NotNullTag",""],["Vector__bindgen_ty_1",""]],"mod":[["detail",""],["ipc",""],["span_details",""],["tl",""]],"static":[["VariantIndex_index",""]],"struct":[["AlignedStorage2",""],["AlignmentFinder",""],["AlignmentFinder_Aligner",""],["AutoCleanLinkedList",""],["BaseTimeDuration","Instances of this class represent the length of an interval of time. Negative durations are allowed, meaning the end is before the start."],["BaseTimeDurationPlatformUtils","Platform-specific implementation details of BaseTimeDuration."],["BaseTimeDuration__SomethingVeryRandomHere",""],["BitSet_Reference",""],["BufferList",""],["BufferList_IterImpl",""],["BufferList_Segment",""],["CStringHasher",""],["CompactPair","CompactPair is the logical concatenation of an instance of A with an instance B. Space is conserved when possible.  Neither A nor B may be a final class."],["CorruptionCanary","This class is designed to cause crashes when various kinds of memory corruption are observed. For instance, let’s say we have a class C where we suspect out-of-bounds writes to some members.  We can insert a member of type Poison near the members we suspect are being corrupted by out-of-bounds writes.  Or perhaps we have a class K we suspect is subject to use-after-free violations, in which case it doesn’t particularly matter where in the class we add the member of type Poison."],["CorruptionCanaryForStatics","A version of CorruptionCanary that is suitable as a member of objects that are statically allocated."],["DebugOnly","DebugOnly contains a value of type T, but only in debug builds.  In release builds, it does not contain a value.  This helper is intended to be used with MOZ_ASSERT()-style macros, allowing one to write:"],["DefaultDelete","A default deletion policy using plain old operator delete."],["DefaultHasher",""],["FallibleHashMethods",""],["FloatingPoint",""],["GenericErrorResult","A type that auto-converts to an error Result. This is like a Result without a success type. It’s the best return type for functions that always return an error–functions designed to build and populate error objects. It’s also useful in error-handling macros; see MOZ_TRY for an example."],["HashCodeScrambler","A pseudorandom function mapping 32-bit integers to 32-bit integers."],["HashCodeScrambler_SipHasher",""],["HashMap",""],["HashMapEntry",""],["HashMap_MapHashPolicy",""],["HashSet",""],["HashSet_SetHashPolicy",""],["IsDestructible","IsDestructible determines whether a type has a public destructor."],["IsPod","Traits class for identifying POD types.  Until C++11 there’s no automatic way to detect PODs, so for the moment this is done manually.  Users may define specializations of this class that inherit from std::true_type and std::false_type (or equivalently std::integral_constant<bool, true or false>, or conveniently from mozilla::IsPod for composite types) as needed to ensure correct IsPod behavior."],["LinkedList",""],["LinkedListElement",""],["LinkedList_Iterator",""],["MallocAllocPolicy",""],["Maybe",""],["Maybe_SomeGuard",""],["NeverAllocPolicy",""],["NotNull",""],["Nothing",""],["Ok","Empty struct, indicating success for operations that have no return value. For example, if you declare another empty struct `struct OutOfMemory {};`, then `Result<Ok, OutOfMemory>` represents either success or OOM."],["Opaque","Opaque is a replacement for integral T in cases where only comparisons must be supported, and it’s desirable to prevent accidental dependency on exact values."],["OwningNonNull",""],["PointerHasher",""],["Range",""],["RangedPtr",""],["ReentrancyGuard",""],["RefPtrTraits",""],["Result","Result<V, E> represents the outcome of an operation that can either succeed or fail. It contains either a success value of type V or an error value of type E."],["Span_storage_type",""],["StaticLocalRefPtr",""],["StaticRefPtr",""],["TimeDurationValueCalculator","Perform arithmetic operations on the value of a BaseTimeDuration without doing strict checks on the range of values."],["TimeStamp","Instances of this class represent moments in time, or a special “null” moment. We do not use the non-monotonic system clock or local time, since they can be reset, causing apparent backward travel in time, which can confuse algorithms. Instead we measure elapsed time according to the system.  This time can never go backwards (i.e. it never wraps around, at least not in less than five million years of system elapsed time). It might not advance while the system is sleeping. If TimeStamp::SetNow() is not called at all for hours or days, we might not notice the passage of some of that time."],["TimeStamp63Bit",""],["Tuple","Tuple is a class that stores zero or more objects, whose types are specified as template parameters. It can be thought of as a generalization of std::pair, (which can be thought of as a 2-tuple)."],["UniquePtr","UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be transferred out of a UniquePtr through explicit action, but otherwise the resource is destroyed when the UniquePtr is destroyed."],["Variant","mozilla::Variant"],["VariantType",""],["Vector_CapacityAndReserved",""],["Vector_ConstRange",""],["Vector_Range",""],["unused_t",""]],"type":[["Array_ElementType",""],["Array_const_iterator",""],["Array_const_reverse_iterator",""],["Array_iterator",""],["Array_reverse_iterator",""],["AutoCleanLinkedList_ClientType",""],["AutoCleanLinkedList_Traits",""],["CStringHasher_Key",""],["CStringHasher_Lookup",""],["CompactPair_Base",""],["DefaultHasher_Lookup",""],["EnumeratedArray_ArrayType",""],["EnumeratedArray_const_iterator",""],["EnumeratedArray_const_reverse_iterator",""],["EnumeratedArray_iterator",""],["EnumeratedArray_reverse_iterator",""],["FloatingPoint_Base",""],["FloatingPoint_Bits","An unsigned integral type suitable for accessing the bitwise representation of T."],["Generation",""],["HashMapEntry_KeyType",""],["HashMapEntry_ValueType",""],["HashMap_AddPtr",""],["HashMap_Entry",""],["HashMap_Enum",""],["HashMap_Impl",""],["HashMap_Iterator",""],["HashMap_Lookup",""],["HashMap_MapHashPolicy_Base",""],["HashMap_MapHashPolicy_KeyType",""],["HashMap_ModIterator",""],["HashMap_Ptr",""],["HashMap_Range",""],["HashMap_TableEntry",""],["HashNumber",""],["HashSet_AddPtr",""],["HashSet_Entry",""],["HashSet_Enum",""],["HashSet_Impl",""],["HashSet_Iterator",""],["HashSet_Lookup",""],["HashSet_ModIterator",""],["HashSet_Ptr",""],["HashSet_Range",""],["HashSet_SetHashPolicy_Base",""],["HashSet_SetHashPolicy_KeyType",""],["InfinityBits_Traits",""],["LinkedListElement_ClientType",""],["LinkedListElement_ConstClientType",""],["LinkedListElement_ConstRawType",""],["LinkedListElement_RawType",""],["LinkedListElement_Traits",""],["LinkedList_ClientType",""],["LinkedList_ConstClientType",""],["LinkedList_ConstElementType",""],["LinkedList_ConstRawType",""],["LinkedList_ElementType",""],["LinkedList_Iterator_difference_type",""],["LinkedList_Iterator_iterator_category",""],["LinkedList_Iterator_pointer",""],["LinkedList_Iterator_reference",""],["LinkedList_Iterator_value_type",""],["LinkedList_RawType",""],["LinkedList_Traits",""],["MallocSizeOf",""],["Maybe_ValueType",""],["PointerHasher_Lookup",""],["Result_Impl",""],["Result_err_type",""],["Result_ok_type",""],["Span_const_iterator",""],["Span_const_reverse_iterator",""],["Span_element_type",""],["Span_index_type",""],["Span_iterator",""],["Span_pointer",""],["Span_reference",""],["Span_reverse_iterator",""],["SpecificNaNBits_Traits",""],["TimeDuration","Specialization of BaseTimeDuration that uses TimeDurationValueCalculator for arithmetic on the mValue member."],["TimeStampValue",""],["Tuple_Impl",""],["UniquePtr_DeleterType",""],["UniquePtr_ElementType",""],["UniquePtr_Pointer",""],["VariantType_Type",""],["Variant_Impl",""],["Variant_Tag",""],["Vector_ElementType",""],["Vector_Impl",""]],"union":[["AlignedStorage2_U",""],["Utf8Unit","A code unit within a UTF-8 encoded string.  (A code unit is the smallest unit within the Unicode encoding of a string.  For UTF-8 this is an 8-bit number; for UTF-16 it would be a 16-bit number.)"]]});