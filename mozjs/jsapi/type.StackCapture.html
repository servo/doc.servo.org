<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="mozilla::Variant"><title>StackCapture in mozjs::jsapi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="mozjs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../mozjs/index.html">mozjs</a><span class="version">0.14.1</span></h2></div><h2 class="location"><a href="#">StackCapture</a></h2><div class="sidebar-elems"><h2><a href="index.html">In mozjs::jsapi</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Type Alias <a href="../index.html">mozjs</a>::<wbr><a href="index.html">jsapi</a>::<wbr><a class="type" href="#">StackCapture</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/mozjs_sys/home/runner/work/servo/servo/target/debug/build/mozjs_sys-143fabef74859ace/out/build/jsapi.rs.html#8942">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub type StackCapture = [<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u64.html">u64</a>; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.array.html">4</a>];</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="mozillavariant"><a class="doc-anchor" href="#mozillavariant">§</a>mozilla::Variant</h2>
<p>A variant / tagged union / heterogenous disjoint union / sum-type template
class. Similar in concept to (but not derived from) <code>boost::variant</code>.</p>
<p>Sometimes, you may wish to use a C union with non-POD types. However, this is
forbidden in C++ because it is not clear which type in the union should have
its constructor and destructor run on creation and deletion
respectively. This is the problem that <code>mozilla::Variant</code> solves.</p>
<h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3>
<p>A <code>mozilla::Variant</code> instance is constructed (via move or copy) from one of
its variant types (ignoring const and references). It does <em>not</em> support
construction from subclasses of variant types or types that coerce to one of
the variant types.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>Variant&lt;char, uint32_t&gt; v1(<span class="string">'a'</span>);
Variant&lt;UniquePtr&lt;A&gt;, B, C&gt; v2(MakeUnique&lt;A&gt;());
Variant&lt;bool, char&gt; v3(VariantType&lt;char&gt;, <span class="number">0</span>); <span class="comment">// disambiguation needed
</span>Variant&lt;int, int&gt; v4(VariantIndex&lt;<span class="number">1</span>&gt;, <span class="number">0</span>); <span class="comment">// 2nd int</span></code></pre></div>
<p>Because specifying the full type of a Variant value is often verbose,
there are two easier ways to construct values:</p>
<p>A. AsVariant() can be used to construct a Variant value using type inference
in contexts such as expressions or when returning values from functions.
Because AsVariant() must copy or move the value into a temporary and this
cannot necessarily be elided by the compiler, it’s mostly appropriate only
for use with primitive or very small types.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>Variant&lt;char, uint32_t&gt; Foo() { <span class="kw">return </span>AsVariant(<span class="string">'x'</span>); }
<span class="comment">// ...
</span>Variant&lt;char, uint32_t&gt; v1 = Foo();  <span class="comment">// v1 holds char('x').</span></code></pre></div>
<p>B. Brace-construction with VariantType or VariantIndex; this also allows
in-place construction with any number of arguments.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>AB { AB(int, int){...} };
<span class="kw">static </span>Variant&lt;AB, bool&gt; foo()
{
  <span class="kw">return </span>{VariantIndex&lt;<span class="number">0</span>&gt;{}, <span class="number">1</span>, <span class="number">2</span>};
}
<span class="comment">// ...
</span>Variant&lt;AB, bool&gt; v0 = Foo();  <span class="comment">// v0 holds AB(1,2).</span></code></pre></div>
<p>All access to the contained value goes through type-safe accessors.
Either the stored type, or the type index may be provided.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>void
Foo(Variant&lt;A, B, C&gt; v)
{
  <span class="kw">if </span>(v.is&lt;A&gt;()) {
    A&amp; <span class="kw-2">ref </span>= v.<span class="kw">as</span>&lt;A&gt;();
    ...
  } <span class="kw">else </span>(v.is&lt;<span class="number">1</span>&gt;()) { <span class="comment">// Instead of v.is&lt;B&gt;.
    </span>...
  } <span class="kw">else </span>{
    ...
  }
}</code></pre></div>
<p>In some situation, a Variant may be constructed from templated types, in
which case it is possible that the same type could be given multiple times by
an external developer. Or seemingly-different types could be aliases.
In this case, repeated types can only be accessed through their index, to
prevent ambiguous access by type.</p>
<p>// Bad!
template <typename T>
struct ResultOrError
{
Variant&lt;T, int&gt; m;
ResultOrError() : m(int(0)) {} // Error ‘0’ by default
ResultOrError(const T&amp; r) : m(r) {}
bool IsResult() const { return m.is<T>(); }
bool IsError() const { return m.is<int>(); }
};
// Now instantiante with the result being an int too:
ResultOrError<int> myResult(123); // Fail!
// In Variant&lt;int, int&gt;, which ‘int’ are we refering to, from inside
// ResultOrError functions?</p>
<p>// Good!
template <typename T>
struct ResultOrError
{
Variant&lt;T, int&gt; m;
ResultOrError() : m(VariantIndex&lt;1&gt;{}, 0) {} // Error ‘0’ by default
ResultOrError(const T&amp; r) : m(VariantIndex&lt;0&gt;{}, r) {}
bool IsResult() const { return m.is&lt;0&gt;(); } // 0 -&gt; T
bool IsError() const { return m.is&lt;1&gt;(); } // 1 -&gt; int
};
// Now instantiante with the result being an int too:
ResultOrError<int> myResult(123); // It now works!</p>
<p>Attempting to use the contained value as type <code>T1</code> when the <code>Variant</code>
instance contains a value of type <code>T2</code> causes an assertion failure.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>A a;
Variant&lt;A, B, C&gt; v(a);
v.<span class="kw">as</span>&lt;B&gt;(); <span class="comment">// &lt;--- Assertion failure!</span></code></pre></div>
<p>Trying to use a <code>Variant&lt;Ts...&gt;</code> instance as some type <code>U</code> that is not a
member of the set of <code>Ts...</code> is a compiler error.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>A a;
Variant&lt;A, B, C&gt; v(a);
v.<span class="kw">as</span>&lt;SomeRandomType&gt;(); <span class="comment">// &lt;--- Compiler error!</span></code></pre></div>
<p>Additionally, you can turn a <code>Variant</code> that <code>is&lt;T&gt;</code> into a <code>T</code> by moving it
out of the containing <code>Variant</code> instance with the <code>extract&lt;T&gt;</code> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>Variant&lt;UniquePtr&lt;A&gt;, B, C&gt; v(MakeUnique&lt;A&gt;());
auto ptr = v.extract&lt;UniquePtr&lt;A&gt;&gt;();</code></pre></div>
<p>Finally, you can exhaustively match on the contained variant and branch into
different code paths depending on which type is contained. This is preferred
to manually checking every variant type T with is<T>() because it provides
compile-time checking that you handled every type, rather than runtime
assertion failures.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Bad!
</span>char* foo(Variant&lt;A, B, C, D&gt;&amp; v) {
  <span class="kw">if </span>(v.is&lt;A&gt;()) {
    <span class="kw">return </span>...;
  } <span class="kw">else if </span>(v.is&lt;B&gt;()) {
    <span class="kw">return </span>...;
  } <span class="kw">else </span>{
    <span class="kw">return </span>doSomething(v.<span class="kw">as</span>&lt;C&gt;()); <span class="comment">// Forgot about case D!
  </span>}
}

<span class="comment">// Instead, a single function object (that can deal with all possible
// options) may be provided:
</span><span class="kw">struct </span>FooMatcher
{
  <span class="comment">// The return type of all matchers must be identical.
  </span>char* operator()(A&amp; a) { ... }
  char* operator()(B&amp; b) { ... }
  char* operator()(C&amp; c) { ... }
  char* operator()(D&amp; d) { ... } <span class="comment">// Compile-time error to forget D!
</span>}
char* foo(Variant&lt;A, B, C, D&gt;&amp; v) {
  <span class="kw">return </span>v.<span class="kw">match</span>(FooMatcher());
}

<span class="comment">// In some situations, a single generic lambda may also be appropriate:
</span>char* foo(Variant&lt;A, B, C, D&gt;&amp; v) {
  <span class="kw">return </span>v.<span class="kw">match</span>([](auto<span class="kw-2">&amp;</span>) {...});
}

<span class="comment">// Alternatively, multiple function objects may be provided, each one
// corresponding to an option, in the same order:
</span>char* foo(Variant&lt;A, B, C, D&gt;&amp; v) {
  <span class="kw">return </span>v.<span class="kw">match</span>([](A<span class="kw-2">&amp;</span>) { ... },
                 [](B<span class="kw-2">&amp;</span>) { ... },
                 [](C<span class="kw-2">&amp;</span>) { ... },
                 [](D<span class="kw-2">&amp;</span>) { ... });
}

<span class="comment">// In rare cases, the index of the currently-active alternative is
// needed, it may be obtained by adding a first parameter in the matcner
// callback, which will receive the index in its most compact type (just
// use `size_t` if the exact type is not important), e.g.:
</span>char* foo(Variant&lt;A, B, C, D&gt;&amp; v) {
  <span class="kw">return </span>v.<span class="kw">match</span>([](auto aIndex, auto&amp; aAlternative) {...});
  <span class="comment">// --OR--
  </span><span class="kw">return </span>v.<span class="kw">match</span>([](size_t aIndex, auto&amp; aAlternative) {...});
}</code></pre></div>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<p>A tree is either an empty leaf, or a node with a value and two children:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Leaf { };

template&lt;typename T&gt;
<span class="kw">struct </span>Node
{
  T value;
  Tree&lt;T&gt;* left;
  Tree&lt;T&gt;* right;
};

template&lt;typename T&gt;
using Tree = Variant&lt;Leaf, Node&lt;T&gt;&gt;;</code></pre></div>
<p>A copy-on-write string is either a non-owning reference to some existing
string, or an owning reference to our copy:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>class CopyOnWriteString
{
  Variant&lt;<span class="kw">const </span>char<span class="kw-2">*</span>, UniquePtr&lt;char[]&gt;&gt; string;

  ...
};</code></pre></div>
<p>Because Variant must be aligned suitable to hold any value stored within it,
and because |alignas| requirements don’t affect platform ABI with respect to
how parameters are laid out in memory, Variant can’t be used as the type of a
function parameter.  Pass Variant to functions by pointer or reference
instead.</p>
</div></details></section></div></main></body></html>