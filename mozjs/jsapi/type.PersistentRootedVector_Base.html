<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A copyable, assignable global GC root type with arbitrary lifetime, an infallible constructor, and automatic unrooting on destruction."><title>PersistentRootedVector_Base in mozjs::jsapi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="mozjs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../mozjs/index.html">mozjs</a><span class="version">0.14.1</span></h2></div><h2 class="location"><a href="#">PersistentRootedVector_Base</a></h2><div class="sidebar-elems"><h2><a href="index.html">In mozjs::jsapi</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Type Alias <a href="../index.html">mozjs</a>::<wbr><a href="index.html">jsapi</a>::<wbr><a class="type" href="#">PersistentRootedVector_Base</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/mozjs_sys/home/runner/work/servo/servo/target/debug/build/mozjs_sys-143fabef74859ace/out/build/jsapi.rs.html#9410">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub type PersistentRootedVector_Base = <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u8.html">u8</a>;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A copyable, assignable global GC root type with arbitrary lifetime, an
infallible constructor, and automatic unrooting on destruction.</p>
<p>These roots can be used in heap-allocated data structures, so they are not
associated with any particular JSContext or stack. They are registered with
the JSRuntime itself, without locking. Initialization may take place on
construction, or in two phases if the no-argument constructor is called
followed by init().</p>
<p>Note that you must not use an PersistentRooted in an object owned by a JS
object:</p>
<p>Whenever one object whose lifetime is decided by the GC refers to another
such object, that edge must be traced only if the owning JS object is traced.
This applies not only to JS objects (which obviously are managed by the GC)
but also to C++ objects owned by JS objects.</p>
<p>If you put a PersistentRooted in such a C++ object, that is almost certainly
a leak. When a GC begins, the referent of the PersistentRooted is treated as
live, unconditionally (because a PersistentRooted is a <em>root</em>), even if the
JS object that owns it is unreachable. If there is any path from that
referent back to the JS object, then the C++ object containing the
PersistentRooted will not be destructed, and the whole blob of objects will
not be freed, even if there are no references to them from the outside.</p>
<p>In the context of Firefox, this is a severe restriction: almost everything in
Firefox is owned by some JS object or another, so using PersistentRooted in
such objects would introduce leaks. For these kinds of edges, Heap<T> or
TenuredHeap<T> would be better types. It’s up to the implementor of the type
containing Heap<T> or TenuredHeap<T> members to make sure their referents get
marked when the object itself is marked.</p>
</div></details></section></div></main></body></html>