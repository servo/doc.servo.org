<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Provides a way to run a memchr-like function while amortizing the cost of runtime CPU feature detection."><title>unsafe_ifunc in memchr::arch::x86_64::memchr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="memchr" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../memchr/index.html">memchr</a><span class="version">2.7.4</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In memchr::arch::x86_64::memchr</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Macro <a href="../../../index.html">memchr</a>::<wbr><a href="../../index.html">arch</a>::<wbr><a href="../index.html">x86_64</a>::<wbr><a href="index.html">memchr</a>::<wbr><a class="macro" href="#">unsafe_ifunc</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../../src/memchr/arch/x86_64/memchr.rs.html#58-160">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><span class="macro">macro_rules!</span> unsafe_ifunc {
    (
        <span class="macro-nonterminal">$memchrty</span>:ident,
        <span class="macro-nonterminal">$memchrfind</span>:ident,
        <span class="macro-nonterminal">$fnty</span>:ty,
        <span class="macro-nonterminal">$retty</span>:ty,
        <span class="macro-nonterminal">$hay_start</span>:ident,
        <span class="macro-nonterminal">$hay_end</span>:ident,
        $(<span class="macro-nonterminal">$needle</span>:ident),+
    ) =&gt; { ... };
}</pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Provides a way to run a memchr-like function while amortizing the cost of
runtime CPU feature detection.</p>
<p>This works by loading a function pointer from an atomic global. Initially,
this global is set to a function that does CPU feature detection. For
example, if AVX2 is enabled, then the AVX2 implementation is used.
Otherwise, at least on x86_64, the SSE2 implementation is used. (And
in some niche cases, if SSE2 isn’t available, then the architecture
independent fallback implementation is used.)</p>
<p>After the first call to this function, the atomic global is replaced with
the specific AVX2, SSE2 or fallback routine chosen. Subsequent calls then
will directly call the chosen routine instead of needing to go through the
CPU feature detection branching again.</p>
<p>This particular macro is specifically written to provide the implementation
of functions with the following signature:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>memchr(needle1: u8, start: <span class="kw-2">*const </span>u8, end: <span class="kw-2">*const </span>u8) -&gt; <span class="prelude-ty">Option</span>&lt;usize&gt;;</code></pre></div>
<p>Where you can also have <code>memchr2</code> and <code>memchr3</code>, but with <code>needle2</code> and
<code>needle3</code>, respectively. The <code>start</code> and <code>end</code> parameters correspond to the
start and end of the haystack, respectively.</p>
<p>We use raw pointers here instead of the more obvious <code>haystack: &amp;[u8]</code> so
that the function is compatible with our lower level iterator logic that
operates on raw pointers. We use this macro to implement “raw” memchr
routines with the signature above, and then define memchr routines using
regular slices on top of them.</p>
<p>Note that we use <code>#[cfg(target_feature = &quot;sse2&quot;)]</code> below even though
it shouldn’t be strictly necessary because without it, it seems to
cause the compiler to blow up. I guess it can’t handle a function
pointer being created with a sse target feature? Dunno. See the
<code>build-for-x86-64-but-non-sse-target</code> CI job if you want to experiment with
this.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>Primarily callers must that <code>$fnty</code> is a correct function pointer type and
not something else.</p>
<p>Callers must also ensure that <code>$memchrty::$memchrfind</code> corresponds to a
routine that returns a valid function pointer when a match is found. That
is, a pointer that is <code>&gt;= start</code> and <code>&lt; end</code>.</p>
<p>Callers must also ensure that the <code>$hay_start</code> and <code>$hay_end</code> identifiers
correspond to valid pointers.</p>
</div></details></section></div></main></body></html>