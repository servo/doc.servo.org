initSidebarItems({"constant":[["GLOBAL_POOL_ALREADY_INITIALIZED",""]],"enum":[["ErrorKind",""]],"fn":[["current_num_threads","Returns the number of threads in the current registry. If this code is executing within a Rayon thread-pool, then this will be the number of threads for the thread-pool of the current thread. Otherwise, it will be the number of threads for the global thread-pool."],["current_thread_has_pending_tasks","If called from a Rayon worker thread, indicates whether that thread’s local deque still has pending tasks. Otherwise, returns `None`. For more information, see the `ThreadPool::current_thread_has_pending_tasks()` method."],["current_thread_index","If called from a Rayon worker thread, returns the index of that thread within its current pool; if not called from a Rayon thread, returns `None`."],["in_place_scope","Creates a “fork-join” scope `s` and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete."],["in_place_scope_fifo","Creates a “fork-join” scope `s` with FIFO order, and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete."],["initialize","Deprecated in favor of `ThreadPoolBuilder::build_global`."],["join","Takes two closures and potentially runs them in parallel. It returns a pair of the results from those closures."],["join_context","Identical to `join`, except that the closures have a parameter that provides context for the way the closure has been called, especially indicating whether they’re executing on a different thread than where `join_context` was called.  This will occur if the second job is stolen by a different thread, or if `join_context` was called from outside the thread pool to begin with."],["scope","Creates a “fork-join” scope `s` and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete."],["scope_fifo","Creates a “fork-join” scope `s` with FIFO order, and invokes the closure with a reference to `s`. This closure can then spawn asynchronous tasks into `s`. Those tasks may run asynchronously with respect to the closure; they may themselves spawn additional tasks into `s`. When the closure returns, it will block until all tasks that have been spawned into `s` complete."],["spawn","Fires off a task into the Rayon threadpool in the “static” or “global” scope.  Just like a standard thread, this task is not tied to the current stack frame, and hence it cannot hold any references other than those with `'static` lifetime. If you want to spawn a task that references stack data, use the `scope()` function to create a scope."],["spawn_fifo","Fires off a task into the Rayon threadpool in the “static” or “global” scope.  Just like a standard thread, this task is not tied to the current stack frame, and hence it cannot hold any references other than those with `'static` lifetime. If you want to spawn a task that references stack data, use the `scope_fifo()` function to create a scope."]],"mod":[["compile_fail",""],["job",""],["join",""],["latch",""],["log","Debug Logging"],["private","The public parts of this private module are used to create traits that cannot be implemented outside of our own crate.  This way we can feel free to extend those traits without worrying about it being a breaking change for other implementations."],["registry",""],["scope","Methods for custom fork-join scopes, created by the `scope()` and `in_place_scope()` functions. These are a more flexible alternative to `join()`."],["sleep","Code that decides when workers should go to sleep. See README.md for an overview."],["spawn",""],["thread_pool","Contains support for user-managed thread pools, represented by the the `ThreadPool` type (see that struct for details)."],["unwind","Package up unwind recovery. Note that if you are in some sensitive place, you can use the `AbortIfPanic` helper to protect against accidental panics in the rayon code itself."]],"struct":[["Configuration","Contains the rayon thread pool configuration. Use `ThreadPoolBuilder` instead."],["FnContext","Provides the calling context to a closure called by `join_context`."],["Scope","Represents a fork-join scope which can be used to spawn any number of tasks. See `scope()` for more information."],["ScopeFifo","Represents a fork-join scope which can be used to spawn any number of tasks. Those spawned from the same thread are prioritized in relative FIFO order. See `scope_fifo()` for more information."],["ThreadBuilder","Thread builder used for customization via `ThreadPoolBuilder::spawn_handler`."],["ThreadPool","Represents a user created thread-pool."],["ThreadPoolBuildError","Error when initializing a thread pool."],["ThreadPoolBuilder","Used to create a new `ThreadPool` or to configure the global rayon thread pool."]],"type":[["ExitHandler","The type for a closure that gets invoked when a thread exits. The closure is passed the index of the thread on which is is invoked. Note that this same closure may be invoked multiple times in parallel."],["PanicHandler","The type for a panic handling closure. Note that this same closure may be invoked multiple times in parallel."],["StartHandler","The type for a closure that gets invoked when a thread starts. The closure is passed the index of the thread on which it is invoked. Note that this same closure may be invoked multiple times in parallel."]]});