<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="ParserI is the internal parser implementation."><title>ParserI in regex_syntax::ast::parse - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="regex_syntax" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../regex_syntax/index.html">regex_syntax</a><span class="version">0.8.5</span></h2></div><h2 class="location"><a href="#">ParserI</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.parser">parser</a></li><li><a href="#structfield.pattern">pattern</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add_capture_name">add_capture_name</a></li><li><a href="#method.bump">bump</a></li><li><a href="#method.bump_and_bump_space">bump_and_bump_space</a></li><li><a href="#method.bump_if">bump_if</a></li><li><a href="#method.bump_space">bump_space</a></li><li><a href="#method.char">char</a></li><li><a href="#method.char_at">char_at</a></li><li><a href="#method.column">column</a></li><li><a href="#method.error">error</a></li><li><a href="#method.ignore_whitespace">ignore_whitespace</a></li><li><a href="#method.is_eof">is_eof</a></li><li><a href="#method.is_lookaround_prefix">is_lookaround_prefix</a></li><li><a href="#method.line">line</a></li><li><a href="#method.maybe_parse_ascii_class">maybe_parse_ascii_class</a></li><li><a href="#method.maybe_parse_special_word_boundary">maybe_parse_special_word_boundary</a></li><li><a href="#method.new">new</a></li><li><a href="#method.next_capture_index">next_capture_index</a></li><li><a href="#method.offset">offset</a></li><li><a href="#method.parse">parse</a></li><li><a href="#method.parse_capture_name">parse_capture_name</a></li><li><a href="#method.parse_counted_repetition">parse_counted_repetition</a></li><li><a href="#method.parse_decimal">parse_decimal</a></li><li><a href="#method.parse_escape">parse_escape</a></li><li><a href="#method.parse_flag">parse_flag</a></li><li><a href="#method.parse_flags">parse_flags</a></li><li><a href="#method.parse_group">parse_group</a></li><li><a href="#method.parse_hex">parse_hex</a></li><li><a href="#method.parse_hex_brace">parse_hex_brace</a></li><li><a href="#method.parse_hex_digits">parse_hex_digits</a></li><li><a href="#method.parse_octal">parse_octal</a></li><li><a href="#method.parse_perl_class">parse_perl_class</a></li><li><a href="#method.parse_primitive">parse_primitive</a></li><li><a href="#method.parse_set_class">parse_set_class</a></li><li><a href="#method.parse_set_class_item">parse_set_class_item</a></li><li><a href="#method.parse_set_class_open">parse_set_class_open</a></li><li><a href="#method.parse_set_class_range">parse_set_class_range</a></li><li><a href="#method.parse_uncounted_repetition">parse_uncounted_repetition</a></li><li><a href="#method.parse_unicode_class">parse_unicode_class</a></li><li><a href="#method.parse_with_comments">parse_with_comments</a></li><li><a href="#method.parser">parser</a></li><li><a href="#method.pattern">pattern</a></li><li><a href="#method.peek">peek</a></li><li><a href="#method.peek_space">peek_space</a></li><li><a href="#method.pop_class">pop_class</a></li><li><a href="#method.pop_class_op">pop_class_op</a></li><li><a href="#method.pop_group">pop_group</a></li><li><a href="#method.pop_group_end">pop_group_end</a></li><li><a href="#method.pos">pos</a></li><li><a href="#method.push_alternate">push_alternate</a></li><li><a href="#method.push_class_op">push_class_op</a></li><li><a href="#method.push_class_open">push_class_open</a></li><li><a href="#method.push_group">push_group</a></li><li><a href="#method.push_or_add_alternation">push_or_add_alternation</a></li><li><a href="#method.span">span</a></li><li><a href="#method.span_char">span_char</a></li><li><a href="#method.unclosed_class_error">unclosed_class_error</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-ParserI%3C's,+P%3E">Clone</a></li><li><a href="#impl-Debug-for-ParserI%3C's,+P%3E">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-ParserI%3C's,+P%3E">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-ParserI%3C's,+P%3E">RefUnwindSafe</a></li><li><a href="#impl-Send-for-ParserI%3C's,+P%3E">Send</a></li><li><a href="#impl-Sync-for-ParserI%3C's,+P%3E">Sync</a></li><li><a href="#impl-Unpin-for-ParserI%3C's,+P%3E">Unpin</a></li><li><a href="#impl-UnwindSafe-for-ParserI%3C's,+P%3E">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In regex_syntax::ast::parse</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">regex_syntax</a>::<wbr><a href="../index.html">ast</a>::<wbr><a href="index.html">parse</a>::<wbr><a class="struct" href="#">ParserI</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/regex_syntax/ast/parse.rs.html#295-300">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>struct ParserI&lt;'s, P&gt; {
    parser: P,
    pattern: &amp;'s <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>ParserI is the internal parser implementation.</p>
<p>We use this separate type so that we can carry the provided pattern string
along with us. In particular, a <code>Parser</code> internal state is not tied to any
one pattern, but <code>ParserI</code> is.</p>
<p>This type also lets us use <code>ParserI&lt;&amp;Parser&gt;</code> in production code while
retaining the convenience of <code>ParserI&lt;Parser&gt;</code> for tests, which sometimes
work against the internal interface of the parser.</p>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.parser" class="structfield section-header"><a href="#structfield.parser" class="anchor field">§</a><code>parser: P</code></span><div class="docblock"><p>The parser state/configuration.</p>
</div><span id="structfield.pattern" class="structfield section-header"><a href="#structfield.pattern" class="anchor field">§</a><code>pattern: &amp;'s <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a></code></span><div class="docblock"><p>The full regular expression provided by the user.</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-ParserI%3C's,+P%3E" class="impl"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#391-972">source</a><a href="#impl-ParserI%3C's,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'s, P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="struct.Parser.html" title="struct regex_syntax::ast::parse::Parser">Parser</a>&gt;&gt; <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#393-395">source</a><h4 class="code-header">fn <a href="#method.new" class="fn">new</a>(parser: P, pattern: &amp;'s <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;</h4></section></summary><div class="docblock"><p>Build an internal parser from a parser configuration and a pattern.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parser" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#398-400">source</a><h4 class="code-header">fn <a href="#method.parser" class="fn">parser</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.Parser.html" title="struct regex_syntax::ast::parse::Parser">Parser</a></h4></section></summary><div class="docblock"><p>Return a reference to the parser state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pattern" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#403-405">source</a><h4 class="code-header">fn <a href="#method.pattern" class="fn">pattern</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Return a reference to the pattern being parsed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.error" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#408-410">source</a><h4 class="code-header">fn <a href="#method.error" class="fn">error</a>(&amp;self, span: <a class="struct" href="../struct.Span.html" title="struct regex_syntax::ast::Span">Span</a>, kind: <a class="enum" href="../enum.ErrorKind.html" title="enum regex_syntax::ast::ErrorKind">ErrorKind</a>) -&gt; <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a></h4></section></summary><div class="docblock"><p>Create a new error with the given span and error type.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.offset" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#416-418">source</a><h4 class="code-header">fn <a href="#method.offset" class="fn">offset</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the current offset of the parser.</p>
<p>The offset starts at <code>0</code> from the beginning of the regular expression
pattern string.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.line" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#423-425">source</a><h4 class="code-header">fn <a href="#method.line" class="fn">line</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the current line number of the parser.</p>
<p>The line number starts at <code>1</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.column" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#430-432">source</a><h4 class="code-header">fn <a href="#method.column" class="fn">column</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Return the current column of the parser.</p>
<p>The column number starts at <code>1</code> and is reset whenever a <code>\n</code> is seen.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.next_capture_index" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#441-448">source</a><h4 class="code-header">fn <a href="#method.next_capture_index" class="fn">next_capture_index</a>(&amp;self, span: <a class="struct" href="../struct.Span.html" title="struct regex_syntax::ast::Span">Span</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Return the next capturing index. Each subsequent call increments the
internal index.</p>
<p>The span given should correspond to the location of the opening
parenthesis.</p>
<p>If the capture limit is exceeded, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_capture_name" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#452-466">source</a><h4 class="code-header">fn <a href="#method.add_capture_name" class="fn">add_capture_name</a>(&amp;self, cap: &amp;<a class="struct" href="../struct.CaptureName.html" title="struct regex_syntax::ast::CaptureName">CaptureName</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Adds the given capture name to this parser. If this capture name has
already been used, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ignore_whitespace" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#469-471">source</a><h4 class="code-header">fn <a href="#method.ignore_whitespace" class="fn">ignore_whitespace</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return whether the parser should ignore whitespace or not.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.char" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#476-478">source</a><h4 class="code-header">fn <a href="#method.char" class="fn">char</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.char.html">char</a></h4></section></summary><div class="docblock"><p>Return the character at the current position of the parser.</p>
<p>This panics if the current position does not point to a valid char.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.char_at" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#483-488">source</a><h4 class="code-header">fn <a href="#method.char_at" class="fn">char_at</a>(&amp;self, i: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.char.html">char</a></h4></section></summary><div class="docblock"><p>Return the character at the given position.</p>
<p>This panics if the given position does not point to a valid char.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bump" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#493-507">source</a><h4 class="code-header">fn <a href="#method.bump" class="fn">bump</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Bump the parser to the next Unicode scalar value.</p>
<p>If the end of the input has been reached, then <code>false</code> is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bump_if" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#513-522">source</a><h4 class="code-header">fn <a href="#method.bump_if" class="fn">bump_if</a>(&amp;self, prefix: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>If the substring starting at the current position of the parser has
the given prefix, then bump the parser to the character immediately
following the prefix and return true. Otherwise, don’t bump the parser
and return false.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_lookaround_prefix" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#531-536">source</a><h4 class="code-header">fn <a href="#method.is_lookaround_prefix" class="fn">is_lookaround_prefix</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if the parser is positioned at a look-around
prefix. The conditions under which this returns true must always
correspond to a regular expression that would otherwise be consider
invalid.</p>
<p>This should only be called immediately after parsing the opening of
a group or a set of flags.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bump_and_bump_space" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#541-547">source</a><h4 class="code-header">fn <a href="#method.bump_and_bump_space" class="fn">bump_and_bump_space</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Bump the parser, and if the <code>x</code> flag is enabled, bump through any
subsequent spaces. Return true if and only if the parser is not at
EOF.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bump_space" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#558-586">source</a><h4 class="code-header">fn <a href="#method.bump_space" class="fn">bump_space</a>(&amp;self)</h4></section></summary><div class="docblock"><p>If the <code>x</code> flag is enabled (i.e., whitespace insensitivity with
comments), then this will advance the parser through all whitespace
and comments to the next non-whitespace non-comment byte.</p>
<p>If the <code>x</code> flag is disabled, then this is a no-op.</p>
<p>This should be used selectively throughout the parser where
arbitrary whitespace is permitted when the <code>x</code> flag is enabled. For
example, <code>{   5  , 6}</code> is equivalent to <code>{5,6}</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#591-596">source</a><h4 class="code-header">fn <a href="#method.peek" class="fn">peek</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.char.html">char</a>&gt;</h4></section></summary><div class="docblock"><p>Peek at the next character in the input without advancing the parser.</p>
<p>If the input has been exhausted, then this returns <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek_space" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#600-622">source</a><h4 class="code-header">fn <a href="#method.peek_space" class="fn">peek_space</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.char.html">char</a>&gt;</h4></section></summary><div class="docblock"><p>Like peek, but will ignore spaces when the parser is in whitespace
insensitive mode.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_eof" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#625-627">source</a><h4 class="code-header">fn <a href="#method.is_eof" class="fn">is_eof</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if the next call to <code>bump</code> would return false.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pos" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#631-633">source</a><h4 class="code-header">fn <a href="#method.pos" class="fn">pos</a>(&amp;self) -&gt; <a class="struct" href="../struct.Position.html" title="struct regex_syntax::ast::Position">Position</a></h4></section></summary><div class="docblock"><p>Return the current position of the parser, which includes the offset,
line and column.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.span" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#637-639">source</a><h4 class="code-header">fn <a href="#method.span" class="fn">span</a>(&amp;self) -&gt; <a class="struct" href="../struct.Span.html" title="struct regex_syntax::ast::Span">Span</a></h4></section></summary><div class="docblock"><p>Create a span at the current position of the parser. Both the start
and end of the span are set.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.span_char" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#642-653">source</a><h4 class="code-header">fn <a href="#method.span_char" class="fn">span_char</a>(&amp;self) -&gt; <a class="struct" href="../struct.Span.html" title="struct regex_syntax::ast::Span">Span</a></h4></section></summary><div class="docblock"><p>Create a span that covers the current character.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push_alternate" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#665-671">source</a><h4 class="code-header">fn <a href="#method.push_alternate" class="fn">push_alternate</a>(&amp;self, concat: <a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse and push a single alternation on to the parser’s internal stack.
If the top of the stack already has an alternation, then add to that
instead of pushing a new one.</p>
<p>The concatenation given corresponds to a single alternation branch.
The concatenation returned starts the next branch and is empty.</p>
<p>This assumes the parser is currently positioned at <code>|</code> and will advance
the parser to the character following <code>|</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push_or_add_alternation" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#675-687">source</a><h4 class="code-header">fn <a href="#method.push_or_add_alternation" class="fn">push_or_add_alternation</a>(&amp;self, concat: <a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>)</h4></section></summary><div class="docblock"><p>Pushes or adds the given branch of an alternation to the parser’s
internal stack of state.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push_group" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#703-732">source</a><h4 class="code-header">fn <a href="#method.push_group" class="fn">push_group</a>(&amp;self, concat: <a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse and push a group AST (and its parent concatenation) on to the
parser’s internal stack. Return a fresh concatenation corresponding
to the group’s sub-AST.</p>
<p>If a set of flags was found (with no group), then the concatenation
is returned with that set of flags added.</p>
<p>This assumes that the parser is currently positioned on the opening
parenthesis. It advances the parser to the character at the start
of the sub-expression (or adjoining expression).</p>
<p>If there was a problem parsing the start of the group, then an error
is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_group" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#744-787">source</a><h4 class="code-header">fn <a href="#method.pop_group" class="fn">pop_group</a>(&amp;self, group_concat: <a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Pop a group AST from the parser’s internal stack and set the group’s
AST to the given concatenation. Return the concatenation containing
the group.</p>
<p>This assumes that the parser is currently positioned on the closing
parenthesis and advances the parser to the character following the <code>)</code>.</p>
<p>If no such group could be popped, then an unopened group error is
returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_group_end" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#796-828">source</a><h4 class="code-header">fn <a href="#method.pop_group_end" class="fn">pop_group_end</a>(&amp;self, concat: <a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../enum.Ast.html" title="enum regex_syntax::ast::Ast">Ast</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Pop the last state from the parser’s internal stack, if it exists, and
add the given concatenation to it. There either must be no state or a
single alternation item on the stack. Any other scenario produces an
error.</p>
<p>This assumes that the parser has advanced to the end.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push_class_open" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#839-851">source</a><h4 class="code-header">fn <a href="#method.push_class_open" class="fn">push_class_open</a>(
    &amp;self,
    parent_union: <a class="struct" href="../struct.ClassSetUnion.html" title="struct regex_syntax::ast::ClassSetUnion">ClassSetUnion</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.ClassSetUnion.html" title="struct regex_syntax::ast::ClassSetUnion">ClassSetUnion</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the opening of a character class and push the current class
parsing context onto the parser’s stack. This assumes that the parser
is positioned at an opening <code>[</code>. The given union should correspond to
the union of set items built up before seeing the <code>[</code>.</p>
<p>If there was a problem parsing the opening of the class, then an error
is returned. Otherwise, a new union of set items for the class is
returned (which may be populated with either a <code>]</code> or a <code>-</code>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_class" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#868-910">source</a><h4 class="code-header">fn <a href="#method.pop_class" class="fn">pop_class</a>(
    &amp;self,
    nested_union: <a class="struct" href="../struct.ClassSetUnion.html" title="struct regex_syntax::ast::ClassSetUnion">ClassSetUnion</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../../either/enum.Either.html" title="enum regex_syntax::either::Either">Either</a>&lt;<a class="struct" href="../struct.ClassSetUnion.html" title="struct regex_syntax::ast::ClassSetUnion">ClassSetUnion</a>, <a class="struct" href="../struct.ClassBracketed.html" title="struct regex_syntax::ast::ClassBracketed">ClassBracketed</a>&gt;, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the end of a character class set and pop the character class
parser stack. The union given corresponds to the last union built
before seeing the closing <code>]</code>. The union returned corresponds to the
parent character class set with the nested class added to it.</p>
<p>This assumes that the parser is positioned at a <code>]</code> and will advance
the parser to the byte immediately following the <code>]</code>.</p>
<p>If the stack is empty after popping, then this returns the final
“top-level” character class AST (where a “top-level” character class
is one that is not nested inside any other character class).</p>
<p>If there is no corresponding opening bracket on the parser’s stack,
then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.unclosed_class_error" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#917-926">source</a><h4 class="code-header">fn <a href="#method.unclosed_class_error" class="fn">unclosed_class_error</a>(&amp;self) -&gt; <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a></h4></section></summary><div class="docblock"><p>Return an “unclosed class” error whose span points to the most
recently opened class.</p>
<p>This should only be called while parsing a character class.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push_class_op" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#934-946">source</a><h4 class="code-header">fn <a href="#method.push_class_op" class="fn">push_class_op</a>(
    &amp;self,
    next_kind: <a class="enum" href="../enum.ClassSetBinaryOpKind.html" title="enum regex_syntax::ast::ClassSetBinaryOpKind">ClassSetBinaryOpKind</a>,
    next_union: <a class="struct" href="../struct.ClassSetUnion.html" title="struct regex_syntax::ast::ClassSetUnion">ClassSetUnion</a>,
) -&gt; <a class="struct" href="../struct.ClassSetUnion.html" title="struct regex_syntax::ast::ClassSetUnion">ClassSetUnion</a></h4></section></summary><div class="docblock"><p>Push the current set of class items on to the class parser’s stack as
the left hand side of the given operator.</p>
<p>A fresh set union is returned, which should be used to build the right
hand side of this operator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop_class_op" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#954-971">source</a><h4 class="code-header">fn <a href="#method.pop_class_op" class="fn">pop_class_op</a>(&amp;self, rhs: <a class="enum" href="../enum.ClassSet.html" title="enum regex_syntax::ast::ClassSet">ClassSet</a>) -&gt; <a class="enum" href="../enum.ClassSet.html" title="enum regex_syntax::ast::ClassSet">ClassSet</a></h4></section></summary><div class="docblock"><p>Pop a character class set from the character class parser stack. If the
top of the stack is just an item (not an operation), then return the
given set unchanged. If the top of the stack is an operation, then the
given set will be used as the rhs of the operation on the top of the
stack. In that case, the binary operation is returned as a set.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-ParserI%3C's,+P%3E-1" class="impl"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#974-2261">source</a><a href="#impl-ParserI%3C's,+P%3E-1" class="anchor">§</a><h3 class="code-header">impl&lt;'s, P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="struct.Parser.html" title="struct regex_syntax::ast::parse::Parser">Parser</a>&gt;&gt; <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#976-978">source</a><h4 class="code-header">fn <a href="#method.parse" class="fn">parse</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../enum.Ast.html" title="enum regex_syntax::ast::Ast">Ast</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the regular expression into an abstract syntax tree.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_with_comments" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#982-1032">source</a><h4 class="code-header">fn <a href="#method.parse_with_comments" class="fn">parse_with_comments</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.WithComments.html" title="struct regex_syntax::ast::WithComments">WithComments</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the regular expression and return an abstract syntax tree with
all of the comments found in the pattern.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_uncounted_repetition" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1048-1088">source</a><h4 class="code-header">fn <a href="#method.parse_uncounted_repetition" class="fn">parse_uncounted_repetition</a>(
    &amp;self,
    concat: <a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>,
    kind: <a class="enum" href="../enum.RepetitionKind.html" title="enum regex_syntax::ast::RepetitionKind">RepetitionKind</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses an uncounted repetition operation. An uncounted repetition
operator includes ?, * and +, but does not include the {m,n} syntax.
The given <code>kind</code> should correspond to the operator observed by the
caller.</p>
<p>This assumes that the parser is currently positioned at the repetition
operator and advances the parser to the first character after the
operator. (Note that the operator may include a single additional <code>?</code>,
which makes the operator ungreedy.)</p>
<p>The caller should include the concatenation that is being built. The
concatenation returned includes the repetition operator applied to the
last expression in the given concatenation.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_counted_repetition" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1103-1206">source</a><h4 class="code-header">fn <a href="#method.parse_counted_repetition" class="fn">parse_counted_repetition</a>(&amp;self, concat: <a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Concat.html" title="struct regex_syntax::ast::Concat">Concat</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses a counted repetition operation. A counted repetition operator
corresponds to the {m,n} syntax, and does not include the ?, * or +
operators.</p>
<p>This assumes that the parser is currently positioned at the opening <code>{</code>
and advances the parser to the first character after the operator.
(Note that the operator may include a single additional <code>?</code>, which
makes the operator ungreedy.)</p>
<p>The caller should include the concatenation that is being built. The
concatenation returned includes the repetition operator applied to the
last expression in the given concatenation.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_group" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1227-1289">source</a><h4 class="code-header">fn <a href="#method.parse_group" class="fn">parse_group</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../../either/enum.Either.html" title="enum regex_syntax::either::Either">Either</a>&lt;<a class="struct" href="../struct.SetFlags.html" title="struct regex_syntax::ast::SetFlags">SetFlags</a>, <a class="struct" href="../struct.Group.html" title="struct regex_syntax::ast::Group">Group</a>&gt;, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a group (which contains a sub-expression) or a set of flags.</p>
<p>If a group was found, then it is returned with an empty AST. If a set
of flags is found, then that set is returned.</p>
<p>The parser should be positioned at the opening parenthesis.</p>
<p>This advances the parser to the character before the start of the
sub-expression (in the case of a group) or to the closing parenthesis
immediately following the set of flags.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>If flags are given and incorrectly specified, then a corresponding
error is returned.</p>
<p>If a capture name is given and it is incorrectly specified, then a
corresponding error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_capture_name" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1298-1342">source</a><h4 class="code-header">fn <a href="#method.parse_capture_name" class="fn">parse_capture_name</a>(&amp;self, capture_index: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.CaptureName.html" title="struct regex_syntax::ast::CaptureName">CaptureName</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses a capture group name. Assumes that the parser is positioned at
the first character in the name following the opening <code>&lt;</code> (and may
possibly be EOF). This advances the parser to the first character
following the closing <code>&gt;</code>.</p>
<p>The caller must provide the capture index of the group for this name.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_flags" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1359-1403">source</a><h4 class="code-header">fn <a href="#method.parse_flags" class="fn">parse_flags</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Flags.html" title="struct regex_syntax::ast::Flags">Flags</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a sequence of flags starting at the current character.</p>
<p>This advances the parser to the character immediately following the
flags, which is guaranteed to be either <code>:</code> or <code>)</code>.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>If any flags are duplicated, then an error is returned.</p>
<p>If the negation operator is used more than once, then an error is
returned.</p>
<p>If no flags could be found or if the negation operation is not followed
by any flags, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_flag" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1411-1425">source</a><h4 class="code-header">fn <a href="#method.parse_flag" class="fn">parse_flag</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../enum.Flag.html" title="enum regex_syntax::ast::Flag">Flag</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse the current character as a flag. Do not advance the parser.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>If the flag is not recognized, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_primitive" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1437-1471">source</a><h4 class="code-header">fn <a href="#method.parse_primitive" class="fn">parse_primitive</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="enum.Primitive.html" title="enum regex_syntax::ast::parse::Primitive">Primitive</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a primitive AST. e.g., A literal, non-set character class or
assertion.</p>
<p>This assumes that the parser expects a primitive at the current
location. i.e., All other non-primitive cases have been handled.
For example, if the parser’s position is at <code>|</code>, then <code>|</code> will be
treated as a literal (e.g., inside a character class).</p>
<p>This advances the parser to the first character immediately following
the primitive.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_escape" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1479-1596">source</a><h4 class="code-header">fn <a href="#method.parse_escape" class="fn">parse_escape</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="enum.Primitive.html" title="enum regex_syntax::ast::parse::Primitive">Primitive</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse an escape sequence as a primitive AST.</p>
<p>This assumes the parser is positioned at the start of the escape
sequence, i.e., <code>\</code>. It advances the parser to the first position
immediately following the escape sequence.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.maybe_parse_special_word_boundary" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1617-1672">source</a><h4 class="code-header">fn <a href="#method.maybe_parse_special_word_boundary" class="fn">maybe_parse_special_word_boundary</a>(
    &amp;self,
    wb_start: <a class="struct" href="../struct.Position.html" title="struct regex_syntax::ast::Position">Position</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../enum.AssertionKind.html" title="enum regex_syntax::ast::AssertionKind">AssertionKind</a>&gt;, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Attempt to parse a specialty word boundary. That is, <code>\b{start}</code>,
<code>\b{end}</code>, <code>\b{start-half}</code> or <code>\b{end-half}</code>.</p>
<p>This is similar to <code>maybe_parse_ascii_class</code> in that, in most cases,
if it fails it will just return <code>None</code> with no error. This is done
because <code>\b{5}</code> is a valid expression and we want to let that be parsed
by the existing counted repetition parsing code. (I thought about just
invoking the counted repetition code from here, but it seemed a little
ham-fisted.)</p>
<p>Unlike <code>maybe_parse_ascii_class</code> though, this can return an error.
Namely, if we definitely know it isn’t a counted repetition, then we
return an error specific to the specialty word boundaries.</p>
<p>This assumes the parser is positioned at a <code>{</code> immediately following
a <code>\b</code>. When <code>None</code> is returned, the parser is returned to the position
at which it started: pointing at a <code>{</code>.</p>
<p>The position given should correspond to the start of the <code>\b</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_octal" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1682-1706">source</a><h4 class="code-header">fn <a href="#method.parse_octal" class="fn">parse_octal</a>(&amp;self) -&gt; <a class="struct" href="../struct.Literal.html" title="struct regex_syntax::ast::Literal">Literal</a></h4></section></summary><div class="docblock"><p>Parse an octal representation of a Unicode codepoint up to 3 digits
long. This expects the parser to be positioned at the first octal
digit and advances the parser to the first character immediately
following the octal number. This also assumes that parsing octal
escapes is enabled.</p>
<p>Assuming the preconditions are met, this routine can never fail.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_hex" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1713-1733">source</a><h4 class="code-header">fn <a href="#method.parse_hex" class="fn">parse_hex</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Literal.html" title="struct regex_syntax::ast::Literal">Literal</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a hex representation of a Unicode codepoint. This handles both
hex notations, i.e., <code>\xFF</code> and <code>\x{FFFF}</code>. This expects the parser to
be positioned at the <code>x</code>, <code>u</code> or <code>U</code> prefix. The parser is advanced to
the first character immediately following the hexadecimal literal.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_hex_digits" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1743-1780">source</a><h4 class="code-header">fn <a href="#method.parse_hex_digits" class="fn">parse_hex_digits</a>(&amp;self, kind: <a class="enum" href="../enum.HexLiteralKind.html" title="enum regex_syntax::ast::HexLiteralKind">HexLiteralKind</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Literal.html" title="struct regex_syntax::ast::Literal">Literal</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse an N-digit hex representation of a Unicode codepoint. This
expects the parser to be positioned at the first digit and will advance
the parser to the first character immediately following the escape
sequence.</p>
<p>The number of digits given must be 2 (for <code>\xNN</code>), 4 (for <code>\uNNNN</code>)
or 8 (for <code>\UNNNNNNNN</code>).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_hex_brace" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1786-1832">source</a><h4 class="code-header">fn <a href="#method.parse_hex_brace" class="fn">parse_hex_brace</a>(&amp;self, kind: <a class="enum" href="../enum.HexLiteralKind.html" title="enum regex_syntax::ast::HexLiteralKind">HexLiteralKind</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.Literal.html" title="struct regex_syntax::ast::Literal">Literal</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a hex representation of any Unicode scalar value. This expects
the parser to be positioned at the opening brace <code>{</code> and will advance
the parser to the first character following the closing brace <code>}</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_decimal" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1843-1867">source</a><h4 class="code-header">fn <a href="#method.parse_decimal" class="fn">parse_decimal</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.u32.html">u32</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a decimal number into a u32 while trimming leading and trailing
whitespace.</p>
<p>This expects the parser to be positioned at the first position where
a decimal digit could occur. This will advance the parser to the byte
immediately following the last contiguous decimal digit.</p>
<p>If no decimal digit could be found or if there was a problem parsing
the complete set of digits into a u32, then an error is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_set_class" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1877-1933">source</a><h4 class="code-header">fn <a href="#method.parse_set_class" class="fn">parse_set_class</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.ClassBracketed.html" title="struct regex_syntax::ast::ClassBracketed">ClassBracketed</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a standard character class consisting primarily of characters or
character ranges, but can also contain nested character classes of
any type (sans <code>.</code>).</p>
<p>This assumes the parser is positioned at the opening <code>[</code>. If parsing
is successful, then the parser is advanced to the position immediately
following the closing <code>]</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_set_class_range" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1944-1978">source</a><h4 class="code-header">fn <a href="#method.parse_set_class_range" class="fn">parse_set_class_range</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../enum.ClassSetItem.html" title="enum regex_syntax::ast::ClassSetItem">ClassSetItem</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a single primitive item in a character class set. The item to
be parsed can either be one of a simple literal character, a range
between two simple literal characters or a “primitive” character
class like \w or \p{Greek}.</p>
<p>If an invalid escape is found, or if a character class is found where
a simple literal is expected (e.g., in a range), then an error is
returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_set_class_item" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#1991-2003">source</a><h4 class="code-header">fn <a href="#method.parse_set_class_item" class="fn">parse_set_class_item</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="enum.Primitive.html" title="enum regex_syntax::ast::parse::Primitive">Primitive</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a single item in a character class as a primitive, where the
primitive either consists of a verbatim literal or a single escape
sequence.</p>
<p>This assumes the parser is positioned at the beginning of a primitive,
and advances the parser to the first position after the primitive if
successful.</p>
<p>Note that it is the caller’s responsibility to report an error if an
illegal primitive was parsed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_set_class_open" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#2022-2085">source</a><h4 class="code-header">fn <a href="#method.parse_set_class_open" class="fn">parse_set_class_open</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="../struct.ClassBracketed.html" title="struct regex_syntax::ast::ClassBracketed">ClassBracketed</a>, <a class="struct" href="../struct.ClassSetUnion.html" title="struct regex_syntax::ast::ClassSetUnion">ClassSetUnion</a>), <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parses the opening of a character class set. This includes the opening
bracket along with <code>^</code> if present to indicate negation. This also
starts parsing the opening set of unioned items if applicable, since
there are special rules applied to certain characters in the opening
of a character class. For example, <code>[^]]</code> is the class of all
characters not equal to <code>]</code>. (<code>]</code> would need to be escaped in any other
position.) Similarly for <code>-</code>.</p>
<p>In all cases, the op inside the returned <code>ast::ClassBracketed</code> is an
empty union. This empty union should be replaced with the actual item
when it is popped from the parser’s stack.</p>
<p>This assumes the parser is positioned at the opening <code>[</code> and advances
the parser to the first non-special byte of the character class.</p>
<p>An error is returned if EOF is found.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.maybe_parse_ascii_class" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#2096-2158">source</a><h4 class="code-header">fn <a href="#method.maybe_parse_ascii_class" class="fn">maybe_parse_ascii_class</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../struct.ClassAscii.html" title="struct regex_syntax::ast::ClassAscii">ClassAscii</a>&gt;</h4></section></summary><div class="docblock"><p>Attempt to parse an ASCII character class, e.g., <code>[:alnum:]</code>.</p>
<p>This assumes the parser is positioned at the opening <code>[</code>.</p>
<p>If no valid ASCII character class could be found, then this does not
advance the parser and <code>None</code> is returned. Otherwise, the parser is
advanced to the first byte following the closing <code>]</code> and the
corresponding ASCII class is returned.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_unicode_class" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#2167-2240">source</a><h4 class="code-header">fn <a href="#method.parse_unicode_class" class="fn">parse_unicode_class</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../struct.ClassUnicode.html" title="struct regex_syntax::ast::ClassUnicode">ClassUnicode</a>, <a class="struct" href="../struct.Error.html" title="struct regex_syntax::ast::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Parse a Unicode class in either the single character notation, <code>\pN</code>
or the multi-character bracketed notation, <code>\p{Greek}</code>. This assumes
the parser is positioned at the <code>p</code> (or <code>P</code> for negation) and will
advance the parser to the character immediately following the class.</p>
<p>Note that this does not check whether the class name is valid or not.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse_perl_class" class="method"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#2246-2260">source</a><h4 class="code-header">fn <a href="#method.parse_perl_class" class="fn">parse_perl_class</a>(&amp;self) -&gt; <a class="struct" href="../struct.ClassPerl.html" title="struct regex_syntax::ast::ClassPerl">ClassPerl</a></h4></section></summary><div class="docblock"><p>Parse a Perl character class, e.g., <code>\d</code> or <code>\W</code>. This assumes the
parser is currently at a valid character class name and will be
advanced to the character immediately following the class.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-ParserI%3C's,+P%3E" class="impl"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#294">source</a><a href="#impl-Clone-for-ParserI%3C's,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'s, P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#294">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-ParserI%3C's,+P%3E" class="impl"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#294">source</a><a href="#impl-Debug-for-ParserI%3C's,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'s, P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/regex_syntax/ast/parse.rs.html#294">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-ParserI%3C's,+P%3E" class="impl"><a href="#impl-Freeze-for-ParserI%3C's,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'s, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-ParserI%3C's,+P%3E" class="impl"><a href="#impl-RefUnwindSafe-for-ParserI%3C's,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'s, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-ParserI%3C's,+P%3E" class="impl"><a href="#impl-Send-for-ParserI%3C's,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'s, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-ParserI%3C's,+P%3E" class="impl"><a href="#impl-Sync-for-ParserI%3C's,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'s, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-ParserI%3C's,+P%3E" class="impl"><a href="#impl-Unpin-for-ParserI%3C's,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'s, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-ParserI%3C's,+P%3E" class="impl"><a href="#impl-UnwindSafe-for-ParserI%3C's,+P%3E" class="anchor">§</a><h3 class="code-header">impl&lt;'s, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.ParserI.html" title="struct regex_syntax::ast::parse::ParserI">ParserI</a>&lt;'s, P&gt;<div class="where">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>