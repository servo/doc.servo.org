initSidebarItems({"enum":[["AsmDialect",""],["AttrStyle","Distinguishes between Attributes that decorate items and Attributes that are contained as statements within items. These two cases need to be distinguished for pretty-printing."],["BinOp_",""],["BindingMode",""],["BlockCheckMode",""],["CaptureClause",""],["Decl_",""],["ExplicitSelf_","Represents the kind of 'self' associated with a method"],["Expr_",""],["FloatTy",""],["ForeignItem_",""],["FunctionRetTy",""],["ImplItem",""],["ImplPolarity",""],["InlinedItem","The data we save and restore about an inlined item or method.  This is not part of the AST that we parse from a file, but it becomes part of the tree that we trans."],["IntTy",""],["Item_",""],["KleeneOp","A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star) for token sequences."],["LitIntType",""],["Lit_",""],["LocalSource","Where a local declaration came from: either a true `let ... = ...;`, or one desugared from the pattern of a for loop."],["MacStmtStyle",""],["Mac_","Represents a macro invocation. The Path indicates which macro is being invoked, and the vector of token-trees contains the source of the macro invocation. There's only one flavor, now, so this could presumably be simplified."],["MatchSource",""],["MetaItem_",""],["Method_",""],["Mutability",""],["PatWildKind",""],["Pat_",""],["PathListItem_",""],["PathParameters",""],["PrimTy","Not represented directly in the AST, referred to by name through a ty_path."],["Sign",""],["Stmt_",""],["StrStyle",""],["StructFieldKind",""],["TokenTree","When the main rust parser encounters a syntax-extension invocation, it  parses the arguments to the invocation as a token-tree. This is a very  loose structure, such that all sorts of different AST-fragments can  be passed to syntax extensions using a uniform type."],["TraitBoundModifier","A modifier on a bound, currently this is only used for `?Sized`, where the modifier is `Maybe`. Negative bounds should also be handled here."],["TraitItem","Represents a method declaration in a trait declaration, possibly including a default implementation A trait method is either required (meaning it doesn't have an implementation, just a signature) or provided (meaning it has a default implementation)."],["TyParamBound","The AST represents all type param bounds as types. typeck::collect::compute_bounds matches these against the \"special\" built-in traits (see middle::lang_items) and detects Copy, Send and Sync."],["Ty_","The different kinds of types recognized by the compiler"],["UintTy",""],["UnOp",""],["UnsafeSource",""],["Unsafety",""],["VariantKind",""],["ViewPath_",""],["Visibility",""],["WherePredicate",""]],"struct":[["AngleBracketedParameterData","A path like `Foo<'a, T>`"],["Arg","represents an argument in a function header"],["Arm","represents one arm of a 'match'"],["AssociatedType",""],["AttrId",""],["Attribute_","Doc-comments are promoted to attributes that have is_sugared_doc = true"],["BareFnTy",""],["Block",""],["Crate",""],["DefId",""],["Delimited","A delimited sequence of token trees"],["EnumDef",""],["Expr",""],["Field",""],["FieldPat",""],["FnDecl","represents the header (not the body) of a function declaration"],["ForeignItem",""],["ForeignMod",""],["Generics","Represents lifetimes and type parameters attached to a declaration of a function, enum, trait, etc."],["Ident","An identifier contains a Name (index into the interner table) and a SyntaxContext to track renaming and macro expansion per Flatt et al., \"Macros That Work Together\""],["InlineAsm",""],["Item",""],["Lifetime",""],["LifetimeDef",""],["Local","Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`"],["MacroDef","A macro definition, in this crate or imported from another."],["Method",""],["Mod",""],["MutTy",""],["Name","A name is a part of an identifier, representing a string or gensym. It's the result of interning."],["ParenthesizedParameterData","A path like `Foo(A,B) -> C`"],["Pat",""],["Path","A \"Path\" is essentially Rust's notion of a name; for instance: std::cmp::PartialEq  .  It's represented as a sequence of identifiers, along with a bunch of supporting information."],["PathSegment","A segment of a path: an identifier, an optional lifetime, and a set of types."],["PolyTraitRef",""],["QSelf","The explicit Self type in a \"qualified path\". The actual path, including the trait and the associated item, is stored sepparately. `position` represents the index of the associated item qualified with this Self type."],["SequenceRepetition","A sequence of token treesee"],["StructDef",""],["StructField_",""],["TraitRef","TraitRef's appear in impls. resolve maps each TraitRef's ref_id to its defining trait; that's all that the ref_id is for. The impl_id maps to the \"self type\" of this impl. If this impl is an ItemImpl, the impl_id is redundant (it could be the same as the impl's node id)."],["Ty",""],["TyParam",""],["TypeBinding",""],["TypeField",""],["TypeMethod","Represents a required method in a trait declaration, one without a default implementation"],["Typedef",""],["VariantArg",""],["Variant_",""],["WhereBoundPredicate",""],["WhereClause",""],["WhereEqPredicate",""],["WhereRegionPredicate",""]],"type":[["Attribute","Meta-data associated with an item"],["BinOp",""],["CrateConfig","The set of MetaItems that define the compilation environment of the crate, used to drive conditional compilation"],["CrateNum",""],["Decl",""],["ExplicitSelf",""],["FnIdent","Function name (not all functions have names)"],["Lit",""],["Mac",""],["MetaItem",""],["Mrk","A mark represents a unique id associated with a macro expansion"],["NodeId",""],["PathListItem",""],["SpannedIdent",""],["Stmt",""],["StructField",""],["SyntaxContext","A SyntaxContext represents a chain of macro-expandings and renamings. Each macro expansion corresponds to a fresh usize"],["TyParamBounds",""],["Variant",""],["ViewPath",""]],"constant":[["CRATE_NODE_ID",""],["DUMMY_NODE_ID","When parsing and doing expansions, we initially give all AST nodes this AST node value. Then later, in the renumber pass, we renumber them to have small, positive ids."],["EMPTY_CTXT",""],["ILLEGAL_CTXT",""],["LOCAL_CRATE","Item definitions in the currently-compiled crate would have the CrateNum LOCAL_CRATE in their DefId."]]});