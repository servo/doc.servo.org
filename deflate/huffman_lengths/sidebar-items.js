initSidebarItems({"constant":[["BLOCK_MARKER_LENGTH",""],["HCLEN_BITS",""],["HDIST_BITS",""],["HLIT_BITS",""],["HUFFMAN_LENGTH_ORDER","The output ordering of the lengths for the Huffman codes used to encode the lengths used to build the full Huffman tree for length/literal codes. http://www.gzip.org/zlib/rfc-deflate.html#dyn"],["MAX_HUFFMAN_CODE_LENGTH","The longest a Huffman code describing another Huffman length can be"],["MIN_NUM_DISTANCES","The minimum number of distances"],["MIN_NUM_LITERALS_AND_LENGTHS","The minimum number of literal/length values"],["NUM_HUFFMAN_LENGTHS",""],["STORED_BLOCK_HEADER_LENGTH",""]],"enum":[["BlockType",""]],"fn":[["calculate_block_length","Calculate how many bits data with the given frequencies will use when compressed with dynamic code lengths (first return value) and static code lengths (second return value)."],["calculate_huffman_length","Calculate how many bits the Huffman-encoded Huffman lengths will use."],["extra_bits_for_huffman_length_code","How many extra bits the Huffman length code uses to represent a value."],["gen_huffman_lengths","Generate the lengths of the Huffman codes we will be using, using the frequency of the different symbols/lengths/distances, and determine what block type will give the shortest representation. TODO: This needs a test"],["remove_trailing_zeroes","Creates a new slice from the input slice that stops at the final non-zero value"],["stored_length","Calculate the number of bits storing the data in stored blocks will take up, excluding the first block start code and potential padding bits. As stored blocks have a maximum length, (as opposed to fixed and dynamic ones), multiple blocks may have to be utilised."],["stored_padding","Get how extra padding bits after a block start header a stored block would use."],["write_huffman_lengths","Write the specified Huffman lengths to the bit writer"]],"struct":[["DynamicBlockHeader","A struct containing the different data needed to write the header for a dynamic block."]]});