searchState.loadedDescShard("regex_automata", 0, "This crate exposes a variety of regex engines used by the …\nReport all possible matches.\nThe type of anchored search to perform.\nThe search, based on heuristics, determined that it would …\nA representation of “half” of a match reported by a …\nThis error occurs if the haystack given to the regex …\nThe parameters for a regex search including the haystack …\nReport only the leftmost matches. When multiple leftmost …\nA representation of a match reported by a regex engine.\nAn error indicating that a search stopped before reporting …\nThe underlying kind of a <code>MatchError</code>.\nThe kind of match semantics to use for a regex pattern.\nRun an unanchored search. This means a match may occur …\nRun an anchored search for a specific pattern. This means …\nThe identifier of a regex pattern, represented by a …\nA set of <code>PatternID</code>s.\nAn error that occurs when a <code>PatternID</code> failed to insert …\nAn iterator over all pattern identifiers in a <code>PatternSet</code>.\nThe search saw a “quit” byte at which it was …\nA representation of a span reported by a regex engine.\nAn error indicating that a particular type of anchored …\nRun an anchored search. This means that a match must begin …\nA module for building and searching with deterministic …\nThe end offset of the span, exclusive.\nReturns the argument unchanged.\nA module for building and searching with lazy …\nCalls <code>U::from(self)</code>.\nThe number of patterns set to ‘true’ in this set.\nProvides a regex matcher that composes several other regex …\nProvides non-deterministic finite automata (NFA) and regex …\nThe offset of the match.\nThe pattern ID.\nThe pattern ID.\nThe underlying match span.\nThe start offset of the span, inclusive.\nA collection of modules that provide APIs that are useful …\nA map from PatternID to boolean of whether a pattern …\nThe “quit” byte that was observed that caused the …\nThe length of the haystack that exceeded the limit.\nThe anchored mode given that is unsupported.\nThe offset at which the quit byte was observed.\nThe offset at which the search stopped. This corresponds …\nThis is an alias for a state ID of zero. It has special …\nA DFA that can return spans for matching capturing groups.\nAn error that occurred during the construction of a …\nThe kind of error that occurred during the construction of …\nA builder for a one-pass DFA.\nA cache represents mutable state that a one-pass <code>DFA</code> …\nThe configuration used for building a one-pass DFA.\nA one-pass DFA for executing a subset of anchored regex …\nEpsilons represents all of the NFA epsilons transitions …\nAn internal builder for encapsulating the state necessary …\nA representation of a match state’s pattern ID along …\nThe set of epsilon transitions indicating that the current …\nAn iterator over all of the bits set in a slot set.\nAn iterator over groups of consecutive equivalent …\nRepresents a single transition in a one-pass DFA.\nAdd a new DFA state corresponding to the given NFA state. …\nUnconditionally add a new empty DFA state. If adding it …\nAdd a start state to the DFA corresponding to the given …\nReturns the total number of elements in the alphabet for …\nThe number of elements in each state in the transition …\nCreate a new one-pass DFA that matches every input.\nFor the position <code>at</code> in the current haystack, copy it to …\nBuild a one-pass DFA from the given pattern.\nBuild the DFA from the NFA given to this builder. If the …\nBuild a DFA from the given NFA.\nBuild a one-pass DFA from the given patterns.\nReturn a builder for configuring the construction of a DFA.\nWhether to attempt to shrink the size of the DFA’s …\nExecutes an anchored leftmost forward search and writes …\nThe equivalence classes that make up the alphabet for this …\nThe alphabet of this DFA, split into equivalence classes. …\nCompile the given NFA transition into the DFA state given.\nReturn a default configuration for a DFA.\nThe config passed to the builder.\nThe configuration provided by the caller.\nApply the given one-pass DFA configuration options to this …\nCreate a new cache for this DFA.\nCreate a new empty set of capturing groups that is …\nThe DFA we’re building.\nReturn a new empty pattern epsilons that has no pattern ID …\nCreate a new empty epsilons. It has no slots and no …\nReturn the epsilons embedded in this transition.\nReturn the epsilons part of this pattern epsilons.\nThe number of slots in the caller-provided ‘Captures’ …\nThe first explicit slot index. This refers to the first …\nScratch space used to store slots during a search. …\nExecutes an anchored leftmost forward search, and returns …\nAssumes ‘sid’ is a match state and looks for whether a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns whether this configuration has enabled byte …\nReturn the config for this one-pass DFA.\nReturns the match semantics set in this configuration.\nReturns a reference to the underlying NFA.\nReturns the DFA size limit of this configuration if one …\nReturns whether this configuration has enabled anchored …\nInsert the slot at the given bit index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this transition points to the …\nWhether this pattern epsilons is empty or not. It’s …\nReturns true if this epsilons contains no slots and no …\nReturns true if and only if this set contains no slots.\nExecutes an anchored leftmost forward search, and returns …\nReturns an iterator over all of the set bits in this set.\nReturns the state ID of the last state in this DFA’s …\nReturn the set of look-around assertions in these epsilon …\nSet the desired match semantics.\nReturn whether this transition has a “match wins” …\nWhether a match NFA state has been observed while …\nReturns the memory usage, in bytes, of this DFA.\nReturns the heap memory usage, in bytes, of this cache.\nEvery state ID &gt;= this value corresponds to a match state.\nCreate a new one-pass DFA that never matches any input.\nReturn a new default one-pass DFA configuration.\nCreate a new one-pass DFA builder with the default …\nCreate a new builder with an initial empty DFA.\nParse the given regular expression using the default …\nCreate a new <code>onepass::DFA</code> cache.\nReturn a new transition to the given state ID with the …\nLike <code>new</code>, but builds a one-pass DFA directly from an NFA. …\nLike <code>new</code>, but parses multiple patterns into a single “…\nThe NFA we’re building a one-pass DFA from.\nThe NFA used to build this DFA.\nA map from NFA state ID to DFA state ID. This is useful …\nOverwrite the default configuration such that the options …\nThe offset at which the PatternEpsilons for a match state …\nReturn the pattern epsilons for the given state ID.\nReturn the pattern ID in this pattern epsilons if one …\nReturns the pattern ID without checking whether it’s …\nReturns the total number of patterns compiled into this …\nReturns the state ID prior to the one given. This returns …\nMap all state IDs in this DFA (transition table + start …\nRemove the slot at the given bit index.\nReset this cache such that it can be used for searching …\nReset the given cache such that it can be used for …\nThe set of NFA states that we’ve visited via ‘stack’.\nReturn a new pattern epsilons with the given epsilons, but …\nSet the look-around assertions on these epsilon …\nSet the pattern epsilons for the given state ID.\nReturn a new pattern epsilons with the given pattern ID, …\nSet the slot epsilon transitions.\nSet the “next” state ID in this transition.\nSet the transition from the given state ID and byte of …\nShuffle all match states to the end of the transition …\nSet a size limit on the total heap used by a one-pass DFA.\nReturns the slot epsilon transitions.\nReturn an iterator of “sparse” transitions for the …\nA stack used to traverse the NFA states that make up a …\nPush the given NFA state ID and its corresponding epsilons …\nReturns the anchored start state for matching any pattern …\nReturns the anchored start state for matching the given …\nThe DFA state IDs of the starting states.\nWhether to compile a separate start state for each pattern …\nReturn the “next” state ID that this transition points …\nReturns the total number of states in this one-pass DFA.\nReturns the total stride for every state in this DFA. This …\nReturns the total stride for every state in this DFA, …\nThe number of columns in the transition table, expressed …\nMove the transitions from ‘id1’ to ‘id2’ and vice …\nSet the syntax configuration for this builder using …\nThe transition table. Given a state ID ‘s’ and a byte …\nSet the Thompson NFA configuration for this builder using …\nReturns the transition from the given state ID and byte of …\nExecutes an anchored leftmost forward search and writes …\nExecutes an anchored leftmost forward search and writes …\nAn unordered collection of NFA state IDs that we haven’t …\nA simple type for mapping between state indices and state …\nRemappable is a tightly coupled abstraction that …\nRemapper is an abstraction the manages the remapping of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nA mapper from state index to state ID (and back).\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA map from the index of a state to its pre-multiplied …\nCreate a new remapper from the given remappable …\nThis must remap every single state ID in the underlying …\nComplete the remapping process by rewriting all state IDs …\nReturn the total number of states.\nReturn the power-of-2 exponent that yields the stride. The …\nThe power of 2 corresponding to the stride of the …\nSwap two states. Once this is called, callers must follow …\nSwap the states pointed to by the given IDs. The …\nConvert a state ID to a state index.\nConvert a state index to a state ID.\nAn error that occurs when initial construction of a lazy …\nAn error that occurs when cache inefficiency has dropped …\nAn error that occurs when cache usage has become …\nA state identifier specifically tailored for lazy DFAs.\nAn error that occurs when a starting configuration’s …\nAn error that can occur when computing the start state for …\nAn error that occurs when the caller requests an anchored …\nTypes and routines specific to lazy DFAs.\nA lazy DFA backed <code>Regex</code>.\nThe quit byte that was found.\nThe underlying cache error that occurred.\nThe anchored mode given that is unsupported.\nA builder for constructing a lazy deterministic finite …\nA cache represents a partially computed DFA.\nThe configuration used for building a lazy DFA.\nA hybrid NFA/DFA (also called a “lazy DFA”) for regex …\nA type that groups methods that require the base NFA/DFA …\nA type that groups methods that require the base NFA/DFA …\nThe minimum number of states that a lazy DFA’s cache …\nAn empty state saver. In this case, no states (other than …\nRepresents the current state of an overlapping search.\nThe number of “sentinel” states that get added to …\nAn ID that of a state that has been persisted through a …\nKeeps track of the progress of the current search.\nA map from states to state identifiers. When using std, we …\nA simple type that encapsulates the saving of a state ID …\nAn ID of a state (and the state itself) that should be …\nEither add the given builder state to this cache, or …\nAllocate a new state ID and add the given state to this …\nCreate a new lazy DFA that matches every input.\nReturn an immutable view by downgrading a writable cache …\nThe position of the search.\nBuild a lazy DFA from the given pattern.\nBuild a DFA from the given NFA.\nBuild a lazy DFA from the given patterns.\nReturn a builder for configuring the construction of a …\nReturns the equivalence classes that make up the alphabet …\nWhether to attempt to shrink the size of the lazy DFA’s …\nReturns the byte class map used during search from the …\nThe total number of bytes searched since the last time …\nSets the maximum amount of heap memory, in bytes, to …\nThis is marked as ‘inline(never)’ to avoid bloating …\nCompute and cache the starting state for the given pattern …\nCompute and cache the starting state for the given NFA …\nClear the cache used by this lazy DFA.\nReturns the total number of times this cache has been …\nThe number of times the cache has been cleared. When a …\nReturn a default configuration for a <code>DFA</code>.\nApply the given lazy DFA configuration options to this …\nCreate a new cache for this lazy DFA.\nReturns the ID of the dead state for this lazy DFA.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns whether this configuration has enabled byte …\nReturns the cache capacity set on this configuration.\nReturn the ID of the start state for the given …\nReturn the cached NFA/DFA powerset state for the given ID.\nReturns this lazy DFA’s configuration.\nReturn the match result of the most recent search to …\nReturns the match semantics set in this configuration.\nReturns, if set, the minimum number of bytes per state …\nReturns the minimum lazy DFA cache capacity required for …\nReturns, if set, the minimum number of times the cache …\nReturns a reference to the underlying NFA.\nReturns the prefilter set in this configuration, if one at …\nReturns whether this configuration will instruct the lazy …\nReturns whether the cache capacity check should be skipped.\nReturns whether this configuration will instruct the lazy …\nReturns whether this configuration has enabled anchored …\nReturns a state builder from this DFA that might have …\nReturns whether this configuration has enabled heuristic …\nThe state ID of the state at which the search was in when …\nInitialize this cache from emptiness to a place where it …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if the given ID corresponds to a …\nReturns true if and only if the given ID is valid.\nReturns the length, in bytes, of this search so far.\nThe match reported by the most recent overlapping search …\nSet the desired match semantics.\nReturns the total number of patterns that match in this …\nReturns the pattern ID corresponding to the given match …\nReturns the memory usage, in bytes, of this lazy DFA.\nReturns the heap memory usage, in bytes, of this cache.\nReturns the additional memory usage, in bytes, required to …\nThe memory usage, in bytes, used by ‘states’ and ‘…\nConfigure a lazy DFA search to quit only when its …\nBased on the minimum number of states required for a …\nConfigure a lazy DFA search to quit after a certain number …\nBased on the minimum number of states required for a …\nCreate a new lazy DFA that never matches any input.\nParse the given regular expression using a default …\nCreate a new cache for the given lazy DFA.\nCreates a new ‘Lazy’ wrapper for a DFA and its …\nCreates a new ‘Lazy’ wrapper for a DFA and its …\nReturn a new default lazy DFA builder configuration.\nCreate a new lazy DFA builder with the default …\nParse the given regular expressions using a default …\nTransitions from the current state to the next state for …\nThe index into the matching patterns of the next match to …\nTransitions from the current state to the next state, …\nAllocate a new state ID.\nTransitions from the current state to the next state, …\nTransitions from the current state to the next state, …\nCreate an empty state saver.\nOverwrite the default configuration such that the options …\nReturns the total number of patterns compiled into this …\nSet a prefilter to be used whenever a start state is …\nThe progress of the current search.\nPuts the given state builder back into this DFA for reuse.\nAdd a “quit” byte to the lazy DFA.\nReturns the ID of the quit state for this lazy DFA.\nReturn the quit set for this configuration and the given …\nReset this cache such that it can be used for searching …\nReset the given cache such that it can be used for …\nClears <em>and</em> resets the cache. Resetting the cache means …\nThis is set to true when a reverse overlapping search has …\nSave the state corresponding to the ID given such that the …\nReturns the updated lazy state ID for a state that was …\nScratch space for building a NFA/DFA powerset state. This …\nIndicates that a search has finished at the given position.\nInitializes a new search starting at the given position.\nReturns the total number of bytes that have been searched …\nUpdates the current search to indicate that it has search …\nSet all transitions on the state ‘from’ to ‘to’.\nSet the start ID for the given pattern ID (if given) and …\nSet the transition on ‘from’ for ‘unit’ to ‘to’…\nConfigures construction of a lazy DFA to use the minimum …\nRuns the given overlapping <code>search</code> function (forwards or …\nSparse sets used to track which NFA states have been …\nEnable specializing start states in the lazy DFA.\nScratch space for traversing the NFA graph. (We use space …\nCreate a new overlapping state that begins at the start …\nReturn the ID of the start state for this lazy DFA for the …\nReturn the ID of the start state for this lazy DFA when …\nReturn the ID of the start state for this lazy DFA when …\nThe starting states for this DFA.\nWhether to compile a separate start state for each pattern …\nReturns true if adding the state to be built by the given …\nReturns true if adding the state given would fit in this …\nA simple abstraction for handling the saving of at most a …\nA sequence of NFA/DFA powerset states that have been …\nA map from states to their corresponding IDs. This map may …\nReturns the total stride for every state in this lazy DFA. …\nReturns the stride, as a base-2 exponent, required for …\nSet the syntax configuration for this builder using …\nReplace this state saver with an empty saver, and if this …\nReplace this state saver with an empty saver, and if this …\nSet the Thompson NFA configuration for this builder using …\nThe transition table.\nAttempt to clear the cache used by this lazy DFA.\nExecutes a forward search and returns the end position of …\nExecutes an overlapping forward search and returns the end …\nExecutes a reverse overlapping search and returns the …\nExecutes a reverse search and returns the start of the …\nWrites the set of patterns that match anywhere in the …\nHeuristically enable Unicode word boundaries.\nReturns the ID of the unknown state for this lazy DFA.\nAn error that occurs when initial construction of a lazy …\nAn error that occurs when cache inefficiency has dropped …\nAn error that occurs when cache usage has become …\nAn error that occurs when a starting configuration’s …\nAn error that can occur when computing the start state for …\nAn error that occurs when the caller requests an anchored …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe quit byte that was found.\nThe underlying cache error that occurred.\nThe anchored mode given that is unsupported.\nA state identifier specifically tailored for lazy DFAs.\nThis error occurs when a lazy state ID could not be …\nReturn this lazy state ID as its raw internal <code>usize</code> value, …\nReturn this lazy state ID as an untagged <code>usize</code>.\nReturns the value that failed to constructed a lazy state …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if and only if this represents a dead state. A …\nReturn true if and only if this lazy state ID has been …\nReturn true if and only if this represents a quit state. A …\nReturn true if and only if this lazy state ID has been …\nReturn true if and only if this lazy state ID is tagged.\nReturn true if and only if this represents a lazy state ID …\nCreate a new lazy state ID.\nCreate a new lazy state ID without checking whether the …\nReturn this lazy state ID as a lazy state ID that is …\nReturn this lazy state ID as a state ID that is tagged as …\nA builder for a regex based on a hybrid NFA/DFA.\nA cache represents a partially computed forward and …\nAn iterator over all non-overlapping matches for an …\nA regular expression that uses hybrid NFA/DFAs (also …\nReturn references to the forward and reverse caches, …\nReturn mutable references to the forward and reverse …\nBuild a regex from the given pattern.\nBuild a regex from its component forward and reverse …\nBuild a regex from the given patterns.\nReturn a builder for configuring the construction of a …\nCreate a new cache for this <code>Regex</code>.\nSet the lazy DFA compilation configuration for this …\nReturns the start and end offset of the leftmost match. If …\nReturns an iterator over all non-overlapping leftmost …\nReturn the underlying lazy DFA responsible for forward …\nReturn a reference to the forward cache.\nThe forward lazy DFA. This can only find the end of a …\nReturn a mutable reference to the forward cache.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if either the given input specifies an …\nReturns true if and only if this regex matches the given …\nReturns the heap memory usage, in bytes, as a sum of the …\nParse the given regular expression using the default …\nCreate a new cache for the given <code>Regex</code>.\nCreate a new regex builder with the default configuration.\nLike <code>new</code>, but parses multiple patterns into a single “…\nReturns the total number of patterns matched by this regex.\nReset this cache such that it can be used for searching …\nReset the given cache such that it can be used for …\nReturn the underlying lazy DFA responsible for reverse …\nReturn a reference to the reverse cache.\nThe reverse lazy DFA. This can only find the start of a …\nReturn a mutable reference to the reverse cache.\nSet the syntax configuration for this builder using …\nSet the Thompson NFA configuration for this builder using …\nReturns the start and end offset of the leftmost match. If …\nA convenience routine for constructing a “gave up” …\nRe-compute the starting state that a DFA should be in …\nAn error that occurs when construction of a <code>Regex</code> fails.\nA builder for configuring and constructing a <code>Regex</code>.\nRepresents mutable scratch space used by regex engines …\nAn iterator over all non-overlapping leftmost matches with …\nAn object describing the configuration of a <code>Regex</code>.\nAn iterator over all non-overlapping matches.\nA regex matcher that works by composing several other …\nYields all substrings delimited by a regular expression …\nYields at most <code>N</code> spans delimited by a regular expression …\nThe actual regex implementation.\nThis module defines two bespoke reverse DFA searching …\nA thread safe pool of caches.\nA module dedicated to plucking inner literals out of a …\nThis module defines two bespoke forward DFA search …\nThis module contains a boat load of wrappers around each …\nAn error that occurs when construction of a <code>Regex</code> fails.\nAn error that occurs when a search should be retried.\nAn error that occurs when a regex engine “gives up” …\nAn error that occurs when potential quadratic behavior has …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf it is known which pattern ID caused this build error to …\nIf this error occurred because the regex exceeded the …\nIf this error corresponds to a syntax error, then a …\nPull out an alternation of literals from the given …\nA builder for configuring and constructing a <code>Regex</code>.\nRepresents mutable scratch space used by regex engines …\nA type alias for our pool of meta::Cache that fixes the …\nThe type of the closure we use to create new caches. We …\nSame as above, but for the guard returned by a pool.\nAn iterator over all non-overlapping leftmost matches with …\nAn object describing the configuration of a <code>Regex</code>.\nAn iterator over all non-overlapping matches.\nA regex matcher that works by composing several other …\nThe internal implementation of <code>Regex</code>, split out so that it …\nYields all substrings delimited by a regular expression …\nYields at most <code>N</code> spans delimited by a regular expression …\nToggles whether automatic prefilter support is enabled.\nToggle whether a bounded backtracking regex engine should …\nBuilds a <code>Regex</code> from a single pattern string.\nBuilds a <code>Regex</code> directly from an <code>Hir</code> expression.\nBuilds a <code>Regex</code> from many pattern strings.\nBuilds a <code>Regex</code> directly from many <code>Hir</code> expressions.\nReturn a builder for configuring the construction of a …\nWhether to attempt to shrink the size of the alphabet for …\nExecutes a leftmost forward search and writes the spans of …\nReturns an iterator over all non-overlapping <code>Captures</code> …\nReturns the total number of capturing groups.\nReturn a default configuration for a <code>Regex</code>.\nConfigure the behavior of a <code>Regex</code>.\nCreates a new cache for use with lower level search APIs …\nCreates a new object for recording capture group offsets. …\nToggle whether a fully compiled DFA should be available …\nSets the size limit, in bytes, for heap memory used for a …\nSets a limit on the total number of NFA states, beyond …\nExecutes a leftmost search and returns the first match …\nReturns an iterator over all non-overlapping leftmost …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns whether automatic prefilters are enabled, as set by\nReturns whether the bounded backtracking regex engine may …\nReturns whether byte classes are enabled, as set by …\nReturns the configuration object used to build this <code>Regex</code>.\nReturns whether the DFA regex engine may be used, as set by\nReturns DFA size limit, as set by <code>Config::dfa_size_limit</code>.\nReturns DFA size limit in terms of the number of states in …\nReturns whether the hybrid NFA/DFA regex engine may be …\nReturns hybrid NFA/DFA cache capacity, as set by …\nReturns the line terminator for this configuration, as set …\nReturns the match kind on this configuration, as set by …\nReturns NFA size limit, as set by <code>Config::nfa_size_limit</code>.\nReturns whether the one-pass DFA regex engine may be used, …\nReturns one-pass DFA size limit, as set by …\nReturns a manually set prefilter, if one was set by …\nReturns whether empty matches must fall on valid UTF-8 …\nReturns the capture configuration, as set by …\nReturn information about the capture groups in this <code>Regex</code>.\nToggle whether the hybrid NFA/DFA (also known as the “…\nSet the cache capacity, in bytes, for the lazy DFA.\nThe actual regex implementation.\nMetadata about the regexes driving the strategy. The …\nReturns the current <code>Input</code> associated with this iterator.\nReturns the current <code>Input</code> associated with this iterator.\nReturns the current <code>Input</code> associated with this iterator.\nReturns the current <code>Input</code> associated with this iterator.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this regex has a high chance of being “…\nReturns true when this regex is always anchored to the end …\nReturns true when this regex is always anchored to the …\nReturns true when the search is guaranteed to be anchored. …\nReturns true if and only if it is known that a match is …\nReturns true if and only if this regex matches the given …\nSet the line terminator to be used by the <code>^</code> and <code>$</code> anchors …\nSet the match semantics for a <code>Regex</code>.\nReturn the total approximate heap memory, in bytes, used …\nReturns the heap memory usage, in bytes, of this cache.\nBuilds a <code>Regex</code> from a single pattern string using the …\nCreates a new <code>Cache</code> for use with this regex.\nCreate a new configuration object for a <code>Regex</code>.\nCreates a new builder for configuring and constructing a …\nBuilds a <code>Regex</code> from many pattern strings using the default …\nSets the size limit, in bytes, to enforce on the …\nToggle whether a one-pass DFA should be available for use …\nSets the size limit, in bytes, for the one-pass DFA.\nOverwrite the default configuration such that the options …\nReturns the total number of patterns in this regex.\nA thread safe pool of caches.\nOverrides and sets the prefilter to use inside a <code>Regex</code>.\nReturns the <code>Regex</code> value that created this iterator.\nReturns the <code>Regex</code> value that created this iterator.\nReset this cache such that it can be used for searching …\nReturns the start and end offset of the leftmost match. If …\nExecutes a leftmost forward search and writes the spans of …\nThis is like <code>Regex::search_captures</code>, but requires the …\nReturns the end offset of the leftmost match. If no match …\nThis is like <code>Regex::search_half</code>, but requires the caller to\nExecutes a leftmost forward search and writes the spans of …\nThis is like <code>Regex::search_slots</code>, but requires the caller …\nThis is like <code>Regex::search</code>, but requires the caller to …\nReturns an iterator of spans of the haystack given, …\nReturns an iterator of at most <code>limit</code> spans of the haystack …\nReturns the total number of capturing groups that appear …\nThe core matching engine.\nConfigure the syntax options when parsing a pattern string …\nToggles whether empty matches are permitted to occur …\nConfigures what kinds of groups are compiled as “…\nWrites the set of patterns that match anywhere in the …\nThis is like <code>Regex::which_overlapping_matches</code>, but …\nAttempts to extract an “inner” prefilter from the …\nReturns a copy of the given HIR but with all capturing …\nAttempt to extract a prefilter from an HIR expression.\nLooks for a “top level” HirKind::Concat item in the …\nA trait that represents a single meta strategy. Its main …\nCopies the offsets in the given match to the corresponding …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempts to extract an alternation of literals, and if it…\nGiven a sequence of prefixes, attempt to return a full …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDefines a Thompson NFA and provides the <code>PikeVM</code> and …\nAll capture states, including those corresponding to both …\nAn alternation such that there exists precisely two …\nAn error that can occurred during the construction of a …\nAn abstraction for building Thompson NFAs by hand.\nA state with a single transition that can only be taken if …\nAn empty state that records a capture location.\nA builder for compiling an NFA from a regex’s high-level …\nThe configuration used for a Thompson NFA compiler.\nA dense representation of a state with multiple …\nA sequence of transitions used to represent a dense state.\nA state that cannot be transitioned out of. This is useful …\nOnly capture states corresponding to implicit capture …\nA conditional epsilon transition satisfied via some sort of\nA match state. There is at least one such occurrence of …\nA byte oriented Thompson non-deterministic finite …\nNo capture states are compiled into the Thompson NFA.\nAn iterator over all pattern IDs in an NFA.\nA state with possibly many transitions represented in a …\nA sequence of transitions used to represent a sparse state.\nA state in an NFA.\nA single transition to another state.\nAn alternation such that there exists an epsilon …\nA configuration indicating which kinds of <code>State::Capture</code> …\nWe explicitly associate a lifetime with this iterator even …\nAn NFA backed bounded backtracker for executing regex …\nThe builder for actually constructing an NFA. This …\nA map from pattern ID to capture group index to name. (If …\nThe compiler configuration.\nThe inclusive end of the byte range.\nThe matcher to use for look-around assertions.\nThe combined memory used by each of the ’State’s in ‘…\nThe identifier of the state to transition to.\nA regex parser, used when compiling an NFA directly from a …\nThe ID of the pattern that we’re currently building.\nAn NFA backed Pike VM for executing regex searches with …\nWhether this NFA should be matched in reverse or not.\nA size limit to respect when building an NFA. If the total …\nThe inclusive start of the byte range.\nThe starting states for each individual pattern. Starting …\nA sequence of intermediate NFA states. Once a state is …\nThe sorted sequence of non-overlapping transitions.\nA dense representation of this state’s transitions on …\nState used for arranging character classes in reverse into …\nWhether this NFA only matches UTF-8 and whether regex …\nState used for compiling character classes to UTF-8 byte …\nState used for caching common suffixes when compiling …\nAn unconditional epsilon transition to another NFA state. …\nAn unconditional epsilon transition to another NFA state. …\nAn ordered sequence of unconditional epsilon transitions …\nThe capture group index that this capture belongs to. …\nThe look-around assertion that must be satisfied before …\nThe state to transition to if the look-around assertion is …\nThe state to transition to, unconditionally.\nThe pattern ID that this capture belongs to.\nThe matching pattern ID.\nThe slot index for this capture. Every capturing group has …\nThe transition from this state to the next.\nThe size of each block, in bits.\nA backtracking regex engine that bounds its execution to …\nA builder for a bounded backtracker.\nA cache represents mutable state that a <code>BoundedBacktracker</code> …\nThe configuration used for building a bounded backtracker.\nRepresents a stack frame on the heap while doing …\nReset the given <code>slot</code> to the given <code>offset</code> (which might be …\nLook for a match starting at <code>sid</code> and the given position in …\nAn iterator over all non-overlapping leftmost matches, …\nAn iterator over all non-overlapping matches for a …\nA bitset that keeps track of whether a particular …\nCreate a new <code>BoundedBacktracker</code> that matches every input.\nLook for a match starting at <code>at</code> in <code>input</code> and write the …\nThe actual underlying bitset. Each element in the bitset …\nBuild a <code>BoundedBacktracker</code> from the given pattern.\nBuild a <code>BoundedBacktracker</code> directly from its NFA.\nBuild a <code>BoundedBacktracker</code> from the given patterns.\nReturn a builder for configuring the construction of a …\nReturn a default configuration for a <code>BoundedBacktracker</code>.\nApply the given <code>BoundedBacktracker</code> configuration options …\nCreate a new cache for this regex.\nCreate a new empty set of capturing groups that is …\nInteger division, but rounds up instead of down.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the config for this <code>BoundedBacktracker</code>.\nReturns a reference to the underlying NFA.\nReturns the prefilter set in this configuration, if one at …\nReturns the configured visited capacity.\nInsert the given (StateID, offset) pair into this set. If …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the maximum haystack length supported by this …\nReturns the heap memory usage, in bytes, of this cache.\nReturn the heap memory usage, in bytes, of this visited …\nReturns the minimum visited capacity for the given …\nCreate a new <code>BoundedBacktracker</code> that never matches any …\nReturn a new default regex configuration.\nCreate a new BoundedBacktracker builder with its default …\nParse the given regular expression using the default …\nCreate a new <code>BoundedBacktracker</code> cache.\nCreate a new visited set for the given backtracker.\nExample\nLike <code>new</code>, but parses multiple patterns into a single “…\nOverwrite the default configuration such that the options …\nReturns the total number of patterns compiled into this …\nSet a prefilter to be used whenever a start state is …\nReset this cache such that it can be used for searching …\nReset this visited set to work with the given bounded …\nReset the given cache such that it can be used for …\nThe implementation of standard leftmost backtracking …\nClears this cache. This should be called at the start of …\nSetup this visited set to work for a search using the …\nStack used on the heap for doing backtracking instead of …\nExecute a “step” in the backtracing algorithm.\nThe stride represents one plus length of the haystack we’…\nSet the syntax configuration for this builder using …\nSet the Thompson NFA configuration for this builder using …\nExecutes a leftmost forward search and writes the spans of …\nReturns an iterator over all non-overlapping <code>Captures</code> …\nExecutes a leftmost forward search and returns a <code>Match</code> if …\nReturns an iterator over all non-overlapping leftmost …\nReturns true if and only if this regex matches the given …\nExecutes a leftmost forward search and writes the spans of …\nExecutes a leftmost forward search and writes the spans of …\nThis is the actual implementation of <code>try_search_slots_imp</code> …\nThe set of (StateID, HaystackOffset) pairs that have been …\nSet the visited capacity used to bound backtracking.\nAn abstraction for building Thompson NFAs by hand.\nA state that only transitions to another state if the …\nAn empty state that records the end of a capture location. …\nAn empty state that records the start of a capture …\nAn empty state whose only purpose is to forward the …\nA state that cannot be transitioned out of. This is useful …\nA conditional epsilon transition satisfied via some sort of\nA match state. There is at most one such occurrence of …\nA state with possibly many transitions, represented in a …\nAn intermediate NFA state used during construction.\nAn alternation such that there exists an epsilon …\nAn alternation such that there exists an epsilon …\nThe common implementation of “add a state.” It handles …\nAdd a “end capture” NFA state.\nAdd a “start capture” NFA state.\nAdd an “empty” NFA state.\nAdds a “fail” NFA state.\nAdd a “look” NFA state.\nAdds a “match” NFA state.\nAdd a “range” NFA state.\nAdd a “sparse” NFA state.\nAdd a “union” NFA state.\nAdd a “reverse union” NFA state.\nAssemble a <code>NFA</code> from the states added so far.\nA map from pattern ID to capture group index to name. (If …\nClear this builder.\nReturns the pattern identifier of the current pattern.\nFinish the assembly of a pattern in this NFA.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the look-around matcher used for this builder.\nReturns whether reverse mode is enabled for this builder.\nReturn the currently configured size limit.\nReturns whether UTF-8 mode is enabled for this builder.\nIf this state is an unconditional epsilon transition, then …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe matcher to use for look-around assertions.\nThe combined memory used by each of the ’State’s in ‘…\nReturns the heap memory usage, in bytes, of this state.\nReturns the heap memory usage, in bytes, used by the NFA …\nCreate a new builder for hand-assembling NFAs.\nAdd a transition from one state to another.\nThe ID of the pattern that we’re currently building.\nReturns the number of patterns added to this builder so …\nWhether this NFA should be matched in reverse or not.\nSets the look-around matcher that should be used for the …\nSets whether the NFA produced by this builder should be …\nSet the size limit on this builder.\nSet whether the NFA produced by this builder should only …\nA size limit to respect when building an NFA. If the total …\nStart the assembly of a pattern in this NFA.\nThe starting states for each individual pattern. Starting …\nA sequence of intermediate NFA states. Once a state is …\nWhether this NFA only matches UTF-8 and whether regex …\nThe capture group index that this capture state …\nThe capture group index that this capture state …\nThe next state that this state should transition to.\nThe next state that this state should transition to.\nThe next state that this state should transition to.\nThe ID of the pattern that this capture was defined.\nThe ID of the pattern that this capture was defined.\nAll capture states, including those corresponding to both …\nA builder for compiling an NFA from a regex’s high-level …\nThe configuration used for a Thompson NFA compiler.\nOnly capture states corresponding to implicit capture …\nNo capture states are compiled into the Thompson NFA.\nA value that represents the result of compiling a …\nA UTF-8 compiler based on Daciuk’s algorithm for …\nA configuration indicating which kinds of <code>State::Capture</code> …\nCompile the given regular expression pattern into an NFA.\nCompile the given high level intermediate representation …\nCompile the given regular expression patterns into a …\nCompile the given high level intermediate representations …\nThe builder for actually constructing an NFA. This …\nCompile an arbitrary HIR expression.\nCompile an alternation, where each element yielded by the …\nCompile an alternation of the given HIR values.\nCompile the given expression such that it may be matched <code>n</code> …\nCompile the given expression such that it matches at least …\nCompile the given byte oriented character class.\nCompile the given capture sub-expression. <code>expr</code> should be …\nCompile a concatenation of the sub-expressions yielded by …\nCompile an “empty” state with one unconditional …\nCompile the given HIR expression exactly <code>n</code> times.\nCompile a “fail” state that can never have any …\nCompile the given byte string to a concatenation of bytes.\nCompile the given HIR look-around assertion to an NFA …\nCompile a “range” state with one transition that may …\nCompile the given repetition expression. This handles all …\nCompile the given Unicode character class.\nCompile the given Unicode character class in reverse with …\nCompile the given expression such that it may be matched …\nWhether to include ‘Capture’ states in the NFA.\nCompile the sequence of HIR expressions given. Pattern IDs …\nThe compiler configuration.\nApply the given NFA configuration options to this builder.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn whether NFA compilation is configured to produce …\nReturn the look-around matcher for this NFA.\nReturn the configured NFA size limit, if it exists, in the …\nReturns whether this configuration has enabled reverse NFA …\nReturn whether NFA shrinking is enabled.\nReturn whether NFA compilation is configured to include an …\nReturns whether this configuration has enabled UTF-8 mode.\nReturn what kinds of capture states will be compiled into …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this configuration indicates that some …\nReturns true if this configuration indicates that no …\nSets the look-around matcher that should be used with this …\nReturn a new default Thompson NFA compiler configuration.\nCreate a new NFA builder with its default configuration.\nSets an approximate size limit on the total heap used by …\nOverwrite the default configuration such that the options …\nA regex parser, used when compiling an NFA directly from a …\nReverse the NFA.\nApply best effort heuristics to shrink the NFA at the …\nSet the syntax configuration for this builder using …\nState used for arranging character classes in reverse into …\nWhether to enable UTF-8 mode during search or not.\nState used for compiling character classes to UTF-8 byte …\nState used for caching common suffixes when compiling …\nConfigures what kinds of capture groups are compiled into …\nAn error that can occurred during the construction of a …\nThe kind of error that occurred during the construction of …\nAn error that occurs if the capturing groups provided to …\nAn error that occurs when NFA compilation exceeds a …\nAn error that occurs when an invalid capture group index …\nAn error that occurred while parsing a regular expression. …\nAn error that occurs if too many patterns were given to …\nAn error that occurs if too states are produced while …\nAn error that occurs when one tries to build a reverse NFA …\nAn error that occurs when an NFA contains a Unicode word …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf this error occurred because the NFA exceeded the …\nThe number of patterns given, which exceeds the limit.\nThe minimum number of states that are desired, which …\nThe invalid index that was given.\nThe limit on the number of patterns.\nThe limit on the number of states.\nThe configured limit, in bytes.\nAn explicit stack frame used for traversing the trie …\nA trie that preserves leftmost-first match semantics.\nA state in a trie.\nAn iterator over all of the chunks in a state, including …\nA single transition in a trie to another state.\nReturns the active chunk as a slice of transitions.\nReturns the index into ‘transitions’ where the active …\nAdd the given literal to this trie.\nMark this state as a match state and freeze the active …\nReturns an iterator over all of the chunks (including the …\nThe remaining chunks to visit for a trie state.\nCompile this literal trie to the NFA builder given.\nCreate a new literal trie that adds literals in the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the given transition is defined, then return the next …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this state is a leaf state. …\nCreate a new stack frame for trie traversal. This …\nWhether to add literals in reverse to the trie. Useful …\nCreate a new literal trie that adds literals in reverse.\nThe actual NFA transitions for a single chunk in a trie …\nThe set of trie states. Each state contains one or more …\nThe transitions of the current chunk that we’re …\nThe NFA state IDs pointing to the start of each chunk …\nAn entry in this map.\nA bounded hash map where the key is a sequence of NFA …\nAn entry in this map.\nA key that uniquely identifies an NFA state. It is a …\nA cache of suffixes used to modestly compress UTF-8 …\nThe total number of entries this map can store.\nThe total number of entries this map can store.\nClear this map of all entries, but permit the reuse of …\nClear this map of all entries, but permit the reuse of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRetrieve the cached state ID corresponding to the given …\nRetrieve the cached state ID corresponding to the given …\nReturn a hash of the given transitions.\nReturn a hash of the given transition.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe key, which is a sorted sequence of non-overlapping NFA …\nThe key, which consists of a transition in a particular …\nThe actual entries, keyed by hash. Collisions between …\nThe actual entries, keyed by hash. Collisions between …\nCreate a new bounded map with the given capacity. The map …\nCreate a new bounded map with the given capacity. The map …\nAdd a cached state to this map with the given key. Callers …\nAdd a cached state to this map with the given key. Callers …\nThe state ID corresponding to the state containing the …\nThe identifier that the transition in the key maps to.\nThe current version of this map. Only entries with …\nThe version of the map used to produce this entry. If this …\nThe current version of this map. Only entries with …\nThe version of the map used to produce this entry. If this …\nAn alternation such that there exists precisely two …\nA state with a single transition that can only be taken if …\nAn empty state that records a capture location.\nA dense representation of a state with multiple …\nA sequence of transitions used to represent a dense state.\nA state that cannot be transitioned out of. This is useful …\nThe “inner” part of the NFA. We split this part out so …\nA conditional epsilon transition satisfied via some sort of\nA match state. There is at least one such occurrence of …\nA byte oriented Thompson non-deterministic finite …\nAn iterator over all pattern IDs in an NFA.\nA state with possibly many transitions represented in a …\nA sequence of transitions used to represent a sparse state.\nA state in an NFA.\nA single transition to another state.\nAn alternation such that there exists an epsilon …\nWe explicitly associate a lifetime with this iterator even …\nAdd the given state to this NFA after allocating a fresh …\nReturns an NFA with a single regex pattern that always …\nGet the byte class set for this NFA.\nA representation of equivalence classes over the …\nGet the byte classes for this NFA.\nThis is generated from <code>byte_class_set</code>, and essentially …\nReturn a compiler for configuring the construction of an …\nReturn a default configuration for an <code>NFA</code>.\nThe inclusive end of the byte range.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the capturing group info for this NFA.\nReturns the capturing group info for this NFA.\nInfo about the capturing groups in this NFA. This is …\nReturns true if and only if this NFA has at least one …\nWhether this NFA has a <code>Capture</code> state anywhere.\nReturns true if and only if this NFA can match the empty …\nWhen the empty string is in the language matched by this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRuns any last finalization bits and turns this into a full …\nReturns true if and only if all starting states for this …\nReturns true if and only if this state contains one or …\nReturns true when this NFA is meant to be matched in …\nWhether UTF-8 mode is enabled for this NFA or not.\nReturns an iterator over all transitions that don’t …\nReturns the look-around matcher associated with this NFA.\nThe matcher to be used for look-around assertions.\nReturns the union of all look-around assertions used …\nThe union of all look-around assertions that occur …\nReturns the union of all prefix look-around assertions for …\nThe union of all look-around assertions that occur as a …\nThis follows the matching transition for a particular byte.\nThis follows the matching transition for a particular byte.\nReturns true if the position <code>at</code> in <code>haystack</code> falls in this …\nThis follows the matching transition for a particular byte.\nThis follows the matching transition for a particular byte.\nReturns true if the given byte falls in this transition’…\nThis follows the matching transition for any member of the …\nThis follows the matching transition for any member of the …\nReturns true if the given alphabet unit falls in this …\nHeap memory used indirectly by NFA states and other things …\nReturns the memory usage, in bytes, of this NFA.\nReturns the heap memory usage of this NFA state in bytes.\nReturns an NFA that never matches at any position.\nParse the given regular expression using a default …\nParse the given regular expressions using a default …\nThe identifier of the state to transition to.\nReturns the total number of regex patterns in this NFA.\nReturns an iterator over all pattern identifiers in this …\nRemap the transitions in every state of this NFA using the …\nRemap the transitions in this state using the given map. …\nWhether this NFA is meant to be matched in reverse or not.\nSet the capturing groups for this NFA.\nSets the look-around assertion matcher for this NFA.\nSets the reverse mode of this NFA.\nSet the starting state identifiers for this NFA.\nSets the UTF-8 mode of this NFA.\nThe inclusive start of the byte range.\nReturn the state identifier of the initial anchored state …\nThe anchored starting state of this NFA.\nReturn the state identifier of the initial anchored state …\nThe starting states for each individual pattern. Starting …\nReturn the state identifier of the initial unanchored …\nThe unanchored starting state of this NFA.\nReturn a reference to the NFA state corresponding to the …\nReturns a slice of all states in this NFA.\nThe state sequence. This sequence is guaranteed to be …\nThe sorted sequence of non-overlapping transitions.\nA dense representation of this state’s transitions on …\nWhether UTF-8 mode is enabled for this NFA. Briefly, this …\nAn unconditional epsilon transition to another NFA state. …\nAn unconditional epsilon transition to another NFA state. …\nAn ordered sequence of unconditional epsilon transitions …\nThe capture group index that this capture belongs to. …\nThe look-around assertion that must be satisfied before …\nThe state to transition to if the look-around assertion is …\nThe state to transition to, unconditionally.\nThe pattern ID that this capture belongs to.\nThe matching pattern ID.\nThe slot index for this capture. Every capturing group has …\nThe transition from this state to the next.\nA set of active states used to “simulate” the …\nA builder for a <code>PikeVM</code>.\nA cache represents mutable state that a <code>PikeVM</code> requires …\nAn iterator over all non-overlapping leftmost matches, …\nThe configuration used for building a <code>PikeVM</code>.\nExplore the epsilon transitions from a state ID.\nAn iterator over all non-overlapping matches for a …\nRepresents a stack frame for use while computing an …\nA virtual machine for executing regex searches with …\nReset the given <code>slot</code> to the given <code>offset</code> (which might be …\nA table of slots, where each row represent a state in an …\nReturn a slice of slots of appropriate length where every …\nCreate a new <code>PikeVM</code> that matches every input.\nBuild a <code>PikeVM</code> from the given pattern.\nBuild a <code>PikeVM</code> directly from its NFA.\nBuild a <code>PikeVM</code> from the given patterns.\nReturn a builder for configuring the construction of a …\nExecutes a leftmost forward search and writes the spans of …\nReturns an iterator over all non-overlapping <code>Captures</code> …\nReturn a default configuration for a <code>PikeVM</code>.\nApply the given <code>PikeVM</code> configuration options to this …\nCreate a new cache for this <code>PikeVM</code>.\nCreate a new empty set of capturing groups that is …\nThe current active states being explored for the current …\nCompute the epsilon closure of ‘sid’, writing the …\nExplore all of the epsilon transitions out of ‘sid’. …\nExecutes a leftmost forward search and returns a <code>Match</code> if …\nReturns an iterator over all non-overlapping leftmost …\nReturn a mutable slice of the slots for the given state.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the config for this <code>PikeVM</code>.\nReturns the match semantics set in this configuration.\nReturns a reference to the underlying NFA.\nReturns the prefilter set in this configuration, if one at …\nA simple macro for conditionally executing instrumentation …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this <code>PikeVM</code> matches the given …\nSet the desired match semantics.\nReturns the heap memory usage, in bytes, of this cache.\nReturn the heap memory usage, in bytes, used by this set …\nReturn the heap memory usage, in bytes, used by this slot …\nCreate a new <code>PikeVM</code> that never matches any input.\nReturn a new default PikeVM configuration.\nCreate a new PikeVM builder with its default configuration.\nParse the given regular expression using the default …\nCreate a new <code>PikeVM</code> cache.\nCreate a new set of active states for the given PikeVM. …\nCreate a new slot table.\nLike <code>new</code>, but builds a PikeVM directly from an NFA. This …\nLike <code>new</code>, but parses multiple patterns into a single “…\nStarting from ‘sid’, if the position ‘at’ in the …\nThe next set of states we’re building that will be …\nProcess the active states in ‘curr’ to find the states …\nLike ‘nexts’, but for the overlapping case. This doesn…\nOverwrite the default configuration such that the options …\nReturns the total number of patterns compiled into this …\nSet a prefilter to be used whenever a start state is …\nReset this cache such that it can be used for searching …\nReset this set of active states such that it can be used …\nReset this slot table such that it can be used with the …\nReset the given cache such that it can be used for …\nExecutes a leftmost forward search and writes the spans of …\nThe implementation of standard leftmost search.\nExecutes a leftmost forward search and writes the spans of …\nThis is the actual implementation of <code>search_slots_imp</code> that …\nThe set of active NFA states. This set preserves insertion …\nClears this cache. This should be called at the start of …\nSetup this set of active states for a new search. The …\nPerform any per-search setup for this slot table.\nThe slots for every NFA state, where each slot stores a …\nThe number of slots in the caller-provided ‘Captures’ …\nThe number of slots per state, i.e., the table’s stride …\nStack used while computing epsilon closure. This …\nReturn the starting configuration of a PikeVM search.\nSet the syntax configuration for this builder using …\nThe actual table of offsets.\nSet the Thompson NFA configuration for this builder using …\nThe implementation for the ‘which_overlapping_matches’ …\nWrites the set of patterns that match anywhere in the …\nThere is only one final state in this trie. Every sequence …\nThe next state to process during duplication.\nThe next state to process during insertion and any …\nThe next state (and its corresponding transition) that we …\nThe root state of the trie.\nA range trie represents an ordered set of sequences of …\nSplit represents a partitioning of two ranges into one or …\nA tagged range indicating how it was derived from a pair …\nA single state in this trie.\nA transition is a single range of bytes. If a particular …\nAdds the given transition to the given state.\nLike <code>add_transition</code>, except this inserts the transition …\nReturn the partitions in this split as a slice.\nClear this range trie such that it is empty. Clearing a …\nClear this state such that it has zero transitions.\nA stack used for traversing the trie in order to (deeply) …\nPerforms a deep clone of the given state and returns the …\nFind the position at which the given range should be …\nA free-list of states. When a range trie is cleared, all …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts a new sequence of ranges into this trie.\nA stack used for traversing the trie during insertion of a …\nReturns true if and only if the given ranges intersect.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over all of the sequences of byte ranges in this …\nA buffer that stores the current sequence during iteration.\nA stack for traversing this trie to yield sequences of …\nThe number of valid ranges in the above array.\nCreate a new empty range trie.\nCreate the next item to visit. The given state ID should …\nCreate a partitioning of the given ranges.\nThe ID of the new state that is a duplicate of old_id.\nThe next state to transition to.\nThe state we want to duplicate.\nCreate a new split with a single partition. This only …\nCreate a new split with two partitions.\nCreate a new split with three partitions.\nPush a new empty state to visit along with any remaining …\nThe byte range.\nReturn the remaining ranges to insert.\nThe ranges to insert. We used a fixed-size array here to …\nOverwrites the transition at position i with the given …\nReturn an immutable borrow for the state with the given ID.\nReturn the ID of the state to visit.\nThe next state to begin inserting ranges. This state …\nReturn a mutable borrow for the state with the given ID.\nThe states in this trie. The first is always the shared …\nA sorted sequence of non-overlapping transitions to other …\nThis module provides APIs for dealing with the alphabets …\nProvides types for dealing with capturing groups.\nThis module contains types and routines for implementing …\nThis module provides helper routines for dealing with …\nProvides convenience routines for escaping raw bytes.\nThis module provides several integer oriented traits for …\nProvides routines for interpolating capture group …\nGeneric helpers for iteration of matches from a regex …\nA lazily initialized value for safe sharing between …\nTypes and routines for working with look-around assertions.\nThis module defines simple wrapper routines for the memchr …\nA thread safe memory pool.\nDefines a prefilter for accelerating regex searches.\nLower level primitive types that are useful in a variety …\nTypes and routines that support the search APIs of most …\nThis module defines a sparse set data structure. Its most …\nProvides helpers for dealing with start state …\nUtilities for dealing with the syntax of a regular …\nUtilities for dealing with UTF-8.\nTypes and routines that support the wire format of finite …\nThe representation of a byte set. Split out so that we can …\nAn iterator over all elements in an equivalence class …\nAn iterator over all elements in an equivalence class.\nAn iterator over each equivalence class.\nAn iterator over representative bytes from each …\nA partitioning of bytes into equivalence classes.\nA representation of byte oriented equivalence classes.\nA simple set of bytes that is reasonably cheap to copy and …\nRepresents the “end of input” sentinel. We regretably …\nRepresents a byte value, or more typically, an equivalence …\nUnit represents a single unit of haystack for DFA based …\nAdd a byte to this set.\nAdd the contiguous ranges in the set given to this byte …\nReturn the total number of elements in the alphabet …\nIf this unit is an “end of input” sentinel, then …\nIf this unit is not an “end of input” sentinel, then …\nReturn this unit as a <code>usize</code>, regardless of whether it is a …\nConvert this boolean set to a map that maps all byte …\nReturn true if and only if the given byte is in this set.\nReturn true if and only if the given inclusive range of …\nReturns an iterator of byte ranges in the given …\nReturns an iterator of the bytes in the given equivalence …\nCreates a new set of equivalence classes where all bytes …\nCreate a new set of byte classes where all bytes are part …\nCreate an empty set of bytes.\nCreate a new “end of input” haystack unit.\nCreate a unit that represents the “end of input” …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserializes a byte class map from the given slice. If the …\nDeserializes a byte set from the given slice. If the slice …\nGet the equivalence class for the given byte.\nGet the equivalence class for the given haystack unit and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only of this unit is a byte value …\nReturn true if and only if this set is empty.\nReturns true when this unit represents an “end of input…\nReturns true if and only if every byte in this class maps …\nReturns true when this unit corresponds to an ASCII word …\nReturns an iterator over all equivalence classes in this …\nReturns an iterator over all bytes in this set.\nReturns an iterator over all contiguous ranges of bytes in …\nRemove a byte from this set.\nReturns an iterator over a sequence of representative …\nSet the equivalence class for the given byte.\nIndicate the range of byte given (inclusive) can …\nCreates a new set of equivalence classes where each byte …\nReturns the stride, as a base-2 exponent, required for …\nCreate a new haystack unit from a byte value.\nWrites this byte class map to the given byte buffer. if …\nWrites this byte set to the given byte buffer. If the …\nReturns the total number of bytes written by <code>write_to</code>.\nReturns the total number of bytes written by <code>write_to</code>.\nA map from capture group name to its corresponding capture …\nThe span offsets of capturing groups after a match has …\nA little helper type to provide a nice map-like debug …\nAn iterator over all capturing groups in a <code>Captures</code> value.\nAn error that occurs when duplicate capture group names …\nAn error that occurs when one tries to provide a name for …\nRepresents information about capturing groups in a …\nAn iterator over capturing groups and their names for a …\nAn error that may occur when building a <code>GroupInfo</code>.\nThe kind of error that occurs when building a <code>GroupInfo</code> …\nThe inner guts of <code>GroupInfo</code>. This type only exists so that …\nAn iterator over capturing groups and their names for a …\nAn error that occurs when a pattern has no capture groups. …\nThis occurs when too many capturing groups have been added …\nThis occurs when too many patterns have been added. i.e., …\nAdd an explicit capturing group for the given pattern with …\nThis adds the first unnamed group for the given pattern …\nCreate new storage for the offsets of all matching …\nReturn the total number of capture groups across all …\nReturn an iterator of all capture groups for all patterns …\nClear this <code>Captures</code> value.\nCreate new storage for only tracking which pattern …\nThis creates an empty <code>GroupInfo</code>.\nReturns the total number of slots for explicit capturing …\nThis is a convenience routine for extracting the substrings\nThis is a convenience routine for extracting the substrings\nThis corrects the slot ranges to account for the slots …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the span of a capturing group match corresponding …\nReturns the span of a capturing group match corresponding …\nReturns the pattern ID and the span of the match, if one …\nReturns a reference to the underlying group info on which …\nThe group info that these capture groups are coupled to. …\nReturn the total number of capturing groups for the …\nReturn the number of capture groups in a pattern.\nReturn the total number of capturing groups for the given …\nReturns the total number of slots for implicit capturing …\nInterpolates the capture references in <code>replacement</code> with the\nInterpolates the capture references in <code>replacement</code> with the\nInterpolates the capture references in <code>replacement</code> with the\nInterpolates the capture references in <code>replacement</code> with the\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this capturing group …\nReturns an iterator of possible spans for every capturing …\nCreate new storage for only the full match spans of a …\nReturns the memory usage, in bytes, of this <code>GroupInfo</code>.\nCreates a new group info from a sequence of patterns, …\nReturns the identifier of the pattern that matched when …\nReturns the total number of patterns in this <code>GroupInfo</code>.\nReturn the total number of patterns represented by this …\nReturn an iterator of all capture groups and their names …\nThe ID of the pattern that matched. Regex engines must set …\nSet the pattern on this <code>Captures</code> value.\nReturns the starting slot corresponding to the given …\nReturns the total number of slots in this <code>GroupInfo</code> across …\nReturns the underlying slots, where each slot stores a …\nReturns the starting and ending slot corresponding to the …\nThe slot values, i.e., submatch offsets.\nReturns the underlying slots as a mutable slice, where …\nReturn the total number of slots in this capture slot info …\nReturn the capture group index corresponding to the given …\nReturn the capture name for the given index and given …\nThe minimum number of groups that the caller has tried to …\nThe duplicate name.\nThe ID of the pattern that had too many groups.\nThe ID of the pattern that had no capturing groups.\nThe ID of the pattern that was found to have a named first …\nThe pattern in which the duplicate capture group name was …\nAdd the NFA state IDs in the given <code>set</code> to the given DFA …\nCompute the epsilon closure for the given NFA state. The …\nCompute the set of all reachable NFA states, including the …\nSets the appropriate look-behind assertions on the given …\nThis module defines a DFA state representation and …\nRepr is a read-only view into the representation of a DFA …\nReprVec is a write-only view into the representation of a …\nA DFA state that, at its core, is represented by an …\nA state builder that represents an empty state.\nA state builder that collects assertions and pattern IDs.\nA state builder that collects some assertions and NFA …\nAdd a pattern ID to this state. All match states must have …\nAdd an NFA state ID to this state. The order in which NFA …\nIndicate that no more pattern IDs will be added to this …\nReturns the total number of <em>encoded</em> pattern IDs in this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if and only if this state has had at least …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this state is marked as having …\nReturns true if and only if this state is marked as being …\nReturns true if and only if this is a match state.\nCalls the given function on every pattern ID in this state.\nCalls the given function on every NFA state ID in this …\nThe set of look-behind assertions that were true in the …\nThe set of look-behind assertions that were true in the …\nThe set of look-around (both behind and ahead) assertions …\nThe set of look-around (both behind and ahead) assertions …\nReturns the total number of match pattern IDs in this …\nReturns the pattern ID for this match state at the given …\nReturns a copy of all match pattern IDs in this state. If …\nReturns the offset into this state’s representation …\nRead a signed 32-bit integer using zig-zag encoding. Also, …\nRead an unsigned 32-bit varint. Also, return the number of …\nReturn a read-only view of this state’s representation.\nSet that this state has pattern IDs explicitly written to …\nSet this state as being built from a transition over a …\nSet this state as having seen half of a CRLF terminator.\nSet this state as a match state.\nMutate the set of look-behind assertions that were true in …\nMutate the set of look-around (both behind and ahead) …\nPush a native-endian encoded <code>n</code> on to <code>dst</code>.\nWrite a signed 32-bit integer using zig-zag encoding.\nWrite an unsigned 32-bit integer as a varint. In essence, <code>n</code>…\nProvides a convenient <code>Debug</code> implementation for a <code>u8</code>.\nProvides a convenient <code>Debug</code> implementation for <code>&amp;[u8]</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>CaptureRef</code> represents a reference to a capture group …\nA reference to a capture group in some text.\nAccepts a replacement byte string and interpolates capture …\nParses a possible reference to a capture group name in the …\nLooks for a braced reference, e.g., <code>${foo1}</code>. This assumes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if the given byte is allowed in a …\nAccepts a replacement string and interpolates capture …\nAn iterator over all non-overlapping captures for an …\nAn iterator over all non-overlapping half matches for an …\nAn iterator over all non-overlapping matches for an …\nA searcher for creating iterators and performing lower …\nAn iterator over all non-overlapping captures for a …\nAn iterator over all non-overlapping half matches for a …\nAn iterator over all non-overlapping matches for a …\nReturn the next match for an infallible search if one …\nReturn the next half match for an infallible search if one …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHandles the special case of a match that begins where the …\nHandles the special case of an empty match by ensuring …\nReturn an infallible version of this iterator.\nReturn an infallible version of this iterator.\nReturn an infallible version of this iterator.\nReturns the current <code>Input</code> used by this iterator.\nReturns the current <code>Input</code> used by this iterator.\nReturns the current <code>Input</code> used by this searcher.\nReturns the current <code>Input</code> used by this iterator.\nReturns the current <code>Input</code> used by this iterator.\nThe input parameters to give to each regex engine call.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven a closure that executes a single search, return an …\nGiven a closure that executes a single search, return an …\nGiven a closure that executes a single search, return an …\nRecords the end offset of the most recent match. This is …\nCreate a new fallible non-overlapping matches iterator.\nReturn the next match for a fallible search if one exists, …\nReturn the next half match for a fallible search if one …\nA lazily initialized value that implements <code>Deref</code> for <code>T</code>.\nReturns the argument unchanged.\nReturn a reference to the lazily initialized value.\nCalls <code>U::from(self)</code>.\nCreate a new <code>Lazy</code> value that is initialized via the given …\nA non-std lazy initialized value.\nReturns the argument unchanged.\nGet the underlying lazy value. If it hasn’t been …\nCalls <code>U::from(self)</code>.\nCreate a new alloc but non-std lazy value that is racily …\nIf this lazy value has been initialized successfully, then …\nMatch the end of text. Specifically, this matches at the …\nMatch the end of a line or the end of text. Specifically, …\nMatch the end of a line or the end of text. Specifically, …\nA look-around assertion.\nA matcher for look-around assertions.\nLookSet is a memory-efficient set of look-around …\nAn iterator over all look-around assertions in a <code>LookSet</code>.\nMatch the beginning of text. Specifically, this matches at …\nMatch the beginning of a line or the beginning of text. …\nMatch the beginning of a line or the beginning of text. …\nAn error that occurs when the Unicode-aware <code>\\w</code> class is …\nMatch an ASCII-only word boundary. That is, this matches a …\nMatch an ASCII-only negation of a word boundary.\nMatch the end of an ASCII-only word boundary. That is, …\nMatch the end half of an ASCII-only word boundary. That …\nMatch the end half of a Unicode word boundary. That is, …\nMatch the end of a Unicode word boundary. That is, this …\nMatch the start of an ASCII-only word boundary. That is, …\nMatch the start half of an ASCII-only word boundary. That …\nMatch the start half of a Unicode word boundary. That is, …\nMatch the start of a Unicode word boundary. That is, this …\nMatch a Unicode-aware word boundary. That is, this matches …\nMatch a Unicode-aware negation of a word boundary.\nSplit up the given byte classes into equivalence classes …\nReturns a convenient single codepoint representation of …\nReturn the underlying representation of this look-around …\nChecks that all assertions in this set can be matched.\nThe underlying representation this set is exposed to make …\nReturns an error if and only if Unicode word boundary data …\nReturns true if and only if the given look-around …\nReturns true if and only if this set contains any anchor …\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any word …\nReturns true if and only if this set contains any ASCII …\nReturns true if and only if this set contains any Unicode …\nCreate an empty set of look-around assertions.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven the underlying representation of a <code>Look</code> value, …\nCreate a full set of look-around assertions.\nReturns the line terminator that was configured for this …\nReturn a new set that is equivalent to the original, but …\nReturns a new set that is the intersection of this and the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this set is empty.\nReturns true when <code>Look::End</code> is satisfied <code>at</code> the given …\nReturns true when <code>Look::EndCRLF</code> is satisfied <code>at</code> the given …\nReturns true when <code>Look::EndLF</code> is satisfied <code>at</code> the given …\nReturns true when <code>Look::Start</code> is satisfied <code>at</code> the given …\nReturns true when <code>Look::StartCRLF</code> is satisfied <code>at</code> the given\nReturns true when <code>Look::StartLF</code> is satisfied <code>at</code> the given …\nReturns true when <code>Look::WordAscii</code> is satisfied <code>at</code> the given\nReturns true when <code>Look::WordAsciiNegate</code> is satisfied <code>at</code> …\nA module that looks for word codepoints using regex-syntax…\nReturns true when <code>Look::WordEndAscii</code> is satisfied <code>at</code> the …\nReturns true when <code>Look::WordEndHalfAscii</code> is satisfied <code>at</code> …\nReturns true when <code>Look::WordEndHalfUnicode</code> is satisfied <code>at</code> …\nReturns true when <code>Look::WordEndUnicode</code> is satisfied <code>at</code> the …\nReturns true when <code>Look::WordStartAscii</code> is satisfied <code>at</code> the …\nReturns true when <code>Look::WordStartHalfAscii</code> is satisfied <code>at</code> …\nReturns true when <code>Look::WordStartHalfUnicode</code> is satisfied …\nReturns true when <code>Look::WordStartUnicode</code> is satisfied <code>at</code> …\nReturns true when <code>Look::WordUnicode</code> is satisfied <code>at</code> the …\nReturns true when <code>Look::WordUnicodeNegate</code> is satisfied <code>at</code> …\nReturns an iterator over all of the look-around assertions …\nReturns the total number of look-around assertions in this …\nReturns true when the position <code>at</code> in <code>haystack</code> satisfies …\nLike <code>matches</code>, but forcefully inlined.\nReturns true when <em>all</em> of the assertions in the given set …\nLike <code>LookSet::matches</code>, but forcefully inlined for perf.\nCreates a new default matcher for look-around assertions.\nReturn a <code>LookSet</code> from the slice given as a native endian …\nReturn a new set that is equivalent to the original, but …\nFlip the look-around assertion to its equivalent for …\nUpdates this set in place with the result of inserting the …\nUpdates this set in place with the result of intersecting …\nSets the line terminator for use with <code>(?m:^)</code> and <code>(?m:$)</code>.\nUpdates this set in place with the result of removing the …\nUpdates this set in place with the result of subtracting …\nUpdates this set in place with the result of unioning it …\nCreate a look-around set containing the look-around …\nReturns a new set that is the result of subtracting the …\nReturns a new set that is the union of this and the one …\nWrite a <code>LookSet</code> as a native endian 32-bit integer to the …\nA thread safe pool that works in an <code>alloc</code>-only context.\nA guard that is returned when a caller requests a value …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a value from the pool. The caller is guaranteed to have\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new pool. The given closure is used to create …\nConsumes this guard and puts it back into the pool.\nAn atomic counter used to allocate thread IDs.\nThis puts each stack in the pool below into its own cache …\nThe number of stacks we use inside of the pool. These are …\nA thread safe pool utilizing std-only features.\nA guard that is returned when a caller requests a value …\nA thread local used to assign an ID to a thread.\nThis sentinel is used to indicate that a guard has already …\nA thread ID indicating that the special owner value is in …\nA thread ID indicating that there is no owner. This is the …\nA function to create more T values when stack is empty and …\nWhen true, the value should be discarded instead of being …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a value from the pool. This may block if another …\nThis is the “slow” version that goes through a mutex …\nCreate a guard that represents the special owned T.\nCreate a guard that contains a value from the pool’s …\nCreate a guard that contains a value from the pool’s …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new pool. The given closure is used to create …\nThe ID of the thread that owns this pool. The owner is the …\nA value to return when the caller is in the same thread …\nThe pool that this guard is attached to.\nConsumes this guard and puts it back into the pool.\nPuts this guard back into the pool by only borrowing the …\nPuts a value back into the pool. Callers don’t need to …\nMultiple stacks of T values to hand out. These are used …\nReturn the underlying value.\nThis is Err when the guard represents the special “owned…\nReturn the underlying value as a mutable borrow.\nA type that encapsulates the selection of a prefilter …\nA prefilter for accelerating regex searches.\nA trait for abstracting over prefilters. Basically, a …\nRun this prefilter on <code>haystack[span.start..end]</code> and return …\nRun this prefilter on <code>haystack[span.start..end]</code> and return …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis turns a prefilter selection into a <code>Prefilter</code>. That …\nThis attempts to extract prefixes from the given <code>Hir</code> …\nThis attempts to extract prefixes from the given <code>Hir</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImplementations might return true here if they believe …\nImplementations might return true here if they believe …\nReturn the length of the longest needle in this Prefilter\nReturns the heap memory, in bytes, used by the underlying …\nReturns the heap memory, in bytes, used by the underlying …\nCreate a new prefilter from a sequence of needles and a …\nSelect what is believed to be the best prefilter algorithm …\nReturns the span of a prefix of …\nReturns the span of a prefix of …\nExtracts all of the prefix literals from the given HIR …\nLike <code>prefixes</code>, but for all suffixes of all matches for the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhen running an anchored search, the packed searcher can’…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe length of the smallest literal we look for.\nThe actual Teddy searcher.\nA utility trait that defines a couple of adapters for …\nThe total number of values that can be represented as a …\nThe total number of values that can be represented.\nThe total number of values that can be represented.\nThe maximum index value.\nThe maximum value.\nThe maximum value.\nA <code>usize</code> that can never be <code>usize::MAX</code>.\nThe identifier of a regex pattern, represented by a …\nThis error occurs when a value could not be constructed.\nThe number of bytes that a single small index uses in …\nThe number of bytes that a single value uses in memory.\nThe number of bytes that a single value uses in memory.\nA type that represents a “small” index.\nThis error occurs when a small index could not be …\nThe identifier of a finite automaton state, represented by …\nThis error occurs when a value could not be constructed.\nAn iterator adapter that is like std::iter::Enumerate, but …\nAn iterator adapter that is like std::iter::Enumerate, but …\nThe zero index value.\nThe zero value.\nThe zero value.\nReturn the internal <code>u32</code> of this small index represented as …\nReturn the internal value as a i32…\nReturn the internal value as a i32…\nReturn the internal <code>u32</code> of this small index. This is …\nReturn the internal value as a <code>u32</code>. This is guaranteed to …\nReturn the internal value as a <code>u32</code>. This is guaranteed to …\nReturn this small index as a <code>u64</code>. This is guaranteed to …\nReturn the internal value as a <code>u64</code>. This is guaranteed to …\nReturn the internal value as a <code>u64</code>. This is guaranteed to …\nReturn this small index as a <code>usize</code>. This is guaranteed to …\nReturn the internal value as a <code>usize</code>. This is guaranteed to\nReturn the internal value as a <code>usize</code>. This is guaranteed to\nReturns the value that could not be converted to a small …\nReturns the value that could not be converted to an ID.\nReturns the value that could not be converted to an ID.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode this small index from the bytes given using the …\nDecode this value from the bytes given using the native …\nDecode this value from the bytes given using the native …\nDecode this small index from the bytes given using the …\nDecode this value from the bytes given using the native …\nDecode this value from the bytes given using the native …\nReturn the underlying <code>usize</code> value. The returned value is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over all values from 0 up to and not …\nReturns an iterator over all values from 0 up to and not …\nLike <code>SmallIndex::new</code>, but panics if the given index is not …\nLike <code>new</code>, but panics if the given value is not valid.\nLike <code>new</code>, but panics if the given value is not valid.\nCreate a new <code>NonMaxUsize</code> from the given value.\nCreate a new small index.\nCreate a new value that is represented by a “small index.…\nCreate a new value that is represented by a “small index.…\nCreate a new small index without checking whether the …\nCreate a new value without checking whether the given …\nCreate a new value without checking whether the given …\nReturns one more than this small index as a usize.\nReturns one more than this value as a usize.\nReturns one more than this value as a usize.\nReturn the underlying small index integer as raw bytes in …\nReturn the underlying integer as raw bytes in native endian\nReturn the underlying integer as raw bytes in native endian\nReport all possible matches.\nThe type of anchored search to perform.\nThe search, based on heuristics, determined that it would …\nA representation of “half” of a match reported by a …\nThis error occurs if the haystack given to the regex …\nThe parameters for a regex search including the haystack …\nReport only the leftmost matches. When multiple leftmost …\nA representation of a match reported by a regex engine.\nAn error indicating that a search stopped before reporting …\nThe underlying kind of a <code>MatchError</code>.\nThe kind of match semantics to use for a regex pattern.\nRun an unanchored search. This means a match may occur …\nRun an anchored search for a specific pattern. This means …\nA set of <code>PatternID</code>s.\nAn error that occurs when a <code>PatternID</code> failed to insert …\nAn iterator over all pattern identifiers in a <code>PatternSet</code>.\nThe search saw a “quit” byte at which it was …\nA representation of a span reported by a regex engine.\nAn error indicating that a particular type of anchored …\nRun an anchored search. This means that a match must begin …\nSets the anchor mode of a search.\nReturns the total number of pattern identifiers that may …\nClear this set such that it contains no pattern IDs.\nReturns true when the given offset is contained within …\nReturn true if and only if the given pattern identifier is …\nWhether to execute an “earliest” search or not.\nReturn the end position of this search.\nThe ending position of the match.\nThe end offset of the span, exclusive.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new “gave up” error. The given <code>offset</code> …\nReturn the anchored mode for this search configuration.\nReturn whether this search should execute in “earliest”…\nReturn the span as a range for this search configuration.\nReturn the span for this search configuration.\nReturn a borrow of the underlying haystack as a slice of …\nCreate a new “haystack too long” error. The given <code>len</code> …\nInsert the given pattern identifier into this set and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this anchor mode corresponds …\nReturns true if and only if the given offset in this search…\nReturn true if and only if this search can never return …\nReturns true when this span is empty. That is, when …\nReturns true when the span in this match is empty.\nReturn true if and only if this set has no pattern …\nReturn true if and only if this set has the maximum number …\nReturns an iterator over all pattern identifiers in this …\nReturns a reference to the underlying error kind.\nReturns the length of this span.\nReturns the length of this match.\nReturns the total number of pattern identifiers in this …\nThe number of patterns set to ‘true’ in this set.\nCreate a new half match from a pattern ID and a byte …\nCreate a new match from a pattern ID and a byte offset …\nCreate a new search configuration for the given haystack.\nCreate a new half match from a pattern ID and a byte …\nCreate a new match from a pattern ID and a span.\nCreate a new set of pattern identifiers with the given …\nCreate a new error value with the given kind.\nReturns a new span with <code>offset</code> added to this span’s <code>start</code>…\nThe position of the match.\nThe offset of the match.\nReturns the ID of the pattern that matched.\nReturns the ID of the pattern that matched.\nReturns the pattern ID associated with this configuration …\nThe pattern ID.\nThe pattern ID.\nCreate a new “quit” error. The given <code>byte</code> corresponds …\nLike <code>Input::span</code>, but accepts any range instead.\nReturns this span as a range.\nReturns the match span as a range.\nSet the anchor mode of a search.\nSet whether the search should execute in “earliest” …\nSet the ending offset for the span for this search …\nSet the span for this search configuration given any range.\nSet the span for this search configuration.\nSet the starting offset for the span for this search …\nSet the span for this search.\nReturns the span for this match.\nThe underlying match span.\nReturn the start position of this search.\nThe starting position of the match.\nThe start offset of the span, inclusive.\nInsert the given pattern identifier into this set and …\nCreate a new “unsupported anchored” error. This occurs …\nA map from PatternID to boolean of whether a pattern …\nThe “quit” byte that was observed that caused the …\nThe length of the haystack that exceeded the limit.\nThe anchored mode given that is unsupported.\nThe offset at which the quit byte was observed.\nThe offset at which the search stopped. This corresponds …\nA sparse set used for representing ordered NFA states.\nAn iterator over all elements in a sparse set.\nA pairse of sparse sets.\nReturns the capacity of this set.\nClear both sparse sets.\nClear this set such that it has no members.\nReturns true if and only if this set contains the given …\nDense contains the ids in the order in which they were …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert the state ID value into this set and return true if …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this set is empty.\nReturns the number of elements in this set.\nThe number of elements currently in this set.\nReturns the memory usage, in bytes, used by this pair of …\nReturns the heap memory usage, in bytes, used by this …\nCreate a new pair of sparse sets where each set has the …\nCreate a new sparse set with the given capacity.\nResizes these sparse sets to have the new capacity given.\nResizes this sparse set to have the new capacity given.\nSparse maps ids to their location in dense.\nSwap set1 with set2.\nThe configuration used to determine a DFA’s start state …\nThis occurs when a custom line terminator has been set via …\nThis occurs when the byte immediately preceding the start …\nThis occurs when the byte immediately preceding the start …\nThis occurs when the starting position is not any of the …\nRepresents the six possible starting configurations of a …\nA map from every possible byte value to its corresponding …\nThis occurs when the starting position of the search …\nThis occurs when the byte immediately preceding the start …\nSet the anchored mode of a search.\nReturn this starting configuration as <code>u8</code> integer. It is …\nReturn this starting configuration as a <code>usize</code> integer. It …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDeserializes a byte class map from the given slice. If the …\nA convenience routine for building a start configuration …\nA convenience routine for building a start configuration …\nReturn the starting state corresponding to the given …\nReturn the starting configuration for the given …\nReturn the anchored mode in this configuration.\nReturn the look-behind byte in this configuration, if one …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the total number of starting state configurations.\nSet the look-behind byte at the start of a search.\nCreate a new default start configuration.\nCreate a new map from byte values to their corresponding …\nWrites this map to the given byte buffer. if the given …\nReturns the total number of bytes written by <code>write_to</code>.\nA common set of configuration options that apply to the …\nApplies this configuration to the given parser.\nApplies this configuration to the given AST parser.\nApplies this configuration to the given AST-to-HIR …\nEnable or disable the case insensitive flag by default.\nEnable or disable the “CRLF mode” flag by default.\nEnable or disable the “dot matches any character” flag …\nReturns the argument unchanged.\nReturns whether “case insensitive” mode is enabled.\nReturns whether “CRLF” mode is enabled.\nReturns whether “dot matches new line” mode is enabled.\nReturns whether “ignore whitespace” mode is enabled.\nReturns the line terminator in this syntax configuration.\nReturns whether “multi line” mode is enabled.\nReturns the “nest limit” setting.\nReturns whether “octal” mode is enabled.\nReturns whether “swap greed” mode is enabled.\nReturns whether “unicode” mode is enabled.\nReturns whether UTF-8 mode is enabled.\nEnable verbose mode in the regular expression.\nCalls <code>U::from(self)</code>.\nSets the line terminator for use with <code>(?u-s:.)</code> and <code>(?-us:.)</code>…\nEnable or disable the multi-line matching flag by default.\nSet the nesting limit used for the regular expression …\nReturn a new default syntax configuration.\nWhether to support octal syntax or not.\nA convenience routine for parsing a pattern into an HIR …\nA convenience routine for parsing many patterns into HIR …\nA convenience routine for parsing many patterns into HIR …\nA convenience routine for parsing a pattern into an HIR …\nEnable or disable the “swap greed” flag by default.\nEnable or disable the Unicode flag (<code>u</code>) by default.\nWhen disabled, the builder will permit the construction of …\nDecodes the next UTF-8 encoded codepoint from the given …\nDecodes the last UTF-8 encoded codepoint from the given …\nReturns true if and only if the given offset in the given …\nReturns true if and only if the given byte is either a …\nReturns true if and only if the given byte is considered a …\nGiven a UTF-8 leading byte, this returns the total number …\nA hack to align a smaller type <code>B</code> with a bigger type <code>T</code>.\nBig endian writing.\nAn error that occurs when deserializing an object defined …\nA simple trait for writing code generic over endianness.\nLittle endian writing.\nAn error that occurs when serializing an object from this …\nA zero-sized field indicating the alignment we want.\nAdd the given numbers, and on overflow, return an error …\nAllocate a byte buffer of the given size, along with some …\nA possibly non-sized field containing a sequence of bytes.\nChecks that the given slice has an alignment that matches <code>T</code>…\nChecks that the given slice has some minimal length. If it…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMultiply the given numbers, and on overflow, return an …\nReturns the number of additional bytes required to add to …\nReads the endianness check from the beginning of the given …\nReads a NUL terminated label starting at the beginning of …\nReads a pattern ID from the given slice. If the slice has …\nReads a pattern ID from the given slice. If the slice has …\nReads a state ID from the given slice. If the slice has …\nReads a state ID from the given slice. If the slice has …\nRead a u128 from the beginning of the given slice in …\nRead a u16 from the beginning of the given slice in native …\nRead a u32 from the beginning of the given slice in native …\nReads a version number from the beginning of the given …\nShift <code>a</code> left by <code>b</code>, and on overflow, return an error that …\nReads a possibly empty amount of padding, up to 7 bytes, …\nAttempts to read a state ID from the given slice. If the …\nTry to read a u128 from the beginning of the given slice …\nTry to read a u16 from the beginning of the given slice in …\nTry to read a u16 as a usize from the beginning of the …\nTry to read a u32 from the beginning of the given slice in …\nTry to read a u32 as a usize from the beginning of the …\nSafely converts a <code>&amp;[u32]</code> to <code>&amp;[PatternID]</code> with zero cost.\nSafely converts a <code>&amp;[u32]</code> to <code>&amp;[StateID]</code> with zero cost.\nSafely converts a <code>&amp;mut [u32]</code> to <code>&amp;mut [StateID]</code> with zero …\nThe name of the thing that a buffer is too small for.\nWrites 0xFEFF as an integer using the given endianness.\nReturns the number of bytes written by the endianness …\nWrites the given label to the buffer as a NUL terminated …\nReturns the total number of bytes (including padding) that …\nWrite the given pattern ID to the beginning of the given …\nWrite the given state ID to the beginning of the given …\nWrites a u128 to the given destination buffer in a …\nWrites a u16 to the given destination buffer in a …\nWrites a u32 to the given destination buffer in a …\nWrites the given version number to the beginning of the …\nReturns the number of bytes written by writing the version …")