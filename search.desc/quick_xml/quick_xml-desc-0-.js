searchState.loadedDescShard("quick_xml", 0, "High performance XML reader/writer.\nA module for wrappers that encode / decode data.\nError management module\nManage xml character escapes\nDefines zero-copy XML events used throughout this library.\nModule for handling names according to the W3C Namespaces …\nContains low-level parsers of different XML pieces.\nContains high-level interface for a pull-based XML parser.\nContains high-level interface for an events-based XML …\nDecoder of byte slices into strings.\nUnicode “byte order mark” (\\u{FEFF}) encoded as UTF-8. …\nWithout <code>encoding</code> feature\nDecodes the <code>Cow</code> buffer, preserves the lifetime\nLike <code>decode</code> but using a pre-allocated buffer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA comment contains forbidden double-hyphen (<code>--</code>) sequence …\nContains the error value\nThe error type used by this crate.\nEscape error\nThe document is not well-formed.\nAn error returned if parsed document is not well-formed, …\nAttribute parsing error\nThe parser started to parse <code>&lt;!</code>, but the input ended before …\nError for when a reserved namespace is set incorrectly.\nXML document cannot be read from or written to underlying …\nThe specified end tag does not match the start tag at that …\nA <code>version</code> attribute was not found in an XML declaration or …\nA document type definition (DTD) does not contain a name …\nThe end tag was not found during reading of a sub-tree of …\nInput decoding error. If <code>encoding</code> feature is disabled, …\nContains the success value\nA specialized <code>Result</code> type where the error is hard-wired to …\nThe document does not corresponds to the XML grammar.\nAn error returned if parsed document does not correspond …\nThe parser started to parse <code>&lt;![CDATA[</code> content, but the …\nThe parser started to parse comment (<code>&lt;!--</code>) content, but …\nThe parser started to parse DTD (<code>&lt;!DOCTYPE</code>) content, but …\nThe parser started to parse processing instruction or XML …\nThe parser started to parse tag content, but the input …\nSpecified namespace prefix is unknown, cannot resolve …\nThe specified end tag was encountered without …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>Error::NonDecodable</code> from the given error\nCreates a new <code>Error::Io</code> from the given error\nCreates a new <code>Error::Utf8</code> from the given error\nCreates a new <code>Error::IllFormed</code> from the given error\nCreates a new <code>Error::Syntax</code> from the given error\nCreates a new <code>Error::EscapeError</code> from the given error\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNamespace to which prefix tried to be bound\nThe prefix that is tried to be bound\nName of open tag, that is expected to be closed\nName of actually closed tag\nError for XML escape / unescape.\nCharacter reference expanded to a not permitted character …\nAttempt to parse character reference (<code>&amp;#&lt;dec-number&gt;;</code> or …\nCharacter reference represents not a valid unicode …\nNumber cannot be parsed due to non-number characters or a …\nError of parsing character reference (<code>&amp;#&lt;dec-number&gt;;</code> or …\nNumber contains sign character (<code>+</code> or <code>-</code>) which is not …\nReferenced entity in unknown to the parser.\nCannot find <code>;</code> after <code>&amp;</code>\nEscapes an <code>&amp;str</code> and replaces a subset of xml special …\nEscapes an <code>&amp;str</code> and replaces all xml special characters (<code>&lt;</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nXML standard requires that only <code>&lt;</code> and <code>&amp;</code> was escaped in …\nEscapes an <code>&amp;str</code> and replaces xml special characters (<code>&lt;</code>, <code>&gt;</code>, …\nResolves predefined XML entities or all HTML5 entities …\nResolves predefined XML entities. If specified entity is …\nUnescape an <code>&amp;str</code> and replaces all xml escaped characters (…\nUnescape an <code>&amp;str</code> and replaces all xml escaped characters (…\nCDATA content contains unescaped data from the reader. If …\nAn XML declaration (<code>Event::Decl</code>).\nClosing tag data (<code>Event::End</code>): <code>&lt;/name&gt;</code>.\nProcessing instructions (PIs) allow documents to contain …\nOpening tag data (<code>Event::Start</code>), with optional attributes: …\nData from various events (most notably, <code>Event::Text</code>) that …\nUnescaped character data stored in <code>&lt;![CDATA[...]]&gt;</code>.\nComment <code>&lt;!-- ... --&gt;</code>.\nXML declaration <code>&lt;?xml ...?&gt;</code>.\nDocument type definition data (DTD) stored in …\nEmpty element tag (with attributes) <code>&lt;tag attr=&quot;value&quot; /&gt;</code>.\nEnd tag <code>&lt;/tag&gt;</code>.\nEnd of XML document.\nEvent emitted by <code>Reader::read_event_into</code>.\nProcessing instruction <code>&lt;?...?&gt;</code>.\nStart tag (with attributes) <code>&lt;tag attr=&quot;value&quot;&gt;</code>.\nEscaped character data between tags.\nXml Attributes module\nReturns an iterator over the attributes of this tag.\nA view of the processing instructions’ content as a list …\nGets the undecoded raw string with the attributes of this …\nConverts the event into a borrowed event. Most useful when …\nConverts the event into a borrowed event.\nConverts the event into a borrowed event.\nConverts the event into a borrowed event.\nConverts the event into a borrowed event.\nConverts the event into a borrowed event.\nConverts the event into a borrowed event.\ncontent of the element, before any utf8 conversion\nRemove all attributes from the ByteStart\nContent of the processing instruction. Contains everything …\nEscaped then encoded content of the event. Content is …\nGets content of this text buffer in the specified encoding\nEncoding in which the <code>content</code> is stored inside the event\nEncoding in which the <code>content</code> is stored inside the event\nGets xml encoding, excluding quotes (<code>&#39;</code> or <code>&quot;</code>).\nConverts this CDATA content to an escaped version, that …\nAdd additional attributes to this tag using an iterator.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new <code>BytesStart</code> from the given content (name + …\nCreates a new <code>BytesText</code> from an escaped string.\nCreates a <code>BytesDecl</code> from a <code>BytesStart</code>\nReturns an iterator over the HTML-like attributes of this …\nRemoves trailing XML whitespace bytes from text content.\nRemoves leading XML whitespace bytes from text content.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtracts the inner <code>Cow</code> from the <code>BytesText</code> event container.\nExtracts the inner <code>Cow</code> from the <code>BytesCData</code> event container.\nExtracts the inner <code>Cow</code> from the <code>BytesPI</code> event container.\nConverts the event into an owned event.\nConverts the event into an owned event.\nEnsures that all data is owned to extend the object’s …\nEnsures that all data is owned to extend the object’s …\nEnsures that all data is owned to extend the object’s …\nConverts the event into an owned event.\nConverts the event to an owned version, untied to the …\nGets the undecoded raw local tag name (excluding …\nGets the undecoded raw local tag name (excluding …\nConverts this CDATA content to an escaped version, that …\nGets the undecoded raw tag name, as present in the input …\nGets the undecoded raw tag name, as present in the input …\nend of the element name, the name starts at that the start …\nCreates a new <code>BytesStart</code> from the given name.\nCreates a new <code>BytesEnd</code> borrowing a slice.\nCreates a new <code>BytesText</code> from a string. The string is …\nCreates a new <code>BytesCData</code> from a string.\nCreates a new <code>BytesPI</code> from a string.\nConstructs a new <code>XmlDecl</code> from the (mandatory) <em>version</em> …\nConverts this CDATA content to an escaped version, that …\nAdds an attribute to this element.\nAdds an attribute to this element.\nAdds indentation bytes in existing element\nAdds new line in existing element\nEdit the name of the BytesStart in-place\nGets xml standalone, excluding quotes (<code>&#39;</code> or <code>&quot;</code>).\nA target used to identify the application to which the …\nCreates new paired close tag\nConverts the event into an owned event without taking …\nTry to get an attribute\nDecodes then unescapes the content of the event.\nDecodes then unescapes the content of the event with …\nGets xml version, excluding quotes (<code>&#39;</code> or <code>&quot;</code>).\nConsumes <code>self</code> and yield a new <code>BytesStart</code> with additional …\nInternal constructor, used by <code>Reader</code>. Supplies data in …\nInternal constructor, used by <code>Reader</code>. Supplies data in …\nCreates a new <code>BytesText</code> from an escaped byte sequence in …\nCreates a new <code>BytesCData</code> from a byte sequence in the …\nCreates a new <code>BytesPI</code> from a byte sequence in the …\nA struct representing a key/value XML or HTML attribute.\nErrors that can be raised during parsing attributes.\nA struct representing a key/value XML attribute.\nIterator over XML attributes.\nIteration finished, iterator will return <code>None</code> to all …\nAttribute with value enclosed in double quotes (<code>&quot;</code>). …\nAn attribute with the same name was already encountered. …\nAttribute without value. Attribute key provided. This is …\nContains the error value\nAttribute key was not followed by <code>=</code>, position relative to …\nAttribute value was not finished with a matching quote, …\nAttribute value was not found after <code>=</code>, position relative …\nExternal iterator over spans of attribute key and value\nThe last attribute returned was deserialized successfully. …\nContains the success value\nAttribute with value enclosed in single quotes (<code>&#39;</code>). …\nThe last attribute returns <code>AttrError::Duplicated</code>, offset …\nThe last attribute returns <code>AttrError::UnquotedValue</code>, …\nAttribute with value not enclosed in quotes. Attribute key …\nAttribute value is not quoted, position relative to the …\nSlice of <code>BytesStart</code> corresponding to attributes\nIf <code>true</code>, checks for duplicate names\nDecodes then unescapes the value.\nDecodes then unescapes the value with custom entities.\nCreates new attribute from raw bytes. Does not apply any …\nCreates new attribute from text representation. Key is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new attribute iterator from a buffer, allowing …\nIf <code>true</code>, enables ability to parse unquoted values and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the key value\nThe key to uniquely define the attribute.\nParameters\nIf <code>check_duplicates</code> is set, contains the ranges of already …\nMaps an <code>Attr&lt;T&gt;</code> to <code>Attr&lt;U&gt;</code> by applying a function to a …\nCreates a new attribute iterator from a buffer.\nRecover from an error that could have been made on a …\nSkip all characters up to first space symbol or …\nSkip all characters up to first space symbol or …\nIterator state, independent from the actual source of bytes\nIteration state that determines what actions should be …\nDecodes using UTF-8 then unescapes the value.\nDecodes using UTF-8 then unescapes the value, using custom …\nReturns the attribute value. For <code>Self::Empty</code> variant an …\nThe raw value of the attribute.\nChanges whether attributes should be checked for …\nInternal constructor, used by <code>BytesStart</code>. Supplies data in …\n<code>Prefix</code> resolved to the specified namespace\nXML attribute binds a default namespace. Corresponds to …\nA local (unqualified) name of an element or an attribute, …\nXML attribute binds a specified prefix to a namespace. …\nA namespace name that is declared in a …\nAn entry that contains index into the buffer with …\nA namespace management buffer.\nA namespace prefix part of the qualified name of an …\nA namespace prefix declaration, <code>xmlns</code> or <code>xmlns:&lt;name&gt;</code>, as …\nIterator on the current declared prefixes.\nA qualified name of an element or an attribute, including …\nThat constant define the one of reserved namespaces for …\nThat constant define the one of reserved namespaces for …\nResult of prefix resolution which creates by …\nQualified name does not contain prefix, and resolver does …\nSpecified prefix was not found in scope\nIf that <code>QName</code> represents <code>&quot;xmlns&quot;</code> series of names, returns …\nA stack of namespace bindings to prefixes that currently …\nBuffer that contains names of namespace prefixes (the part …\nThe same as <code>(qname.local_name(), qname.prefix())</code>, but does …\nFinds a namespace name for a given qualified <strong>element name</strong>, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates <code>LocalName</code> from a <code>QName</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the index in the name where prefix ended\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts this name to an internal slice representation.\nConverts this name to an internal slice representation.\nExtracts internal slice\nConverts this namespace to an internal slice …\nLevel of nesting at which this namespace was declared. The …\nReturns local part of this qualified name.\nGets the namespace name (the URI) slice out of namespace …\nThe number of open tags at the moment. We need to keep …\nEnds a top-most scope by popping all namespace binding, …\nReturns namespace part of this qualified name or <code>None</code> if …\nGet the namespace prefix, bound to this namespace …\nLength of the prefix\nBegins a new scope and add to it all [namespace bindings] …\nResolves a potentially qualified <strong>element name</strong> or <strong>attribute </strong>…\nIndex of the namespace in the buffer\nThe length of a namespace name (the URI) of this namespace …\nInside a double-quoted region (<code>&quot;...&quot;</code>).\nA parser that search a <code>&gt;</code> symbol in the slice outside of …\nThe initial state (inside element, but outside of …\nUsed to decouple reading of data from data source and …\nA parser that search a <code>?&gt;</code> sequence in the slice.\nInside a single-quoted region (<code>&#39;...&#39;</code>).\nContains a parser for an XML element.\nReturns parse error produced by this parser in case of …\nProcess new data and try to determine end of the parsed …\nContains a parser for an XML processing instruction.\nInside a double-quoted region (<code>&quot;...&quot;</code>).\nA parser that search a <code>&gt;</code> symbol in the slice outside of …\nThe initial state (inside element, but outside of …\nInside a single-quoted region (<code>&#39;...&#39;</code>).\nReturns number of consumed bytes or <code>None</code> if <code>&gt;</code> was not …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA parser that search a <code>?&gt;</code> sequence in the slice.\nDetermines the end position of a processing instruction in …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPossible elements started with <code>&lt;!</code>\nA direct stream to the underlying <code>Reader</code>s reader which …\nA struct that holds a parser configuration.\nReader enters this state when <code>Eof</code> event generated or an …\nIO error occurred.\nInitial state in which reader stay after creation. …\nThis state is used only if option <code>expand_empty_elements</code> is …\nState after seeing the <code>&lt;</code> symbol. Depending on the next …\nState in which reader searches the <code>&lt;</code> symbol of a markup. …\nStart of markup (<code>&lt;</code> character) was found in the first byte. …\nA low level encoding-agnostic XML event reader that …\nPossible reader states. The state transition diagram (<code>true</code> …\nResult of an attempt to read XML textual data from the …\nA low level encoding-agnostic XML event reader.\nRange of input in bytes, that corresponds to some piece of …\nContains text block up to EOF, start of markup (<code>&lt;</code> …\nContains text block up to start of markup (<code>&lt;</code> character).\nRepresents an input for a reader that can return borrowed …\nWhether unmatched closing tag names should be allowed. …\nGets the current byte position in the input data.\nThis is an implementation of <code>Reader</code> for reading from a …\nWhether comments should be validated. If enabled, in case …\nWhether mismatched closing tag names should be detected. …\nReturns reference to the parser configuration\nReturns mutable reference to the parser configuration\nGet the decoder, used to decode bytes, read by this …\nTurn on or off all checks for well-formedness. Currently …\nThe upper bound of the range (exclusive).\nGets the last error byte position in the input data. If …\nWhether empty elements should be split into an <code>Open</code> and a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an XML reader from a file path.\nCreates a <code>Reader</code> that reads from a given reader.\nCreates an XML reader from a string slice.\nGets a mutable reference to the underlying reader.\nGets a mutable reference to the underlying reader.\nGets a reference to the underlying reader.\nGets a reference to the underlying reader.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes <code>Reader</code> returning the underlying reader\nA reader that manages namespace declarations found in the …\nA buffer to manage namespaces\nReturns current position in bytes in the original source.\nIf element is finished, returns its content up to <code>&gt;</code> symbol …\nReturn one character without consuming it, so that future …\nWe cannot pop data from the namespace stack until returned …\nRead input until comment or CDATA is finished.\nRead an event that borrows from the input rather than a …\nRead text into the given buffer, and return an event that …\nReads the next <code>Event</code>.\nRead input until start of markup (the <code>&lt;</code>) is found or end …\nReads content between start and end tags, including any …\nReads until end element is found. This function is …\nGeneralization of <code>read_to_end</code> method for buffered and …\nReads until end element is found using provided buffer as …\nPrivate function to read until <code>&gt;</code> is found. This function …\nRead bytes up to the <code>&gt;</code> and skip it. This method is …\nRead input until processing instruction is finished.\nAn XML reader\nSource of data for parse\nRemoves UTF-8 BOM if it is present\nConsume and discard all the whitespace until the next …\nThis is an implementation of <code>Reader</code> for reading from a …\nThe lower bound of the range (inclusive).\nConfiguration and current parse state\nGet the direct access to the underlying reader, but tracks …\nWhether trailing whitespace after the markup name are …\nSet both <code>trim_text_start</code> and <code>trim_text_end</code> to the same …\nWhether whitespace after character data should be removed.\nWhether whitespace before character data should be removed.\nA low level encoding-agnostic XML event reader that …\nReturns reference to the parser configuration\nReturns mutable reference to the parser configuration\nReturns the argument unchanged.\nCreates an XML reader from a file path.\nCreates a <code>NsReader</code> that reads from a reader.\nCreates an XML reader from a string slice.\nGets a mutable reference to the underlying reader.\nCalls <code>U::from(self)</code>.\nConsumes <code>NsReader</code> returning the underlying reader\nA buffer to manage namespaces\nWe cannot pop data from the namespace stack until returned …\nReturns all the prefixes currently declared except the …\nReads the next event, borrow its content from the input …\nReads the next event into given buffer.\nReads the next event, borrow its content from the input …\nReads the next event into given buffer and resolves its …\nReads content between start and end tags, including any …\nReads until end element is found. This function is …\nReads until end element is found using provided buffer as …\nAn XML reader\nResolves a potentially qualified <strong>element name</strong> or <strong>attribute </strong>…\nResolves a potentially qualified <strong>attribute name</strong> into …\nResolves a potentially qualified <strong>element name</strong> into …\nA struct that holds a current reader state and a parser …\nUser-defined settings that affect parsing\nGet the decoder, used to decode bytes, read by this …\nReturns <code>Comment</code>, <code>CData</code> or <code>DocType</code> event.\nWraps content of <code>buf</code> into the <code>Event::End</code> event. Does the …\n<code>buf</code> contains data between <code>&lt;</code> and <code>&gt;</code> and the first byte is <code>?</code>. …\nConverts content of a tag to a <code>Start</code> or an <code>Empty</code> event\nTrims end whitespaces from <code>bytes</code>, if required, and returns …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA snapshot of an <code>offset</code> of the last error returned. It can …\nNumber of bytes read from the source of data since the …\nAll currently Started elements which didn’t have a …\nOpened name start indexes into <code>Self::opened_buffer</code>. See …\nDefines how to process next byte\nTrack indent inside elements state\nKeep indent that should be used if <code>new_line()</code> would be …\nA struct to write an element. Contains methods to add …\nInitial state. <code>ElementWriter</code> was just created and no …\nKeep space indent that should be used if <code>new_line()</code> would …\nWrite specified count of indent characters before writing …\nWrite specified count of spaces to indent before writing …\nXML writer. Writes XML <code>Event</code>s to a <code>std::io::Write</code> …\nReturns indent with current indent plus additional indent\nProvides a simple, high-level API for writing XML elements.\nReturns indent string for current level\nThe current amount of indentation\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a mutable reference to the underlying writer.\nGet a reference to the underlying writer.\nIncrease indentation by one level\nThe character code to be used for indentations (e.g. <code> </code> or …\nHow many instances of the indent character ought to be …\nUsed as a cache for the bytes used for indentation\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this <code>Writer</code>, returning the underlying writer.\nCreates a <code>Writer</code> from a generic writer.\nPush a new line inside an element between attributes. …\nCreates a <code>Writer</code> with configured indents from a generic …\ntodo: this is an awkward fit as it has no impact on …\nDecrease indentation by one level. Do nothing, if level …\nContains spaces used to write space indents of attributes\nAdds an attribute to this element.\nAdd additional attributes to this element using an …\nWrites bytes\nWrites attribute and maintain indentation state\nWrite a Byte-Order-Mark character to the document.\nWrite a CData event <code>&lt;![CDATA[...]]&gt;</code> inside the current …\nWrite an empty (self-closing) tag.\nWrites the given event to the underlying writer.\nManually write a newline and indentation at the proper …\nCreate a new scope for writing XML inside the current …\nWrite a processing instruction <code>&lt;?...?&gt;</code> inside the current …\nWrite some text inside the current element.\nunderlying writer")