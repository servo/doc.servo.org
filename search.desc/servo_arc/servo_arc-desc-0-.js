searchState.loadedDescShard("servo_arc", 0, "Fork of Arc for Servo. This has the following advantages …\nAn atomically reference counted shared pointer\nA “borrowed <code>Arc</code>”. This is a pointer to a T that is …\nThe object allocated by an Arc\nA tagged union that can represent <code>Arc&lt;A&gt;</code> or <code>Arc&lt;B&gt;</code> while …\nThis represents a borrow of an <code>ArcUnion</code>.\nStructure to allow Arc-managing some fixed-sized data and …\nA soft limit on the amount of references that may be made …\nSpecial refcount value that means the data is not …\nThis is functionally equivalent to Arc&lt;(H, [T])&gt;\nSee <code>ArcUnion</code>. This is a version that works for <code>ThinArc</code>s.\nAn <code>Arc</code> that is known to be uniquely owned\nReturns a borrow of the first type if applicable, …\nReturns a borrow of the second type if applicable, …\nConvert to an initialized Arc.\nReturns an enum representing a borrow of either A or B.\nProduce a pointer to the data that can be converted back …\nClone this as an <code>Arc&lt;T&gt;</code>. This bumps the refcount.\nThe dynamically-sized data.\nReturns a mutable reference to the slice.\nComputes the offset of the data field within ArcInner.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an <code>ArcUnion</code> from an instance of the first type.\nCreates an Arc for a HeaderSlice using the given header …\nCreates an Arc for a HeaderSlice using the given header …\nCreates an Arc for a HeaderSlice using the given header …\nReconstruct the Arc from a raw pointer obtained from …\nLike from_raw, but returns an addrefed arc instead.\nFor constructing from a reference known to be Arc-backed, …\nCreates an <code>ArcUnion</code> from an instance of the second type.\nSimilar to deref, but uses the lifetime |a| rather than …\nProvides mutable access to the contents <em>if</em> the <code>Arc</code> is …\nThe fixed-sized data.\nReturns a mutable reference to the header.\nReturns the address on the heap of the Arc itself – not …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the Arc to a raw pointer, suitable for use across …\nReturns true if this <code>ArcUnion</code> contains the first type.\nReturns true if this <code>ArcUnion</code> contains the second type.\nWhether or not the <code>Arc</code> is a static reference.\nWhether or not the <code>Arc</code> is uniquely owned (is the refcount …\nReturns the len of the slice.\nThe length of the slice at our end.\nMakes a mutable reference to the <code>Arc</code>, cloning if necessary\nMarks this <code>Arc</code> as intentionally leaked for the purposes of …\nConstruct an <code>Arc&lt;T&gt;</code>\nConstruct a new UniqueArc\nConstruct an intentionally-leaked arc.\nCreate a new static Arc (one that won’t reference count …\nConstruct an uninitialized arc\nTest pointer equality between the two Arcs, i.e. they must …\nReturns true if the two values are pointer-equal.\nCompare two <code>ArcBorrow</code>s via pointer equality. Will only …\nReturns a raw ptr to the underlying allocation.\nConvert to a shareable Arc once we’re done mutating it\nReturns the dynamically sized slice in this HeaderSlice.\nReturns the dynamically sized slice in this HeaderSlice.\nTemporarily converts |self| into a bonafide Arc and …")