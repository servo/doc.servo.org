searchState.loadedDescShard("tracing_core", 0, "Core primitives for <code>tracing</code>.\nTrait implemented by callsites.\n<code>Dispatch</code> trace data to a <code>Subscriber</code>.\n<code>Event</code>s represent single points in time where something …\nAn opaque key allowing <em>O</em>(1) access to a field in a <code>Span</code>’…\nDescribes the level of verbosity of a span or event.\nA filter comparable to a verbosity <code>Level</code>.\nMetadata describing a span or event.\nA synchronization primitive which can be used to run a …\nTrait representing the functions required to collect trace …\nPerforms an initialization routine once and only once. The …\nPerforms the same function as <code>call_once()</code> except ignores …\nCallsites represent the source locations from which spans …\nNotifies the subscriber that a span ID has been cloned.\nReturns a type representing this subscriber’s view of …\nReturns the current default dispatcher\nDispatches trace events to <code>Subscriber</code>s.\nIf <code>self</code> is the same type as the provided <code>TypeId</code>, returns …\n<strong>This method is deprecated.</strong>\nReturns true if a span or event with the specified metadata…\nRecords that a span has been entered.\nEvents represent single points in time during the …\nRecords that an <code>Event</code> has occurred.\nDetermine if an <code>Event</code> should be recorded.\nRecords that a span has been exited.\n<code>Span</code> and <code>Event</code> key-value data.\nThe names of the key-value fields attached to the …\nThe name of the source code file where the span occurred, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nStatically constructs an <code>Identifier</code> for the provided …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if some <code>call_once()</code> call has completed …\nThe kind of the callsite.\nThe level of verbosity of the described span.\nThe line number in the source code file where the span …\nReturns the highest verbosity level that this <code>Subscriber</code> …\nMetadata describing trace data.\nReturns the metadata associated with the callsite.\nStatically constructs new span metadata.\nThe name of the Rust module where the span occurred, or …\nThe name of the span described by this metadata.\nCreates a new <code>Once</code> value.\nVisit the construction of a new span, returning a new span …\nInvoked when this subscriber becomes a <code>Dispatch</code>.\nRecord a set of values on a span.\nAdds an indication that <code>span</code> follows from the span with …\nRegisters a new callsite with this subscriber, returning …\nSets the <code>Interest</code> for this callsite.\nSpans represent periods of time in the execution of a …\nRe-exports either the Rust <code>std</code> library or <code>core</code> and <code>alloc</code> …\nCollectors collect and record trace data.\nThe part of the system that the span that this metadata …\nNotifies the subscriber that a span ID has been dropped, …\nTrait implemented by callsites.\nA default <code>Callsite</code> implementation.\nUniquely identifies a <code>Callsite</code>\nInvokes the provided closure <code>f</code> with each callsite in the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the callsite’s cached <code>Interest</code>, or registers it …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the metadata associated with the callsite.\nReturns a new <code>DefaultCallsite</code> with the specified <code>Metadata</code>.\nPush a <code>DefaultCallsite</code> to the callsite registry.\nPush a <code>dyn Callsite</code> trait object to the callsite registry.\nRebuild <code>Interest</code>s for all callsites in the registry.\nClear and reregister interest on every <code>Callsite</code>\nRegister a new <code>Callsite</code> with the global registry.\nRegisters this callsite with the global callsite registry.\nSets the <code>Interest</code> for this callsite.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDon’t call this function, it’s private.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA guard that resets the current default dispatcher to the …\n<code>Dispatch</code> trace data to a <code>Subscriber</code>.\nWhile this guard is active, additional calls to subscriber …\nReturned if setting the global dispatcher fails.\nThe dispatch state of a thread.\n<code>WeakDispatch</code> is a version of <code>Dispatch</code> that holds a …\nWhether or not we can currently begin dispatching a trace …\nNotifies the subscriber that a span ID has been cloned.\nReturns a type representing this subscriber’s view of …\nThis thread’s current default dispatcher.\nReturns some reference to the <code>Subscriber</code> this <code>Dispatch</code> …\nCreates a <code>WeakDispatch</code> from this <code>Dispatch</code>.\nNotifies the subscriber that a span ID has been dropped.\nReturns true if a span with the specified metadata would be\nRecords that a span has been can_enter.\nRecords that an <code>Event</code> has occurred.\nRecords that a span has been exited.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nExecutes a closure with a reference to this thread’s …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this <code>Dispatch</code> forwards to a <code>Subscriber</code> of …\nReturns the highest verbosity level that this <code>Subscriber</code> …\nReturns a <code>Dispatch</code> that forwards to the given <code>Subscriber</code>.\nRecord the construction of a new span, returning a new ID …\nReturns a new <code>Dispatch</code> that discards events and spans.\nRecord a set of values on a span.\nAdds an indication that <code>span</code> follows from the span with …\nRegisters a new callsite with this subscriber, returning …\nSets the dispatch as the default dispatch for the duration …\nReplaces the current default dispatcher on this thread …\nSets this dispatch as the global default for the duration …\nNotifies the subscriber that a span ID has been dropped, …\nAttempts to upgrade this <code>WeakDispatch</code> to a <code>Dispatch</code>.\nSets this dispatch as the default for the duration of a …\n<code>Event</code>s represent single points in time where something …\nConstructs a new <code>Event</code> with the specified metadata and set …\nConstructs a new <code>Event</code> with the specified metadata and set …\nReturns an iterator over the set of values on this <code>Event</code>.\nReturns true if the new event’s parent should be …\nReturns true if the new event should be a root.\nReturns metadata describing this <code>Event</code>.\nReturns a new <code>Event</code> in the current span, with the …\nReturns a new <code>Event</code> as a child of the specified span, with …\nReturns the new event’s explicitly-specified parent, if …\nVisits all the fields on this <code>Event</code> with the specified …\nA <code>Value</code> which serializes as a string using <code>fmt::Debug</code>.\nA <code>Value</code> which serializes using <code>fmt::Display</code>.\nAn empty field.\nAn opaque key allowing <em>O</em>(1) access to a field in a <code>Span</code>’…\nDescribes the fields present on a span.\nAn iterator over a set of fields.\nA field value of an erased type.\nA set of fields and values for a span.\nVisits typed values.\nReturns an <code>Identifier</code> that uniquely identifies the <code>Callsite</code>\nReturns an <code>Identifier</code> that uniquely identifies the <code>Callsite</code>\nReturns an <code>Identifier</code> that uniquely identifies the <code>Callsite</code>\nThe callsite where the described span originates.\nReturns <code>true</code> if <code>self</code> contains the given <code>field</code>.\nReturns <code>true</code> if this <code>ValueSet</code> contains a value for the …\nWraps a type implementing <code>fmt::Debug</code> as a <code>Value</code> that can be\nWraps a type implementing <code>fmt::Display</code> as a <code>Value</code> that can …\nReturns the <code>Field</code> named <code>name</code>, or <code>None</code> if no such field …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether or not this <code>FieldSet</code> has fields.\nReturns true if this <code>ValueSet</code> contains <em>no</em> values.\nReturns an iterator over the <code>Field</code>s in this <code>FieldSet</code>.\nReturns the number of fields in this <code>FieldSet</code>.\nReturns the number of fields in this <code>ValueSet</code> that would …\nReturns a string representing the name of the field.\nThe names of each field on the described span.\nConstructs a new <code>FieldSet</code> with the given array of field …\nVisits this value with the given <code>Visitor</code>.\nVisits all the fields in this <code>ValueSet</code> with the provided …\nVisit a boolean value.\nVisit a value implementing <code>fmt::Debug</code>.\nRecords a type implementing <code>Error</code>.\nVisit a double-precision floating point value.\nVisit a signed 128-bit integer value.\nVisit a signed 64-bit integer value.\nVisit a string value.\nVisit an unsigned 128-bit integer value.\nVisit an unsigned 64-bit integer value.\nRestrictions on <code>ValueSet</code> lengths were removed in #2508 but …\nA value which is initialized on the first access.\nCreates a new lazy value using <code>Default</code> as the initializing …\nForces the evaluation of this lazy value and returns a …\nForces the evaluation of this lazy value and returns a …\nReturns the argument unchanged.\nGets the reference to the result of this lazy value if it …\nGets the reference to the result of this lazy value if it …\nCalls <code>U::from(self)</code>.\nConsumes this <code>Lazy</code> returning the stored value.\nCreates a new lazy value with the given initializing …\nThe “debug” level.\nThe “debug” level.\nThe “debug” level.\nThe “error” level.\nThe “error” level.\n<code>Event</code> callsite\nThe “error” level.\n<code>enabled!</code> callsite. <code>Subscriber</code>s can assume this <code>Kind</code> means …\nThe “info” level.\nThe “info” level.\nThe “info” level.\nIndicates whether the callsite is a span or event.\nDescribes the level of verbosity of a span or event.\nA filter comparable to a verbosity <code>Level</code>.\nMetadata describing a span or event.\nThe “off” level.\nReturned if parsing a <code>Level</code> fails.\nIndicates that a string could not be parsed to a valid …\n<code>Span</code> callsite\nThe “trace” level.\nThe “trace” level.\nThe “trace” level.\nThe “warn” level.\nThe “warn” level.\nThe “warn” level.\nReturns the string representation of the <code>Level</code>.\nReturns an opaque <code>Identifier</code> that uniquely identifies the …\nReturns a <code>LevelFilter</code> that matches the most verbose <code>Level</code> …\nReturns the names of the fields on the described span or …\nThe names of the key-value fields attached to the …\nReturns the name of the source code file where the span …\nThe name of the source code file where the span occurred, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a <code>LevelFilter</code> that enables spans and events with …\nSets that this <code>Kind</code> is a hint.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the most verbose <code>Level</code> that this filter accepts, …\nReturns true if the callsite kind is <code>Event</code>.\nReturn true if the callsite kind is <code>Event</code>\nReturn true if the callsite kind is <code>Hint</code>\nReturn true if the callsite kind is <code>Span</code>.\nReturn true if the callsite kind is <code>Span</code>\nThe kind of the callsite.\nReturns the level of verbosity of the described span or …\nThe level of verbosity of the described span.\nReturns the line number in the source code file where the …\nThe line number in the source code file where the span …\nReturns the path to the Rust module where the span …\nThe name of the Rust module where the span occurred, or …\nReturns the name of the span.\nThe name of the span described by this metadata.\nConstruct new metadata for a span or event, with a name, …\nReturns a string describing the part of the system where …\nThe part of the system that the span that this metadata …\nThe new span will be rooted in the current span.\nThe new span has an explicitly-specified parent.\nThe new span will be a root span.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAttributes provided to a <code>Subscriber</code> describing a new span …\nIndicates what the <code>Subscriber</code> considers the “current” …\nIdentifies a span within the context of a subscriber.\nA set of fields recorded by a span.\nReturns <code>Attributes</code> describing a new child span of the …\nReturns <code>true</code> if this set of <code>Attributes</code> contains a value …\nReturns <code>true</code> if this <code>Record</code> contains a value for the given …\nReturns the set of all fields defined by this span’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a new span ID from the given <code>NonZeroU64</code>.\nConstructs a new span ID from the given <code>u64</code>.\nBorrows the <code>Id</code> of the current span, if one exists and is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes <code>self</code> and returns the span <code>Id</code> and <code>Metadata</code> of the …\nReturns the span’s ID as a <code>NonZeroU64</code>.\nReturns the span’s ID as a <code>u64</code>.\nReturns true if the new span’s parent should be …\nReturns true if this set of <code>Attributes</code> contains <em>no</em> values.\nReturns true if this <code>Record</code> contains <em>no</em> values.\nReturns <code>true</code> if the <code>Subscriber</code> that constructed this …\nReturns true if the new span should be a root.\nReturns the number of fields that would be visited from …\nReturns a reference to the new span’s metadata.\nBorrows the <code>Metadata</code> of the current span, if one exists …\nReturns <code>Attributes</code> describing a new child span of the …\nConstructs a new <code>Record</code> from a <code>ValueSet</code>.\nConstructs a new <code>Current</code> that indicates the current …\nReturns <code>Attributes</code> describing a new span at the root of …\nConstructs a new <code>Current</code> that indicates the current …\nReturns the new span’s explicitly-specified parent, if …\nRecords all the fields in this set of <code>Attributes</code> with the …\nRecords all the fields in this <code>Record</code> with the provided …\nConstructs a new <code>Current</code> that indicates the <code>Subscriber</code> …\nReturns a reference to a <code>ValueSet</code> containing any values …\nMemory allocation APIs.\nUtilities for dynamic typing or type reflection.\nSIMD and vendor intrinsics module.\nUtilities for the array primitive type.\nOperations on ASCII strings and characters.\nAsserts that a boolean expression is <code>true</code> at runtime.\nAsserts that two expressions are equal to each other …\nUnstable module containing the unstable <code>assert_matches</code> …\nAsserts that two expressions are not equal to each other …\nComposable asynchronous iteration.\nSupport for capturing a stack backtrace of an OS thread\nA module for working with borrowed data.\nThe <code>Box&lt;T&gt;</code> type for heap allocation.\nShareable mutable containers.\nEvaluates boolean combinations of configuration flags at …\nA macro for defining <code>#[cfg]</code> match-like statements.\nUtilities for the <code>char</code> primitive type.\nThe <code>Clone</code> trait for types that cannot be ‘implicitly …\nUtilities for comparing and ordering values.\nCollection types.\nExpands to the column number at which it was invoked.\nCauses compilation to fail with the given error message …\nConcatenates literals into a static string slice.\nConcatenates literals into a byte slice.\nConcatenates identifiers into one identifier.\nSame as <code>format_args</code>, but can be used in some const …\nTraits for conversions between types.\nPrints and returns the value of a given expression for …\nAsserts that a boolean expression is <code>true</code> at runtime.\nAsserts that two expressions are equal to each other.\nAsserts that two expressions are not equal to each other.\nThe <code>Default</code> trait for types with a default value.\nInspection and manipulation of the process’s environment.\nInspects an environment variable at compile time.\nPrints to the standard error.\nPrints to the standard error, with a newline.\nInterfaces for working with Errors.\nConstants for the <code>f128</code> double-precision floating point …\nConstants for the <code>f16</code> double-precision floating point type.\nConstants for the <code>f32</code> single-precision floating point type.\nConstants for the <code>f64</code> double-precision floating point type.\nUtilities related to FFI bindings.\nExpands to the file name in which it was invoked.\nUtilities for formatting and printing <code>String</code>s.\nCreates a <code>String</code> using interpolation of runtime …\nConstructs parameters for the other string-formatting …\nSame as <code>format_args</code>, but adds a newline in the end.\nFilesystem manipulation operations.\nAsynchronous basic functionality.\nGeneric hashing support.\nHints to compiler that affects how code should be emitted …\nRedundant constants module for the <code>i128</code> primitive type.\nRedundant constants module for the <code>i16</code> primitive type.\nRedundant constants module for the <code>i32</code> primitive type.\nRedundant constants module for the <code>i64</code> primitive type.\nRedundant constants module for the <code>i8</code> primitive type.\nParses a file as an expression or an item according to the …\nIncludes a file as a reference to a byte array.\nIncludes a UTF-8 encoded file as a string.\nCompiler intrinsics.\nTraits, helpers, and type definitions for core I/O …\nA macro to test at <em>runtime</em> whether a CPU feature is …\nRedundant constants module for the <code>isize</code> primitive type.\nComposable external iteration.\nExpands to the line number on which it was invoked.\nPrints passed tokens into the standard output.\nPrimitive traits and types representing basic properties …\nReturns whether the given expression matches the provided …\nBasic functions for dealing with memory.\nExpands to a string that represents the current module …\nNetworking primitives for TCP/UDP communication.\nAdditional functionality for numerics.\nOverloadable operators.\nOptional values.\nOptionally inspects an environment variable at compile …\nOS-specific functionality.\nPanic support in the standard library.\nPanics the current thread.\nHelper module for exporting the <code>pattern_type</code> macro\nCross-platform path manipulation.\nTypes that pin data to a location in memory.\nThe Rust Prelude\nThis module reexports the primitive types to allow usage …\nPrints to the standard output.\nPrints to the standard output, with a newline.\nA module for working with processes.\nManually manage memory through raw pointers.\nSingle-threaded reference-counting pointers. ‘Rc’ …\nError handling with the <code>Result</code> type.\nPortable SIMD module.\nUtilities for the slice primitive type.\nUtilities for the <code>str</code> primitive type.\nA UTF-8–encoded, growable string.\nStringifies its arguments.\nUseful synchronization primitives.\nTypes and Traits for working with asynchronous tasks.\nNative threads.\nDeclare a new thread local storage key of type …\nTemporal quantification.\nIndicates unfinished code.\nEnables or disables tracing functionality used for …\nUnwraps a result or propagates its error.\nRedundant constants module for the <code>u128</code> primitive type.\nRedundant constants module for the <code>u16</code> primitive type.\nRedundant constants module for the <code>u32</code> primitive type.\nRedundant constants module for the <code>u64</code> primitive type.\nRedundant constants module for the <code>u8</code> primitive type.\nIndicates unimplemented code by panicking with a message …\nIndicates unreachable code.\nRedundant constants module for the <code>usize</code> primitive type.\nA contiguous growable array type with heap-allocated …\nCreates a <code>Vec</code> containing the arguments.\nWrites formatted data into a buffer.\nWrite formatted data into a buffer, with a newline …\nThe <code>AllocError</code> error indicates an allocation failure that …\nAn implementation of <code>Allocator</code> can allocate, grow, shrink, …\nThe global memory allocator.\nA memory allocator that can be registered as the standard …\nLayout of a block of memory.\nThe parameters given to <code>Layout::from_size_align</code> or some …\nThe default memory allocator provided by the operating …\nThe minimum byte alignment for a memory block of this …\nCreates a layout describing the record that can hold a …\nAllocate memory with the global allocator.\nAllocate memory as described by the given <code>layout</code>.\nAllocate zero-initialized memory with the global allocator.\nBehaves like <code>alloc</code>, but also ensures that the contents are …\nAttempts to allocate a block of memory.\nBehaves like <code>allocate</code>, but also ensures that the returned …\nCreates a layout describing the record for a <code>[T; n]</code>.\nCreates a “by reference” adapter for this instance of …\nCreates a <code>NonNull</code> that is dangling, but well-aligned for …\nDeallocate memory with the global allocator.\nDeallocate the block of memory at the given <code>ptr</code> pointer …\nDeallocates the memory referenced by <code>ptr</code>.\nCreates a layout describing the record for <code>self</code> followed by\nCreates a layout describing the record for <code>self</code> followed by\nProduces layout describing a record that could be used to …\nProduces layout describing a record that could be used to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a <code>Layout</code> from a given <code>size</code> and <code>align</code>, or …\nCreates a layout, bypassing all checks.\nAttempts to extend the memory block.\nBehaves like <code>grow</code>, but also ensures that the new contents …\nSignal a memory allocation error.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a <code>Layout</code> suitable for holding a value of type <code>T</code>.\nCreates a layout by rounding the size of this layout up to …\nReturns the amount of padding we must insert after <code>self</code> to …\nReallocate memory with the global allocator.\nShrink or grow a block of memory to the given <code>new_size</code> in …\nCreates a layout describing the record for <code>n</code> instances of …\nCreates a layout describing the record for <code>n</code> instances of …\nRegisters a custom allocation error hook, replacing any …\nAttempts to shrink the memory block.\nThe minimum size in bytes for a memory block of this …\nUnregisters the current allocation error hook, returning …\nA trait to emulate dynamic typing.\nA <code>TypeId</code> represents a globally unique identifier for a …\nReturns some mutable reference to the inner value if it is …\nForwards to the method defined on the type <code>Any</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nReturns a mutable reference to the inner value as type …\nForwards to the method defined on the type <code>Any</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>Any</code>.\nReturns some reference to the inner value if it is of type …\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>Any</code>.\nReturns a reference to the inner value as type <code>dyn T</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nForwards to the method defined on the type <code>Any</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nReturns <code>true</code> if the inner type is the same as <code>T</code>.\nReturns the <code>TypeId</code> of the type this generic function has …\nGets the <code>TypeId</code> of <code>self</code>.\nReturns the name of a type as a string slice.\nReturns the type name of the pointed-to value as a string …\nInline assembly.\nModule-level inline assembly.\nThis macro tests, at runtime, whether an <code>aarch64</code> feature …\nChecks if <code>arm</code> feature is enabled.\nChecks if <code>mips64</code> feature is enabled.\nChecks if <code>mips</code> feature is enabled.\nChecks if <code>powerpc</code> feature is enabled.\nChecks if <code>powerpc</code> feature is enabled.\nA macro to test at <em>runtime</em> whether instruction sets are …\nA macro to test at <em>runtime</em> whether a CPU feature is …\nPlatform-specific intrinsics for the <code>x86_64</code> platform.\nResult of the <code>cpuid</code> instruction.\nEqual (ordered, non-signaling)\nEqual (ordered, signaling)\nEqual (unordered, non-signaling)\nEqual (unordered, signaling)\nFalse (ordered, non-signaling)\nFalse (ordered, signaling)\nGreater-than-or-equal (ordered, non-signaling)\nGreater-than-or-equal (ordered, signaling)\nGreater-than (ordered, non-signaling)\nGreater-than (ordered, signaling)\nLess-than-or-equal (ordered, non-signaling)\nLess-than-or-equal (ordered, signaling)\nLess-than (ordered, non-signaling)\nLess-than (ordered, signaling)\nNot-equal (ordered, non-signaling)\nNot-equal (ordered, signaling)\nNot-equal (unordered, non-signaling)\nNot-equal (unordered, signaling)\nNot-greater-than-or-equal (unordered, non-signaling)\nNot-greater-than-or-equal (unordered, signaling)\nNot-greater-than (unordered, non-signaling)\nNot-greater-than (unordered, signaling)\nNot-less-than-or-equal (unordered, non-signaling)\nNot-less-than-or-equal (unordered, signaling)\nNot-less-than (unordered, non-signaling)\nNot-less-than (unordered, signaling)\nOrdered (non-signaling)\nOrdered (signaling)\nTrue (unordered, non-signaling)\nTrue (unordered, signaling)\nUnordered (non-signaling)\nUnordered (signaling)\nThe <code>_MM_CMPINT_ENUM</code> type used to specify comparison …\nEqual\nFalse\nLess-than-or-equal\nLess-than\nNot-equal\nNot less-than-or-equal\nNot less-than\nTrue\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_STATE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_FLUSH_ZERO_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nround up and do not suppress exceptions\nuse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>\nround down and do not suppress exceptions\nuse MXCSR.RC and suppress exceptions; see …\nround to nearest and do not suppress exceptions\nsuppress exceptions\ndo not suppress exceptions\nuse MXCSR.RC and do not suppress exceptions; see …\nround to nearest\nround down\nround up\ntruncate\ntruncate and do not suppress exceptions\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa …\nThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa …\ninterval [1, 2)\ninterval [0.5, 1)\ninterval [0.5, 2)\ninterval [0.75, 1.5)\nDEST = NaN if sign(SRC) = 1\nsign = sign(SRC)\nsign = 0\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_MASK</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nThe <code>MM_PERM_ENUM</code> type used to specify shuffle operations …\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_ROUNDING_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nA utility function for creating masks to use with Intel …\nTranspose the 4x4 matrix formed by 4 rows of __m128 in …\n<strong>Mask only</strong>: return the bit mask\nFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>\nThe strings defined by <code>a</code> and <code>b</code> are equal\nSearch for the defined substring in the target\nFor each character in <code>a</code>, determine if …\n<strong>Index only</strong>: return the least significant bit <em>(Default)</em>\nNegates results only before the end of the string\nDo not negate results before the end of the string\n<strong>Index only</strong>: return the most significant bit\nNegates results\nDo not negate results <em>(Default)</em>\nString contains signed 8-bit characters\nString contains unsigned 16-bit characters\nString contains unsigned 8-bit characters <em>(Default)</em>\n<strong>Mask only</strong>: return the byte mask\nString contains unsigned 16-bit characters\nTransaction abort due to the transaction using too much …\nTransaction abort due to a memory conflict with another …\nTransaction abort due to a debug trap.\nTransaction explicitly aborted with xabort. The parameter …\nTransaction abort in a inner nested transaction.\nTransaction retry is possible.\nTransaction successfully started.\n<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>\nSee <code>__cpuid_count</code>.\nReturns the result of the <code>cpuid</code> instruction for a given …\nReturns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>…\n128-bit wide set of four <code>f32</code> types, x86-specific\n128-bit wide set of eight <code>u16</code> types, x86-specific\n128-bit wide set of two <code>f64</code> types, x86-specific\n128-bit wide integer vector type, x86-specific\n256-bit wide set of eight <code>f32</code> types, x86-specific\n256-bit wide set of 16 <code>u16</code> types, x86-specific\n256-bit wide set of four <code>f64</code> types, x86-specific\n256-bit wide integer vector type, x86-specific\n512-bit wide set of sixteen <code>f32</code> types, x86-specific\n512-bit wide set of 32 <code>u16</code> types, x86-specific\n512-bit wide set of eight <code>f64</code> types, x86-specific\n512-bit wide integer vector type, x86-specific\nThe <code>__mmask16</code> type used in AVX-512 intrinsics, a 16-bit …\nThe <code>__mmask32</code> type used in AVX-512 intrinsics, a 32-bit …\nThe <code>__mmask64</code> type used in AVX-512 intrinsics, a 64-bit …\nThe <code>__mmask8</code> type used in AVX-512 intrinsics, a 8-bit …\nReads the current value of the processor’s time-stamp …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nClears all bits below the least significant zero bit of <code>x</code>.\nClears all bits below the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code>.\nSets the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> below the least significant one.\nSets all bits of <code>x</code> below the least significant one.\nExtracts lowest set isolated bit.\nExtracts lowest set isolated bit.\nClears least significant bit and sets all other bits.\nClears least significant bit and sets all other bits.\nGets mask up to lowest set bit.\nGets mask up to lowest set bit.\nResets the lowest set bit of <code>x</code>.\nResets the lowest set bit of <code>x</code>.\nReturns an integer with the reversed byte order of x\nReturns an integer with the reversed byte order of x\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nAdd 32-bit masks in a and b, and store the result in k.\nAdd 64-bit masks in a and b, and store the result in k.\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise AND of 32-bit masks a and b, and store …\nCompute the bitwise AND of 64-bit masks a and b, and store …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCompute the bitwise NOT of 32-bit masks a and then AND …\nCompute the bitwise NOT of 64-bit masks a and then AND …\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise NOT of 32-bit mask a, and store the …\nCompute the bitwise NOT of 64-bit mask a, and store the …\nCompute the bitwise OR of 16-bit masks a and b, and store …\nCompute the bitwise OR of 32-bit masks a and b, and store …\nCompute the bitwise OR of 64-bit masks a and b, and store …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XNOR of 32-bit masks a and b, and …\nCompute the bitwise XNOR of 64-bit masks a and b, and …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nCompute the bitwise XOR of 32-bit masks a and b, and store …\nCompute the bitwise XOR of 64-bit masks a and b, and store …\nLoad 32-bit mask from memory into k.\nLoad 64-bit mask from memory into k.\nCounts the leading most significant zero bits.\nCounts the leading most significant zero bits.\nComputes the absolute values of packed 16-bit integers in <code>a</code>…\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nComputes the absolute values of packed 8-bit integers in <code>a</code>.\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdds packed single-precision (32-bit) floating-point …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively adds and subtracts packed double-precision …\nAlternatively adds and subtracts packed single-precision …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a …\nComputes the bitwise AND of a packed double-precision …\nComputes the bitwise AND of packed single-precision …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise NOT of packed double-precision …\nComputes the bitwise NOT of packed single-precision …\nComputes the bitwise NOT of 256 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlends packed 16-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBlends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcasts 128 bits from memory (composed of 2 packed …\nBroadcasts 128 bits from memory (composed of 4 packed …\nBroadcasts a double-precision (64-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts 128 bits of integer data from a to all 128-bit …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nCasts vector of type __m128d to type __m256d; the upper …\nCasts vector of type __m256d to type __m128d.\nCast vector of type __m256d to type __m256.\nCasts vector of type __m256d to type __m256i.\nCasts vector of type __m128 to type __m256; the upper 128 …\nCasts vector of type __m256 to type __m128.\nCast vector of type __m256 to type __m256d.\nCasts vector of type __m256 to type __m256i.\nCasts vector of type __m128i to type __m256i; the upper …\nCasts vector of type __m256i to type __m256d.\nCasts vector of type __m256i to type __m256.\nCasts vector of type __m256i to type __m128i.\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nSign-extend 16-bit integers to 32-bit integers.\nSign-extend 16-bit integers to 64-bit integers.\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign-extend 32-bit integers to 64-bit integers.\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign-extend 8-bit integers to 16-bit integers.\nSign-extend 8-bit integers to 32-bit integers.\nSign-extend 8-bit integers to 64-bit integers.\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZero-extend the lower four unsigned 16-bit integers in <code>a</code> …\nZero-extend unsigned 32-bit integers in <code>a</code> to 64-bit …\nConvert packed unsigned 32-bit integers in a to packed …\nZero-extend unsigned 8-bit integers in <code>a</code> to 16-bit …\nZero-extend the lower eight unsigned 8-bit integers in <code>a</code> …\nZero-extend the lower four unsigned 8-bit integers in <code>a</code> to …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConverts the 8 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 8 x 32-bit float values in the 256-bit vector …\nReturns the first element of the input vector of …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nReturns the first element of the input vector of <code>[8 x i32]</code>.\nReturns the first element of the input vector of …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nComputes the division of each of the 4 packed 64-bit …\nComputes the division of each of the 8 packed 32-bit …\nConditionally multiplies the packed single-precision …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts a 64-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts 128 bits (composed of 2 packed double-precision …\nExtracts 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (composed of integer data) from <code>a</code>, …\nExtract 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (of integer data) from <code>a</code> selected with …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally adds adjacent pairs of 32-bit integers in <code>a</code> …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nHorizontally subtract adjacent pairs of 32-bit integers in …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nScatter 64-bit integers from a into memory using 32-bit …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and insert the 64-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 2 …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 4 …\nCopies <code>a</code> to result, then inserts 128 bits from <code>b</code> into …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nLoads 256-bits of integer data from unaligned memory into …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nLoads two 128-bit values (composed of 4 packed …\nLoads two 128-bit values (composed of 2 packed …\nLoads two 128-bit values (composed of integer data) from …\nLoad 256-bits (composed of 16 packed 16-bit integers) from …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoad 256-bits (composed of 32 packed 8-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies packed signed 16-bit integers in <code>a</code> and <code>b</code>, …\nVertically multiplies each unsigned 8-bit integer from <code>a</code> …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …\nBlend packed single-precision (32-bit) floating-point …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 4 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 8 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nZero extend packed unsigned 8-bit integers in the low 4 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using …\nMove packed 32-bit integers from a to dst using writemask …\nMove packed 64-bit integers from a to dst using writemask …\nMove packed 8-bit integers from a into dst using writemask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast 16-bit integer a to all elements of dst using …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle 8-bit integers in a within 128-bit lanes using the …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nStore packed 16-bit integers from a into memory using …\nStore packed 32-bit integers from a into memory using …\nStore packed 64-bit integers from a into memory using …\nStore packed 8-bit integers from a into memory using …\nStore packed double-precision (64-bit) floating-point …\nStore packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nLoads packed 32-bit integers from memory pointed by …\nLoads packed 64-bit integers from memory pointed by …\nLoads packed double-precision (64-bit) floating-point …\nLoads packed single-precision (32-bit) floating-point …\nStores packed 32-bit integers from <code>a</code> into memory pointed …\nStores packed 64-bit integers from <code>a</code> into memory pointed …\nStores packed double-precision (64-bit) floating-point …\nStores packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nContiguously store the active 16-bit integers in a (those …\nContiguously store the active 32-bit integers in a (those …\nContiguously store the active 64-bit integers in a (those …\nContiguously store the active 8-bit integers in a (those …\nContiguously store the active double-precision (64-bit) …\nContiguously store the active single-precision (32-bit) …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 4 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in the low 8 …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nZero extend packed unsigned 8-bit integers in the low 4 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nLoad contiguous active 16-bit integers from a (those with …\nLoad contiguous active 32-bit integers from a (those with …\nLoad contiguous active 64-bit integers from a (those with …\nLoad contiguous active 8-bit integers from a (those with …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nLoad contiguous active 16-bit integers from unaligned …\nLoad contiguous active 32-bit integers from unaligned …\nLoad contiguous active 64-bit integers from unaligned …\nLoad contiguous active 8-bit integers from unaligned …\nLoad contiguous active double-precision (64-bit) …\nLoad contiguous active single-precision (32-bit) …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nCopy a to tmp, then insert 128 bits (composed of 4 packed …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nLoad packed 16-bit integers from memory into dst using …\nLoad packed 32-bit integers from memory into dst using …\nLoad packed 64-bit integers from memory into dst using …\nLoad packed 8-bit integers from memory into dst using …\nLoad packed double-precision (64-bit) floating-point …\nLoad packed single-precision (32-bit) floating-point …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply packed unsigned 8-bit integers in a by packed …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b, and …\nCompare packed signed 32-bit integers in a and b, and …\nCompare packed signed 64-bit integers in a and b, and …\nCompare packed signed 8-bit integers in a and b, and store …\nCompare packed unsigned 16-bit integers in a and b, and …\nCompare packed unsigned 32-bit integers in a and b, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompare packed unsigned 8-bit integers in a and b, and …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nMove packed 16-bit integers from a into dst using zeromask …\nMove packed 32-bit integers from a into dst using zeromask …\nMove packed 64-bit integers from a into dst using zeromask …\nMove packed 8-bit integers from a into dst using zeromask …\nMove packed double-precision (64-bit) floating-point …\nMove packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nMultiply the low signed 32-bit integers from each packed …\nMultiply the low unsigned 32-bit integers from each packed …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply the packed signed 16-bit integers in a and b, …\nMultiply the packed unsigned 16-bit integers in a and b, …\nMultiply packed signed 16-bit integers in a and b, …\nMultiply the packed 16-bit integers in a and b, producing …\nMultiply the packed 32-bit integers in a and b, producing …\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nConvert packed signed 16-bit integers from a and b to …\nConvert packed signed 32-bit integers from a and b to …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nCompute the approximate reciprocal square root of packed …\nCompute the approximate reciprocal square root of packed …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nBroadcast 32-bit integer a to all elements of dst using …\nBroadcast 64-bit integer a to all elements of dst using …\nBroadcast 8-bit integer a to all elements of dst using …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffle 32-bit integers in a within 128-bit lanes using …\nShuffle packed 8-bit integers in a according to shuffle …\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in the high 64 bits of 128-bit …\nShuffle 16-bit integers in the low 64 bits of 128-bit …\nShift packed 16-bit integers in a left by count while …\nShift packed 32-bit integers in a left by count while …\nShift packed 64-bit integers in a left by count while …\nShift packed 16-bit integers in a left by imm8 while …\nShift packed 32-bit integers in a left by imm8 while …\nShift packed 64-bit integers in a left by imm8 while …\nShift packed 16-bit integers in a left by the amount …\nShift packed 32-bit integers in a left by the amount …\nShift packed 64-bit integers in a left by the amount …\nCompute the square root of packed double-precision …\nCompute the square root of packed single-precision …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShift packed 16-bit integers in a right by count while …\nShift packed 32-bit integers in a right by count while …\nShift packed 64-bit integers in a right by count while …\nShift packed 16-bit integers in a right by imm8 while …\nShift packed 32-bit integers in a right by imm8 while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShift packed 32-bit integers in a right by the amount …\nShift packed 64-bit integers in a right by the amount …\nSubtract packed 16-bit integers in b from packed 16-bit …\nSubtract packed 32-bit integers in b from packed 32-bit …\nSubtract packed 64-bit integers in b from packed 64-bit …\nSubtract packed 8-bit integers in b from packed 8-bit …\nSubtract packed double-precision (64-bit) floating-point …\nSubtract packed single-precision (32-bit) floating-point …\nSubtract packed signed 16-bit integers in b from packed …\nSubtract packed signed 8-bit integers in b from packed …\nSubtract packed unsigned 16-bit integers in b from packed …\nSubtract packed unsigned 8-bit integers in b from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nUnpack and interleave 16-bit integers from the high half …\nUnpack and interleave 32-bit integers from the high half …\nUnpack and interleave 64-bit integers from the high half …\nUnpack and interleave 8-bit integers from the high half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nUnpack and interleave 16-bit integers from the low half of …\nUnpack and interleave 32-bit integers from the low half of …\nUnpack and interleave 64-bit integers from the low half of …\nUnpack and interleave 8-bit integers from the low half of …\nUnpack and interleave double-precision (64-bit) …\nUnpack and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code>, and returns …\nCompare packed signed 64-bit integers in a and b, and …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code>, and returns the …\nCompares packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed unsigned 32-bit integers in <code>a</code> and <code>b</code>, and …\nCompare packed unsigned 64-bit integers in a and b, and …\nCompares packed unsigned 8-bit integers in <code>a</code> and <code>b</code>, and …\nCompares packed double-precision (64-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nDuplicate even-indexed double-precision (64-bit) …\nDuplicate odd-indexed single-precision (32-bit) …\nDuplicate even-indexed single-precision (32-bit) …\nCreates mask from the most significant bit of each 8-bit …\nSets each bit of the returned mask based on the most …\nSets each bit of the returned mask based on the most …\nSet each bit of mask register k based on the most …\nSet each bit of mask register k based on the most …\nSet each packed 16-bit integer in dst to all ones or all …\nSet each packed 8-bit integer in dst to all ones or all …\nComputes the sum of absolute differences (SADs) of …\nMultiplies the low 32-bit integers from each packed 64-bit …\nMultiplies the low unsigned 32-bit integers from each …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nMultiplies the packed unsigned 16-bit integers in <code>a</code> and <code>b</code>, …\nMultiplies packed 16-bit integers in <code>a</code> and <code>b</code>, producing …\nMultiplies the packed 16-bit integers in <code>a</code> and <code>b</code>, producing\nMultiplies the packed 32-bit integers in <code>a</code> and <code>b</code>, producing\nFor each 64-bit element in b, select 8 unaligned bytes …\nCompute the bitwise OR of packed 32-bit integers in a and …\nCompute the bitwise OR of packed 64-bit integers in a and …\nComputes the bitwise OR packed double-precision (64-bit) …\nComputes the bitwise OR packed single-precision (32-bit) …\nComputes the bitwise OR of 256 bits (representing integer …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 16-bit integers from <code>a</code> and <code>b</code> to packed …\nConverts packed 32-bit integers from <code>a</code> and <code>b</code> to packed …\nShuffles 256 bits (composed of 4 packed double-precision …\nShuffles 256 bits (composed of 8 packed single-precision …\nShuffles 128-bits (composed of integer data) selected by …\nShuffles 128-bits of integer data selected by <code>imm8</code> from <code>a</code> …\nPermutes 64-bit integers from <code>a</code> using control mask <code>imm8</code>.\nShuffles 64-bit floating-point elements in <code>a</code> across lanes …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nPermutes packed 32-bit integers from <code>a</code> according to the …\nShuffles eight 32-bit floating-point elements in <code>a</code> across …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nShuffle 64-bit integers in a within 256-bit lanes using …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle 16-bit integers in a across lanes using the …\nShuffle 32-bit integers in a across lanes using the …\nShuffle 64-bit integers in a across lanes using the …\nShuffle 8-bit integers in a across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nFor each packed 16-bit integer maps the value to the …\nFor each packed 32-bit integer maps the value to the …\nFor each packed 64-bit integer maps the value to the …\nFor each packed 8-bit integer maps the value to the number …\nCompute the approximate reciprocal of packed …\nCompute the approximate reciprocal of packed …\nComputes the approximate reciprocal of packed …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRotate the bits in each packed 32-bit integer in a to the …\nRotate the bits in each packed 64-bit integer in a to the …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nRound packed double-precision (64-bit) floating-point …\nRound packed single-precision (32-bit) floating-point …\nComputes the approximate reciprocal square root of packed …\nComputes the absolute differences of packed unsigned 8-bit …\nScale the packed double-precision (64-bit) floating-point …\nScale the packed single-precision (32-bit) floating-point …\nBroadcasts 16-bit integer <code>a</code> to all elements of returned …\nBroadcasts 32-bit integer <code>a</code> to all elements of returned …\nBroadcasts 64-bit integer <code>a</code> to all elements of returned …\nBroadcasts 8-bit integer <code>a</code> to all elements of returned …\nBroadcasts double-precision (64-bit) floating-point value <code>a</code>…\nBroadcasts single-precision (32-bit) floating-point value <code>a</code>…\nSets packed 16-bit integers in returned vector with the …\nSets packed 32-bit integers in returned vector with the …\nSets packed 64-bit integers in returned vector with the …\nSets packed 8-bit integers in returned vector with the …\nSets packed __m256 returned vector with the supplied …\nSets packed __m256d returned vector with the supplied …\nSets packed __m256i returned vector with the supplied …\nSets packed double-precision (64-bit) floating-point …\nSets packed single-precision (32-bit) floating-point …\nSets packed 16-bit integers in returned vector with the …\nSets packed 32-bit integers in returned vector with the …\nSets packed 64-bit integers in returned vector with the …\nSets packed 8-bit integers in returned vector with the …\nSets packed __m256 returned vector with the supplied …\nSets packed __m256d returned vector with the supplied …\nSets packed __m256i returned vector with the supplied …\nSets packed double-precision (64-bit) floating-point …\nSets packed single-precision (32-bit) floating-point …\nReturns vector of type __m256d with all elements set to …\nReturns vector of type __m256 with all elements set to …\nReturns vector of type __m256i with all elements set to …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in a and b producing an …\nConcatenate packed 32-bit integers in a and b producing an …\nConcatenate packed 64-bit integers in a and b producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nConcatenate packed 16-bit integers in b and a producing an …\nConcatenate packed 32-bit integers in b and a producing an …\nConcatenate packed 64-bit integers in b and a producing an …\nShuffles 32-bit integers in 128-bit lanes of <code>a</code> using the …\nShuffles bytes from <code>a</code> according to the content of <code>b</code>.\nShuffle 128-bits (composed of 4 single-precision (32-bit) …\nShuffle 128-bits (composed of 2 double-precision (64-bit) …\nShuffle 128-bits (composed of 4 32-bit integers) selected …\nShuffle 128-bits (composed of 2 64-bit integers) selected …\nShuffles double-precision (64-bit) floating-point elements …\nShuffles single-precision (32-bit) floating-point elements …\nShuffles 16-bit integers in the high 64 bits of 128-bit …\nShuffles 16-bit integers in the low 64 bits of 128-bit …\nNegates packed 16-bit integers in <code>a</code> when the corresponding …\nNegates packed 32-bit integers in <code>a</code> when the corresponding …\nNegates packed 8-bit integers in <code>a</code> when the corresponding …\nShifts packed 16-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> left by <code>IMM8</code> while …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShift packed 16-bit integers in a left by the amount …\nShifts packed 32-bit integers in <code>a</code> left by the amount …\nShifts packed 64-bit integers in <code>a</code> left by the amount …\nReturns the square root of packed double-precision …\nReturns the square root of packed single-precision …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShift packed 64-bit integers in a right by count while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShift packed 64-bit integers in a right by imm8 while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShift packed 64-bit integers in a right by the amount …\nShifts packed 16-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>count</code> while …\nShifts packed 16-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 32-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts packed 64-bit integers in <code>a</code> right by <code>IMM8</code> while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nShift packed 16-bit integers in a right by the amount …\nShifts packed 32-bit integers in <code>a</code> right by the amount …\nShifts packed 64-bit integers in <code>a</code> right by the amount …\nStore 256-bits (composed of 8 packed 32-bit integers) from …\nStore 256-bits (composed of 4 packed 64-bit integers) from …\nStores 256-bits (composed of 4 packed double-precision …\nStores 256-bits (composed of 8 packed single-precision …\nStores 256-bits of integer data from <code>a</code> into memory. …\nStores the high and low 128-bit halves (each composed of 4 …\nStores the high and low 128-bit halves (each composed of 2 …\nStores the high and low 128-bit halves (each composed of …\nStore 256-bits (composed of 16 packed 16-bit integers) …\nStore 256-bits (composed of 8 packed 32-bit integers) from …\nStore 256-bits (composed of 4 packed 64-bit integers) from …\nStore 256-bits (composed of 32 packed 8-bit integers) from …\nStores 256-bits (composed of 4 packed double-precision …\nStores 256-bits (composed of 8 packed single-precision …\nStores 256-bits of integer data from <code>a</code> into memory. …\nMoves double-precision values from a 256-bit vector of …\nMoves single-precision floating point values from a …\nMoves integer data from a 256-bit integer vector to a …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 32-bit integers in <code>b</code> from packed 32-bit …\nSubtract packed 64-bit integers in <code>b</code> from packed 64-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtracts packed double-precision (64-bit) floating-point …\nSubtracts packed single-precision (32-bit) floating-point …\nSubtract packed 16-bit integers in <code>b</code> from packed 16-bit …\nSubtract packed 8-bit integers in <code>b</code> from packed 8-bit …\nSubtract packed unsigned 16-bit integers in <code>b</code> from packed …\nSubtract packed unsigned 8-bit integers in <code>b</code> from packed …\nBitwise ternary logic that provides the capability to …\nBitwise ternary logic that provides the capability to …\nCompute the bitwise AND of packed 16-bit integers in a and …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed 8-bit integers in a and …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nCompute the bitwise NAND of packed 16-bit integers in a …\nCompute the bitwise NAND of packed 32-bit integers in a …\nCompute the bitwise NAND of packed 64-bit integers in a …\nCompute the bitwise NAND of packed 8-bit integers in a and …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing …\nComputes the bitwise AND of 256 bits (representing integer …\nReturns vector of type <code>__m256d</code> with indeterminate elements.\nReturns vector of type <code>__m256</code> with indeterminate elements. …\nReturns vector of type __m256i with with indeterminate …\nUnpacks and interleave 16-bit integers from the high half …\nUnpacks and interleave 32-bit integers from the high half …\nUnpacks and interleave 64-bit integers from the high half …\nUnpacks and interleave 8-bit integers from the high half …\nUnpacks and interleave double-precision (64-bit) …\nUnpacks and interleave single-precision (32-bit) …\nUnpacks and interleave 16-bit integers from the low half …\nUnpacks and interleave 32-bit integers from the low half …\nUnpacks and interleave 64-bit integers from the low half …\nUnpacks and interleave 8-bit integers from the low half of …\nUnpacks and interleave double-precision (64-bit) …\nUnpacks and interleave single-precision (32-bit) …\nCompute the bitwise XOR of packed 32-bit integers in a and …\nCompute the bitwise XOR of packed 64-bit integers in a and …\nComputes the bitwise XOR of packed double-precision …\nComputes the bitwise XOR of packed single-precision …\nComputes the bitwise XOR of 256 bits (representing integer …\nZeroes the contents of all XMM or YMM registers.\nZeroes the upper 128 bits of all YMM registers; the lower …\nConstructs a 256-bit floating-point vector of <code>[4 x double]</code> …\nConstructs a 256-bit floating-point vector of <code>[8 x float]</code> …\nConstructs a 256-bit integer vector from a 128-bit integer …\nCompute the absolute value of packed signed 16-bit …\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nFinds the absolute value of each packed double-precision …\nFinds the absolute value of each packed single-precision …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate a and b into a 128-byte immediate result, …\nConcatenate pairs of 16-byte blocks in a and b into a …\nCompute the bitwise AND of packed 32-bit integers in a and …\nCompute the bitwise AND of 512 bits (composed of packed …\nCompute the bitwise AND of 512 bits (representing integer …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of 512 bits (composed of packed …\nCompute the bitwise NOT of 512 bits (representing integer …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcast the 4 packed double-precision (64-bit) …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcast the 4 packed 64-bit integers from a to all …\nBroadcast the low packed 8-bit integer from a to all …\nBroadcast the low packed 32-bit integer from a to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcast the low packed 64-bit integer from a to all …\nBroadcast the low double-precision (64-bit) floating-point …\nBroadcast the low single-precision (32-bit) floating-point …\nBroadcast the low packed 16-bit integer from a to all …\nShift 128-bit lanes in a left by imm8 bytes while shifting …\nShift 128-bit lanes in a right by imm8 bytes while …\nCast vector of type __m128d to type __m512d; the upper 384 …\nCast vector of type __m256d to type __m512d; the upper 256 …\nCast vector of type __m512d to type __m128d. This …\nCast vector of type __m512d to type __m256d. This …\nCast vector of type __m512d to type __m512. This intrinsic …\nCast vector of type __m512d to type __m512i. This …\nCast vector of type __m128 to type __m512; the upper 384 …\nCast vector of type __m256 to type __m512; the upper 256 …\nCast vector of type __m512 to type __m128. This intrinsic …\nCast vector of type __m512 to type __m256. This intrinsic …\nCast vector of type __m512 to type __m512d. This intrinsic …\nCast vector of type __m512 to type __m512i. This intrinsic …\nCast vector of type __m128i to type __m512i; the upper 384 …\nCast vector of type __m256i to type __m512i; the upper 256 …\nCast vector of type __m512i to type __m512d. This …\nCast vector of type __m512i to type __m512. This intrinsic …\nCast vector of type __m512i to type __m128i. This …\nCast vector of type __m512i to type __m256i. This …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for equality, …\nCompare packed 64-bit integers in a and b for equality, …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nSign extend packed 16-bit integers in a to packed 32-bit …\nSign extend packed 16-bit integers in a to packed 64-bit …\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign extend packed 32-bit integers in a to packed 64-bit …\nConvert packed 32-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nSign extend packed 8-bit integers in a to packed 16-bit …\nSign extend packed 8-bit integers in a to packed 32-bit …\nSign extend packed 8-bit integers in the low 8 bytes of a …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 16-bit integers in a to packed …\nZero extend packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nPerforms element-by-element conversion of the lower half …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in a to packed …\nZero extend packed unsigned 8-bit integers in the low 8 …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nPerforms an element-by-element conversion of packed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nPerforms element-by-element conversion of the lower half …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nCopy the lower 32-bit integer in a to dst.\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nCompute the sum of absolute differences (SADs) of …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nDivide packed double-precision (64-bit) floating-point …\nDivide packed single-precision (32-bit) floating-point …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nExtract 128 bits (composed of 4 packed single-precision …\nExtract 256 bits (composed of 4 packed double-precision …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtract 256 bits (composed of 4 packed 64-bit integers) …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …")