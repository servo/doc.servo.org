searchState.loadedDescShard("encoding_c_mem", 0, "FFI bindings for <code>encoding_rs::mem</code>.\nChecks whether a valid UTF-8 buffer contains code points …\nChecks whether a potentially invalid UTF-16 buffer …\nChecks whether a potentially invalid UTF-8 buffer contains …\nConverts bytes whose unsigned value is interpreted as …\nConverts bytes whose unsigned value is interpreted as …\nConverts bytes whose unsigned value is interpreted as …\nConverts valid UTF-8 to valid UTF-16.\nIf the input is valid UTF-16 representing only Unicode …\nConverts potentially-invalid UTF-16 to valid UTF-8 with …\nConverts potentially-invalid UTF-16 to valid UTF-8 with …\nIf the input is valid UTF-8 representing only Unicode code …\nConverts potentially-invalid UTF-8 to valid UTF-16 with …\nConverts potentially-invalid UTF-8 to valid UTF-16 …\nCopies ASCII from source to destination up to the first …\nCopies ASCII from source to destination zero-extending it …\nCopies Basic Latin from source to destination narrowing it …\nReplaces unpaired surrogates in the input with the …\nChecks whether the buffer is all-ASCII.\nChecks whether the buffer is all-Basic Latin (i.e. UTF-16 …\nChecks whether a scalar value triggers right-to-left …\nChecks whether a valid UTF-8 buffer contains code points …\nChecks whether the buffer represents only code points less …\nChecks whether a UTF-16 buffer contains code points that …\nChecks whether a UTF-16 code unit triggers right-to-left …\nChecks whether the buffer represents only code point less …\nChecks whether a potentially-invalid UTF-8 buffer contains …\nChecks whether the buffer is valid UTF-8 representing only …\nReturns the index of first byte that starts a non-Latin1 …\nReturns the index of the first unpaired surrogate or, if …\nReturns the index of first byte that starts an invalid byte")