searchState.loadedDescShard("ordermap", 0, "<code>OrderMap</code> is a hash table where the iteration order of the …\nEntry for an existing key-value pair or a vacant location …\nKey equivalence trait.\nHash value newtype. Not larger than usize, since anything …\nOpt-in mutable access to keys.\nExisting slot with equivalent key.\nA hash table where the iteration order of the key-value …\n<code>Pos</code> is stored in the <code>indices</code> array and it points to the …\nA possibly truncated hash value.\nTrait for the “size class”. Either u32 or u64 …\nVacant slot (no equivalent key in the map).\nThis method is not useful in itself – it is there to …\nComputes in <strong>O(1)</strong> time.\nRemove all key-value pairs in the map, while preserving …\nReturn <code>true</code> if and equivalent to <code>key</code> exists in the map.\nReturn an empty <code>OrderMap</code>\nCall self.method(args) with <code>::&lt;u32&gt;</code> or <code>::&lt;u64&gt;</code> depending …\nClears the <code>OrderMap</code>, returning all key-value pairs as a …\nentries is a dense vec of entries in their order. …\nGet the given key’s corresponding entry in the map for …\nCompare self to <code>key</code> and return <code>true</code> if they are equal.\nExtend the map with all key-value pairs in the iterable.\nExtend the map with all key-value pairs in the iterable.\nReturn probe (indices) and position (entries)\nFind <code>entry</code> which is already placed inside self.entries; …\nFind, in the indices, an entry that already exists at a …\nReturn probe (indices) and position (entries)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an <code>OrderMap</code> from the sequence of key-value pairs in …\nReturn a reference to the value stored for <code>key</code>, if it is …\nReturn item index, key and value\nReturn item index, mutable reference to key and value\nGet a key-value pair by index\nGet a key-value pair by index\nGet the hash from either <code>self</code> or from a lookup into <code>entries</code>…\nReturn a reference to the map’s <code>BuildHasher</code>.\nReturn the index where the key-value pair exists or will …\nReturn the index of the key-value pair\nReturn the index where the key-value pair will be inserted.\n<em><strong>Panics</strong></em> if <code>key</code> is not present in the map.\n<em><strong>Panics</strong></em> if <code>key</code> is not present in the map.\nindices are the buckets. indices.len() == raw capacity\nInsert a key-value pair in the map.\nphase 2 is post-insert where we forward-shift <code>Pos</code> in the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPretend this is a full HashValue, which is completely ok …\nReturns true if the map contains no elements.\nReturn an iterator over the key-value pairs of the map, in …\nReturn an iterator over the key-value pairs of the map, in …\nReturn an iterator over the keys of the map, in their order\nReturn the number of key-value pairs in the map.\nCreate a new map. (Does not allocate.)\nComputes in <strong>O(1)</strong> time (amortized average).\nComputes in <strong>O(1)</strong> time (amortized average).\nCreate an <code>OrderMap</code> from a list of key-value pairs\nCreate an <code>OrderSet</code> from a list of values\nRemove the last key-value pair\nReturn the index part of the Pos value inside <code>Some(_)</code> if …\nThe number of steps that <code>current</code> is forward of the desired …\nNOTE: Same as .swap_remove\nRemove and return the key, value pair stored in the map …\nReserve capacity for <code>additional</code> more key-value pairs.\n“Resolve” the Pos into a combination of its index …\nLike resolve, but the Pos <strong>must</strong> be non-none. Return its …\nScan through each key-value pair in the map and keep those …\nScan through each key-value pair in the map and keep those …\nA hash set implemented using <code>OrderMap</code>\nSet the index part of the Pos value to <code>i</code>\nSort the map’s key-value pairs in place using the …\nSort the map’s key-value pairs by the default ordering …\nSort the key-value pairs of the map and return a by value …\nRemove the key-value pair equivalent to <code>key</code> and return its …\nRemove the key-value pair equivalent to <code>key</code> and return it …\nRemove the key-value pair by index\nReturn an iterator over the values of the map, in their …\nReturn an iterator over mutable references to the the …\nCreate a new map with capacity for <code>n</code> key-value pairs. …\nCreate a new map with capacity for <code>n</code> key-value pairs. …\nCreate a new map with <code>hash_builder</code>\nKey equivalence trait.\nCompare self to <code>key</code> and return <code>true</code> if they are equal.\nOpt-in mutable access to keys.\nThis method is not useful in itself – it is there to …\nReturns the argument unchanged.\nReturn item index, mutable reference to key and value\nCalls <code>U::from(self)</code>.\nScan through each key-value pair in the map and keep those …\nA hash set where the iteration order of the values is …\nReturns the set intersection, cloned into a new set.\nReturns the set union, cloned into a new set.\nReturns the set symmetric-difference, cloned into a new …\nComputes in <strong>O(1)</strong> time.\nRemove all elements in the set, while preserving its …\nReturn <code>true</code> if an equivalent to <code>value</code> exists in the set.\nReturn an empty <code>OrderSet</code>\nReturn an iterator over the values that are in <code>self</code> but …\nClears the <code>OrderSet</code>, returning all values as a drain …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn a reference to the value stored in the set, if it …\nReturn item index and value\nGet a value by index\nReturn a reference to the set’s <code>BuildHasher</code>.\nInsert the value into the set.\nReturn an iterator over the values that are in both <code>self</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>self</code> has no elements in common with <code>other</code>.\nReturns true if the set contains no elements.\nReturns <code>true</code> if all elements of <code>self</code> are contained in <code>other</code>…\nReturns <code>true</code> if all elements of <code>other</code> are contained in <code>self</code>…\nReturn an iterator over the values of the set, in their …\nReturn the number of elements in the set.\nCreate a new set. (Does not allocate.)\nRemove the last value\nFIXME Same as .swap_remove\nAdds a value to the set, replacing the existing value, if …\nFIXME Not implemented fully yet\nScan through each value in the set and keep those where the\nSort the set’s values by their default ordering.\nSort the set’s values in place using the comparison …\nSort the values of the set and return a by value iterator …\nReturns the set difference, cloned into a new set.\nRemove the value from the set, and return <code>true</code> if it was …\nRemove the value from the set return it and the index it …\nRemove the key-value pair by index\nRemoves and returns the value in the set, if any, that is …\nReturn an iterator over the values that are in <code>self</code> or …\nFIXME Same as .swap_take\nReturn an iterator over all values that are in <code>self</code> or …\nCreate a new set with capacity for <code>n</code> elements. (Does not …\nCreate a new set with capacity for <code>n</code> elements. (Does not …\nCreate a new set with <code>hash_builder</code>\nreturn the number of steps from a to b")