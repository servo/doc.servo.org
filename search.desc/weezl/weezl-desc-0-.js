searchState.loadedDescShard("weezl", 0, "LZW decoder and encoder\nThe order of bits in bytes.\nThe result of a coding operation on a pair of buffer.\nAlias for a LZW code point\nNo more data will be produced because an end marker was …\nThe input contained an invalid code.\nThe least significant bit is processed first.\nThe error kind after unsuccessful coding of an LZW stream.\nThe status after successful coding of an LZW stream.\nThe most significant bit is processed first.\nNo bytes were read or written and no internal state …\nEverything went well.\nA default buffer size for encoding/decoding buffer.\nAn owned or borrowed buffer for stream operations.\nThe result of coding into an output stream.\nThe total number of bytes consumed from the reader.\nThe total number of bytes written into the writer.\nThe number of bytes consumed from the input buffer.\nThe number of bytes written into the output buffer.\nA module for all decoding needs.\nA module for all encoding needs.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe status after returning from the write call.\nThe possible error that occurred.\nThe state for decoding data with an LZW algorithm.\nA decoding stream sink.\nA decoding sink into a vector.\nA buffer of individual bits. The oldest code is kept in …\nA buffer of individual bits. The oldest code is kept in …\nThe number of bits in the buffer.\nThe number of bits in the buffer.\nThe buffer of decoded data.\nCode to reset all tables.\nThe buffer for decoded words.\nA precomputed mask for this code.\nA precomputed mask for this code.\nThe current code size.\nThe current code size.\nDecode a single chunk of lzw encoded data.\nDecode data from a reader.\nDecode data from a slice.\nDecode data from a reader, requiring an end marker.\nDecode data from a slice, requiring an end marker.\nDecode some bytes from <code>inp</code> and write result to <code>out</code>.\nCode to signal the end of the stream.\nWhen encoding a sequence <code>cScSc</code> where <code>c</code> is any character …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the next buffered code word.\nCheck if the decoding has finished.\nA stored flag if the end code has already appeared.\nDo we allow stream to start without an explicit reset code?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a decoder into a writer.\nConstruct a decoder into a vector.\nIf tiff then bumps are a single code sooner.\nThe link which we are still decoding and its original code.\nThe original minimum code size.\nCreate a new decoder with the specified bit order and …\nThe next code entry.\nRetrieve the next symbol, refilling if necessary.\nRefill the internal buffer.\nReset the decoder to the beginning, dropping all buffers …\nReset all internal state.\nIgnore an end code and continue decoding (no implied …\nIgnore an end code and continue.\nUse a particular buffer as an intermediate decode buffer.\nSet the size of the intermediate decode buffer.\nThe table of decoded codes.\nCreate a TIFF compatible decoder with the specified bit …\nThe state for encoding data with an LZW algorithm.\nA encoding stream sink.\nA encoding sink into a vector.\nOne tree node for at most each code. To avoid using too …\nThe number of valid buffer bits.\nThe number of valid buffer bits.\nThe bit buffer for encoding.\nThe buffer bits.\nThe buffer bits.\nInsert a code into the buffer.\nPad the buffer to a full byte.\nIncrease the maximum code size.\nApply effects of a Clear Code.\nThe clear code for resetting the dictionary.\nReturn the current code size in bits.\nThe current code length.\nThe current code length.\nThe code corresponding to the currently read characters.\nEncode a single chunk of data.\nEncode data from a reader.\nEncode data from a slice.\nEncode data from a reader and an end marker.\nDecode data from a reader, adding an end marker.\nEncode some bytes from <code>inp</code> into <code>out</code>.\nMark the encoding as in the process of finishing.\nFlush all full bytes, returning if at least one more byte …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf we have pushed the end code.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a encoder into a writer.\nConstruct an encoder into a vector.\nIf tiff then bumps are a single code sooner.\nIterate to the next char. Return Ok when it was already in …\nReturn the maximum code with the current code size.\nThe configured minimal code size.\nCreate a new encoder with the specified bit order and …\nPush bytes if the buffer space is getting small.\nReset the encoder to the beginning, dropping all buffers …\nReset the code size in the buffer.\nReset all internal state.\nReset the state tracking if end code has been written.\nUndo marking this data stream as ending. FIXME: clarify …\nUse a particular buffer as an intermediate encode buffer.\nSet the size of the intermediate encode buffer.\nInternally dispatch via a dynamic trait object. This did …\nThe current encoding symbol tree.\nCreate a TIFF compatible encoder with the specified bit …\nThe result of a coding operation on a pair of buffer.\nNo more data will be produced because an end marker was …\nThe input contained an invalid code.\nThe error kind after unsuccessful coding of an LZW stream.\nThe status after successful coding of an LZW stream.\nNo bytes were read or written and no internal state …\nEverything went well.\nThe result of coding into an output stream.\nThe result of a coding operation into a vector.\nThe total number of bytes consumed from the reader.\nThe total number of bytes written into the writer.\nThe number of bytes consumed from the input buffer.\nThe number of bytes consumed from the input buffer.\nThe number of bytes written into the output buffer.\nThe number of bytes written into the output buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe status after returning from the write call.\nThe status after returning from the write call.\nThe possible error that occurred.")