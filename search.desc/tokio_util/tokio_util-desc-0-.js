searchState.loadedDescShard("tokio_util", 0, "Utilities for working with Tokio.\nAdaptors from <code>AsyncRead</code>/<code>AsyncWrite</code> to Stream/Sink\nModule defining an Either type.\nHelpers for IO related tasks.\nSynchronization primitives\nA simple <code>Decoder</code> and <code>Encoder</code> implementation that splits up …\nAn error occurred while encoding or decoding a chunk.\nA simple <code>Decoder</code> and <code>Encoder</code> implementation that just …\nDecoding of frames via buffers.\nTrait of helper objects to write out messages as bytes, …\nThe type of unrecoverable frame decoding errors.\nThe type of encoding errors.\nA unified <code>Stream</code> and <code>Sink</code> interface to an underlying I/O …\n<code>FramedParts</code> contains an export of the data of a Framed …\nA <code>Stream</code> of messages decoded from an <code>AsyncRead</code>.\nA <code>Sink</code> of frames encoded to an <code>AsyncWrite</code>.\nAn IO error occurred.\nAn IO error occurred.\nThe type of decoded frames.\nA simple <code>Decoder</code> and <code>Encoder</code> implementation that splits up …\nAn error occurred while encoding or decoding a line.\nThe maximum chunk length was exceeded.\nThe maximum line length was exceeded.\nThis private field allows us to add additional fields in …\nThe codec\nAttempts to decode a frame from the provided buffer of …\nEncodes a frame into the buffer provided.\nThe inner transport used to read bytes to and write bytes …\nAre we currently discarding the remainder of a line which …\nAre we currently discarding the remainder of a chunk which …\nFrame a stream of bytes based on a length prefix\nThe maximum length for a given line. If <code>usize::MAX</code>, lines …\nThe maximum length for a given chunk. If <code>usize::MAX</code>, …\nThe buffer with read but unprocessed data.\nThe bytes that are using for search during decode\nThe bytes that are using for encoding\nA buffer with unprocessed data which are not written yet.\nA simple <code>Decoder</code> and <code>Encoder</code> implementation that splits up …\nAn error occurred while encoding or decoding a chunk.\nAn IO error occurred.\nThe maximum chunk length was exceeded.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre we currently discarding the remainder of a chunk which …\nReturns the maximum chunk length when decoding.\nThe maximum length for a given chunk. If <code>usize::MAX</code>, …\nReturns a <code>AnyDelimiterCodec</code> for splitting up data into …\nReturns a <code>AnyDelimiterCodec</code> with a maximum chunk length …\nThe bytes that are using for search during decode\nThe bytes that are using for encoding\nA simple <code>Decoder</code> and <code>Encoder</code> implementation that just …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>BytesCodec</code> for shipping around raw bytes.\nDecoding of frames via buffers.\nThe type of unrecoverable frame decoding errors.\nThe type of decoded frames.\nAttempts to decode a frame from the provided buffer of …\nA default method available to be called when there are no …\nA default method available to be called when there are no …\nProvides a <code>Stream</code> and <code>Sink</code> interface for reading and …\nProvides a <code>Stream</code> and <code>Sink</code> interface for reading and …\nTrait of helper objects to write out messages as bytes, …\nThe type of encoding errors.\nEncodes a frame into the buffer provided.\nA unified <code>Stream</code> and <code>Sink</code> interface to an underlying I/O …\n<code>FramedParts</code> contains an export of the data of a Framed …\nThis private field allows us to add additional fields in …\nReturns backpressure boundary\nReturns a reference to the underlying codec wrapped by …\nThe codec\nReturns a mutable reference to the underlying codec …\nReturns a mutable reference to the underlying codec …\nReturns the argument unchanged.\nReturns the argument unchanged.\nProvides a <code>Stream</code> and <code>Sink</code> interface for reading and …\nReturns a mutable reference to the underlying I/O stream …\nReturns a pinned mutable reference to the underlying I/O …\nReturns a reference to the underlying I/O stream wrapped by\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the <code>Framed</code>, returning its underlying I/O stream.\nConsumes the <code>Framed</code>, returning its underlying I/O stream, …\nThe inner transport used to read bytes to and write bytes …\nMaps the codec <code>U</code> to <code>C</code>, preserving the read and write …\nCreate a new, default, <code>FramedParts</code>\nProvides a <code>Stream</code> and <code>Sink</code> interface for reading and …\nThe buffer with read but unprocessed data.\nReturns a reference to the read buffer.\nReturns a mutable reference to the read buffer.\nUpdates backpressure boundary\nProvides a <code>Stream</code> and <code>Sink</code> interface for reading and …\nA buffer with unprocessed data which are not written yet.\nReturns a reference to the write buffer.\nReturns a mutable reference to the write buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA <code>Stream</code> of messages decoded from an <code>AsyncRead</code>.\nReturns a reference to the underlying decoder.\nReturns a mutable reference to the underlying decoder.\nReturns a mutable reference to the underlying decoder.\nReturns the argument unchanged.\nReturns a mutable reference to the underlying I/O stream …\nReturns a pinned mutable reference to the underlying I/O …\nReturns a reference to the underlying I/O stream wrapped by\nCalls <code>U::from(self)</code>.\nConsumes the <code>FramedRead</code>, returning its underlying I/O …\nMaps the decoder <code>D</code> to <code>C</code>, preserving the read buffer …\nCreates a new <code>FramedRead</code> with the given <code>decoder</code>.\nReturns a reference to the read buffer.\nReturns a mutable reference to the read buffer.\nCreates a new <code>FramedRead</code> with the given <code>decoder</code> and a …\nA <code>Sink</code> of frames encoded to an <code>AsyncWrite</code>.\nReturns backpressure boundary\nReturns a reference to the underlying encoder.\nReturns a mutable reference to the underlying encoder.\nReturns a mutable reference to the underlying encoder.\nReturns the argument unchanged.\nReturns a mutable reference to the underlying I/O stream …\nReturns a pinned mutable reference to the underlying I/O …\nReturns a reference to the underlying I/O stream wrapped by\nCalls <code>U::from(self)</code>.\nConsumes the <code>FramedWrite</code>, returning its underlying I/O …\nMaps the encoder <code>E</code> to <code>C</code>, preserving the write buffer …\nCreates a new <code>FramedWrite</code> with the given <code>encoder</code>.\nUpdates backpressure boundary\nReturns a reference to the write buffer.\nReturns a mutable reference to the write buffer.\nConfigure length delimited <code>LengthDelimitedCodec</code>s.\nA codec for frames delimited by a frame head specifying …\nAn error when the number of bytes read is more than max …\nRead the length field as a big endian integer\nCreates a new length delimited codec builder with default …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDelta between the payload length specified in the header …\nSets the number of bytes used to represent the length field\nSets the number of bytes in the header before the length …\nSets the unsigned integer type used to represent the …\nRead the length field as a little endian integer\nSets the max frame length in bytes\nReturns the current max frame setting\nRead the length field as a native endian integer\nCreates a new length delimited codec builder with default …\nCreates a new <code>LengthDelimitedCodec</code> with the default …\nCreate a configured length delimited <code>LengthDelimitedCodec</code>\nCreate a configured length delimited <code>Framed</code>\nCreate a configured length delimited <code>FramedRead</code>\nCreate a configured length delimited <code>FramedWrite</code>\nSets the number of bytes to skip before reading the payload\nUpdates the max frame setting.\nTypes that can be used with <code>Builder::length_field_type</code>.\nAn IO error occurred.\nA simple <code>Decoder</code> and <code>Encoder</code> implementation that splits up …\nAn error occurred while encoding or decoding a line.\nThe maximum line length was exceeded.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre we currently discarding the remainder of a line which …\nReturns the maximum line length when decoding.\nThe maximum length for a given line. If <code>usize::MAX</code>, lines …\nReturns a <code>LinesCodec</code> for splitting up data into lines.\nReturns a <code>LinesCodec</code> with a maximum line length limit.\nCombines two different futures, streams, or sinks having …\nA small helper macro which reduces amount of boilerplate …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA helper that wraps a <code>Sink</code><code>&lt;</code><code>Bytes</code><code>&gt;</code> and converts it into a …\nAn adapter that lets you inspect the data that’s being …\nAn adapter that lets you inspect the data that’s being …\nConvert an <code>AsyncRead</code> into a <code>Stream</code> of byte chunks.\nConvert a <code>Sink</code> of byte chunks into an <code>AsyncWrite</code>.\nConvert a <code>Stream</code> of byte chunks into an <code>AsyncRead</code>.\nTry to read data from an <code>AsyncRead</code> into an implementer of …\nTry to write data from an implementer of the <code>Buf</code> trait to …\nRead data from an <code>AsyncRead</code> into an implementer of the …\nA helper that wraps a <code>Sink</code><code>&lt;</code><code>Bytes</code><code>&gt;</code> and converts it into a …\nReturns the argument unchanged.\nGets a mutable reference to the underlying sink.\nGets a reference to the underlying sink.\nCalls <code>U::from(self)</code>.\nConsumes this <code>CopyToBytes</code>, returning the underlying sink.\nCreates a new <code>CopyToBytes</code>.\nAn adapter that lets you inspect the data that’s being …\nAn adapter that lets you inspect the data that’s being …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the <code>InspectWriter</code>, returning the wrapped writer\nConsumes the <code>InspectReader</code>, returning the wrapped reader\nCreate a new <code>InspectWriter</code>, wrapping <code>write</code> and calling <code>f</code> …\nCreate a new <code>InspectReader</code>, wrapping <code>reader</code> and calling <code>f</code> …\nRead data from an <code>AsyncRead</code> into an implementer of the …\nConvert an <code>AsyncRead</code> into a <code>Stream</code> of byte chunks.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConvert an <code>AsyncRead</code> into a <code>Stream</code> with item type …\nConvert an <code>AsyncRead</code> into a <code>Stream</code> with item type …\nConvert a <code>Sink</code> of byte chunks into an <code>AsyncWrite</code>.\nReturns the argument unchanged.\nGets a mutable reference to the underlying sink.\nGets a reference to the underlying sink.\nCalls <code>U::from(self)</code>.\nConsumes this <code>SinkWriter</code>, returning the underlying sink.\nCreates a new <code>SinkWriter</code>.\nConvert a <code>Stream</code> of byte chunks into an <code>AsyncRead</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets a mutable reference to the underlying stream.\nGets a pinned mutable reference to the underlying stream.\nGets a reference to the underlying stream.\nDo we have a chunk and is it non-empty?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this <code>BufWriter</code>, returning the underlying stream.\nConsumes this <code>StreamReader</code>, returning a Tuple consisting …\nConvert a stream of byte chunks into an <code>AsyncRead</code>.\nUseful synchronization primitives.\nA thread-safe reference-counting pointer. ‘Arc’ stands …\nA barrier enables multiple threads to synchronize the …\nA <code>BarrierWaitResult</code> is returned by <code>Barrier::wait()</code> when …\nA Condition Variable\nContains the error value\nContains the error value\n<code>Exclusive</code> provides only <em>mutable</em> access, also referred to …\nA value which is initialized on the first access.\nA type alias for the result of a lock method which can be …\nAn RAII mutex guard returned by <code>MutexGuard::map</code>, which can …\nRAII structure used to release the shared read access of a …\nRAII structure used to release the exclusive write access …\nA mutual exclusion primitive useful for protecting shared …\nAn RAII implementation of a “scoped lock” of a mutex. …\nInitialization value for static <code>Once</code> values.\nContains the success value\nContains the success value\nA synchronization primitive which can be used to run a …\nA synchronization primitive which can nominally be written …\nState yielded to <code>Once::call_once_force()</code>’s closure …\nA type of error which can be returned whenever a lock is …\nThe lock could not be acquired because another thread …\nA re-entrant mutual exclusion lock\nAn RAII implementation of a “scoped lock” of a …\nA reader-writer lock\nRAII structure used to release the shared read access of a …\nRAII structure used to release the exclusive write access …\nAn enumeration of possible errors associated with a …\nA type alias for the result of a nonblocking locking …\nA type indicating whether a timed wait on a condition …\n<code>Weak</code> is a version of <code>Arc</code> that holds a non-owning reference …\nThe lock could not be acquired at this time because the …\nReturns a reference to the underlying allocator.\nProvides a raw pointer to the data.\nReturns a raw pointer to the object <code>T</code> pointed to by this …\nConverts to <code>Arc&lt;T&gt;</code>.\nConverts to <code>Arc&lt;[T]&gt;</code>.\nAtomic types\nPerforms an initialization routine once and only once. The …\nPerforms the same function as <code>call_once()</code> except ignores …\nClear the poisoned state from a mutex.\nClear the poisoned state from a lock.\nMakes a clone of the <code>Arc</code> pointer.\nMakes a clone of the <code>Weak</code> pointer that points to the same …\nComparison for two <code>Arc</code>s.\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nCreates a <code>Condvar</code> which is ready to be waited on and …\nCreates a new lazy value using <code>Default</code> as the initializing …\nCreates an empty CStr inside an Arc\nCreates an empty str inside an Arc\nCreates a new <code>Arc&lt;T&gt;</code>, with the <code>Default</code> value for <code>T</code>.\nCreates an empty <code>[T]</code> inside an Arc\nConstructs a new <code>Weak&lt;T&gt;</code>, without allocating memory. …\nCreates a <code>Mutex&lt;T&gt;</code>, with the <code>Default</code> value for T.\nCreates a new empty cell.\nCreates a new <code>RwLock&lt;T&gt;</code>, with the <code>Default</code> value for T.\nDereferences the value.\nAttempt to downcast the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a …\nDowncasts the <code>Arc&lt;dyn Any + Send + Sync&gt;</code> to a concrete …\nCreates a new <code>Weak</code> pointer to this allocation.\nDrops the <code>Arc</code>.\nDrops the <code>Weak</code> pointer.\nEquality for two <code>Arc</code>s.\nForces the evaluation of this lazy value and returns a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a <code>Path</code> into an <code>Arc</code> by copying the <code>Path</code> data into …\nAllocate a reference-counted slice and fill it by cloning <code>v</code>…\nMove a boxed object to a new, reference-counted allocation.\nCopies the string into a newly allocated Arc&lt;OsStr&gt;.\nCreate an atomically reference-counted pointer from a …\nConverts a <code>PathBuf</code> into an Arc&lt;Path&gt; by moving the <code>PathBuf</code> …\nConverts a <code>CString</code> into an Arc&lt;CStr&gt; by moving the <code>CString</code> …\nConverts a <code>[T; N]</code> into an <code>Arc&lt;[T]&gt;</code>.\nConverts an <code>OsString</code> into an Arc&lt;OsStr&gt; by moving the …\nAllocate a reference-counted <code>str</code> and copy <code>v</code> into it.\nConverts a <code>&amp;CStr</code> into a <code>Arc&lt;CStr&gt;</code>, by copying the contents …\nConverts an atomically reference-counted string slice into …\nConverts a <code>T</code> into an <code>Arc&lt;T&gt;</code>\nAllocate a reference-counted <code>str</code> and copy <code>v</code> into it.\nAllocate a reference-counted slice and move <code>v</code>’s items …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new mutex in an unlocked state ready for use. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new cell with its contents set to <code>value</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTakes each element in the <code>Iterator</code> and collects it into an …\nBuild a <em>mutable</em> reference to an <code>Exclusive&lt;T&gt;</code> from a <em>mutable</em>…\nBuild a <em>pinned mutable</em> reference to an <code>Exclusive&lt;T&gt;</code> from a …\nConstructs an <code>Arc&lt;T&gt;</code> from a raw pointer.\nConverts a raw pointer previously created by <code>into_raw</code> back …\nConstructs an <code>Arc&lt;T, A&gt;</code> from a raw pointer.\nConverts a raw pointer previously created by <code>into_raw</code> back …\n‘Greater than or equal to’ comparison for two <code>Arc</code>s.\nGets the reference to the underlying value.\nReturns a mutable reference into the given <code>Arc</code>, if there …\nReturns a mutable reference to the underlying data.\nGets the mutable reference to the underlying value.\nReaches into this error indicating that a lock is …\nReturns a mutable reference to the underlying data.\nReturns a mutable reference to the underlying data.\nGet exclusive access to the underlying value.\nGets the mutable reference of the contents of the cell, …\nGets the mutable reference of the contents of the cell, …\nReturns a mutable reference into the given <code>Arc</code>, without …\nGets the contents of the cell, initializing it with <code>f</code> if …\nGets the contents of the cell, initializing it with <code>f</code> if …\nGet pinned exclusive access to the underlying value.\nReaches into this error indicating that a lock is …\nGreater-than comparison for two <code>Arc</code>s.\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this <code>LazyLock</code> returning the stored value.\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nConsumes this mutex, returning the underlying data.\nConsumes the <code>OnceLock</code>, returning the wrapped value. Returns\nConsumes this error indicating that a lock is poisoned, …\nConsumes this lock, returning the underlying data.\nConsumes this <code>RwLock</code>, returning the underlying data.\nUnwrap the value contained in the <code>Exclusive</code>\nConsumes the <code>Arc</code>, returning the wrapped pointer.\nConsumes the <code>Weak&lt;T&gt;</code> and turns it into a raw pointer.\nConsumes the <code>Arc</code>, returning the wrapped pointer and …\nConsumes the <code>Weak&lt;T&gt;</code>, returning the wrapped pointer and …\nReturns <code>true</code> if some <code>call_once()</code> call has completed …\nReturns <code>true</code> if this thread is the “leader thread” for …\nDetermines whether the mutex is poisoned.\nReturns <code>true</code> if the associated <code>Once</code> was poisoned prior to …\nDetermines whether the lock is poisoned.\n‘Less than or equal to’ comparison for two <code>Arc</code>s.\nAcquires a mutex, blocking the current thread until it is …\nAcquires the lock, blocking the current thread until it is …\nLess-than comparison for two <code>Arc</code>s.\nMakes a mutable reference into the given <code>Arc</code>.\nMakes a <code>MappedMutexGuard</code> for a component of the borrowed …\nMakes a <code>MappedMutexGuard</code> for a component of the borrowed …\nMakes a <code>MappedRwLockReadGuard</code> for a component of the …\nMakes a <code>MappedRwLockWriteGuard</code> for a component of the …\nMakes a <code>MappedRwLockReadGuard</code> for a component of the …\nMakes a <code>MappedRwLockWriteGuard</code> for a component of the …\nMulti-producer, single-consumer FIFO queue communication …\nInequality for two <code>Arc</code>s.\nCreates a new barrier that can block a given number of …\nCreates a new condition variable which is ready to be …\nCreates a new lazy value with the given initializing …\nConstructs a new <code>Arc&lt;T&gt;</code>.\nConstructs a new <code>Weak&lt;T&gt;</code>, without allocating any memory. …\nCreates a new mutex in an unlocked state ready for use.\nCreates a new <code>Once</code> value.\nCreates a new empty cell.\nCreates a <code>PoisonError</code>.\nCreates a new re-entrant lock in an unlocked state ready …\nCreates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked.\nWrap a value in an <code>Exclusive</code>\nConstructs a new <code>Arc&lt;T&gt;</code> while giving you a <code>Weak&lt;T&gt;</code> to the …\nConstructs a new <code>Arc&lt;T&gt;</code> in the provided allocator.\nConstructs a new <code>Weak&lt;T, A&gt;</code>, without allocating any …\nConstructs a new <code>Arc</code> with uninitialized contents.\nConstructs a new <code>Arc</code> with uninitialized contents in the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new atomically reference-counted slice with …\nConstructs a new atomically reference-counted slice with …\nWakes up all blocked threads on this condvar.\nWakes up one blocked thread on this condvar.\nPartial comparison for two <code>Arc</code>s.\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>. If <code>T</code> does not implement <code>Unpin</code>…\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator. …\nReturns <code>true</code> if the two <code>Arc</code>s point to the same allocation …\nReturns <code>true</code> if the two <code>Weak</code>s point to the same allocation …\nLocks this <code>RwLock</code> with shared read access, blocking the …\nSets the contents of this cell to <code>value</code>.\nGets the number of strong (<code>Arc</code>) pointers to this …\nGets the number of strong (<code>Arc</code>) pointers pointing to this …\nTakes the value out of this <code>OnceLock</code>, moving it back to an …\nReturns <code>true</code> if the wait was known to have timed out.\nSets the contents of this cell to <code>value</code> if the cell was …\nAttempts to acquire this lock.\nMakes a <code>MappedMutexGuard</code> for a component of the borrowed …\nMakes a <code>MappedMutexGuard</code> for a component of the borrowed …\nMakes a <code>MappedRwLockReadGuard</code> for a component of the …\nMakes a <code>MappedRwLockWriteGuard</code> for a component of the …\nMakes a <code>MappedRwLockReadGuard</code> for a component of the …\nMakes a <code>MappedRwLockWriteGuard</code> for a component of the …\nConstructs a new <code>Arc&lt;T&gt;</code>, returning an error if allocation …\nConstructs a new <code>Arc&lt;T, A&gt;</code> in the provided allocator, …\nConstructs a new <code>Arc</code> with uninitialized contents, …\nConstructs a new <code>Arc</code> with uninitialized contents, in the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Arc</code> with uninitialized contents, with the …\nConstructs a new <code>Pin&lt;Arc&lt;T&gt;&gt;</code>, return an error if …\nConstructs a new <code>Pin&lt;Arc&lt;T, A&gt;&gt;</code> in the provided allocator, …\nAttempts to acquire this <code>RwLock</code> with shared read access.\nReturns the inner value, if the <code>Arc</code> has exactly one strong …\nAttempts to lock this <code>RwLock</code> with exclusive write access.\nIf we have the only reference to <code>T</code> then unwrap it. …\nAttempts to upgrade the <code>Weak</code> pointer to an <code>Arc</code>, delaying …\nBlocks the current thread until all threads have …\nBlocks the current thread until this condition variable …\nWaits on this condition variable for a notification, …\nWaits on this condition variable for a notification, …\nWaits on this condition variable for a notification, …\nBlocks the current thread until this condition variable …\nGets the number of <code>Weak</code> pointers to this allocation.\nGets an approximation of the number of <code>Weak</code> pointers …\nLocks this <code>RwLock</code> with exclusive write access, blocking …\nAn <code>AtomicBool</code> initialized to <code>false</code>.\nAn <code>AtomicIsize</code> initialized to <code>0</code>.\nAn <code>AtomicUsize</code> initialized to <code>0</code>.\nHas the effects of both <code>Acquire</code> and <code>Release</code> together: For …\nWhen coupled with a load, if the loaded value was written …\nA boolean type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nA raw pointer type which can be safely shared between …\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAn integer type which can be safely shared between threads.\nAtomic memory orderings\nNo ordering constraints, only atomic operations.\nWhen coupled with a store, all previous operations become …\nLike <code>Acquire</code>/<code>Release</code>/<code>AcqRel</code> (for load, store, and …\nReturns a mutable pointer to the underlying <code>bool</code>.\nReturns a mutable pointer to the underlying pointer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nReturns a mutable pointer to the underlying integer.\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the pointer if the current value is …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the pointer if the current value is …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the <code>bool</code> if the current value is the …\nStores a value into the pointer if the current value is …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nStores a value into the atomic integer if the current …\nA compiler memory fence.\nCreates an <code>AtomicBool</code> initialized to <code>false</code>.\nCreates a null <code>AtomicPtr&lt;T&gt;</code>.\nAn atomic fence.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nAdds to the current value, returning the previous value.\nLogical “and” with a boolean value.\nPerforms a bitwise “and” operation on the address of …\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nBitwise “and” with the current value.\nOffsets the pointer’s address by adding <code>val</code> <em>bytes</em>, …\nOffsets the pointer’s address by subtracting <code>val</code> <em>bytes</em>, …\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMaximum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nMinimum with the current value.\nLogical “nand” with a boolean value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nBitwise “nand” with the current value.\nLogical “not” with a boolean value.\nLogical “or” with a boolean value.\nPerforms a bitwise “or” operation on the address of …\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nBitwise “or” with the current value.\nOffsets the pointer’s address by adding <code>val</code> (in units of …\nOffsets the pointer’s address by subtracting <code>val</code> (in …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nSubtracts from the current value, returning the previous …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nFetches the value, and applies a function to it that …\nLogical “xor” with a boolean value.\nPerforms a bitwise “xor” operation on the address of …\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nBitwise “xor” with the current value.\nReturns the argument unchanged.\nConverts a <code>bool</code> into an <code>AtomicBool</code>.\nReturns the argument unchanged.\nConverts a <code>*mut T</code> into an <code>AtomicPtr&lt;T&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i8</code> into an <code>AtomicI8</code>.\nConverts an <code>u8</code> into an <code>AtomicU8</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i16</code> into an <code>AtomicI16</code>.\nConverts an <code>u16</code> into an <code>AtomicU16</code>.\nReturns the argument unchanged.\nConverts an <code>i32</code> into an <code>AtomicI32</code>.\nReturns the argument unchanged.\nConverts an <code>u32</code> into an <code>AtomicU32</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an <code>i64</code> into an <code>AtomicI64</code>.\nReturns the argument unchanged.\nConverts an <code>u64</code> into an <code>AtomicU64</code>.\nConverts an <code>isize</code> into an <code>AtomicIsize</code>.\nReturns the argument unchanged.\nConverts an <code>usize</code> into an <code>AtomicUsize</code>.\nReturns the argument unchanged.\nGet atomic access to a <code>&amp;mut bool</code>.\nGet atomic access to a pointer.\nGet atomic access to a <code>&amp;mut i8</code>.\nGet atomic access to a <code>&amp;mut u8</code>.\nGet atomic access to a <code>&amp;mut i16</code>.\nGet atomic access to a <code>&amp;mut u16</code>.\nGet atomic access to a <code>&amp;mut i32</code>.\nGet atomic access to a <code>&amp;mut u32</code>.\nGet atomic access to a <code>&amp;mut i64</code>.\nGet atomic access to a <code>&amp;mut u64</code>.\nGet atomic access to a <code>&amp;mut isize</code>.\nGet atomic access to a <code>&amp;mut usize</code>.\nGet atomic access to a <code>&amp;mut [bool]</code> slice.\nGet atomic access to a slice of pointers.\nGet atomic access to a <code>&amp;mut [i8]</code> slice.\nGet atomic access to a <code>&amp;mut [u8]</code> slice.\nGet atomic access to a <code>&amp;mut [i16]</code> slice.\nGet atomic access to a <code>&amp;mut [u16]</code> slice.\nGet atomic access to a <code>&amp;mut [i32]</code> slice.\nGet atomic access to a <code>&amp;mut [u32]</code> slice.\nGet atomic access to a <code>&amp;mut [i64]</code> slice.\nGet atomic access to a <code>&amp;mut [u64]</code> slice.\nGet atomic access to a <code>&amp;mut [isize]</code> slice.\nGet atomic access to a <code>&amp;mut [usize]</code> slice.\nCreates a new <code>AtomicBool</code> from a pointer.\nCreates a new <code>AtomicPtr</code> from a pointer.\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nCreates a new reference to an atomic integer from a …\nReturns a mutable reference to the underlying <code>bool</code>.\nReturns a mutable reference to the underlying pointer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nReturns a mutable reference to the underlying integer.\nGet non-atomic access to a <code>&amp;mut [AtomicBool]</code> slice.\nGet non-atomic access to a <code>&amp;mut [AtomicPtr]</code> slice.\nGet non-atomic access to a <code>&amp;mut [AtomicI8]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU8]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicI16]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU16]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicI32]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU32]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicI64]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicU64]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicIsize]</code> slice\nGet non-atomic access to a <code>&amp;mut [AtomicUsize]</code> slice\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nConsumes the atomic and returns the contained value.\nLoads a value from the bool.\nLoads a value from the pointer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nLoads a value from the atomic integer.\nCreates a new <code>AtomicBool</code>.\nCreates a new <code>AtomicPtr</code>.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nCreates a new atomic integer.\nSignals the processor that it is inside a busy-wait …\nStores a value into the bool.\nStores a value into the pointer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the atomic integer.\nStores a value into the bool, returning the previous value.\nStores a value into the pointer, returning the previous …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nStores a value into the atomic integer, returning the …\nThe <strong>channel</strong>’s sending half has become disconnected, and …\nThe <strong>channel</strong>’s sending half has become disconnected, and …\nThis <code>sync_channel</code>’s receiving half has disconnected, so …\nThis <strong>channel</strong> is currently empty, but the <strong>Sender</strong>(s) have …\nThe data could not be sent on the <code>sync_channel</code> because it …\nAn owning iterator over messages on a <code>Receiver</code>, created by …\nAn iterator over messages on a <code>Receiver</code>, created by <code>iter</code>.\nThe receiving half of Rust’s <code>channel</code> (or <code>sync_channel</code>) …\nAn error returned from the <code>recv</code> function on a <code>Receiver</code>.\nThis enumeration is the list of possible errors that made …\nAn error returned from the <code>Sender::send</code> or <code>SyncSender::send</code>\nThe sending-half of Rust’s asynchronous <code>channel</code> type.\nThe sending-half of Rust’s synchronous <code>sync_channel</code> type.\nThis <strong>channel</strong> is currently empty, but the <strong>Sender</strong>(s) have …\nAn iterator that attempts to yield all pending values for …\nThis enumeration is the list of the possible reasons that …\nThis enumeration is the list of the possible error …\nCreates a new asynchronous channel, returning the …\nClone a sender to send to other threads.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts a <code>RecvError</code> into a <code>TryRecvError</code>.\nReturns the argument unchanged.\nConverts a <code>RecvError</code> into a <code>RecvTimeoutError</code>.\nReturns the argument unchanged.\nConverts a <code>SendError&lt;T&gt;</code> into a <code>TrySendError&lt;T&gt;</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator that will block waiting for messages, …\nAttempts to wait for a value on this receiver, returning …\nAttempts to wait for a value on this receiver, returning …\nAttempts to wait for a value on this receiver, returning …\nAttempts to send a value on this channel, returning it …\nSends a value on this synchronous channel.\nCreates a new synchronous, bounded channel. All data sent …\nReturns an iterator that will attempt to yield all pending …\nAttempts to return a pending value on this receiver …\nAttempts to send a value on this channel without blocking.\nA token which can be used to signal a cancellation request …\nA wrapper for cancellation token which automatically …\nA wrapper around <code>Semaphore</code> that provides a <code>poll_acquire</code> …\nError returned by the <code>PollSender</code> when the channel is …\nA wrapper around <code>mpsc::Sender</code> that can be polled.\nA reusable <code>Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send + &#39;a&gt;&gt;</code>.\nA Future that is resolved once the corresponding …\nA Future that is resolved once the corresponding …\nAn asynchronously awaitable <code>CancellationToken</code>. The token …\nA token which can be used to signal a cancellation request …\nA Future that is resolved once the corresponding …\nA Future that is resolved once the corresponding …\nCancel the <code>CancellationToken</code> and all child tokens which …\nReturns a <code>Future</code> that gets fulfilled when cancellation is …\nReturns a <code>Future</code> that gets fulfilled when cancellation is …\nCreates a <code>CancellationToken</code> which will get cancelled …\nCreates a clone of the <code>CancellationToken</code> which will get …\nCreates a <code>DropGuard</code> for this token.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the <code>CancellationToken</code> is cancelled.\nCreates a new <code>CancellationToken</code> in the non-cancelled state.\nSafety\nRuns a future to completion and returns its result wrapped …\nThis mod provides the logic for the inner tree structure …\nA wrapper for cancellation token which automatically …\nReturns stored cancellation token and removes this drop …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe data contained inside a <code>TreeNode</code>.\nA node of the cancellation tree structure\nCancels a node and its children.\nCreates a child node\nDecreases the reference count of handles.\nDisconnects the given parent from all of its children.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIncreases the reference count of handles.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether or not the node is cancelled\nMoves all children from <code>node</code> to <code>parent</code>.\nRemoves a child from the parent.\nFigures out the parent of the node and locks the node and …\nError returned by the <code>PollSender</code> when the channel is …\nA wrapper around <code>mpsc::Sender</code> that can be polled.\nAborts the current in-progress send, if any.\nClones this <code>PollSender</code>.\nCloses this sender.\nCreate with an empty inner future with no <code>Send</code> bound.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets a reference to the <code>Sender</code> of the underlying channel.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the stored value, if any.\nChecks whether this sender is been closed.\nCreates a new <code>PollSender</code>.\nCreate with an empty inner future.\nPoll the inner future.\nAttempts to prepare the sender to receive a value.\nSends an item to the channel.\nReplace the inner future.\nA wrapper around <code>Semaphore</code> that provides a <code>poll_acquire</code> …\nAdds <code>n</code> new permits to the semaphore.\nReturns the current number of available permits.\nObtain a clone of the inner semaphore.\nCloses the semaphore.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGet back the inner semaphore.\nCreate a new <code>PollSemaphore</code>.\nPoll to acquire a permit from the semaphore.\nPoll to acquire many permits from the semaphore.\nA reusable <code>Pin&lt;Box&lt;dyn Future&lt;Output = T&gt; + Send + &#39;a&gt;&gt;</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a pinned reference to the underlying future.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>ReusableBoxFuture&lt;T&gt;</code> containing the provided …\nPoll the future stored inside this box.\nPoll the future stored inside this box.\nReplace the future currently stored in this box.\nReplace the future currently stored in this box.\nA wrapper type that tells the compiler that the contents …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTry to read data from an <code>AsyncRead</code> into an implementer of …\nTry to write data from an implementer of the <code>Buf</code> trait to …")