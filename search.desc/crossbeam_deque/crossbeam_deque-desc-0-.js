searchState.loadedDescShard("crossbeam_deque", 0, "Concurrent work-stealing deques.\nThe queue was empty at the time of stealing.\nAn injector queue.\nThe steal operation needs to be retried.\nPossible outcomes of a steal operation.\nA stealer handle of a worker queue.\nAt least one task was successfully stolen.\nA worker queue.\nIndicates that the worker cannot be shared among threads.\nIndicates that dropping a <code>Injector&lt;T&gt;</code> may drop values of …\nA copy of <code>inner.buffer</code> for quick access.\nThe flavor of the queue.\nThe flavor of the queue.\nThe head of the queue.\nA reference to the inner representation of the queue.\nA reference to the inner representation of the queue.\nThe tail of the queue.\nA block in a linked list.\nA buffer that holds tasks in a worker queue.\nThe queue was empty at the time of stealing.\nThe first-in first-out flavor.\nWorker queue flavor: FIFO or LIFO.\nAn injector queue.\nInternal queue data shared between the worker and stealers.\nThe last-in first-out flavor.\nA position in a queue.\nThe steal operation needs to be retried.\nA slot in a block.\nPossible outcomes of a steal operation.\nA stealer handle of a worker queue.\nAt least one task was successfully stolen.\nA worker queue.\nIndicates that the worker cannot be shared among threads.\nIndicates that dropping a <code>Injector&lt;T&gt;</code> may drop values of …\nAllocates a new buffer with the specified capacity.\nReturns a pointer to the task at the specified <code>index</code>.\nThe back index.\nThe block in the linked list.\nThe underlying buffer.\nA copy of <code>inner.buffer</code> for quick access.\nCapacity of the buffer. Always a power of two.\nDeallocates the buffer.\nSets the <code>DESTROY</code> bit in slots starting from <code>start</code> and …\nThe flavor of the queue.\nThe flavor of the queue.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConsumes items until a <code>Success</code> is found and returns it.\nThe front index.\nThe head of the queue.\nThe index in the queue.\nA reference to the inner representation of the queue.\nA reference to the inner representation of the queue.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the queue is empty.\nReturns <code>true</code> if the queue is empty.\nReturns <code>true</code> if the queue is empty.\nReturns <code>true</code> if the queue was empty at the time of …\nReturns <code>true</code> if the steal operation needs to be retried.\nReturns <code>true</code> if at least one task was stolen.\nReturns the number of tasks in the deque.\nReturns the number of tasks in the deque.\nReturns the number of tasks in the queue.\nCreates an empty block that starts at <code>start_index</code>.\nCreates a new injector queue.\nCreates a FIFO worker queue.\nCreates a LIFO worker queue.\nThe next block in the linked list.\nIf no task was stolen, attempts another steal operation.\nPops a task from the queue.\nPointer to the allocated memory.\nPushes a task into the queue.\nPushes a task into the queue.\nReads a task from the specified <code>index</code>.\nReserves enough capacity so that <code>reserve_cap</code> tasks can be …\nResizes the internal buffer to the new capacity of <code>new_cap</code>.\nSlots for values.\nThe state of the slot.\nSteals a task from the queue.\nSteals a task from the queue.\nSteals a batch of tasks and pushes them into another …\nSteals a batch of tasks and pushes them into a worker.\nSteals a batch of tasks, pushes them into another worker, …\nSteals a batch of tasks, pushes them into a worker, and …\nSteals no more than <code>limit</code> of tasks and pushes them into …\nSteals no more than of tasks and pushes them into a worker.\nSteals no more than <code>limit</code> of tasks, pushes them into …\nSteals no more than <code>limit</code> of tasks, pushes them into a …\nCreates a stealer for this queue.\nReturns the result of the operation, if successful.\nThe tail of the queue.\nThe task.\nWaits until the next pointer is set.\nWaits until a task is written into the slot.\nWrites <code>task</code> into the specified <code>index</code>.")