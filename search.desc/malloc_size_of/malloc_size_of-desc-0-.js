searchState.loadedDescShard("malloc_size_of", 0, "A crate for measuring the heap usage of data structures in …\n<code>MallocConditionalSizeOf</code> combined with <code>MallocShallowSizeOf</code>.\nLike <code>MallocSizeOf</code>, but only measures if the value hasn’t …\nTrait for measuring the “shallow” heap usage of a …\nTrait for measuring the “deep” heap usage of a data …\nOperations used when measuring heap usage of data …\n<code>MallocUnconditionalSizeOf</code> combined with <code>MallocShallowSizeOf</code>…\nLike <code>MallocSizeOf</code>, but with a different name so it cannot …\nMeasurable that defers to inner value and used to verify …\nA closure implementing a stateful predicate on pointers.\nA C function that takes a pointer to a heap allocation and …\n<code>conditional_size_of</code> combined with <code>shallow_size_of</code>.\nMeasure the heap usage of all heap-allocated descendant …\nLike <code>size_of_op</code>, but can take an interior pointer. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nIs an <code>enclosing_size_of_op</code> available?\nCall <code>have_seen_ptr_op</code> on <code>ptr</code>.\nCheck if a pointer has been seen before, and remember it …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if an allocation is empty. This relies on knowledge …\nCall <code>enclosing_size_of_op</code>, which must be available, on <code>ptr</code>…\nCall <code>size_of_op</code> on <code>ptr</code>, first checking that the allocation …\nFor use on types where size_of() returns 0.\nMeasure the heap usage of immediate heap-allocated …\nMeasure the heap usage of all descendant heap-allocated …\nA function that returns the size of a heap allocation.\n<code>unconditional_size_of</code> combined with <code>shallow_size_of</code>.\nMeasure the heap usage of all heap-allocated descendant …")