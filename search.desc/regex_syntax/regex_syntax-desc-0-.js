searchState.loadedDescShard("regex_syntax", 0, "This crate provides a robust regular expression parser.\nThis error type encompasses any error that can be returned …\nAn error that occurred while translating concrete syntax …\nA convenience parser for regular expressions.\nA builder for a regular expression parser.\nAn error that occurred while translating abstract syntax …\nAn error that occurs when the Unicode-aware <code>\\w</code> class is …\nDefines an abstract syntax for regular expressions.\nEscapes all regular expression meta characters in <code>text</code>.\nEscapes all meta characters in <code>text</code> and writes the result …\nDefines a high-level intermediate (HIR) representation for …\nReturns true if the given character can be escaped in a …\nReturns true if the given character has significance in a …\nReturns true if and only if the given character is an …\nReturns true if and only if the given character is a …\nA convenience routine for parsing a regex using default …\nReturns true if and only if the given character is a …\nConverts ranges of Unicode scalar values to equivalent …\n<code>[0-9A-Za-z]</code>\n<code>[A-Za-z]</code>\nAn alternation of regular expressions.\nAn alternation of regular expressions.\n<code>[\\x00-\\x7F]</code>\nAn ASCII character class, e.g., <code>[:alnum:]</code> or <code>[:punct:]</code>.\nA single zero-width assertion.\nA single zero-width assertion.\nAn assertion kind.\nAn abstract syntax tree for a single regular expression.\n<code>{m,}</code>\nBell, spelled <code>\\a</code> (<code>\\x07</code>).\nA single binary operation (i.e., &amp;&amp;, – or ~~).\n<code>[ \\t]</code>\n<code>{m,n}</code>\nA bracketed character class set, which may contain zero or …\n<code>R</code>\n<code>(a)</code>\nThe capturing group limit was exceeded.\nA capture name.\n<code>(?&lt;name&gt;a)</code> or <code>(?P&lt;name&gt;a)</code>\nCarriage return, spelled <code>\\r</code> (<code>\\x0D</code>).\n<code>i</code>\nAn ASCII character class.\nThe available ASCII character classes.\nA bracketed character class, e.g., <code>[a-z0-9]</code>.\nA single bracketed character class set, which may contain …\nAn invalid escape sequence was found in a character class …\nA Perl character class.\nA single perl character class, e.g., <code>\\d</code> or <code>\\W</code>.\nThe available Perl character classes.\nAn invalid character class range was found. An invalid …\nAn invalid range boundary was found in a character class. …\nA character class set.\nA Unicode character class set operation.\nThe type of a Unicode character class set operation.\nA single component of a character class set.\nA single character class range in a set.\nA union of items inside a character class set.\nAn opening <code>[</code> was found with no corresponding closing <code>]</code>.\nA Unicode character class.\nA single Unicode character class, e.g., <code>\\pL</code> or <code>\\p{Greek}</code>.\nThe available forms of Unicode character classes.\nThe type of op used in a Unicode character class.\n<code>[\\x00-\\x1F\\x7F]</code>\nA property set to a specific value using a colon, e.g., …\nA comment from a regular expression with an associated …\nA concatenation of regular expressions.\nA concatenation of regular expressions.\nNote that this error variant is no longer used. Namely, a …\nAn invalid decimal number was given where one was expected.\nThe difference of two sets, e.g., <code>\\pN--[0-9]</code>.\nDecimal numbers.\n<code>[0-9]</code>\nThe “any character” class.\n<code>s</code>\nAn empty regex that matches everything.\nAn empty item.\n<code>$</code>\n<code>\\z</code>\nA property set to a specific value, e.g., <code>\\p{scx=Katakana}</code>.\nAn error that visiting an AST might return.\nAn error that occurred while parsing a regular expression …\nThe type of an error that occurred while building an AST.\nA bracketed hex literal was empty.\nA bracketed hex literal did not correspond to a Unicode …\nAn invalid hexadecimal digit was found.\nEOF was found before an escape sequence was completed.\nAn unrecognized escape sequence.\n<code>{m}</code>\nA single flag.\nA single flag in a group.\nA dangling negation was used when setting flags, e.g., <code>i-</code>.\nA flag was used twice, e.g., <code>i-i</code>.\nThe negation operator was used twice, e.g., <code>-i-s</code>.\nExpected a flag but got EOF, e.g., <code>(?</code>.\nUnrecognized flag, e.g., <code>a</code>.\nA group of flags.\nA set of flags, e.g., <code>(?is)</code>.\nA single item in a group of flags.\nThe kind of an item in a group of flags.\nForm feed, spelled <code>\\f</code> (<code>\\x0C</code>).\n<code>[!-~]</code>\nA grouped regular expression.\nA grouped regular expression.\nThe kind of a group.\nA duplicate capture name was found.\nA capture group name is empty, e.g., <code>(?P&lt;&gt;abc)</code>.\nAn invalid character was seen for a capture group name. …\nA closing <code>&gt;</code> could not be found for a capture group name.\nAn unclosed group, e.g., <code>(ab</code>.\nAn unopened group, e.g., <code>ab)</code>.\nThe literal is written as a hex code with a bracketed …\nThe literal is written as a hex code with a fixed number …\nThe type of a Unicode hex literal.\n<code>x</code>\nThe intersection of two sets, e.g., <code>\\pN&amp;&amp;[a-z]</code>.\nAn item, which can be a single literal, range, nested …\nLine feed, spelled <code>\\n</code> (<code>\\x0A</code>).\nA single literal expression.\nA single character literal, which includes escape …\nA single literal.\nThe kind of a single literal expression.\n<code>[a-z]</code>\nThe literal is written as an escape because it is …\n<code>m</code>\nA binary property, general category or script. The string …\nA property name and an associated value.\nA negation operator applied to all subsequent flags in the …\nThe nest limit was exceeded. The limit stored here is the …\n<code>(?:a)</code> and <code>(?i:a)</code>\nA property that isn’t a particular value, e.g., …\n<code>\\B</code>\nThe literal is written as an octal escape, e.g., <code>\\141</code>.\nA one letter abbreviated class, e.g., <code>\\pN</code>.\n<code>+</code>\nThe result of visiting an AST.\nA perl character class, e.g., <code>\\d</code> or <code>\\W</code>.\nA single position in a regular expression.\n<code>[ -~]</code>\n<code>[!-/:-@\\[-</code>{-~]`\nA range between two literals.\n<code>{m,n}</code>\nA repetition operation applied to a regular expression.\nA repetition operator applied to an arbitrary regular …\nAn opening <code>{</code> was not followed by a valid decimal value. …\nThe range provided in a counted repetition operator is …\nAn opening <code>{</code> was found with no corresponding closing <code>}</code>.\nThe kind of a repetition operator.\nA repetition operator was applied to a missing …\nThe repetition operator itself.\nA range repetition operator.\nA group of flags that is not applied to a particular …\nSpace, spelled <code>\\ </code> (<code>\\x20</code>). Note that this can only appear …\nWhitespace.\n<code>[\\t\\n\\v\\f\\r ]</code>\nSpan represents the position information of a single AST …\nThe literal is written as a specially recognized escape, …\nThe type of a special literal.\nThe special word boundary syntax, <code>\\b{something}</code>, was used, …\nThe special word boundary syntax, <code>\\b{something}</code>, was used, …\nThe syntax <code>\\b{</code> was observed, but afterwards the end of the …\n<code>^</code>\n<code>\\A</code>\nThe literal is written as an escape despite the fact that …\n<code>U</code>\nThe symmetric difference of two sets. The symmetric …\nTab, spelled <code>\\t</code> (<code>\\x09</code>).\nA Unicode character class, e.g., <code>\\pL</code> or <code>\\p{Greek}</code>.\n<code>u</code>\nThe Unicode class is not valid. This typically occurs when …\nA <code>\\U</code> prefix. When used without brackets, this form is …\nA <code>\\u</code> prefix. When used without brackets, this form is …\nA union of items.\nWhen octal support is disabled, this error is produced …\nWhen syntax similar to PCRE’s look-around is used, this …\n<code>[A-Z]</code>\nThe literal is written verbatim, e.g., <code>a</code> or <code>☃</code>.\nVertical tab, spelled <code>\\v</code> (<code>\\x0B</code>).\nA trait for visiting an abstract syntax tree (AST) in …\nAn abstract syntax tree for a singular expression along …\nWord characters.\n<code>[0-9A-Za-z_]</code>\n<code>\\b</code>\n<code>\\b{end}</code>\n<code>\\&gt;</code> (alias for <code>\\b{end}</code>)\n<code>\\b{end-half}</code>\n<code>\\b{start}</code>\n<code>\\&lt;</code> (alias for <code>\\b{start}</code>)\n<code>\\b{start-half}</code>\nA <code>\\x</code> prefix. When used without brackets, this form is …\n<code>[0-9A-Fa-f]</code>\n<code>*</code>\n<code>?</code>\nAdd the given item to this sequence of flags.\nCreate a “alternation” AST item.\nCreate a “assertion” AST item.\nThe actual ast.\nThe regular expression under repetition.\nThe regular expression in this group.\nThe alternate regular expressions.\nThe concatenation regular expressions.\nReturn an auxiliary span. This span exists only for some …\nIf this literal was written as a <code>\\x</code> hex escape, then this …\nThe Unicode scalar value corresponding to this literal.\nReturns the capture index of this group, if this is a …\nCreate a “bracketed class” AST item.\nCreate a “Perl class” AST item.\nCreate a “Unicode class” AST item.\nThe approximate column number, starting at <code>1</code>.\nThe comment text, starting with the first character …\nAll comments found in the original regular expression.\nCreate a “concat” AST item.\nThe number of digits that must be used with this literal …\nCreate a “dot” AST item.\nCreate an “empty” AST item.\nThe end byte offset.\nThe end of this range.\nAll implementors of <code>Visitor</code> must provide a <code>finish</code> method, …\nReturns the state of the given flag in this set.\nCreate a “flags” AST item.\nIf this group is non-capturing, then this returns the …\nThe actual sequence of flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the corresponding ClassAsciiKind variant for the …\nWhether this operation was applied greedily or not.\nCreate a “group” AST item.\nReturns true if and only if this AST has any (including …\nThe capture index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn this alternation as an AST.\nReturn this concatenation as an AST.\nReturn this union as a character class set item.\nReturns true if and only if this group is capturing.\nReturns true if and only if this span is empty. That is, …\nReturn true if and only if this Ast is empty.\nReturn true if and only if this class set is empty.\nWhether the op is an equality op or not.\nReturns true if this class has been negated.\nReturns true if and only if this item is a negation …\nReturns true if and only if this span occurs on a single …\nReturns true if and only if this character class range is …\nReturns true if and only if this repetition range is valid.\nThe sequence of items that make up this union.\nA sequence of flag items. Each item is either a flag or a …\nReturn the type of this error.\nThe kind of error.\nThe kind of this literal.\nThe kind of Perl class.\nThe kind of ASCII class.\nThe kind of Unicode class.\nThe type of this set. A set is either a normal union of …\nThe type of this set operation.\nThe assertion kind, e.g., <code>\\b</code> or <code>^</code>.\nThe type of operation.\nThe kind of this group.\nThe kind of this item.\nThe left hand side of the operation.\nThe line number, starting at <code>1</code>.\nCreate a “literal” AST item.\nThe capture name.\nWhether the class is negated or not. e.g., <code>\\d</code> is not …\nWhether the class is negated or not. e.g., <code>[[:alpha:]]</code> is …\nWhether this class is negated or not.\nWhether this class is negated or not. e.g., <code>[a]</code> is not …\nCreate a new span with the given positions.\nCreate a new position with the given information.\nThe absolute offset of this position, starting at <code>0</code> from …\nThe actual operation.\nThis module provides a regular expression parser.\nThe original pattern string in which this error occurred.\nThe original pattern that the parser generated the error …\nThis module provides a regular expression printer for <code>Ast</code>.\nPush a new item in this union.\nCreate a “repetition” AST item.\nThe right hand side of the operation.\nReturn the span at which this error occurred.\nReturn the span of this abstract syntax tree.\nReturn the span of this character class set.\nReturn the span of this character class set item.\nThe span of this error.\nThe span of this comment, including the beginning <code>#</code> and …\nThe span of this alternation.\nThe span of this concatenation.\nThe span of this literal.\nThe span of this class.\nThe span of this class.\nThe span of this class.\nThe span of this class.\nThe span of this range.\nThe span of the items in this operation. e.g., the <code>a-z0-9</code> …\nThe span of this operation. e.g., the <code>a-z--[h-p]</code> in …\nThe span of this assertion.\nThe span of this operation.\nThe span of this operator. This includes things like <code>+</code>, <code>*?</code> …\nThe span of this group.\nThe span of this capture name.\nThe span of these flags, including the grouping …\nThe span of this group of flags.\nThe span of this item.\nCreate a new span using the given position as the start …\nThe start byte offset.\nThe start of this range.\nBuild a set from a union.\nExecutes an implementation of <code>Visitor</code> in constant stack …\nCreate a new span by replacing the ending the position …\nCreate a new span by replacing the starting the position …\nThe property name (which may be empty).\nThe type of Unicode op used to associate <code>name</code> with <code>value</code>.\nThe property value (which may be empty).\nThe position of the original flag. The error position …\nThe position of the original negation operator. The error …\nThe position of the initial occurrence of the capture …\nThe capture name.\nTrue if the <code>?P&lt;</code> syntax is used and false if the <code>?&lt;</code> syntax …\nThis state is pushed whenever a new alternation branch is …\nClassState represents a single stack frame while parsing …\nContains the error value\nThis state is pushed whenever an opening group is found.\nGroupState represents a single stack frame while parsing …\nA type that traverses a fully parsed Ast and checks …\nContains the success value\nThis state is pushed when a operator is seen. When popped, …\nThis state is pushed whenever an opening bracket is found.\nA regular expression parser.\nA builder for a regular expression parser.\nParserI is the internal parser implementation.\nA primitive is an expression with no sub-expressions. This …\nAdds the given capture name to this parser. If this …\nBuild a parser from this configuration with the given …\nBump the parser to the next Unicode scalar value.\nBump the parser, and if the <code>x</code> flag is enabled, bump …\nIf the substring starting at the current position of the …\nIf the <code>x</code> flag is enabled (i.e., whitespace insensitivity …\nThe current capture index.\nA sorted sequence of capture names. This is used to detect …\nReturn the character at the current position of the parser.\nReturn the character at the given position.\nReturn the current column of the parser.\nA list of comments, in order of appearance.\nThe current depth while walking an Ast.\nAllow using <code>{,n}</code> as an equivalent to <code>{0,n}</code>.\nWhether the parser supports <code>{,n}</code> repetitions as an …\nCreate a new error with the given span and error type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEnable verbose mode in the regular expression.\nReturn whether the parser should ignore whitespace or not.\nWhether whitespace should be ignored. When enabled, …\nThe initial setting for <code>ignore_whitespace</code> as provided by …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this primitive into a proper AST.\nConvert this primitive into a literal in a character …\nConvert this primitive into an item in a character class.\nReturns true if the given character is a valid in a …\nReturns true if the next call to <code>bump</code> would return false.\nReturns true if the given character is a hexadecimal digit.\nReturns true if and only if the parser is positioned at a …\nReturn the current line number of the parser.\nAttempt to parse an ASCII character class, e.g., <code>[:alnum:]</code>.\nAttempt to parse a specialty word boundary. That is, …\nSet the nesting limit for this parser.\nThe maximum number of open parens/brackets allowed. If the …\nCreate a new parser builder with a default configuration.\nCreate a new parser with a default configuration.\nBuild an internal parser from a parser configuration and a …\nReturn the next capturing index. Each subsequent call …\nWhether to support octal syntax or not.\nWhether to support octal syntax or not. When <code>false</code>, the …\nReturn the current offset of the parser.\nThe parser that is checking the nest limit.\nParse the regular expression into an abstract syntax tree.\nParse the regular expression into an abstract syntax tree.\nParses a capture group name. Assumes that the parser is …\nParses a counted repetition operation. A counted …\nParse a decimal number into a u32 while trimming leading …\nParse an escape sequence as a primitive AST.\nParse the current character as a flag. Do not advance the …\nParse a sequence of flags starting at the current …\nParse a group (which contains a sub-expression) or a set …\nParse a hex representation of a Unicode codepoint. This …\nParse a hex representation of any Unicode scalar value. …\nParse an N-digit hex representation of a Unicode …\nParse an octal representation of a Unicode codepoint up to …\nParse a Perl character class, e.g., <code>\\d</code> or <code>\\W</code>. This assumes …\nParse a primitive AST. e.g., A literal, non-set character …\nParse a standard character class consisting primarily of …\nParse a single item in a character class as a primitive, …\nParses the opening of a character class set. This includes …\nParse a single primitive item in a character class set. …\nParses an uncounted repetition operation. An uncounted …\nParse a Unicode class in either the single character …\nParse the regular expression and return an abstract syntax …\nParse the regular expression and return an abstract syntax …\nReturn a reference to the parser state.\nThe parser state/configuration.\nReturn a reference to the pattern being parsed.\nThe full regular expression provided by the user.\nPeek at the next character in the input without advancing …\nLike peek, but will ignore spaces when the parser is in …\nParse the end of a character class set and pop the …\nPop a character class set from the character class parser …\nPop a group AST from the parser’s internal stack and set …\nPop the last state from the parser’s internal stack, if …\nReturn the current position of the parser, which includes …\nThe current position of the parser.\nParse and push a single alternation on to the parser’s …\nPush the current set of class items on to the class parser…\nParse the opening of a character class and push the …\nParse and push a group AST (and its parent concatenation) …\nPushes or adds the given branch of an alternation to the …\nReset the internal state of a parser.\nA scratch buffer used in various places. Mostly this is …\nReturn the span of this primitive.\nCreate a span at the current position of the parser. Both …\nCreate a span that covers the current character.\nWhen the result is an error, transforms the ast::ErrorKind …\nA stack of nested character classes. This is only …\nA stack of grouped sub-expressions, including alternations.\nReturn an “unclosed class” error whose span points to …\nThe type of the operation, i.e., &amp;&amp;, – or ~~.\nThe left-hand side of the operator.\nThe class that has been opened. Typically this just …\nThe union of class items immediately preceding this class.\nThe concatenation immediately preceding the opening group.\nThe group that has been opened. Its sub-AST is always …\nWhether this group has the <code>x</code> flag enabled or not.\nA printer for a regular expression abstract syntax tree.\nA builder for constructing a printer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new printer.\nPrint the given <code>Ast</code> to the given writer. The writer must …\nThe stack frame used while visiting every child node of an …\nThe stack frame used while a binary class operation.\nA stack frame allocated just before descending into a …\nA stack frame allocated just before descending into a …\nRepresents a single stack frame while performing …\nA representation of the inductive step when performing …\nThe stack frame used while visiting every child node of a …\nAn error that visiting an AST might return.\nRepresents a single stack frame while performing …\nA stack frame allocated just before descending into a group…\nHeapVisitor visits every item in an <code>Ast</code> recursively using …\nThe result of visiting an AST.\nA stack frame allocated just before descending into a …\nThe stack frame used while visiting every child node of a …\nA trait for visiting an abstract syntax tree (AST) in …\nPerform the next inductive step on this frame and return …\nPerform the next inductive step on this frame and return …\nAll implementors of <code>Visitor</code> must provide a <code>finish</code> method, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBuild a stack frame for the given AST if one is needed …\nBuild a stack frame for the given class node if one is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPops the given frame. If the frame has an additional …\nPops the given frame. If the frame has an additional …\nA stack of <code>Ast</code> nodes. This is roughly analogous to the …\nSimilar to the <code>Ast</code> stack above, but is used only for …\nThis method is called before beginning traversal of the …\nThis method is called before beginning traversal of the …\nExecutes an implementation of <code>Visitor</code> in constant stack …\nThis method is called between child nodes of an <code>Alternation</code>…\nThis method is called between child nodes of an <code>Alternation</code>…\nCall the appropriate <code>Visitor</code> methods given an inductive …\nCall the appropriate <code>Visitor</code> methods given an inductive …\nThis method is called between the left hand and right hand …\nThis method is called between the left hand and right hand …\nThis method is called on every <code>ClassSetBinaryOp</code> after …\nThis method is called on every <code>ClassSetBinaryOp</code> after …\nThis method is called on every <code>ClassSetBinaryOp</code> before …\nThis method is called on every <code>ClassSetBinaryOp</code> before …\nThis method is called on every <code>ClassSetItem</code> after …\nThis method is called on every <code>ClassSetItem</code> after …\nThis method is called on every <code>ClassSetItem</code> before …\nThis method is called on every <code>ClassSetItem</code> before …\nThis method is called between child nodes of a …\nThis method is called between child nodes of a …\nThis method is called on an <code>Ast</code> after descending all of …\nThis method is called on an <code>Ast</code> after descending all of …\nThis method is called on an <code>Ast</code> before descending into …\nThis method is called on an <code>Ast</code> before descending into …\nThe child node we are currently visiting.\nThe remaining child nodes to visit (which may be empty).\nThe child node we are currently visiting.\nThe child node we are currently visiting.\nThe remaining child nodes to visit (which may be empty).\nThe remaining child nodes to visit (which may be empty).\nA type that wraps a single byte with a convenient …\nA type that provides a human readable debug impl for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecodes the next UTF-8 encoded codepoint from the given …\nA simple binary sum type.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis error type encompasses any error that can be returned …\nA helper type for formatting nice error messages.\nAn error that occurred while translating concrete syntax …\nThis type represents an arbitrary number of error spans in …\nAn error that occurred while translating abstract syntax …\nAdd the given span to this sequence, putting it in the …\nAn auxiliary and optional span, in case the error needs to …\nAll error spans that occur on a single line. This sequence …\nThe error kind. It must impl fmt::Display.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nBuild a sequence of spans from a formatter.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLeft pad the given line number with spaces such that it is …\nReturn the line number padding beginning at the start of …\nThe total width that should be used for line numbers. The …\nAll error spans that occur over one or more lines. That …\nNotate the pattern string with carents (<code>^</code>) pointing at …\nReturn notes for the line indexed at <code>i</code> (zero-based). If …\nThe original regex pattern string.\nThe original regex pattern in which the error occurred.\nThe primary span of the error.\nAn alternation of expressions.\nMatches any byte value.\nMatches any byte value except for the <code>u8</code> given.\nMatches any byte value except for <code>\\r</code> and <code>\\n</code>.\nMatches any byte value except for <code>\\n</code>.\nMatches the UTF-8 encoding of any Unicode scalar value.\nMatches the UTF-8 encoding of any Unicode scalar value …\nMatches the UTF-8 encoding of any Unicode scalar value …\nMatches the UTF-8 encoding of any Unicode scalar value …\nA set of characters represented by arbitrary bytes (one …\nThe high-level intermediate representation for a capturing …\nA capturing group, which contains a sub-expression.\nAn error that occurs when Unicode-aware simple case …\nThe high-level intermediate representation of a character …\nA single character class that matches any of the …\nA set of characters represented by arbitrary bytes.\nAn iterator over all ranges in a byte character class.\nA single range of characters represented by arbitrary …\nA set of characters represented by Unicode scalar values.\nAn iterator over all ranges in a Unicode character class.\nA single range of characters represented by Unicode scalar …\nA concatenation of expressions.\nA type describing the different flavors of <code>.</code>.\nThe empty regular expression, which matches everything, …\nMatch the end of text. Specifically, this matches at the …\nMatch the end of a line or the end of text. Specifically, …\nMatch the end of a line or the end of text. Specifically, …\nAn error that visiting an HIR might return.\nAn error that can occur while translating an <code>Ast</code> to a <code>Hir</code>.\nThe type of an error that occurred while building an <code>Hir</code>.\nA high-level intermediate representation (HIR) for a …\nThe underlying kind of an arbitrary <code>Hir</code> expression.\nThis error occurs when one uses a non-ASCII byte for a …\nThis error occurs when translating a pattern that could …\nThe high-level intermediate representation of a literal.\nA literalstring that matches exactly these bytes.\nThe high-level intermediate representation for a …\nA look-around assertion. A look-around match always has …\nA set of look-around assertions.\nAn iterator over all look-around assertions in a <code>LookSet</code>.\nThe result of visiting an HIR.\nA type that collects various properties of an HIR value.\nThe property definition. It is split out so that we can …\nThe high-level intermediate representation of a repetition …\nA repetition operation applied to a sub-expression.\nMatch the beginning of text. Specifically, this matches at …\nMatch the beginning of a line or the beginning of text. …\nMatch the beginning of a line or the beginning of text. …\nA set of characters represented by Unicode scalar values.\nThis occurs when the Unicode simple case mapping tables …\nThis error occurs when a Unicode feature is used when …\nThis occurs when a Unicode-aware Perl character class (<code>\\w</code>, …\nThis occurs when an unrecognized Unicode property name …\nThis occurs when an unrecognized Unicode property value …\nA trait for visiting the high-level IR (HIR) in depth …\nMatch an ASCII-only word boundary. That is, this matches a …\nMatch an ASCII-only negation of a word boundary.\nMatch the end of an ASCII-only word boundary. That is, …\nMatch the end half of an ASCII-only word boundary. That …\nMatch the end half of a Unicode word boundary. That is, …\nMatch the end of a Unicode word boundary. That is, this …\nMatch the start of an ASCII-only word boundary. That is, …\nMatch the start half of an ASCII-only word boundary. That …\nMatch the start half of a Unicode word boundary. That is, …\nMatch the start of a Unicode word boundary. That is, this …\nMatch a Unicode-aware word boundary. That is, this matches …\nMatch a Unicode-aware negation of a word boundary.\nReturns the alternation of the given expressions.\nCreate a new set of HIR properties for a concatenation.\nReturns a convenient single codepoint representation of …\nReturn the underlying representation of this look-around …\nThe underlying representation this set is exposed to make …\nCreates a capture HIR expression.\nCreate a new set of HIR properties for a capture.\nApply Unicode simple case folding to this character class, …\nExpand this character class such that it contains all case …\nApply simple case folding to this Unicode scalar value …\nExpand this character class such that it contains all case …\nApply simple case folding to this byte range. Only ASCII …\nCreates a class HIR expression. The class may either be …\nCreate a new set of HIR properties for a character class.\nGiven a sequence of HIR values where each value …\nGiven a sequence of HIR values where each value …\nReturns the concatenation of the given expressions.\nCreate a new set of HIR properties for a concatenation.\nReturns true if and only if the given look-around …\nReturns true if and only if this set contains any anchor …\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any “…\nReturns true if and only if this set contains any word …\nReturns true if and only if this set contains any ASCII …\nReturns true if and only if this set contains any Unicode …\nSubtract the given character class from this character …\nSubtract the given byte class from this byte class, in …\nReturns an HIR expression for <code>.</code>.\nReturns an empty HIR expression.\nCreate a new class with no ranges.\nCreate a new class with no ranges.\nCreate a new set of HIR properties for an empty regex.\nCreate an empty set of look-around assertions.\nReturn the end of this range.\nReturn the end of this range.\nReturns the total number of explicit capturing groups in …\nReturns an HIR expression that can never match anything. …\nAll implementors of <code>Visitor</code> must provide a <code>finish</code> method, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven the underlying representation of a <code>Look</code> value, …\nCreate a full set of look-around assertions.\nWhether this repetition operator is greedy or not. A …\nThe capture index of the capture.\nReturn a new set that is equivalent to the original, but …\nIntersect this character class with the given character …\nIntersect this byte class with the given byte class, in …\nReturns a new set that is the intersection of this and the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes ownership of this HIR expression and returns its …\nSplits this HIR into its constituent parts.\nReturn true if and only if this HIR is either a simple …\nReturns true if and only if this character class will …\nReturns true if and only if this character class will …\nReturns true if and only if this character class is empty. …\nReturns true if and only if this set is empty.\nReturn true if and only if this HIR is a simple literal. …\nReturns true if and only if this character class will only …\nReturn true if and only if the corresponding HIR will …\nReturn an iterator over all ranges in this class.\nReturn an iterator over all ranges in this class.\nReturns an iterator over all of the look-around assertions …\nReturn the type of this error.\nReturns a reference to the underlying HIR kind.\nThe kind of error.\nThe underlying HIR kind.\nReturns the number of codepoints in this range.\nReturns the number of bytes in this range.\nReturns the total number of look-around assertions in this …\nLooks for a common prefix in the list of alternation …\nProvides literal extraction from <code>Hir</code> expressions.\nCreates a literal HIR expression.\nIf this class consists of exactly one element (whether a …\nIf this class consists of exactly one codepoint, then …\nIf this class consists of exactly one byte, then return it …\nCreate a new set of HIR properties for a literal regex.\nCreates a look-around assertion HIR expression.\nCreate a new set of HIR properties for a look-around …\nReturns a set of all look-around assertions that appear at …\nReturns a set of all look-around assertions that appear as …\nReturns a set of all look-around assertions that appear as …\nReturns a set of all look-around assertions that appear as …\nReturns a set of all look-around assertions that appear as …\nThe maximum range of the repetition.\nReturns the length, in bytes, of the longest string …\nReturns the length, in bytes, of the longest string …\nReturns the length, in bytes, of the longest string …\nReturns the length (in bytes) of the longest string …\nReturns the total amount of heap memory usage, in bytes, …\nThe minimum range of the repetition.\nReturns the length, in bytes, of the smallest string …\nReturns the length, in bytes, of the smallest string …\nReturns the length, in bytes, of the smallest string …\nReturns the length (in bytes) of the smallest string …\nThe name of the capture, if it exists.\nNegate this character class in place.\nNegate this character class.\nNegate this byte class.\nCreate a new class from a sequence of ranges.\nCreate a new Unicode scalar value range for a character …\nCreate a new class from a sequence of ranges.\nCreate a new byte range for a character class.\nThe original pattern string in which this error occurred.\nThe original pattern that the translator’s Ast was …\nThis module provides a regular expression printer for <code>Hir</code>.\nReturns the properties computed for this <code>Hir</code>.\nAnalysis info about this HIR, computed during construction.\nAdd a new range to this set.\nAdd a new range to this set.\nReturn the underlying ranges as a slice.\nReturn the underlying ranges as a slice.\nReturn a <code>LookSet</code> from the slice given as a native endian …\nReturn a new set that is equivalent to the original, but …\nCreates a repetition HIR expression.\nCreate a new set of HIR properties for a repetition.\nFlip the look-around assertion to its equivalent for …\nUpdates this set in place with the result of inserting the …\nUpdates this set in place with the result of intersecting …\nUpdates this set in place with the result of removing the …\nUpdates this set in place with the result of subtracting …\nUpdates this set in place with the result of unioning it …\nCreate a look-around set containing the look-around …\nGiven a sequence of HIR values where each value …\nGiven a sequence of HIR values where each value …\nReturn the span at which this error occurred.\nThe span of this error, derived from the Ast given to the …\nReturn the start of this range.\nReturn the start of this range.\nReturns the total number of explicit capturing groups that …\nThe expression inside the capturing group, which may be …\nThe expression being repeated.\nReturns a slice of this kind’s sub-expressions, if any.\nReturns a new set that is the result of subtracting the …\nCompute the symmetric difference of the given character …\nCompute the symmetric difference of the given byte …\nIf this class consists of only ASCII ranges, then return …\nIf this class consists of only ASCII ranges, then return …\nDefines a translator that converts an <code>Ast</code> to an <code>Hir</code>.\nApply Unicode simple case folding to this character class, …\nExpand this character class such that it contains all case …\nUnion this character class with the given character class, …\nUnion this byte class with the given byte class, in place.\nReturns a new set of properties that corresponds to the …\nReturns a new set that is the union of this and the one …\nExecutes an implementation of <code>Visitor</code> in constant stack …\nReturns a new repetition with the same <code>min</code>, <code>max</code> and <code>greedy</code> …\nWrite a <code>LookSet</code> as a native endian 32-bit integer to the …\nAn iterator over intervals.\nConverts this set into a canonical ordering.\nExpand this interval set such that it contains all case …\nCreate a new interval.\nSubtract the given range from this range and return the …\nSubtract the given set from this set, in place.\nWhile not required at all for correctness, we keep track …\nReturns the argument unchanged.\nReturns the argument unchanged.\nIntersect this range with the given range and return the …\nIntersect this set with the given set, in place.\nReturn an immutable slice of intervals in this set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this class is in a canonical …\nReturns true if and only if the two ranges are contiguous. …\nReturns true if and only if the intersection of this range …\nReturns true if and only if this range is a subset of the …\nReturn an iterator over all intervals in this set.\nNegate this interval set.\nCreate a new set from a sequence of intervals. Each …\nAdd a new interval to this set.\nA sorted set of non-overlapping ranges.\nCompute the symmetric difference of the two sets, in place.\nUnion the given overlapping range into this range.\nUnion this set with the given set, in place.\nThe kind of literals to extract from an <code>Hir</code> expression.\nExtracts prefix or suffix literal sequences from <code>Hir</code> …\nA single literal extracted from an <code>Hir</code> expression.\nA “preference” trie that rejects literals that will …\nExtracts only prefix literals from a regex.\nA sequence of literals.\nA single state in a trie. Uses a sparse representation for …\nExtracts only suffix literals from a regex.\nReturns the bytes in this literal.\nReturns true if the given byte class exceeds the …\nReturns true if the given Unicode class exceeds the …\nCreates a new empty state and returns its ID.\nCompute the cross product of the two sequences if the …\nModify this sequence to contain the cross product between …\nA helper function the corresponds to the subtle preamble …\nModify this sequence to contain the cross product between …\nDeduplicate adjacent equivalent literals in this sequence.\nReturns an empty sequence.\nApplies the literal length limit to the given sequence. If …\nReturns a new exact literal containing the bytes given.\nExtend this literal with the literal given.\nExecute the extractor and return a sequence of literals.\nExtract a sequence from the given alternation.\nConvert the given byte class into a sequence of literals …\nConvert the given Unicode class into a sequence of …\nExtract a sequence from the given concatenation. Sequences …\nExtract a sequence of literals from the given repetition. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a new inexact literal containing the bytes given.\nReturns a sequence of literals without a finite size and …\nReturns <code>Ok</code> if the given byte string is accepted into this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nYields ownership of the bytes inside this literal.\nReturns true if and only if this sequence is finite and …\nReturns true if and only if this literal has zero bytes.\nReturns true if and only if all literals in this sequence …\nReturns true if and only if this literal is exact.\nReturns true if this sequence is finite.\nReturns true if and only if all literals in this sequence …\nReturns true if it is believe that this literal is likely …\nReturns true if this kind is the <code>Prefix</code> variant.\nReturns true if this kind is the <code>Suffix</code> variant.\nTrims all literals in this seq such that only the first <code>len</code>…\nTrims this literal such that only the first <code>len</code> bytes …\nTrims all literals in this seq such that only the last <code>len</code> …\nTrims this literal such that only the last <code>len</code> bytes …\nSet the kind of literal sequence to extract from an <code>Hir</code> …\nReturns the number of literals in this sequence if the …\nReturns the length of this literal in bytes.\nConfigure a limit on the length of the sequence that is …\nConfigure a limit on the maximum length of any literal in …\nConfigure a limit on the total number of repetitions that …\nConfigure a limit on the total number of literals that …\nIf this is a finite sequence, return its members as a …\nThe members of this seq.\nReturns the longest common prefix from this seq.\nReturns the longest common suffix from this seq.\nMake all of the literals in this sequence inexact.\nMarks this literal as inexact.\nConverts this sequence to an infinite sequence.\nThis vec indicates which states are match states. It …\nReturn the maximum length of the sequence that would …\nReturns the length of the longest literal in this sequence.\nReturn the maximum length of the sequence that would …\nReturns the length of the shortest literal in this …\nMinimizes the given sequence of literals while preserving …\nShrinks this seq to its minimal size while respecting the …\nCreate a new extractor with a default configuration.\nReturns a sequence of exact literals from the given byte …\nThe index to allocate to the next literal added to this …\nOptimizes this seq while treating its literals as prefixes …\nOptimizes this seq while treating its literals as suffixes …\nPush a literal to the end of this sequence.\nReturns the “rank” of the given byte.\nReverse the bytes in this literal.\nReverses all of the literals in this sequence.\nReturns the root state ID, and if it doesn’t exist, …\nReturns a sequence containing a single literal.\nSorts this sequence of literals lexicographically.\nThe states in this trie. The index of a state in this …\nSparse representation of the transitions out of this …\nUnion the two sequences if the result would be within …\nUnions the <code>other</code> sequence into this one.\nUnions the <code>other</code> sequence into this one by splice the <code>other</code>\nA printer for a regular expression’s high-level …\nA builder for constructing a printer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new printer.\nPrint the given <code>Ast</code> to the given writer. The writer must …\nThis is pushed whenever an alternation is observed. After …\nThis is pushed immediately before each sub-expression in an\nA byte-oriented character class. This frame is mutated as …\nA Unicode character class. This frame is mutated as we …\nThis is pushed whenever a concatenation is observed. After …\nContains the error value\nAn arbitrary HIR expression. These get pushed whenever we …\nA translator’s representation of a regular expression’…\nThis is pushed on to the stack upon first seeing any kind …\nAn HirFrame is a single stack frame, represented …\nA literal that is being constructed, character by …\nContains the success value\nThis is pushed whenever a repetition is observed. After …\nA translator maps abstract syntax to a high level …\nA builder for constructing an AST-&gt;HIR translator.\nThe internal implementation of a translator.\nConvert an Ast literal to its scalar representation.\nBuild a translator using the current configuration.\nEnable or disable the case insensitive flag (<code>i</code>) by default.\nReturn a scalar byte value suitable for use as a literal …\nConverts the given Unicode specific error to an HIR …\nEnable or disable the CRLF mode flag (<code>R</code>) by default.\nEnable or disable the “dot matches any character” flag …\nCreate a new error with the given span and error type.\nReturn a copy of the active flags.\nThe current flag settings.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSets the line terminator for use with <code>(?u-s:.)</code> and <code>(?-us:.)</code>…\nThe line terminator to use for <code>.</code>.\nEnable or disable the multi-line matching flag (<code>m</code>) by …\nCreate a new translator builder with a default c …\nCreate a new translator using the default configuration.\nBuild a new internal translator.\nPop the top of the call stack. If the call stack is empty, …\nPop an HIR expression from the top of the stack for an …\nPop an HIR expression from the top of the stack for a …\nPush the given frame on to the call stack.\nPush the given literal byte on to the call stack.\nPush the given literal char on to the call stack.\nSet the flags of this translator from the flags set in the …\nOur call stack, but on the heap.\nEnable or disable the “swap greed” flag (<code>U</code>) by default.\nReturn a reference to the underlying translator.\nTranslate the given abstract syntax tree (AST) into a high …\nEnable or disable the Unicode flag (<code>u</code>) by default.\nAssert that the current stack frame is an alternation pipe …\nAssert that the current stack frame is a byte class …\nAssert that the current stack frame is a Unicode class …\nAssert that the current stack frame is an Hir expression …\nAssert that the current stack frame is a group indicator …\nAssert that the current stack frame is a repetition …\nWhen disabled, translation will permit the construction of …\nWhether we’re allowed to produce HIR that can match …\nThe old active flags when this group was opened.\nThe stack frame used while visiting every child node of an …\nA stack frame allocated just before descending into a …\nThe stack frame used while visiting every child node of a …\nAn error that visiting an HIR might return.\nRepresents a single stack frame while performing …\nHeapVisitor visits every item in an <code>Hir</code> recursively using …\nThe result of visiting an HIR.\nA stack frame allocated just before descending into a …\nA trait for visiting the high-level IR (HIR) in depth …\nPerform the next inductive step on this frame and return …\nAll implementors of <code>Visitor</code> must provide a <code>finish</code> method, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nBuild a stack frame for the given HIR if one is needed …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPops the given frame. If the frame has an additional …\nA stack of <code>Hir</code> nodes. This is roughly analogous to the …\nThis method is called before beginning traversal of the …\nThis method is called before beginning traversal of the …\nExecutes an implementation of <code>Visitor</code> in constant stack …\nThis method is called between child nodes of an …\nThis method is called between child nodes of an …\nThis method is called between child nodes of a …\nThis method is called between child nodes of a …\nThis method is called on an <code>Hir</code> after descending all of …\nThis method is called on an <code>Hir</code> after descending all of …\nThis method is called on an <code>Hir</code> before descending into …\nThis method is called on an <code>Hir</code> before descending into …\nThe child node we are currently visiting.\nThe child node we are currently visiting.\nThe remaining child nodes to visit (which may be empty).\nThe remaining child nodes to visit (which may be empty).\nA convenience parser for regular expressions.\nA builder for a regular expression parser.\nBuild a parser from this configuration with the given …\nEnable or disable the case insensitive flag by default.\nEnable or disable the CRLF mode flag by default.\nEnable or disable the “dot matches any character” flag …\nReturns the argument unchanged.\nReturns the argument unchanged.\nEnable verbose mode in the regular expression.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSets the line terminator for use with <code>(?u-s:.)</code> and <code>(?-us:.)</code>…\nEnable or disable the multi-line matching flag by default.\nSet the nesting limit for this parser.\nCreate a new parser builder with a default configuration.\nCreate a new parser with a default configuration.\nWhether to support octal syntax or not.\nA convenience routine for parsing a regex using default …\nParse the regular expression into a high level intermediate\nEnable or disable the “swap greed” flag by default.\nEnable or disable the Unicode flag (<code>u</code>) by default.\nWhen disabled, translation will permit the construction of …\nReturn a class corresponding to a Unicode binary property.\nThe canonical binary property name.\nReturn a class corresponding to all codepoints whose …\nAn arbitrary association between property and value, both …\nLike ClassQuery, but its parameters have been …\nAn error that occurs when Unicode-aware simple case …\nA query for finding a character class defined by Unicode. …\nAn error that occurs when dealing with Unicode.\nThe canonical general category name.\nReturn a class corresponding to a Unicode binary property, …\nA mapping of property values for a specific property.\nAn inclusive range of codepoints from a generated file …\nThe canonical script name.\nA state oriented traverser of the simple case folding …\nAn error that occurs when the Unicode-aware <code>\\w</code> class is …\nReturns an iterator over Unicode Age sets. Each item …\nReturns the Unicode HIR class corresponding to the given …\nFind the canonical property name for the given normalized …\nFind the canonical property value for the given normalized …\nLooks up a Unicode class given a query. If one doesn’t …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the Unicode HIR class corresponding to the given …\nReturns the Unicode HIR class corresponding to the given …\nReturns the index at which <code>c</code> occurs in the simple case …\nBuild a Unicode HIR class from a sequence of Unicode …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true only if the given codepoint is in the <code>\\w</code> …\nThe last codepoint that was used for a lookup.\nReturn the equivalence class of case folded codepoints for …\nCreate a new simple case folder, returning an error if the …\nThe index to the entry in <code>table</code> corresponding to the …\nReturns true if and only if the given range overlaps with …\nReturns a Unicode aware class for \\d.\nReturns a Unicode aware class for \\s.\nReturns a Unicode aware class for \\w.\nReturn the table of property values for the given property …\nReturns the Unicode HIR class corresponding to the given …\nReturns the Unicode HIR class corresponding to the given …\nReturns the Unicode HIR class corresponding to the given …\nLike symbolic_name_normalize_bytes, but operates on a …\nNormalize the given symbolic name in place according to …\nThe simple case fold table. It’s a sorted association …\nReturns the Unicode HIR class corresponding to the given …\nThe canonical property name.\nThe canonical property value.\nA property name.\nA property value.\nFour successive byte ranges.\nOne byte range.\nThree successive byte ranges.\nTwo successive byte ranges.\nA single inclusive range of UTF-8 bytes.\nUtf8Sequence represents a sequence of byte ranges.\nAn iterator over ranges of matching UTF-8 byte sequences.\nas_ascii returns this range as a Utf8Range if and only if …\nReturns the underlying sequence of byte ranges as a slice.\nencode writes the UTF-8 encoding of the start and end of …\nEnd of byte range (inclusive).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new UTF-8 sequence from the encoded bytes of a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nis_ascii returns true if the range is ASCII only (i.e., …\nis_valid returns true if and only if start &lt;= end.\nReturns the number of byte ranges in this sequence.\nReturns true if and only if a prefix of <code>bytes</code> matches this …\nReturns true if and only if the given byte is in this …\nCreate a new iterator over UTF-8 byte ranges for the …\nReverses the ranges in this sequence.\nsplit splits this range if it overlaps with a surrogate …\nStart of byte range (inclusive).")