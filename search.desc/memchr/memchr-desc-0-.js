searchState.loadedDescShard("memchr", 0, "This library provides heavily optimized routines for …\nAn iterator over all occurrences of a single byte in a …\nAn iterator over all occurrences of two possible bytes in …\nAn iterator over all occurrences of three possible bytes …\nA module with low-level architecture dependent routines.\nSearch for the first occurrence of a byte in a slice.\nSearch for the first occurrence of two possible bytes in a …\nReturns an iterator over all occurrences of the needles in …\nSearch for the first occurrence of three possible bytes in …\nReturns an iterator over all occurrences of the needles in …\nReturns an iterator over all occurrences of the needle in …\nThis module provides forward and reverse substring search …\nSearch for the last occurrence of a byte in a slice.\nSearch for the last occurrence of two possible bytes in a …\nReturns an iterator over all occurrences of the needles in …\nSearch for the last occurrence of three possible bytes in …\nReturns an iterator over all occurrences of the needles in …\nReturns an iterator over all occurrences of the needle in …\nContains architecture independent routines.\nThis module defines “generic” routines that can be …\nVector algorithms for the <code>x86_64</code> target.\nCompare corresponding bytes in <code>x</code> and <code>y</code> for equality.\nCompare <code>n</code> bytes at the given pointers for equality.\nReturns true if and only if <code>needle</code> is a prefix of <code>haystack</code>.\nReturns true if and only if <code>needle</code> is a suffix of <code>haystack</code>.\nProvides architecture independent implementations of <code>memchr</code>…\nProvides an architecture independent implementation of the …\nAn implementation of the Rabin-Karp substring search …\nAn implementation of the Shift-Or substring search …\nAn implementation of the Two-Way substring search algorithm…\nThe number of bytes we examine per each iteration of our …\nFinds all occurrences of a single byte in a haystack.\nAn iterator over all occurrences of a single byte in a …\nFinds all occurrences of three bytes in a haystack.\nAn iterator over all occurrences of three possible bytes …\nFinds all occurrences of two bytes in a haystack.\nAn iterator over all occurrences of two possible bytes in …\nThe bits that must be zero for a <code>*const usize</code> to be …\nThe number of bytes in a single <code>usize</code> value.\nCounts all occurrences of this byte in the given haystack.\nCounts all occurrences of this byte in the given haystack …\nReturn the first occurrence of the needle in the given …\nReturn the first occurrence of one of the needle bytes in …\nReturn the first occurrence of one of the needle bytes in …\nLike <code>find</code>, but accepts and returns raw pointers.\nLike <code>find</code>, but accepts and returns raw pointers.\nLike <code>find</code>, but accepts and returns raw pointers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn <code>true</code> if <code>x</code> contains any zero byte.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGeneric iterator implementation.\nGeneric iterator implementation.\nGeneric iterator implementation.\nReturns an iterator over all occurrences of the needle …\nReturns an iterator over all occurrences of one of the …\nReturns an iterator over all occurrences of one of the …\nCreate a new searcher that finds occurrences of the byte …\nCreate a new searcher that finds occurrences of the two …\nCreate a new searcher that finds occurrences of the three …\nReturn the last occurrence of the needle in the given …\nReturn the last occurrence of one of the needle bytes in …\nReturn the last occurrence of one of the needle bytes in …\nLike <code>rfind</code>, but accepts and returns raw pointers.\nLike <code>rfind</code>, but accepts and returns raw pointers.\nLike <code>rfind</code>, but accepts and returns raw pointers.\nThe underlying memchr searcher.\nThe underlying memchr searcher.\nThe underlying memchr searcher.\nRepeat the given byte into a word size number. That is, …\nThe default byte frequency heuristic that is good for most …\nAn architecture independent “packed pair” finder.\nThis trait allows the user to customize the heuristic used …\nA pair of byte offsets into a needle to use as a predicate.\nRun this finder on the given haystack as a prefilter.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the first offset of the pair.\nReturns the second offset of the pair.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new prefilter that reports possible locations …\nCreate a new pair of offsets from the given needle.\nReturns the pair of offsets (into the needle) used to …\nReturn the heuristic frequency rank of the given byte. A …\nCreate a new pair using the offsets given for the needle …\nCreate a new prefilter using the pair given.\nCreate a new pair of offsets from the given needle and …\nA forward substring searcher using the Rabin-Karp …\nA reverse substring searcher using the Rabin-Karp …\nA Rabin-Karp hash. This might represent the hash of a …\nAdd a byte to this hash.\nRemove a byte from this hash. The given needle hash should …\nReturn the first occurrence of the <code>needle</code> in the <code>haystack</code> …\nLike <code>find</code>, but accepts and returns raw pointers.\nCreate a new hash from the bytes given for use in forward …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe actual hash.\nThe factor needed to multiply a byte by in order to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true when <code>x[i] == y[i]</code> for all <code>0 &lt;= i &lt; n</code>.\nWhether RK is believed to be very fast for the given …\nCreate a new Rabin-Karp forward searcher for the given …\nCreate a new Rabin-Karp reverse searcher for the given …\nCreate a new hash that represents the empty string.\nCreate a new hash from the bytes given for use in reverse …\nReturn the last occurrence of the <code>needle</code> in the <code>haystack</code> …\nLike <code>rfind</code>, but accepts and returns raw pointers.\nAdd ‘new’ and remove ‘old’ from this hash. The …\nA forward substring searcher using the Shift-Or algorithm.\nThe type of our mask.\nReturn the first occurrence of the needle given to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new Shift-Or forward searcher for the given <code>needle</code>…\nThis occurs when the given candidate byte indicates that …\nA bitset used to track whether a particular byte exists in …\nA forward substring searcher that uses the Two-Way …\nA reverse substring searcher that uses the Two-Way …\nExtract the largest lexicographic suffix from a string.\nExtract the smallest lexicographic suffix from a string.\nThis occurs when no decision to accept or skip the …\nA representation of the amount we’re allowed to shift by …\nThis occurs when the given candidate byte excludes the …\nA suffix extracted from a needle along with its period.\nThe kind of suffix to extract.\nThe result of comparing corresponding bytes between two …\nAn implementation of the TwoWay substring search algorithm.\nA small bitset used as a quick prefilter (in addition to …\nReturns true if and only if the given candidate byte …\nReturn true if and only if the given byte might be in this …\nA critical position in needle. Specifically, this position …\nReturns the first occurrence of <code>needle</code> in the given …\nThis is like <code>Finder::find</code>, but it accepts a prefilter for …\nCompute the shift for a given needle in the forward …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a searcher that finds occurrences of the given …\nCreate a searcher that finds occurrences of the given …\nCreate a new set from the given needle.\nThe period of this suffix.\nThe starting position of this suffix.\nCompute the shift for a given needle in the reverse …\nReturns the last occurrence of <code>needle</code> in the given <code>haystack</code>…\nThe amount we shift by in the Two-Way search algorithm. …\nGeneric crate-internal routines for the <code>memchr</code> family of …\nGeneric crate-internal routines for the “packed pair” …\nAn iterator over all occurrences of a set of bytes in a …\nThe number of bytes we examine per each iteration of our …\nThe number of bytes we examine per each iteration of our …\nThe number of bytes we examine per each iteration of our …\nFinds all occurrences of a single byte in a haystack.\nFinds all occurrences of two bytes in a haystack.\nFinds all occurrences of two bytes in a haystack.\nReturns the number of remaining elements in this iterator.\nPerforms a forward byte-at-a-time loop until <code>ptr &gt;= end_ptr</code>…\nReturn a count of all matching bytes in the given haystack.\nThe current ending point into the haystack. That is, where …\nReturn a pointer to the first occurrence of the needle in …\nReturn a pointer to the first occurrence of one of the …\nReturn a pointer to the first occurrence of one of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerforms a forward byte-at-a-time loop until either …\nA marker for tracking the lifetime of the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the needle given to <code>One::new</code>.\nReturns the first needle given to <code>Two::new</code>.\nReturns the first needle given to <code>Three::new</code>.\nReturns the second needle given to <code>Two::new</code>.\nReturns the second needle given to <code>Three::new</code>.\nReturns the third needle given to <code>Three::new</code>.\nCreate a new searcher that finds occurrences of the byte …\nCreate a new searcher that finds occurrences of the byte …\nCreate a new searcher that finds occurrences of the byte …\nCreate a new generic memchr iterator.\nReturns the next occurrence in the forward direction.\nReturns the next occurrence in reverse.\nThe original starting point into the haystack. We use this …\nPerforms a reverse byte-at-a-time loop until either …\nReturn a pointer to the last occurrence of the needle in …\nReturn a pointer to the last occurrence of the needle in …\nReturn a pointer to the last occurrence of the needle in …\nSearch <code>V::BYTES</code> starting at <code>cur</code> via an unaligned load.\nSearch <code>V::BYTES</code> starting at <code>cur</code> via an unaligned load.\nSearch <code>V::BYTES</code> starting at <code>cur</code> via an unaligned load.\nSearch a slice using a function that operates on raw …\nProvides an implementation of <code>Iterator::size_hint</code>.\nThe current starting point into the haystack. That is, …\nA generic architecture dependent “packed pair” finder.\nSearches the given haystack for the given needle. The …\nSearch for an occurrence of our byte pair from the needle …\nSearches the given haystack for offsets that represent …\nSearch for an occurrence of our byte pair from the needle …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAccepts a chunk-relative offset and returns a haystack …\nReturns the minimum haystack length that this <code>Finder</code> can …\nCreate a new pair searcher. The searcher returned can …\nReturns the pair of offsets (into the needle) used to …\nAlgorithms for the <code>x86_64</code> target using 256-bit vectors via …\nWrapper routines for <code>memchr</code> and friends.\nAlgorithms for the <code>x86_64</code> target using 128-bit vectors via …\nThis module defines 256-bit vector implementations of …\nA 256-bit vector implementation of the “packed pair” …\nFinds all occurrences of a single byte in a haystack.\nAn iterator over all occurrences of a single byte in a …\nFinds all occurrences of three bytes in a haystack.\nAn iterator over all occurrences of three possible bytes …\nFinds all occurrences of two bytes in a haystack.\nAn iterator over all occurrences of two possible bytes in …\nUsed for haystacks bigger than 32 bytes.\nUsed for haystacks bigger than 32 bytes.\nUsed for haystacks bigger than 32 bytes.\nCounts all occurrences of this byte in the given haystack.\nCounts all occurrences of this byte in the given haystack …\nExecute a count using AVX2 vectors and routines.\nExecute a count using SSE2 vectors and routines.\nReturn the first occurrence of one of the needle bytes in …\nReturn the first occurrence of one of the needle bytes in …\nReturn the first occurrence of one of the needle bytes in …\nLike <code>find</code>, but accepts and returns raw pointers.\nLike <code>find</code>, but accepts and returns raw pointers.\nLike <code>find</code>, but accepts and returns raw pointers.\nExecute a search using AVX2 vectors and routines.\nExecute a search using AVX2 vectors and routines.\nExecute a search using AVX2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true when this implementation is available in the …\nReturns true when this implementation is available in the …\nReturns true when this implementation is available in the …\nReturns an iterator over all occurrences of the needle …\nReturns an iterator over all occurrences of the needle …\nReturns an iterator over all occurrences of the needle …\nCreate a new searcher that finds occurrences of the needle …\nCreate a new searcher that finds occurrences of the needle …\nCreate a new searcher that finds occurrences of the needle …\nCreate a new finder specific to AVX2 vectors and routines …\nCreate a new finder specific to AVX2 vectors and routines …\nCreate a new finder specific to AVX2 vectors and routines …\nReturn the last occurrence of one of the needle bytes in …\nReturn the last occurrence of one of the needle bytes in …\nReturn the last occurrence of one of the needle bytes in …\nLike <code>rfind</code>, but accepts and returns raw pointers.\nLike <code>rfind</code>, but accepts and returns raw pointers.\nLike <code>rfind</code>, but accepts and returns raw pointers.\nExecute a search using AVX2 vectors and routines.\nExecute a search using AVX2 vectors and routines.\nExecute a search using AVX2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nUsed for haystacks less than 32 bytes.\nUsed for haystacks less than 32 bytes.\nUsed for haystacks less than 32 bytes.\nA “packed pair” finder that uses 256-bit vector …\nExecute a search using AVX2 vectors and routines.\nExecute a search using AVX2 vectors and routines.\nRun this finder on the given haystack as a prefilter.\nExecute a prefilter search using AVX2 vectors and routines.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns true when this implementation is available in the …\nReturns the minimum haystack length that this <code>Finder</code> can …\nCreate a new pair searcher. The searcher returned can …\nReturns the pair of offsets (into the needle) used to …\nCreate a new “packed pair” finder using the pair of …\nCreate a new <code>Finder</code> specific to SSE2 vectors and routines.\nCount all matching bytes, but using raw pointers to …\nmemchr2, but using raw pointers to represent the haystack.\nmemchr3, but using raw pointers to represent the haystack.\nmemchr, but using raw pointers to represent the haystack.\nmemrchr2, but using raw pointers to represent the haystack.\nmemrchr3, but using raw pointers to represent the haystack.\nmemrchr, but using raw pointers to represent the haystack.\nProvides a way to run a memchr-like function while …\nThis module defines 128-bit vector implementations of …\nA 128-bit vector implementation of the “packed pair” …\nFinds all occurrences of a single byte in a haystack.\nAn iterator over all occurrences of a single byte in a …\nFinds all occurrences of three bytes in a haystack.\nAn iterator over all occurrences of three possible bytes …\nFinds all occurrences of two bytes in a haystack.\nAn iterator over all occurrences of two possible bytes in …\nCounts all occurrences of this byte in the given haystack.\nCounts all occurrences of this byte in the given haystack …\nExecute a count using SSE2 vectors and routines.\nReturn the first occurrence of one of the needle bytes in …\nReturn the first occurrence of one of the needle bytes in …\nReturn the first occurrence of one of the needle bytes in …\nLike <code>find</code>, but accepts and returns raw pointers.\nLike <code>find</code>, but accepts and returns raw pointers.\nLike <code>find</code>, but accepts and returns raw pointers.\nExecute a search using SSE2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true when this implementation is available in the …\nReturns true when this implementation is available in the …\nReturns true when this implementation is available in the …\nReturns an iterator over all occurrences of the needle …\nReturns an iterator over all occurrences of the needle …\nReturns an iterator over all occurrences of the needle …\nCreate a new searcher that finds occurrences of the needle …\nCreate a new searcher that finds occurrences of the needle …\nCreate a new searcher that finds occurrences of the needle …\nCreate a new finder specific to SSE2 vectors and routines …\nCreate a new finder specific to SSE2 vectors and routines …\nCreate a new finder specific to SSE2 vectors and routines …\nReturn the last occurrence of one of the needle bytes in …\nReturn the last occurrence of one of the needle bytes in …\nReturn the last occurrence of one of the needle bytes in …\nLike <code>rfind</code>, but accepts and returns raw pointers.\nLike <code>rfind</code>, but accepts and returns raw pointers.\nLike <code>rfind</code>, but accepts and returns raw pointers.\nExecute a search using SSE2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nA “packed pair” finder that uses 128-bit vector …\nExecute a search using SSE2 vectors and routines.\nExecute a search using SSE2 vectors and routines.\nRun this finder on the given haystack as a prefilter.\nExecute a prefilter search using SSE2 vectors and routines.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns true when this implementation is available in the …\nReturns the minimum haystack length that this <code>Finder</code> can …\nCreate a new pair searcher. The searcher returned can …\nReturns the pair of offsets (into the needle) used to …\nCreate a new “packed pair” finder using the pair of …\nCreate a new <code>Finder</code> specific to SSE2 vectors and routines.\nA specialized copy-on-write byte string.\nReturn a borrowed byte string, regardless of whether this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn an owned version of this copy-on-write byte string.\nCreate a new borrowed CowBytes.\nCreate a new owned CowBytes.\nA trait for adding some helper routines to pointers.\nCasts this pointer to <code>usize</code>.\nReturns the distance, in units of <code>T</code>, between <code>self</code> and …\nAn iterator over all occurrences of a single byte in a …\nAn iterator over all occurrences of two possible bytes in …\nAn iterator over all occurrences of three possible bytes …\nCount all matching bytes, but using raw pointers to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSearch for the first occurrence of a byte in a slice.\nSearch for the first occurrence of two possible bytes in a …\nReturns an iterator over all occurrences of the needles in …\nmemchr2, but using raw pointers to represent the haystack.\nSearch for the first occurrence of three possible bytes in …\nReturns an iterator over all occurrences of the needles in …\nmemchr3, but using raw pointers to represent the haystack.\nReturns an iterator over all occurrences of the needle in …\nmemchr, but using raw pointers to represent the haystack.\nSearch for the last occurrence of a byte in a slice.\nSearch for the last occurrence of two possible bytes in a …\nReturns an iterator over all occurrences of the needles in …\nmemrchr2, but using raw pointers to represent the haystack.\nSearch for the last occurrence of three possible bytes in …\nReturns an iterator over all occurrences of the needles in …\nmemrchr3, but using raw pointers to represent the haystack.\nReturns an iterator over all occurrences of the needle in …\nmemrchr, but using raw pointers to represent the haystack.\nReturns an iterator over all occurrences of the needle …\nReturns an iterator over all occurrences of the needle …\nReturns an iterator over all occurrences of the needle …\nAutomatically detect whether a heuristic prefilter should …\nAn iterator over non-overlapping substring matches.\nAn iterator over non-overlapping substring matches in …\nA single substring searcher fixed to a particular needle.\nA builder for constructing non-default forward or reverse …\nA single substring reverse searcher fixed to a particular …\nNever used a prefilter in substring search.\nPrefilter controls whether heuristics are used to …\nConvert this finder into its borrowed variant.\nConvert this finder into its borrowed variant.\nBuild a forward finder using the given needle from the …\nBuild a forward finder using the given needle and a custom …\nBuild a reverse finder using the given needle from the …\nReturns the index of the first occurrence of the given …\nReturns the index of the first occurrence of this needle …\nReturns an iterator over all non-overlapping occurrences …\nReturns an iterator over all occurrences of a substring in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this iterator into its owned variant, such that it …\nConvert this iterator into its owned variant, such that it …\nConvert this finder into its owned variant, such that it …\nConvert this finder into its owned variant, such that it …\nReturns the needle that this finder searches for.\nReturns the needle that this finder searches for.\nCreate a new finder for the given needle.\nCreate a new reverse finder for the given needle.\nCreate a new finder builder with default settings.\nWhen searching with an empty needle, this gets set to <code>None</code> …\nConfigure the prefilter setting for the finder.\nReturns the index of the last occurrence of the given …\nReturns the index of the last occurrence of this needle in …\nReturns a reverse iterator over all non-overlapping …\nReturns a reverse iterator over all occurrences of a …\nAutomatically detect whether a heuristic prefilter should …\nThe minimum number of skip attempts to try before …\nThe minimum amount of bytes that skipping must average.\nNever used a prefilter in substring search.\nA combination of prefilter effectiveness state and the …\nThe implementation of a prefilter.\nPrefilter controls whether heuristics are used to …\nA union indicating one of several possible prefilters that …\nThe type of a prefilter function.\nPrefilterState tracks state associated with the …\nA “meta” substring searcher.\nA union indicating one of several possible substring …\nThe type of a substring search function.\nA reverse substring searcher.\nThe kind of the reverse searcher.\nA two-way substring searcher with a prefilter.\nReturn a prefilter using a x86_64 AVX2 vector algorithm.\nReturns true if the needle has the right characteristics …\nReturn a “fallback” prefilter, but only if it is …\nSearches the given haystack for the given needle. The …\nReturn a <em>candidate</em> position for a match.\nCall this prefilter on the given haystack with the given …\nA “simple” prefilter that just looks for the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if and only if this state indicates that a …\nReturn true if and only if this prefilter should be used.\nReturns true if the prefilter this state represents should …\nReturns true when this prefilter is set to the <code>None</code> …\nCreates a new “meta” substring searcher that attempts …\nCreates a new searcher for finding occurrences of the …\nCreate a fresh prefilter state.\nReads from the <code>avx2</code> field of <code>PrefilterKind</code> to execute the …\nReads from the <code>fallback</code> field of <code>PrefilterKind</code> to execute …\nReads from the <code>sse2</code> field of <code>PrefilterKind</code> to execute the …\nState that tracks the effectiveness of a prefilter.\nThe actual prefilter.\nSearches the given haystack for the last occurrence of the …\nReads from the <code>avx2</code> field of <code>SearcherKind</code> to execute the …\nReads from the <code>empty</code> field of <code>SearcherKind</code> to handle the …\nReads from the <code>one_byte</code> field of <code>SearcherKind</code> to handle …\nReads from the <code>sse2</code> field of <code>SearcherKind</code> to execute the …\nReads from the <code>two_way</code> field of <code>SearcherKind</code> to handle the …\nReads from the <code>two_way_with_prefilter</code> field of <code>SearcherKind</code>…\nThe total number of bytes that have been skipped.\nReturns the total number of times the prefilter has been …\nThe number of skips that has been executed. This is always …\nReturn a prefilter using a x86_64 SSE2 vector algorithm.\nCreates a new searcher that always uses the Two-Way …\nUpdate this state with the number of bytes skipped on the …\nThe bits that must be zero in order for a <code>*const u8</code> …\nThe number of bytes in the vector. That is, this is the …\nThe type of the value returned by <code>Vector::movemask</code>.\nA trait that abstracts over a vector-to-scalar operation …\nThis is a “sensible” movemask implementation where …\nA trait for describing vector operations used by …\nReturn a mask that is all zeros except for the least …\n_mm_and_si128 or _mm256_and_si256\nDoes a bitwise <code>and</code> operation between <code>self</code> and <code>other</code>.\nReturns a mask that is equivalent to <code>self</code> but with the …\n_mm_cmpeq_epi8 or _mm256_cmpeq_epi8\nReturns the number of bits set to 1 in this mask.\nReturns the offset of the first non-zero lane this mask …\nReturns the argument unchanged.\nGet the mask in a form suitable for computing offsets.\nReturns true if and only if this mask has a a non-zero bit …\nCalls <code>U::from(self)</code>.\nReturns the offset of the last non-zero lane this mask …\nRead a vector-size number of bytes from the given pointer. …\nRead a vector-size number of bytes from the given pointer. …\n_mm_movemask_epi8 or _mm256_movemask_epi8\nReturns true if and only if <code>Self::movemask</code> would return a …\n_mm_or or _mm256_or_si256\nDoes a bitwise <code>or</code> operation between <code>self</code> and <code>other</code>.\nCreate a vector with 8-bit lanes with the given byte …")