searchState.loadedDescShard("base64", 0, "Correct, fast, and configurable base64 decoding and …\nErrors that can occur while decoding.\nA DecodeError occurred\nErrors that can occur while decoding into a slice.\nErrors that can occur while encoding into a slice.\nAn invalid byte was found in the input. The offset and …\nThe last non-padding input symbol’s encoded 6 bits have …\nThe length of the input is invalid. A typical cause of …\nThe nature of the padding was not as configured: absent or …\nThe provided slice is too small.\nThe provided slice <em>may</em> be too small.\nProvides Alphabet and constants for alphabets commonly …\nDecode base64 using the <code>STANDARD</code> engine.\nDecode from string reference as octets using the specified …\nDecode the input into the provided output slice.\nDecode from string reference as octets.\nReturns a conservative estimate of the decoded size of …\nEnables base64’d output anywhere you might use a <code>Display</code> …\nEncode arbitrary octets as base64 using the <code>STANDARD</code> engine…\nEncode arbitrary octets as base64 using the provided <code>Engine</code>…\nEncode arbitrary octets as base64 into a supplied slice.\nEncode arbitrary octets as base64 into a supplied <code>String</code>.\nCalculate the base64 encoded length for a given input …\nProvides the Engine abstraction and out of the box …\nPreconfigured engines for common use cases.\nImplementations of <code>io::Read</code> to transparently decode base64.\nImplementations of <code>io::Write</code> to transparently handle …\nAn alphabet defines the 64 ASCII characters (symbols) used …\nThe bcrypt alphabet.\nThe alphabet used in BinHex 4.0 files.\nThe <code>crypt(3)</code> alphabet (with <code>.</code> and <code>/</code> as the <em>first</em> two …\nAll bytes must be unique\nThe alphabet used in IMAP-modified UTF-7 (with <code>+</code> and <code>,</code>).\nAlphabets must be 64 ASCII bytes\nPossible errors when constructing an Alphabet from a <code>str</code>.\n<code>=</code> cannot be used\nThe standard alphabet (with <code>+</code> and <code>/</code>) specified in RFC 4648.\nThe URL-safe alphabet (with <code>-</code> and <code>_</code>) specified in RFC 4648.\nAll bytes must be printable (in the range <code>[32, 126]</code>).\nCreate a <code>&amp;str</code> from the symbols in the <code>Alphabet</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerforms no checks so that it can be const. Used only for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an <code>Alphabet</code> from a string of 64 unique printable …\nA base64 encoder that emits encoded bytes in chunks …\nThe output mechanism for ChunkedEncoder’s encoded bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHandle a chunk of encoded base64 data (as UTF-8 bytes)\nErrors that can occur while decoding.\nA DecodeError occurred\nErrors that can occur while decoding into a slice.\nAn invalid byte was found in the input. The offset and …\nThe last non-padding input symbol’s encoded 6 bits have …\nThe length of the input is invalid. A typical cause of …\nThe nature of the padding was not as configured: absent or …\nThe provided slice <em>may</em> be too small.\nDecode base64 using the <code>STANDARD</code> engine.\nDecode from string reference as octets using the specified …\nDecode the input into the provided output slice.\nDecode from string reference as octets.\nReturns a conservative estimate of the decoded size of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA convenience wrapper for base64’ing bytes into a format …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>Base64Display</code> with the provided engine.\nErrors that can occur while encoding into a slice.\nThe provided slice is too small.\nWrite padding characters. <code>unpadded_output_len</code> is the size …\nEncode arbitrary octets as base64 using the <code>STANDARD</code> engine…\nEncode arbitrary octets as base64 using the provided <code>Engine</code>…\nEncode arbitrary octets as base64 into a supplied slice.\nEncode arbitrary octets as base64 into a supplied <code>String</code>.\nB64-encode and pad (if configured).\nCalculate the base64 encoded length for a given input …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe minimal level of configuration that engines must …\nThe config type used by this engine\nThe decode estimate used by an engine implementation. …\nThe decode estimate used by this engine\nMetadata about the result of a decode operation\nControls how pad bytes are handled when decoding.\nAn <code>Engine</code> provides low-level encoding and decoding …\nCanonical padding is allowed, but any fewer padding bytes …\nPadding must be canonical (0, 1, or 2 <code>=</code> as needed to …\nPadding must be absent – for when you want predictable …\nReturns the config for this engine.\nDecode the input into a new <code>Vec</code>.\nDecode the input into the provided output slice.\nDecode the input into the provided output slice.\nDecode the <code>input</code> into the supplied <code>buffer</code>.\nNumber of decoded bytes output\nReturns a conservative (err on the side of too big) …\nEncode arbitrary octets as base64 using the provided <code>Engine</code>…\nReturns <code>true</code> if padding should be added after the encoded …\nEncode arbitrary octets as base64 into a supplied slice. …\nEncode arbitrary octets as base64 into a supplied <code>String</code>. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nProvides the GeneralPurpose engine and associated config …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOffset of the first padding byte in the input, if any\nA general-purpose base64 engine.\nContains configuration parameters for base64 encoding and …\nDon’t add padding when encoding, and require no padding …\nInclude padding bytes when encoding, and require that they …\nA GeneralPurpose engine using the alphabet::STANDARD …\nA GeneralPurpose engine using the alphabet::STANDARD …\nA GeneralPurpose engine using the alphabet::URL_SAFE …\nA GeneralPurpose engine using the alphabet::URL_SAFE …\nReturns a table mapping base64 bytes as the lookup index …\nDelegates to GeneralPurposeConfig::new.\nReturns a table mapping a 6-bit index to the ASCII byte …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>GeneralPurpose</code> engine from an Alphabet.\nCreate a new config with <code>padding</code> = <code>true</code>, …\nCreate a new config based on <code>self</code> with an updated …\nCreate a new config based on <code>self</code> with an updated …\nCreate a new config based on <code>self</code> with an updated <code>padding</code> …\nDecode 8 bytes of input into 6 bytes of output. 8 bytes of …\nDecode an 8-byte chunk, but only write the 6 bytes …\nHelper to avoid duplicating num_chunks calculation, which …\nDecode the last 1-8 bytes, checking for trailing set bits …\nA <code>Read</code> implementation that decodes base64 data read from …\nWhere b64 data is read from\nA <code>Read</code> implementation that decodes base64 data read from …\nDecode the requested number of bytes from the b64 buffer …\nWrite as much as possible of the decoded buffer into the …\nReturns the argument unchanged.\nWhere b64 data is read from\nCalls <code>U::from(self)</code>.\nUnwraps this <code>DecoderReader</code>, returning the base reader …\nCreate a new decoder that will read from the provided …\nDecode input from the wrapped reader.\nRead into the remaining space in the buffer after the …\nA <code>Write</code> implementation that base64-encodes data using the …\nA <code>Write</code> implementation that base64 encodes data before …\nAn abstraction around consuming <code>str</code>s produced by base64 …\nConsume the base64 encoded data in <code>buf</code>\nWhere encoded data is written to. It’s an Option as it’…\nHolds a partial chunk, if any, after the last <code>write()</code>, so …\nHow much of <code>extra</code> is occupied, in …\nBuffer to encode into. May hold leftover encoded bytes …\nHow much of <code>output</code> is occupied with encoded data that …\npanic safety: don’t write again in destructor if writer …\nA <code>Write</code> implementation that base64 encodes data before …\nThe most bytes whose encoding will fit in <code>BUF_SIZE</code>\nWhere encoded data is written to. It’s an Option as it’…\nHolds a partial chunk, if any, after the last <code>write()</code>, so …\nHow much of <code>extra</code> is occupied, in …\nEncode all remaining buffered data and write it, including …\nBecause this is usually treated as OK to call multiple …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUnwraps this <code>EncoderWriter</code>, returning the base writer it …\nCreate a new encoder that will write to the provided …\nBuffer to encode into. May hold leftover encoded bytes …\nHow much of <code>output</code> is occupied with encoded data that …\npanic safety: don’t write again in destructor if writer …\nEncode input and then write to the delegate writer.\nWrite all buffered encoded output. If this returns <code>Ok</code>, …\nWrite any remaining buffered data to the delegate writer.\nWrite as much of the encoded output to the delegate writer …\nA <code>Write</code> implementation that base64-encodes data using the …\nAn abstraction around consuming <code>str</code>s produced by base64 …\nA <code>Write</code> that only can handle bytes that are valid …\nConsume the base64 encoded data in <code>buf</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a EncoderStringWriter that will append to the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEncode all remaining buffered data, including any trailing …\nCreate a EncoderStringWriter that will encode into a new …")