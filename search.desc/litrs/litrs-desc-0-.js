searchState.loadedDescShard("litrs", 0, "Parsing and inspecting Rust literal tokens.\nA bool literal: <code>true</code> or <code>false</code>. Also see the reference.\nA shared or owned string buffer. Implemented for <code>String</code> â€¦\nThis is <code>Cow&lt;&#39;static, [u8]&gt;</code> for <code>String</code>, and <code>Cow&lt;&#39;a, [u8]&gt;</code> â€¦\nA (single) byte literal, e.g. <code>b&#39;k&#39;</code> or <code>b&#39;!&#39;</code>.\nA byte string or raw byte string literal, e.g. <code>b&quot;hello&quot;</code> or â€¦\nA character literal, e.g. <code>&#39;g&#39;</code> or <code>&#39;ðŸ¦Š&#39;</code>.\nThis is <code>Cow&lt;&#39;static, str&gt;</code> for <code>String</code>, and <code>Cow&lt;&#39;a, str&gt;</code> for â€¦\nA floating point literal, e.g. <code>3.14</code>, <code>8.</code>, <code>135e12</code>, or â€¦\nAll possible float type suffixes.\nInteger literal types. <em>Implementation detail</em>.\nThe bases in which an integer can be specified.\nAn integer literal, e.g. <code>27</code>, <code>0x7F</code>, <code>0b101010u8</code> or â€¦\nAll possible integer type suffixes.\nAn error signaling that a different kind of token was â€¦\nA literal. This is the main type of this library.\nErrors during parsing.\nA string or raw string literal, e.g. <code>&quot;foo&quot;</code>, <code>&quot;GrÃ¼ÃŸe&quot;</code> or â€¦\nParsed <code>raw[..start_main_part]</code>.\nThe first index after the fractional part.\nThe first index not part of the integer part anymore. â€¦\nFirst index not part of the main number part.\nThe first index after the whole number part (everything â€¦\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMakes a copy of the underlying buffer and returns the â€¦\nThe number of hash signs in case of a raw string literal, â€¦\nThe number of hash signs in case of a raw string literal, â€¦\nParses the given input as a Rust literal.\nThe raw input.\nThe whole raw input. The <code>usize</code> fields in this struct â€¦\nThe raw literal. Grammar: <code>&lt;prefix?&gt;&lt;main part&gt;&lt;suffix?&gt;</code>.\nThe raw input.\nFirst index of the main number part (after the base â€¦\nStart index of the suffix or <code>raw.len()</code> if there is no â€¦\nStart index of the suffix or <code>raw.len()</code> if there is no â€¦\nStart index of the suffix or <code>raw.len()</code> if there is no â€¦\nStart index of the suffix or <code>raw.len()</code> if there is no â€¦\nReturns the suffix of this literal or <code>&quot;&quot;</code> if it doesnâ€™t â€¦\nThe string value (with all escaped unescaped), or <code>None</code> if â€¦\nThe string value (with all escapes unescaped), or <code>None</code> if â€¦\nA bool literal: <code>true</code> or <code>false</code>. Also see the reference.\nReturns the literal as string.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParses the input as a bool literal. Returns an error if â€¦\nReturns the actual Boolean value of this literal.\nA (single) byte literal, e.g. <code>b&#39;k&#39;</code> or <code>b&#39;!&#39;</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the raw input that was passed to <code>parse</code>, â€¦\nParses the input as a byte literal. Returns an error if â€¦\nPrecondition: must start with <code>b&#39;</code>.\nReturns the raw input that was passed to <code>parse</code>.\nStart index of the suffix or <code>raw.len()</code> if there is no â€¦\nThe optional suffix. Returns <code>&quot;&quot;</code> if the suffix is â€¦\nMakes a copy of the underlying buffer and returns the â€¦\nReturns the byte value that this literal represents.\nA byte string or raw byte string literal, e.g. <code>b&quot;hello&quot;</code> or â€¦\nReturns the argument unchanged.\nThe range within <code>self.raw</code> that excludes the quotes and â€¦\nCalls <code>U::from(self)</code>.\nMakes a copy of the underlying buffer and returns the â€¦\nReturns the raw input that was passed to <code>parse</code>, â€¦\nLike <code>value</code> but returns a potentially owned version of the â€¦\nReturns whether this literal is a raw string literal â€¦\nThe number of hash signs in case of a raw string literal, â€¦\nParses the input as a (raw) byte string literal. Returns â€¦\nPrecondition: input has to start with either <code>b&quot;</code> or <code>br</code>.\nThe raw input.\nReturns the raw input that was passed to <code>parse</code>.\nStart index of the suffix or <code>raw.len()</code> if there is no â€¦\nThe optional suffix. Returns <code>&quot;&quot;</code> if the suffix is â€¦\nReturns the string value this literal represents (where â€¦\nThe string value (with all escaped unescaped), or <code>None</code> if â€¦\nA character literal, e.g. <code>&#39;g&#39;</code> or <code>&#39;ðŸ¦Š&#39;</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the raw input that was passed to <code>parse</code>, â€¦\nParses the input as a character literal. Returns an error â€¦\nPrecondition: first character in input must be <code>&#39;</code>.\nReturns the raw input that was passed to <code>parse</code>.\nStart index of the suffix or <code>raw.len()</code> if there is no â€¦\nThe optional suffix. Returns <code>&quot;&quot;</code> if the suffix is â€¦\nMakes a copy of the underlying buffer and returns the â€¦\nReturns the character value that this literal represents.\nInput does not start with decimal digit when trying to â€¦\nWhen parsing a character, byte, string or byte string â€¦\nThe input was an empty string\nAn empty character literal, i.e. <code>&#39;&#39;</code>.\nInteger suffixes cannot start with <code>e</code> or <code>E</code> as this â€¦\nInvalid start for a byte literal.\nA digit invalid for the specified integer base was found.\nLiteral was not recognized.\nA Unicode escape that does not start with a hex digit.\nInvalid start for a string literal.\nLiteral suffix is not a valid identifier.\nAn error signaling that a different kind of token was â€¦\nThe value from a unicode escape does not represent a valid â€¦\nAn <code>\\x</code> escape where the two digits are not valid hex digits.\nAn literal <code>\\r</code> character not followed by a <code>\\n</code> character in a\nInteger literal does not contain any valid digits.\nExponent of a float literal does not contain any digits.\nA string or character literal using the <code>\\xNN</code> escape where â€¦\nIn a <code>\\u{...}</code> escape, a non-hex digit and non-underscore â€¦\nA character literal that contains more than one character.\nErrors during parsing.\nKinds of errors.\nUnfortunately, we have to deal with both cases.\nMore than 6 digits found in unicode escape.\nA <code>&#39;</code> character was not escaped in a character or byte â€¦\nA \\n, \\t or \\r raw character in a char or byte literal.\nAn unexpected char was encountered.\nReturned by <code>Float::parse</code> if an integer literal (no â€¦\nA <code>\\u{...}</code> escape in a byte or byte string literal.\nA <code>\\u{...}</code> escape that lacks the opening brace.\nAn unknown escape code, e.g. <code>\\b</code>.\nA character literal thatâ€™s not terminated.\nA started escape sequence where the input ended before the â€¦\nUnterminated raw string literal.\nString literal without a <code>&quot;</code> at the end.\nA <code>\\u{..</code> escape that is not terminated (lacks the closing â€¦\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is a free standing function instead of an associated â€¦\nReturns a span of this error, if available. <strong>Note</strong>: the â€¦\nReturns a token stream representing <code>compile_error!(&quot;msg&quot;);</code> â€¦\nChecks whether the character is skipped after a string â€¦\nReads and checks a raw (byte) string literal, converting â€¦\nMust start with <code>\\</code>\nUnescapes a whole string or byte string.\nA floating point literal, e.g. <code>3.14</code>, <code>8.</code>, <code>135e12</code>, or â€¦\nAll possible float type suffixes.\nThe first index after the fractional part.\nThe first index not part of the integer part anymore. â€¦\nThe first index after the whole number part (everything â€¦\nOptional exponent part. Might be empty if there was no â€¦\nReturns the optional fractional part of this literal. Does â€¦\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the type corresponding to the given suffix (e.g. â€¦\nReturns the non-empty integer part of this literal.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the raw input that was passed to <code>parse</code>, â€¦\nReturns the number part (including integer part, â€¦\nParses the input as a floating point literal. Returns an â€¦\nPrecondition: first byte of string has to be in <code>b&#39;0&#39;..=b&#39;9&#39;</code>â€¦\nThe whole raw input. The <code>usize</code> fields in this struct â€¦\nReturns the raw input that was passed to <code>parse</code>.\nThe optional suffix. Returns <code>&quot;&quot;</code> if the suffix is â€¦\nReturns the suffix for this type, e.g. <code>&quot;f32&quot;</code> for <code>Self::F32</code>.\nMakes a copy of the underlying buffer and returns the â€¦\nHelper macro to call a <code>callback</code> macro four times for all â€¦\nLike <code>helper!</code> but without reference types.\nTests\nInteger literal types. <em>Implementation detail</em>.\nThe bases in which an integer can be specified.\nAn integer literal, e.g. <code>27</code>, <code>0x7F</code>, <code>0b101010u8</code> or â€¦\nAll possible integer type suffixes.\nThe base of this integer literal.\nParsed <code>raw[..start_main_part]</code>.\nFirst index not part of the main number part.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the type corresponding to the given suffix (e.g. â€¦\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the raw input that was passed to <code>parse</code>, â€¦\nParses the input as an integer literal. Returns an error â€¦\nPrecondition: first byte of string has to be in <code>b&#39;0&#39;..=b&#39;9&#39;</code>â€¦\nReturns the literal prefix that indicates this base, i.e. â€¦\nThe raw literal. Grammar: <code>&lt;prefix?&gt;&lt;main part&gt;&lt;suffix?&gt;</code>.\nReturns the raw input that was passed to <code>parse</code>.\nThe main part containing the digits and potentially <code>_</code>. Do â€¦\nFirst index of the main number part (after the base â€¦\nThe optional suffix. Returns <code>&quot;&quot;</code> if the suffix is â€¦\nReturns the suffix for this type, e.g. <code>&quot;u8&quot;</code> for <code>Self::U8</code>.\nMakes a copy of the underlying buffer and returns the â€¦\nPerforms the actual string to int conversion to obtain the â€¦\nReturns the base value, i.e. 2, 8, 10 or 16.\nMakes sure that <code>s</code> is a valid literal suffix.\nReturns the index of the first non-underscore, non-decimal â€¦\nA string or raw string literal, e.g. <code>&quot;foo&quot;</code>, <code>&quot;GrÃ¼ÃŸe&quot;</code> or â€¦\nReturns the argument unchanged.\nThe range within <code>self.raw</code> that excludes the quotes and â€¦\nCalls <code>U::from(self)</code>.\nMakes a copy of the underlying buffer and returns the â€¦\nReturns the raw input that was passed to <code>parse</code>, â€¦\nLike <code>value</code> but returns a potentially owned version of the â€¦\nReturns whether this literal is a raw string literal â€¦\nThe number of hash signs in case of a raw string literal, â€¦\nParses the input as a (raw) string literal. Returns an â€¦\nPrecondition: input has to start with either <code>&quot;</code> or <code>r</code>.\nThe raw input.\nReturns the raw input that was passed to <code>parse</code>.\nStart index of the suffix or <code>raw.len()</code> if there is no â€¦\nThe optional suffix. Returns <code>&quot;&quot;</code> if the suffix is â€¦\nReturns the string value this literal represents (where â€¦\nThe string value (with all escapes unescaped), or <code>None</code> if â€¦")