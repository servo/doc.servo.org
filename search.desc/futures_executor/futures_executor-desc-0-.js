searchState.loadedDescShard("futures_executor", 0, "Built-in executors and related tools.\nAn iterator which blocks on values from a stream until …\nRepresents an executor context.\nAn error returned by <code>enter</code> if an execution scope has …\nA single-threaded task pool for polling futures to …\nA handle to a <code>LocalPool</code> that implements <code>Spawn</code>.\nRun a future to completion on the current thread.\nTurn a stream into a blocking iterator.\nMarks the current thread as being within the dynamic …\nRepresents an executor context.\nAn error returned by <code>enter</code> if an execution scope has …\nMarks the current thread as being within the dynamic …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn iterator which blocks on values from a stream until …\nA single-threaded task pool for polling futures to …\nA handle to a <code>LocalPool</code> that implements <code>Spawn</code>.\nRun a future to completion on the current thread.\nTurn a stream into a blocking iterator.\nEmpty the incoming queue of newly-spawned tasks.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this <code>BlockingStream</code> into the inner <code>Stream</code> type.\nCreate a new, empty pool of tasks.\nPoll <code>self.pool</code>, re-filling it with any newly-spawned tasks.\nRun all tasks in the pool to completion.\nRuns all the tasks in the pool until the given future …\nRuns all tasks in the pool and returns if no more progress …\nGet a clonable handle to the pool as a <code>Spawn</code>.\nThe (single) executor thread.\nRuns all tasks and returns after completing one future or …\nA flag to ensure a wakeup (i.e. <code>unpark()</code>) is not “…\nCheck for a wakeup, but don’t consume it.")