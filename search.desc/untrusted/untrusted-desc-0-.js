searchState.loadedDescShard("untrusted", 0, "untrusted.rs: Safe, fast, zero-panic, zero-crashing, …\nThe error type used to indicate the end of the input was …\nA wrapper around <code>&amp;&#39;a [u8]</code> that helps in writing panic-free …\nA read-only, forward-only cursor into the data in an <code>Input</code>.\nCalls <code>read</code> with the given input as a <code>Reader</code>, ensuring that …\nA wrapper around <code>&amp;&#39;a [u8]</code> that helps in writing panic-free …\nAccess the input as a slice so it can be processed by …\nReturns the argument unchanged.\nConstruct a new <code>Input</code> for the given input <code>bytes</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the input is empty and false otherwise.\nReturns the length of the <code>Input</code>.\nCalls <code>read</code> with the given input as a <code>Reader</code>, ensuring that …\nA wrapper around a slice that exposes no functions that …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe error type used to indicate the end of the input was …\nA read-only, forward-only cursor into the data in an <code>Input</code>.\nReturns <code>true</code> if the reader is at the end of the input, and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new Reader for the given input. Use <code>read_all</code> or\nReturns <code>true</code> if there is at least one more byte in the …\nReads the next input byte.\nSkips <code>num_bytes</code> of the input, returning the skipped input …\nSkips the reader to the end of the input, returning the …\nCalls <code>read()</code> with the given input as a <code>Reader</code>. On success, …\nSkips <code>num_bytes</code> of the input.\nSkips the reader to the end of the input.")