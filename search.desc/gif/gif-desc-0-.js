searchState.loadedDescShard("gif", 0, "GIF en- and decoding library Build Status\nStreamingDecoder is not required to take any action.\nA newtype wrapper around an arbitrary extension ID.\nApplication extension.\nRestore to background color.\nLimit the amount of memory that can be used for a single …\nOutput mode for the image data\nComment extension.\nControl extension. Use <code>ExtensionData::new_control_ext</code> to …\nControl extension.\nOptions for opening a GIF decoder. <code>DecodeOptions::read_info</code>…\nGIF decoder. Create <code>DecodeOptions</code> to get started, and call …\nDecoding error.\nAn error returned in the case of the image not being …\nDisposal method\nGIF encoder.\nEncoding error.\nThe image has incorrect properties, making it impossible …\nKnown GIF extension labels.\nExtension data.\nFinite number of repetitions\nReturned if the image is found to be malformed.\nReturned if the to image is not encodable as a gif.\nA GIF frame\nThe decoder returns the raw indexed data.\nInfinite number of repetitions\nLZW data is not valid for GIF. This may happen when wrong …\nWraps <code>std::io::Error</code>.\nWraps <code>std::io::Error</code>.\nDo not dispose.\nThe maximum amount of memory the decoder is allowed to use …\nThe image has no color palette which is required.\nRestore to previous.\nThe decoder expands the image data to 32bit RGBA. This …\nNumber of repetitions\nSets the number of repetitions\nPlain Text extension.\nThe image has too many colors.\nEnforce no memory limit.\nVersion 87a, from May 1987.\nVersion 89a, from July 1989.\nOne version number of the GIF standard.\nBuffer containing the image data. Only indices unless …\nFrame delay in units of 10 ms.\nDisposal method.\nMinimal gif encoder\nHeight of the frame.\nTrue if the image is interlaced.\nOffset from the left border of the canvas.\nTrue if the frame needs user input to be displayed.\nFrame local color palette if available.\nLow-level, advanced decoder. Prefer <code>Decoder</code> instead, which …\nOffset from the top border of the canvas.\nTraits used in this library\nTransparent index (if available).\nWidth of the frame.\nFrame delay.\nFlags.\nTransparent index.\nStreamingDecoder is not required to take any action.\nA newtype wrapper around an arbitrary extension ID.\nApplication extension.\nRestore to background color.\nKnown GIF block labels.\nComment extension.\nControl extension.\nDisposal method\nKnown GIF extension labels.\nExtension block.\nA GIF frame\nImage block.\nDo not dispose.\nRestore to previous.\nPlain Text extension.\nImage trailer.\nBuffer containing the image data. Only indices unless …\nFrame delay in units of 10 ms.\nDisposal method.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a frame from indexed pixels in the global palette.\nCreates a frame from a palette and indexed pixels.\nCreates a frame from pixels in RGB format.\nCreates a frame from pixels in RGB format.\nCreates a frame from pixels in RGBA format.\nCreates a frame from pixels in RGBA format.\nConverts <code>u8</code> to <code>Option&lt;Self&gt;</code>\nConverts <code>u8</code> to <code>Option&lt;Self&gt;</code>\nConverts <code>u8</code> to a <code>Extension</code> if it is known.\nHeight of the frame.\nTrue if the image is interlaced.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecode the label as a known extension.\nOffset from the left border of the canvas.\nReplace frame’s buffer with a LZW-compressed one for use …\nTrue if the frame needs user input to be displayed.\nFrame local color palette if available.\nLeaves empty buffer and empty palette behind\nOffset from the top border of the canvas.\nTransparent index (if available).\nWidth of the frame.\nControl extension. Use <code>ExtensionData::new_control_ext</code> to …\nGIF encoder.\nEncoding error.\nThe image has incorrect properties, making it impossible …\nExtension data.\nFinite number of repetitions\nReturned if the to image is not encodable as a gif.\nInfinite number of repetitions\nLZW data is not valid for GIF. This may happen when wrong …\nWraps <code>std::io::Error</code>.\nThe image has no color palette which is required.\nNumber of repetitions\nSets the number of repetitions\nThe image has too many colors.\nreturns rounded palette size, number of missing colors, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets a mutable reference to the writer instance used by …\nGets a reference to the writer instance used by this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFinishes writing, and returns the <code>io::Write</code> instance used …\nEncodes the data into the provided buffer.\nCreates a new encoder.\nConstructor for control extension data.\nWrite an extension block that signals a repeat behaviour.\nWrites an extension to the image.\nWrites a frame to the image.\nWrites the global color palette.\nWrites a frame to the image, but expects <code>Frame.buffer</code> to …\nWrites a raw extension to the image.\nWrites the logical screen desriptor\nWrite the final tailer.\nFrame delay.\nFlags.\nTransparent index.\nLimit the amount of memory that can be used for a single …\nOptions for opening a GIF decoder. <code>DecodeOptions::read_info</code>…\nGIF decoder. Create <code>DecodeOptions</code> to get started, and call …\nUse <code>decoder.into_iter()</code> to iterate over the frames\nThe maximum amount of memory the decoder is allowed to use …\nEnforce no memory limit.\nConfigure if unknown blocks are allowed to be decoded.\nIndex of the background color in the global palette\nOutput buffer size\nReturn a builder that allows configuring limits etc.\nConfigure if frames must be within the screen descriptor.\nConfigure if LZW encoded blocks must end with a marker end …\nReads data of the current frame into a pre-allocated …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe global color palette\nHeight of the image\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAbort decoding and recover the <code>io::Read</code> instance\nAbort decoding and recover the <code>io::Read</code> instance\nLine length of the current frame\nCreate a new decoder with default options.\nCreates a new decoder builder\nReturns the next frame info\nReturns the color palette relevant for the frame that has …\nReads the logical screen descriptor including the global …\nReads the data of the current frame into a pre-allocated …\nReads the next frame from the image.\nNumber of loop repetitions\nConfigure how color data is decoded.\nConfigure a memory limit for decoding.\nConfigure whether to skip decoding frames.\nThis is private for iterator’s use\nWidth of the image\nOutput mode for the image data\nThe decoder returns the raw indexed data.\nDeinterlaces and expands to RGBA if needed\nThe decoder expands the image data to 32bit RGBA. This …\nUse <code>read_into_buffer</code> to deinterlace\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nApplies deinterlacing\nIndex of the background color in the global palette.\nDecoded the last (or only) sub-block of a block.\nThe start of a block. <code>BlockStart(Block::Trailer)</code> is the …\nSingle byte screen descriptor values\nDecoded some data of the current frame. Size is in bytes, …\nKeeps LZW compressed\nNo more data available the current frame.\nDecompresses LZW\nIndicates whether a certain object has been decoded\nDecoding error.\nAn error returned in the case of the image not being …\nDelay time\nCollects data in ext.data\nReturned if the image is found to be malformed.\nVaries depending on <code>skip_frame_decoding</code>\nDecoder for <code>Frame::make_lzw_pre_encoded</code>\nDecoded all information of the next frame, except the …\nGlobal palette.\nPalette and optional <code>Application</code> extension have been …\nFrame height\nLeft frame offset\nTop frame offset\nFrame width\nWraps <code>std::io::Error</code>.\nRaw LZW data\nCopied (or consumed and discarded) compressed data of the …\nDiscard bytes\nDecoded nothing.\nDestination to write to for <code>StreamingDecoder::update</code>\nGIF palettes are RGB\n<code>Frame.buffer</code> will be regular pixel data\nLoop count is known\nLogical screen descriptor height\nLogical screen descriptor width\nOverwrite bytes\nInternal state of the GIF decoder\nGIF decoder which emits low-level events for items in the …\nDecoded a sub-block. More sub-block are available.\nU16 values that may occur in a GIF image\nVersion 87a, from May 1987.\nVersion 89a, from July 1989.\nAppend LZW bytes\nOne version number of the GIF standard.\nNumber of bytes required for …\nFrame data\nCurrent frame info as a ref.\nCurrent frame info as a mutable ref.\nConverts the frame in-place, replacing its LZW buffer with …\nConverts into the given buffer. It must be [<code>buffer_size()</code>] …\next buffer\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nNeeds to emit <code>HeaderEnd</code> once\nHeight of the image\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the data of the last extension that has been …\nSee also <code>set_global_palette</code>\nCreates a new streaming decoder\nPalette used for RGBA conversion\nCurrent frame info as a mutable ref.\nUpdates the internal state of the decoder.\nThe version number of the GIF standard used in this image.\nWidth of the image\nNeeded for decoding\nIndex of the background color in the global palette.\nKnown GIF block labels.\nDecoded the last (or only) sub-block of a block.\nThe start of a block. <code>BlockStart(Block::Trailer)</code> is the …\nDecoded some data of the current frame. Size is in bytes, …\nNo more data available the current frame.\nIndicates whether a certain object has been decoded\nExtension block.\nVaries depending on <code>skip_frame_decoding</code>\nDecoder for <code>Frame::make_lzw_pre_encoded</code>\nDecoded all information of the next frame, except the …\nGlobal palette.\nPalette and optional <code>Application</code> extension have been …\nImage block.\nRaw LZW data\nCopied (or consumed and discarded) compressed data of the …\nDiscard bytes\nDecoded nothing.\nDestination to write to for <code>StreamingDecoder::update</code>\n<code>Frame.buffer</code> will be regular pixel data\nLoop count is known\nOverwrite bytes\nGIF decoder which emits low-level events for items in the …\nDecoded a sub-block. More sub-block are available.\nImage trailer.\nAppend LZW bytes\nFrame data\next buffer\nNeeds to emit <code>HeaderEnd</code> once\nNeeded for decoding\nWriter extension to write little endian data\nWrites <code>T</code> to a bytes stream. Least significant byte first.")