searchState.loadedDescShard("naga", 0, "Universal shader translator.\nWidth of abstract types, in bytes.\nAbstract floating-point type.\nWGSL abstract integer type.\nOpaque object representing an acceleration structure of …\nArray access with a computed index.\nAccess the same types as <code>Access</code>, plus <code>Struct</code> with a known …\nAddressing space of variables.\nAn arena holding some kind of component (e.g., type, …\nHomogeneous list of elements.\nGet the length of an array. The expression must resolve to …\nSize of an array.\nCast a simple type to another kind.\nAtomic scalar.\nAtomic function.\nFunction on an atomic value.\nResult of an atomic operation.\nWidth of a boolean type, in bytes.\nMemory barrier flags.\nSynchronize invocations within the work group. The <code>Barrier</code> …\n2D vector\nApply a binary operator.\nOperation that can be applied on two values.\nDescribes how an input/output variable is to be bound.\nArray of bindings.\nA code block is a vector of statements, with maybe a …\nA block containing more statements, to be executed …\nBoolean type.\nExits the innermost enclosing <code>Loop</code> or <code>Switch</code>.\nAll gather from the same lane at the index given by the …\nAll gather from the active lane with the smallest index\nBuilt-in inputs and outputs.\nBuilt-in shader variable.\nNumber of bytes per scalar.\nCalls a function.\nResult of calling another function.\nInterpolate the value at the center of the pixel.\nInterpolate the value at a point that lies within all …\nComposite expression.\nEnables adjusting depth without disabling early Z.\nConstant value.\nThe array size is constant.\nConstant value.\nSkips to the <code>continuing</code> block of the innermost enclosing …\nCube map\n1D image\n2D image\n3D image\nDepth comparison image.\nCompute the derivative on an axis.\nAxis on which to compute a derivative.\nHint at which precision to compute a derivative.\nThe array size can change at runtime.\nEarly fragment tests.\nUse the value provided by the first or last vertex of the …\nEmit a range of expressions, visible to all statements …\nThe main function for a pipeline stage.\nAn expression that can be evaluated to obtain a value.\nMay not be NaN or infinity.\nMay not be NaN or infinity.\nHash map that is faster but not resilient to DoS attacks.\nHash set that is faster but not resilient to DoS attacks.\nInsertion-order-preserving hash map (<code>IndexMap&lt;K, V&gt;</code>), but …\nInsertion-order-preserving hash set (<code>IndexSet&lt;K&gt;</code>), but …\nUse the value provided by the first vertex of the current …\nIndicates that no interpolation will be performed.\nFloating point type.\nA function defined in the module.\nFunction locals.\nA function argument.\nReference a function parameter, by its index.\nA function result.\nThe specific behavior of a <code>SubgroupGather</code> statement.\nVariable defined at module level.\nReference a global variable.\nShader may rewrite depth only with a value greater than …\nA strongly typed reference to an arena item.\nOpaque handles, such as samplers and images.\nConditionally executes one of two blocks, based on the …\nPossibly multidimensional array of texels.\nSub-class of the image type.\nThe number of dimensions an image has.\nLoad a texel from an image.\nType of an image query.\nQuery information from an image.\nSample a point from a sampled or a depth image.\nStores a texel value to an image.\nInitialize the <code>RayQuery</code> object.\nThe interpolation qualifier of a binding or struct field.\nAborts the current shader execution.\nStorage can be used as a source for load ops.\nShader may rewrite depth smaller than one that would have …\nIndicates that linear, non-perspective, correct …\nLiteral.\nLoad a value indirectly.\nVariable defined at function level.\nReference a local variable.\nIndexed location.\nExecutes a block repeatedly.\nCall a math function\nBuilt-in shader function for math.\nMatrix of numbers.\nShader module.\nEquivalent of the WGSL’s <code>%</code> operator or SPIR-V’s <code>OpFRem</code>\nMap of expressions that have associated variable names\nGet the number of array layers, a <code>u32</code>.\nGet the number of mipmap levels, a <code>u32</code>.\nGet the number of samples, a <code>u32</code>.\nPipeline-overridable constant.\nPipeline-overridable constant.\nThe value will be interpolated in a perspective-correct …\nPointer to another type.\nReturn types predeclared for the frexp, modf, and …\nPrivate data, per invocation, mutable.\nStart or continue the query given by the statement’s …\nPush constants.\n4D vector\nA strongly typed range of handles.\nLocally used handle for ray queries.\nAn operation that a <code>RayQuery</code> statement applies to its <code>query</code>…\nReturn an intersection found by <code>query</code>.\nResult of a <code>Proceed</code> <code>RayQuery</code> statement.\nCall a relational function.\nBuilt-in shader function for testing relation between …\nPipeline binding information for global resources.\nReturns from the function (possibly with a value).\nBarrier affects all <code>AddressSpace::Storage</code> accesses.\nStorage can be used as a target for store ops.\nBarrier synchronizes execution across all invocations …\nInterpolate the value at each sample location. In …\nSampling modifier to control the level of detail.\nRegular sampled image.\nCan be used to sample values from images.\nThe sampling qualifiers of a binding or struct field.\nCharacteristics of a scalar type.\nNumber of integral or floating-point kind.\nPrimitive type for a scalar.\nSelect between two values based on a condition.\nStage of the programmable pipeline.\nRight shift carries the sign of signed integers only.\nEach gathers from a different lane at the index given by …\nEach gathers from their lane plus the shift given by the …\nEach gathers from their lane minus the shift given by the …\nEach gathers from their lane xored with the given by the …\nSigned integer type.\nGet the size at the specified level.\nA human-readable representation for a span, tailored for …\nA source code span, used for error reporting.\nA source code span together with “context”, a …\nSet of special types that can be optionally generated by …\nSplat scalar into a vector.\nInstructions which make up an executable block.\nStorage buffer data, potentially mutable.\nStorage image.\nFlags describing an image.\nImage storage format.\nStores a value at an address.\nUser-defined structure.\nMember of a user-defined structure.\nCalculate a bitmask using a boolean from each active …\nResult of a <code>SubgroupBallot</code> statement.\nCompute a collective operation across all active threads …\nGather a value from another active thread in the subgroup\nResult of a <code>SubgroupCollectiveOperation</code> or <code>SubgroupGather</code> …\nConditionally executes one of multiple blocks, based on …\nA case for a switch statement.\nThe value of the switch case.\nVector swizzle.\nComponent selection for a vector swizzle.\n3D vector\nA data type declared in the module.\nEnum with additional information, depending on the kind of …\nUnsigned integer type.\nApply an unary operator.\nOperation that can be applied on a single value.\nShader may not rewrite depth value.\nUniform buffer data.\nAn arena whose elements are guaranteed to be unique.\nPointer to a scalar or vector.\nVector of numbers.\nNumber of components in a vector.\nBarrier affects all <code>AddressSpace::WorkGroup</code> accesses.\nWrapper class for <code>Error</code>, augmenting it with a list of …\nWorkgroup shared data, mutable.\nLoad uniformly from a uniform pointer in the workgroup …\nResult of a <code>WorkGroupUniformLoad</code> statement.\nZero value of a type.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nApply the usual default interpolation for <code>ty</code> to <code>binding</code>.\nThe <code>Arena</code>, <code>UniqueArena</code>, and <code>Handle</code> types.\nInformation about function argument.\nFind the common type of <code>self</code> and <code>other</code> under WGSL’s …\nReturn <code>true</code> if automatic conversions will covert <code>self</code> to …\nDetermine whether <code>self</code> automatically converts to <code>goal</code>.\nBackend functions that export shader <code>Module</code>s into binary …\nReturns the ref count, upon reaching which this expression …\nFor I/O structs, defines the binding.\nBinding number within the group.\nFor resources, defines the binding point.\nFor entry points, an argument has to have a binding unless …\nFor entry points, the result has to have a binding unless …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nBody of the case.\nBlock of instructions comprising the body of the function.\nReturn the canonical form of <code>self</code>, or <code>None</code> if it’s …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nArena for the constants defined in this module.\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nValues of this arena.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nEarly depth test for fragment stages.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nEntry points.\nCompare <code>self</code> and <code>rhs</code> as types.\nExpressions used inside this function.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nIf true, the control flow continues to the next case in …\nConstruct a float <code>Scalar</code> with the given width.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nFrontend parsers that consume binary and text shaders and …\nThe entrance function.\nArena for the functions defined in this module.\nPopulate this module’s <code>SpecialTypes::predeclared_types</code> …\nPopulate this module’s <code>SpecialTypes::ray_desc</code> type.\nPopulate this module’s <code>SpecialTypes::ray_intersection</code> …\nConstant expressions and override expressions used by this …\nArena for the global variables defined in this module.\nThe bind group index.\nPipeline Constant ID.\nReturn the <code>ImageDimension</code> for which <code>self</code> is an appropriate …\nReturn the length of a subscriptable type.\nThe default value of the pipeline-overridable constant.\nThe value of the constant.\nInitial value for this variable.\nInitial value for this variable.\nWhether a variable with this address space can be …\nInner structure that depends on the kind of the type.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nReturn true if this expression is a dynamic …\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nReturns true if this is a handle to a type rather than the …\nReturns true if the statement directly terminates the …\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nLists of reserved keywords for each shading language with …\nHow the value’s bits are to be interpreted.\nLength in code units (in bytes) of the span.\n1-based line number.\n1-based column in code units (in bytes) of the start of …\nLocal variables defined and used in the function.\nThe name of the type, if any.\nName of the variable, if any.\nName of the variable, if any.\nName of the argument, if any.\nName of the function, if any.\nName of this entry point, visible externally.\nMap of expressions that have associated variable names\nReturns true if the expression is considered emitted at …\n<code>NonMaxU32</code>, a 32-bit type that can represent any value …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\n0-based Offset in code units (in bytes) of the start of …\nOffset from the beginning from the struct.\nReturn the global variable being accessed by the …\nArena for the pipeline-overridable constants defined in …\nTypes for predeclared wgsl types instantiated on demand.\n<code>Module</code> processing functionality.\nType for <code>RayDesc</code>.\nType for <code>RayIntersection</code>.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe result of this function, if any.\nReturn the scalar type of <code>self</code>.\nReturns the scalar width in bytes\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nGet the size of this type.\nHow this variable is to be stored.\nSpans for the elements, indexed by handle.\nDictionary of special type handles.\nShader stage.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nFormat a scalar kind+width as a type is written in wgsl.\nFormats the type as it is written in wgsl.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nType of the field.\nThe type of this variable.\nThe type of this variable.\nType of the argument.\nType of the result.\nArena for the types defined in this module.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nShader validator.\nValue, upon which the case is considered true.\nThis size of the value in bytes.\nWorkgroup size for compute stages\nIndicates the 2nd input to the blender when dual-source …\nThe index into an arrayed image. If the <code>arrayed</code> flag in …\nBoolean expression\nIf provided, converts to the specified byte width. …\nThe coordinate of the texel we wish to load. This must be …\nSource expression, which can only be a scalar or a vector.\nIf Some(), this operation is a gather operation on the …\nThe image to load a texel from. This must have type <code>Image</code>. …\nTarget scalar kind.\nA level of detail, for mipmapped images.\nThis refers to an expression in <code>Module::global_expressions</code>.\nA sample index, for multisampled <code>Sampled</code> and <code>Depth</code> images.\nThe type of the result\nKind of values to sample.\nMulti-sampled image.\nMulti-sampled depth image.\nIf <code>None</code>, the base level is considered.\nThe acceleration structure within which this query should …\nA struct of detailed parameters for the ray query.\nThe value to broadcast over\nThe value to compute over\nHow to combine the results\nFunction to run on the atomic value.\nThe specific operation we’re performing on <code>query</code>.\nSpecifies which thread to gather from\nWhat operation to compute\nPointer to an atomic value.\nThis must be of type <code>Pointer</code> in the <code>WorkGroup</code> address space\nThe value from this thread to store in the ballot\nThe <code>RayQuery</code> object this statement operates on.\n<code>AtomicResult</code> expression representing this function’s …\nThe <code>WorkGroupUniformLoadResult</code> expression representing …\nThe <code>SubgroupBallotResult</code> expression representing this load…\nThe <code>SubgroupOperationResult</code> expression representing this …\nThe <code>SubgroupOperationResult</code> expression representing this …\nValue to use in the function.\nAn arena holding some kind of component (e.g., type, …\nAdds a new value to the arena, returning a typed handle.\nAssert that <code>handle</code> is valid for this arena.\nAssert that <code>range</code> is valid for this arena.\nClears the arena keeping all allocations\nValues of this arena.\nDrains the arena, returning an iterator over the items …\nFetch a handle to an existing type.\nAdds a value with a custom check for uniqueness: returns a …\nAdds a value with a check for uniqueness, where the check …\nReturns the argument unchanged.\nGet a mutable reference to an element in the arena.\nWell-typed indices into <code>Arena</code>s and <code>UniqueArena</code>s.\nThe <code>HandleSet</code> type and associated definitions.\nThe <code>HandleVec</code> type and associated definitions.\nCalls <code>U::from(self)</code>.\nExtracts the inner vector.\nReturns <code>true</code> if the arena contains no elements.\nReturns an iterator over the items stored in this arena, …\nReturns a iterator over the items stored in this arena, …\nReturns the current number of items stored in this arena.\nCreate a new arena with no initial capacity allocated.\nWell-typed ranges of <code>Arena</code>s.\nGet the range of handles from a particular number of …\nThe <code>UniqueArena</code> type and supporting definitions.\nA strongly typed reference to an arena item.\nAn unique index in the arena array that a handle points to.\nCheck that <code>depends_on</code> was constructed before <code>self</code> by …\nLike <code>Self::check_dep</code>, except for <code>Iterator</code>s over handle …\nLike <code>Self::check_dep</code>, except for <code>Option</code>al handle values.\nCheck that <code>self</code> is valid within <code>arena</code> using …\nCheck that <code>self</code> is valid within <code>arena</code> using …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert a <code>usize</code> index into a <code>Handle&lt;T&gt;</code>.\nConvert a <code>usize</code> index into a <code>Handle&lt;T&gt;</code>, without range …\nReturns the index of this handle.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFormats the type as it is written in wgsl.\nWrite this handle’s index to <code>formatter</code>, preceded by …\nA set of <code>Handle&lt;T&gt;</code> values.\nReturn an iterator over all handles that could be made …\nThis type is indexed by values of type <code>T</code>.\nRemove all members from <code>self</code>.\nRemove all members from <code>self</code>, and reserve space to hold …\nReturn a new, empty <code>HandleSet</code>, sized to hold handles from …\nReturns the argument unchanged.\nAdd <code>handle</code> to the set.\nAdd handles from <code>iter</code> to the set.\nCalls <code>U::from(self)</code>.\nReturn an iterator over all handles in <code>self</code>.\nBound on indexes of handles stored in this set.\n<code>members[i]</code> is true if the handle with index <code>i</code> is a member.\nReturn a new, empty <code>HandleSet</code>.\nRemove <code>handle</code> from the set.\nA <code>Vec</code> indexed by <code>Handle</code>s.\nReturns the argument unchanged.\nInsert a mapping from <code>handle</code> to <code>value</code>.\nCalls <code>U::from(self)</code>.\nA strongly typed range of handles.\nreturn the first and last handles included in <code>self</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>Range</code> that covers the indices in <code>inner</code>.\nReturn a range covering all handles with indices from <code>0</code> to …\nReturn the index range covered by <code>self</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn a range enclosing handles <code>first</code> through <code>last</code>, …\nAn arena whose elements are guaranteed to be unique.\nAssert that <code>handle</code> is valid for this arena.\nClears the arena, keeping all allocations.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn this arena’s handle for <code>value</code>, if present.\nReturn this arena’s value at <code>handle</code>, if that is a valid …\nReturn the span associated with <code>handle</code>.\nInsert a new value into the arena.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn <code>true</code> if the arena contains no elements.\nReturns an iterator over the items stored in this arena, …\nReturn the current number of items stored in this arena.\nCreate a new arena with no initial capacity allocated.\nReplace an old value with a new value.\nSpans for the elements, indexed by handle.\nA type for displaying expression handles as baking …\nNames of vector components.\nAn <code>EntryPoint</code>, and its index in <code>Module::entry_points</code>.\nA regular function.\nHelper structure that stores data needed when writing the …\nWhether we’re generating an entry point or a regular …\nIndent for backends.\nIndentation level.\nExpressions that need baking.\nSpecifies the values of pipeline-overridable constants in …\nRay flags, for a <code>RayDesc</code>’s <code>flags</code> field.\nThe intersection test to use for ray queries.\nGet a flags value with all known bits set.\nHelper method that generates a <code>NameKey</code> for a function …\nHelper function that returns the string corresponding to …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWorkarounds for platform bugs and limitations in switches …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nFor constness checks\nThe expression arena of the current function being written\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nBackend for GLSL (OpenGL Shading Language).\nAnalysis about the function\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nReturns true if the function is an entry point for a …\nWhether all bits in this flags value are unset.\nReturns true if the given expression points to a …\nYield a set of contained flags values.\nYield a set of contained named flags values.\nHelper method that generates a <code>NameKey</code> for a local in the …\nMap of expressions that have associated variable names\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nHelper method that resolves a type of a given expression.\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nBackend for SPIR-V (Standard Portable Intermediate …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe current function being written\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nHelper function that returns the string corresponding to …\nEmit <code>if (continue_variable) { break; }</code>\nEmit <code>if (continue_variable) { continue; }</code>\nUtility for tracking nesting of loops and switches to …\nA micro-IR for code a backend should generate after a …\nCurrently nested in at least one <code>Loop</code> statement.\nA summary of the code surrounding a statement.\nCurrently nested in at least one <code>Switch</code> that may need to …\nResets internal state.\nDetermine what to generate for a <code>Continue</code> statement.\nUpdates internal state to record entering a <code>Loop</code> statement.\nUpdates internal state to record entering a <code>Switch</code> …\nUpdates internal state to record exiting a <code>Loop</code> statement.\nUpdate internal state to record leaving a <code>Switch</code> statement.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet if we’ve generated code for a <code>Continue</code> statement …\nFlip output Y and extend Z from (0, 1) to (-1, 1).\nShorthand result used internally by the backend\nBinary operation with a different logic on the GLSL side.\nMapping between resources and bindings.\nThe suffix of the variable that will hold the calculated …\nSupports ARB_shader_draw_parameters on the host, which …\n<code>core</code> GLSL.\n<code>es</code> GLSL.\nThe entry point couldn’t be found.\nContains the error value\nA GLSL compilation error.\nEmit <code>PointSize</code> output builtin to vertex shaders, which is …\nStructure used to encode additions to GLSL that aren’t …\n<code>crate::Sampling::First</code> is unsupported.\nA error occurred while writing to the output.\nInclude unused global variables, constants and functions. …\nHelper structure that generates a number\nA image was used with multiple samplers, which isn’t …\nThe specified <code>Version</code> doesn’t have all required <code>Features</code>.\nGLSL <code>%</code> is SPIR-V <code>OpUMod/OpSMod</code> and <code>mod()</code> is <code>OpFMod</code>, but …\n<code>AddressSpace::PushConstant</code> was used more than once in the …\nContains the success value\nConfiguration used in the <code>Writer</code>.\nAny plain operation. No additional logic required.\nA subset of options meant to be changed per pipeline.\nAll information to bind a single uniform value to the …\nReflection info for texture mappings and uniforms.\nList of supported <code>core</code> GLSL versions.\nList of supported <code>es</code> GLSL versions.\nStructure returned by <code>glsl_scalar</code>\nSupports GL_EXT_texture_shadow_lod on the host, which …\nMapping between a texture and its sampler, if it exists.\nA call was made to an unsupported external.\nA scalar with an unsupported width was requested.\nHelper wrapper used to get a name for a varying\nAssorted options needed for generating varyings.\nVector comparison should use the function like …\nVector component wise operation; used to polyfill …\nA GLSL version.\nThe specified <code>Version</code> isn’t supported.\nWriter responsible for all code generation.\nConfiguration flags for the <code>Writer</code>.\nGL uniform name for the item. This name is the same as if …\nGet a flags value with all known bits set.\nMap of resources association to binding locations.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nA generator for unique block numbers.\nHelper method used to produce the reflection info that’s …\nHelper method that searches the module for all the needed …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nInformation about nesting of loops and switches.\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe selected entry point.\nThe name of the entry point.\nThe index of the selected entry point.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nContains the features related code and the features …\nFeatures manager used to store all the needed features and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe name of the scalar type\nGenerates a number that’s guaranteed to be unique for …\nHelper method used to get a name for a global\nHelper function that returns the glsl variable name for a …\nHelper function that returns the glsl dimension string of …\nHelper function that returns the string corresponding to …\nReturn the GLSL auxiliary qualifier for the given sampling …\nHelper function that returns scalar related strings\nHelper function that returns the glsl storage format …\nHelper function that returns the string corresponding to …\nThe index which can be used for dual source blending. This …\nThe module analysis.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nReturns true if self is <code>Version::Embedded</code> (i.e. is a es …\nChecks the list of currently supported versions and …\nReturns true if targeting WebGL\nYield a set of contained flags values.\nYield a set of contained named flags values.\nContains a constant with a slice of all the reserved …\nThe location of the global. This corresponds to …\nThe module being written.\nHow many views to render to, if doing multiview rendering.\nHow many views to render to, if doing multiview rendering.\nSet of expressions that have associated temporary …\nA map with all the names needed for writing the module …\nSet of expressions that need to be baked to avoid …\nCreates a new <code>Writer</code> instance.\nCreate a new gles version\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe offset in the push constant memory block this uniform …\nUser defined configuration to be used.\nThe output writer.\nThe bound checking policies to be used\nThe prefix used to compose other types\nList of push constant items in the shader.\nA map with the names of global variables needed for …\nThe intersection of a source flags value with the …\nHandle to the associated sampler global variable, if it …\nHelper method that checks the <code>Features</code> needed by a scalar\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe stage of the entry point.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nChecks if the version supports all of the explicit layouts:\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nHandle to the image global variable.\nMapping between texture names and variables/samplers.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nType of the uniform. This will only ever be a scalar, …\nMapping between uniform variables and names.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nHelper method used to find which expressions of a given …\nMapping of varying variables to their location. Needed for …\nMapping between names and attribute locations.\nThe GLSL version to be used.\nWrites the <code>Module</code> as glsl to the output\nIssue a memory barrier. Please note that to ensure …\nHelper function to write the local holding the clamped lod\nWrite a const expression.\nHelper method used to output a dot product as an …\nHelper method to write expressions\nHelper method used to write functions (both entry points …\nHelper method used to write non images/sampler globals\nHelper method used to write global constants\nHelper method used to write a name for a global without …\nHelper method for writing an <code>ImageLoad</code> expression.\nHelper method to write the <code>ImageStore</code> statement\nHelper method to write a image type\nWrite an interface block for a single Naga global.\nWrite <code>Expression</code> variants that can occur in both runtime …\nWrite a list of comma separated <code>T</code> values using a writer …\nHelper method used to write statements\nHelper function that return the glsl storage access string …\nHelper method used to write structs\nHelper method to write the coordinate vector for image …\nHelper method used to write non image/sampler types\nHelper method used to write value types\nWrite a GLSL global that will carry a Naga entry point’s …\nHelper function that write string with zero initialization …\nHelper function that write string with default zero …\nConfiguration flags for the <code>Writer</code>.\nShould workgroup variables be zero initialized (by …\nBuffer address space support.\n8 byte floats.\nDual source blending\nArrays with a dynamic length.\nMore image formats.\nStructure used to encode additions to GLSL that aren’t …\nHelper structure used to store the required <code>Features</code> …\nImage load and early depth tests.\nImage size query\nInstance index\nInterpolation and auxiliary qualifiers.\nSample ID.\nSubgroup operations\nTexture levels query\nTexture samples query\nSample specific LODs of cube / array shadow textures\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nChecks that all required <code>Features</code> are available for the …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nChecks if the list of features <code>Features</code> contains the …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nCreates a new <code>FeaturesManager</code> instance\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nAdds to the list of required <code>Features</code>\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nHelper method used to write all needed extensions\nReplace every expression handle in <code>block</code> with its …\nReplace every expression handle in <code>expr</code> with its …\nReplace every expression handle in <code>stmt</code> with its …\nAdjust <code>Emit</code> statements in <code>block</code> to skip <code>needs_pre_emit</code> …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReplace all override expressions in <code>function</code> with …\nAdd a <code>Constant</code> to <code>module</code> for the override <code>old_h</code>.\nReplace all overrides in <code>module</code> with constants.\nFlip Y coordinate of <code>BuiltIn::Position</code> output.\nA SPIR-V block to which we are still adding instructions.\nGeneral information needed to emit SPIR-V for Naga …\nClamp <code>BuiltIn::FragDepth</code> output between 0 and 1.\nA map from evaluated <code>Expression</code>s to their SPIR-V ids.\nSPIR-V operand kind: Capability\nInclude debug labels for everything.\nTracks the expressions for which the backend emits the …\nEmit <code>PointSize</code> output builtin to vertex shaders, which is …\nThe SPIR-V representation of a <code>crate::GlobalVariable</code>.\nFlags corresponding to the boolean(-ish) parameters to …\nEmit <code>OpName</code> for input/output locations.\nCharacteristics of a SPIR-V <code>OpTypeImage</code> type.\nA SPIR-V type constructed during code generation.\nA type encountered during SPIR-V generation.\nVia <code>VK_KHR_zero_initialize_workgroup_memory</code> or Vulkan 1.3\nA numeric type.\nA numeric type, for use in <code>LocalType</code>.\nEquivalent to a <code>LocalType::Pointer</code> whose <code>base</code> is a Naga IR …\nVia assignments + barrier\nSPIR-V operand kind: SourceLanguage\nA SPIR-V block that ends with a termination instruction.\nThe SPIR-V id of a pointer to this variable’s Naga IR …\nA map taking each expression to the number of <code>Access</code> and …\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nIf the binding is an unsized binding array, this overrides …\nMap of resources to information about the binding.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nImplementations for <code>BlockContext</code> methods.\nHow should generate code handle array, vector, matrix, or …\nCache an expression for a value.\nSPIR-V ids for expressions we’ve evaluated.\nIf given, the set of capabilities modules are allowed to …\nThe set of capabilities modules are permitted to use.\nThe set of capabilities used by this module.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nIndexed by const-expression handle indexes\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWrite the necessary decorations for a struct member.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nThe name of the entry point.\nTracks the constness of <code>Expression</code>s residing in …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nAdd a condition to a chain of bounds checks.\nThe set of spirv extensions used.\nConfiguration flags for the writer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConstruct a <code>LocalImageType</code> from the fields of a …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nInformation module validation produced about <code>ir_function</code>.\nThe <code>spv::Function</code> to which we are contributing SPIR-V …\nReturn the set of capabilities the last module written …\nReturn a SPIR-V type for a pointer to <code>resolution</code>.\nThe loaded value of a <code>AddressSpace::Handle</code> global variable.\nGenerating SPIR-V for image operations.\nBounds-checking for SPIR-V output.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nActual instruction of the argument.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe <code>Function</code> for which we’re generating code.\nThe <code>Module</code> for which we’re generating code.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\n(Major, Minor) target version of the SPIR-V.\nGenerate an access to a spilled temporary, if necessary.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nGenerating SPIR-V for ray query operations.\nReusing collections’ previous allocations.\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIndicate that the code requires any one of the listed …\nReset <code>Writer</code> to its initial state, retaining any …\nPrepare <code>self</code> for use within a single function.\nGenerate code to restrict <code>input</code> to fall between zero and …\nGenerate SPIR-V conditional structures.\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe stage of the entry point.\nA set of expressions that are either in <code>spilled_composites</code> …\nA map taking an expression that yields a composite value …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe <code>Writer</code>’s temporary vector, for convenience.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nIndicate that the code uses the given extension.\nThe SPIR-V id of the <code>OpVariable</code> that declares the global.\nCompute a single index operand to an <code>OpAccessChain</code> …\nGenerate one or more SPIR-V blocks for <code>naga_block</code>.\nEmit code for bounds checks for an array, vector, or …\nEmit a conditional load for …\nWrite instructions to query the size of an image.\nGenerate a vector or scalar ‘one’ for arithmetic on …\nBuild the instructions for the arithmetic expression of a …\nBuild an <code>OpAccessChain</code> instruction.\nExtend image coordinates with an array index, if necessary.\nGenerate code for an <code>ImageLoad</code> expression.\nGenerate code for an <code>ImageQuery</code> expression.\nGenerate code for an <code>ImageSample</code> expression.\nWrite an index bounds comparison to <code>block</code>, if needed.\nBuild the instructions for matrix - matrix column …\nWrite code to restrict coordinates for an image reference.\nRestrict an index to be in range for a vector, matrix, or …\nEmit code to compute the length of a run-time array.\nCompute the length of a subscriptable value.\nCompute the maximum valid index of a subscriptable value.\nGenerate an <code>OpVariable</code> for one value in an <code>EntryPoint</code>’s …\nEmit code to subscript a vector by value with a computed …\nBuild the instructions for vector - scalar multiplication\nThe writer handling the module to which this code belongs.\nDictates the way workgroup variables should be zero …\nHow to derive the type of <code>OpAccessChain</code> instructions from …\nThe termination statement to be added to the end of the …\nWhat code generation did with a provided <code>BlockExit</code> value.\nGenerates an OpBranch to the specified block\nTranslates a loop <code>break if</code> into an <code>OpBranchConditional</code> to …\nThe access expression must be conditional on the value of …\nThe generated code did not use the provided <code>BlockExit</code> …\nThe results of emitting code for a left-hand-side …\nThe SPIR-V type should be an <code>OpPointer</code> to the direct …\nNo adjustment needed: the SPIR-V type should be the direct …\nThe pointer to the expression’s value is available, as …\nGenerates an OpReturn (void return)\nThe generated code used the provided <code>BlockExit</code> value. If …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe condition of the <code>break if</code>\nThe loop header block id\nThe branch target block\nHACK: this is taken from std unstable, remove it when std…\nReturn true if the global requires a type decorated with …\nsplit a string into chunks and keep utf8 valid\nA trait for image access (load or store) code generators.\nInformation about a vector of coordinates.\nTexel access information for an <code>ImageLoad</code> expression.\nThe Rust type that represents SPIR-V values and types for …\nTexel access information for a <code>Store</code> statement.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWrite an image access to <code>block</code>.\nWrite an instruction to access a given texel of this image.\nThe id of the image being accessed.\nThe id of the image being written to.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe specific opcode we’ll use to perform the fetch. …\nConstruct the SPIR-V ‘zero’ value to be returned for …\nStores don’t generate any value, so this just returns <code>()</code>.\nReturn the SPIR-V type of the value produced by the code …\nStores don’t generate any value, so this just returns <code>()</code>.\nThe number of components in <code>value</code>, if it is a vector, or …\nThe SPIR-V id of the type of <code>value</code>.\nThe type id produced by the actual image access …\nThe SPIR-V id of the combined coordinate/index vector …\nThe value we’re going to write to the texel.\nThe results of performing a bounds check.\nThe given instruction computes the index to be used.\nThe value is computed by the instruction with the given id.\nThe given instruction computes a boolean condition which …\nThe value is known at shader translation time.\nThe index is statically known and in bounds, with the …\nA value that we either know at translation time, or need …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe access should only be permitted if this value is true.\nThe access should use this index value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA value that can be reset to its initial state, retaining …\nClear <code>self</code>, retaining its current memory allocations.\nA trait to help <code>Selection</code> manage any number of merged …\nA private struct recording what we know about the …\nThe block pointer we’re emitting code into.\nEmit an unconditional branch to the merge block, and …\nReturns the argument unchanged.\nBranch to a successor block if <code>cond</code> is true, otherwise …\nCalls <code>U::from(self)</code>.\nReturn the id of the merge block, writing a merge …\nThe label of the selection construct’s merge block, or …\nThe types of the values in each element of <code>values</code>.\nStart a new selection construct.\nA set of <code>(VALUES, PARENT)</code> pairs, used to build <code>OpPhi</code> …\nWrite OpPhi instructions for the given set of predecessors.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA code block is a vector of statements, with maybe a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFix up all handles in <code>expr</code>.\nRemove unused types, expressions, and constants from <code>module</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe used map for <code>constants</code>.\nThe arena in which we are currently tracing expressions.\nThe used set for <code>arena</code>.\nReturns the argument unchanged.\nThe used set for the module’s <code>global_expressions</code> arena.\nCalls <code>U::from(self)</code>.\nPropagate usage through <code>self.expressions</code>, starting with …\nThe used map for <code>types</code>.\nFunction-local expressions used.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA map from old handle indices to new, compressed handle …\nReturn the counterpart to <code>old</code> in the compacted module.\nLike <code>adjust</code>, but for optional handles.\nShrink <code>range</code> to include only used handles.\nThis type is indexed by values of type <code>T</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe indices assigned to handles in the compacted module.\nReturn the counterpart to <code>old</code> in the compacted module.\nReturn true if <code>old</code> is used in the compacted module.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPropagate usage through <code>self.types</code>, starting with …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe source code of the shader.\nType representing a lexical scope, associating a name to a …\nStructure responsible for managing variable lookups and …\nA table of types for an <code>Arena&lt;Expression&gt;</code>.\nAdds a new variable to the current scope.\nAdds a new variable to the root scope.\nLimit of the <code>scopes</code> stack (exclusive). By using a separate …\nConstructs a new symbol table with a root scope\nReturns the argument unchanged.\nReturns the argument unchanged.\nGrow this typifier until it contains a type for <code>expr_handle</code>…\nInterpolation defaults.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRecompute the type resolution for <code>expr_handle</code>.\nPerform a lookup for a variable named <code>name</code>.\nRemoves the current lexical scope and all its variables\nAdds a new lexical scope.\nAdd an expression’s type to an <code>Arena&lt;Type&gt;</code>.\nStack of lexical scopes. Not all scopes are active; see …\nType generators.\nFrontend for WGSL (WebGPU Shading Language).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis function may consume a lot of stack space. …\nProducing the WGSL forms of types, for use in error …\nExpected: assignment, increment/decrement expression\nA declaration refers to itself indirectly, through one or …\nAccess of a function\nExpected: ‘struct’, ‘let’, ‘var’, ‘type’, …\nA break if appeared outside of a continuing block\nExpected: constant, parenthesized expression, identifier\nA declaration refers to itself directly.\nRedefinition of an identifier (used for both module-scope …\nExpected: ‘case’, ‘default’, ‘}’\nExpected a type.\nAccess of <code>var</code>, <code>let</code>, <code>const</code>.\nExpected: ‘,’, ‘)’\nEmits a summary of the error to standard error stream.\nEmits a summary of the error to standard error stream.\nEmits a summary of the error to a string.\nEmits a summary of the error to a string.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a <code>SourceLocation</code> for the first label in the error …\nSpan of the identifier in the new definition.\nThe location of the name of the declaration.\nThe location of the name of some declaration in the cycle.\nThe edges of the cycle of references.\nSpan of the identifier in the previous definition.\nThe point at which it is used.\nLocal state for ordering a <code>TranslationUnit</code>’s …\nA <code>GlobalDecl</code> list in which each definition occurs before …\nAn edge from a reference to its referent in the current …\nThe referent of some identifier used in the current …\nEnsure that all declarations used by <code>id</code> have been added to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate an <code>Index</code> for the given translation unit.\nA map from module-scope definitions’ names to their …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe translation unit whose declarations we’re ordering.\nThe list of declaration handles, with declarations before …\nThe current path in our depth-first traversal. Used for …\nProduce the sorted list of declaration handles, and check …\nFor each handle, whether it is an predecessor in the …\nWhere that use occurs within the current declaration.\nIterate over <code>GlobalDecl</code>s, visiting each definition before …\nFor each handle, whether we have pushed it onto <code>out</code> yet.\nA single vector component or swizzle.\nValue declared as const\nWe are lowering to a constant expression, to be included …\nState for lowering an <code>ast::Expression</code> to Naga IR.\nThe type of Naga IR expression we are lowering an …\nState for constructing a <code>crate::Module</code>.\nAn <code>ast::GlobalDecl</code> for which we have built the Naga IR …\nWe are lowering to an override expression, to be included …\nA WGSL plain type.\nA WGSL reference.\nWe are lowering to an arbitrary runtime expression, to be …\nValue declared as non-const\nState for lowering a statement within a function.\nWGSL type annotations on expressions, types, values, etc.\nApply the WGSL Load Rule to <code>expr</code>.\nThe <code>TranslationUnit</code>’s expressions arena.\nA reference to <code>TranslationUnit::expressions</code> for the …\nFind the consensus scalar of <code>components</code> under WGSL’s …\nInsert splats, if needed by the non-‘*’ operations.\nGenerate Naga IR for call expressions and statements, and …\nReturn an expression for the concretized value of <code>expr</code>.\nType judgments for <code>module::global_expressions</code>.\nGenerate Naga IR for a type constructor expression.\nBuild a <code>Constructor</code> for a WGSL construction expression.\nWGSL’s automatic conversions for abstract types.\nConvert all expressions in <code>exprs</code> to a common scalar type.\nConvert <code>expr</code> to the leaf scalar type <code>scalar</code>.\nWhether we are lowering a constant expression or a general …\nLower <code>expr</code> and apply the Load Rule if possible.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe map from the names of module-scope declarations to the …\nThe map from the names of module-scope declarations to the …\nThe map from the names of module-scope declarations to the …\nResolve the types of all expressions up through <code>handle</code>.\nAdd a single expression to the expression table that is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhich <code>Expression</code>s in <code>self.naga_expressions</code> are const …\nWhich <code>Expression</code>s in <code>self.naga_expressions</code> are const …\nA map from each <code>ast::Local</code> handle to the Naga expression we…\nA map from <code>ast::Local</code> handles to the Naga expressions we’…\nThe module we’re constructing.\nThe IR <code>Module</code> we’re constructing.\nStores the names of expressions that are assigned in <code>let</code> …\nConstruct a <code>Components</code> value from a ‘member’ name, …\nDetermine the type of <code>handle</code>, and add it to the module’s …\nResolves the type of a given expression.\nReturn a Naga <code>Handle&lt;Type&gt;</code> representing the front-end type …\nResolves the inner type of a given expression.\nResolves the inner types of two given expressions.\nBuild the Naga equivalent of a named AST type.\nTry to convert <code>expr</code>’s leaf scalar to <code>goal</code> using …\nTry to use WGSL’s automatic conversions to convert <code>expr</code> …\nApply WGSL’s automatic conversions to a vector …\nTry to convert <code>exprs</code> to <code>goal_ty</code> using WGSL’s automatic …\nThe <code>TranslationUnit</code>’s types arena.\nA reference to <code>TranslationUnit::types</code> for the translation …\nA cooked form of <code>ast::ConstructorType</code> that uses Naga types …\nAn array whose component type and size are inferred from …\nA matrix construction whose component type is inferred …\nA vector construction whose component type is inferred …\nA known Naga type.\nReturn an equivalent <code>Constructor</code> value that includes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nState for constructing an AST expression.\nWhich grammar rule we are in the midst of parsing.\nExpects <code>name</code> to be consumed (not in lexer).\nParse an assignment statement (will also parse increment …\ncompound_statement\nDecide if we’re looking at a construction expression, …\nThe <code>TranslationUnit::expressions</code> arena to which we should …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nExpects <code>Rule::PrimaryExpr</code> or <code>Rule::SingularExpr</code> on top; …\nParse a function call statement. Expects <code>ident</code> to be …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA map from identifiers in scope to the locals/arguments …\nLocal variable and function argument arena for the …\nParse a <code>singular_expression</code>.\nParses <code>&lt;T&gt;</code>, returning T and span of T\nParse type declaration of a given name.\nThe <code>TranslationUnit::types</code> arena to which we should …\nParse a <code>unary_expression</code>.\nIdentifiers used by the current global declaration that …\nAn array whose component type and size are written out: …\nThe size of an <code>Array</code> or <code>BindingArray</code>.\nA function call or type constructor expression.\nThe length as a constant expression.\nA type constructor expression.\nA type at the head of a <code>Construct</code> expression.\nA reference to a module-scope definition or predeclared …\nA module-scope declaration.\nA placeholder for a local variable declaration.\nA matrix construction whose component type is written out: …\nAn array whose component type and size are inferred from …\nA matrix construction whose component type is inferred …\nA vector construction whose component type is inferred …\nA scalar type or conversion: <code>f32(1)</code>.\nConstructing a value of a known Naga IR type.\nA user-defined type, like a struct or a type alias.\nA vector construction whose component type is written out: …\nNames of all module-scope or predeclared objects this …\nThe common expressions arena for the entire translation …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe name referred to.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNon-user-defined types, like <code>vec4&lt;f32&gt;</code> or <code>array&lt;i32, 10&gt;</code>.\nThe location at which the reference to that name occurs.\nCalls the function with a lexer and returns the result of …\nReturn the token at the start of <code>input</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether or not a char is a blankspace (Unicode …\nReturns whether or not a char is a comment end (Unicode …\nReturns whether or not a char is a word part (Unicode …\nReturns whether or not a char is a word start (Unicode …\nReturn the next non-whitespace token from <code>self</code>.\nReturn the next non-whitespace token from <code>self</code>.\nReturn the next non-whitespace token from <code>self</code>, with a …\nParses a generic scalar type, for example <code>&lt;f32&gt;</code>.\nParses a generic scalar type, for example <code>&lt;f32&gt;</code>.\nIf the next token matches it is skipped and true is …\nAbstract Float (IEEE-754 binary64)\nAbstract Int (-2^63 ≤ i &lt; 2^63)\nConcrete f32\nConcrete f64\nConcrete i32\nConcrete i64\nWhen using this type assume no Abstract Int/Float for now\nConcrete u32\nConcrete u64\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKeywords for WGSL (WebGPU Shading Language).\nAn unsigned 32-bit value known not to be <code>u32::MAX</code>.\nReturns the argument unchanged.\nConstruct a <code>NonMaxU32</code> whose value is <code>index</code>.\nReturn the value of <code>self</code> as a <code>u32</code>.\nCalls <code>U::from(self)</code>.\nConstruct a <code>NonMaxU32</code> whose value is <code>n</code>, if possible.\nConstruct a <code>NonMaxU32</code> whose value is <code>n</code>.\nA newtype struct where its only valid values are powers of …\nA context for evaluating constant expressions.\nHelper class to emit expressions\nA type stored in the associated arena.\nIf const is also implemented as const\nHelper processor that derives the sizes of all types.\nThis processor assigns names to all the things in a module …\nSize and alignment information for a type.\nThe result of computing an expression’s type.\nA free-floating <code>TypeInner</code>, representing a type that may …\nWhich language’s evaluation rules we should follow.\nThe module’s constant arena.\nEnsure that the given block has return statements at the …\nTry to evaluate the expression in the <code>arena</code> using its …\nTry to evaluate the expression in <code>self.global_expressions</code> …\nTry to evaluate the expression in the <code>arena</code> using its …\nTracks the constness of expressions residing in …\nThe arena to which we are contributing expressions.\nReturn an iterator over the individual components …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDefinitions for index bounds checking.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLayouts for types in an arena.\nThe module’s override arena.\nThe module’s type arena.\nThe last numeric suffix used for each base name. Zero …\nMaps to <code>Literal::AbstractFloat</code>\nMaps to <code>Literal::AbstractFloat</code>\nMaps to <code>Literal::AbstractFloat</code>\nMaps to <code>Literal::AbstractInt</code>\nMaps to <code>Literal::AbstractInt</code>\nA subset of <code>Literal</code>s intended to be used for implementing …\nconst-expressions will be evaluated and inserted in the …\nconst-expressions will be evaluated and inserted in the …\nA context for evaluating constant expressions.\nMaps to <code>Literal::F32</code>\nMaps to <code>Literal::F32</code>\nMaps to <code>Literal::F32</code>\nA subset of <code>Literal</code>s intended to be used for implementing …\nMaps to <code>Literal::I32</code>\nMaps to <code>Literal::I32</code>\nMaps to <code>Literal::I32</code>\nMaps to <code>Literal::I64</code>\nIf const is also implemented as const\nconst-expressions will be evaluated and inserted in the …\nconst-expressions will be evaluated and inserted in the …\nconst-expressions will be evaluated and inserted in the …\nA subset of <code>Literal</code>s intended to be used for implementing …\nA subset of <code>Literal</code>s intended to be used for implementing …\nTrait for conversions of abstract values to concrete types.\nMaps to <code>Literal::U32</code>\nMaps to <code>Literal::U32</code>\nMaps to <code>Literal::U64</code>\nWhich language’s evaluation rules we should follow.\nConvert the scalar components of <code>expr</code> to <code>target</code>.\nConvert the scalar leaves of  <code>expr</code> to <code>target</code>, handling …\nAttempts to evaluate multiple <code>exprs</code> as a combined …\nA convenience macro for using the same RHS for each …\nAttempts to evaluate multiple <code>exprs</code> as a combined <code>Float</code> to …\nA convenience macro for using the same RHS for each <code>Float</code> …\nAttempts to evaluate multiple <code>exprs</code> as a combined <code>Scalar</code> …\nA convenience macro for using the same RHS for each <code>Scalar</code> …\nAttempts to evaluate multiple <code>exprs</code> as a combined <code>Signed</code> …\nA convenience macro for using the same RHS for each <code>Signed</code> …\nThe module’s constant arena.\nDeep copy <code>expr</code> from <code>expressions</code> into <code>self.expressions</code>.\nLower <code>ZeroValue</code> expressions to <code>Literal</code> and <code>Compose</code> …\nLower <code>ZeroValue</code> and <code>Splat</code> expressions to <code>Literal</code> and …\nLower <code>ZeroValue</code> expressions to <code>Literal</code> and <code>Compose</code> …\nTracks the constness of expressions residing in …\nThe arena to which we are contributing expressions.\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nReturn a <code>ConstantEvaluator</code> that will add expressions to …\nForces the the expression to not be const\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobal constant expressions\nReturns <code>true</code> if the inner WGSL/GLSL restrictions are …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the <code>Self::expressions</code> arena the global module …\nReturns <code>true</code> if naga can also evaluate expression as const\nThe module’s override arena.\nSplat <code>value</code> to <code>size</code>, without using <code>Splat</code> expressions.\nTry to evaluate <code>expr</code> at compile time.\nConvert an abstract literal <code>value</code> to <code>Self</code>.\nThe module’s type arena.\nA macro that allows dollar signs (<code>$</code>) to be emitted by …\nHelper class to emit expressions\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPolicies for injecting bounds checks during code …\nHow should code generated by Naga do bounds checks?\nThe number of elements is determined at runtime.\nAn index that may be statically known, or may need to be …\nThe number of elements in an indexable type.\nValues of this type always have the given number of …\nOut-of-bounds reads return zero, and writes have no effect.\nReplace out-of-bounds indexes with some arbitrary …\nNaga adds no checks to indexing operations. Generate the …\nDetermine whether <code>index</code> is statically known to be in …\nHow should the generated code handle binding array indexes …\nHow should the generated code handle array, vector, or …\nDetermine which policy applies to <code>base</code>.\nReturn <code>true</code> if any of <code>self</code>’s policies are <code>policy</code>.\nBuild a set of expressions used as indices, to cache in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHow should the generated code handle image texel loads …\nHow should the generated code handle array, vector, or …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a <code>GuardedIndex::Known</code> from a <code>GuardedIndex::Expression</code> …\nA newtype struct where its only valid values are powers of …\nHelper processor that derives the sizes of all types.\nSize and alignment information for a type.\nRemove all entries from this <code>Layouter</code>, retaining storage.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPanics\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether or not <code>n</code> is a multiple of this alignment.\nLayouts for types in an arena.\nRound <code>n</code> up to the nearest alignment boundary.\nProduce the stride as if this type is a base of an array.\nExtend this <code>Layouter</code> with layouts for any new entries in …\nA string wrapper type with an ascii case insensitive Eq …\nThis processor assigns names to all the things in a module …\nReturn a new identifier based on <code>label_raw</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnter a local namespace for things like structs.\nReturn a form of <code>string</code> suitable for use as the base of an …\nThe last numeric suffix used for each base name. Zero …\nEnsure that the given block has return statements at the …\nA type stored in the associated arena.\nThe result of computing an expression’s type.\nA free-floating <code>TypeInner</code>, representing a type that may …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermine the type of <code>expr</code>.\nInitialize a resolve context from the module.\nConvenience trait for <code>Error</code> to be able to apply spans to …\nConvenience trait for <code>Result</code>, adding a …\nA human-readable representation for a span, tailored for …\nA source code span, used for error reporting.\nA source code span together with “context”, a …\nTrait abstracting over getting a span from an <code>Arena</code> or a …\nWrapper class for <code>Error</code>, augmenting it with a list of …\nConvert inner error into another type. Joins span …\nEmits a summary of the error to standard error stream.\nEmits a summary of the error to standard error stream.\nEmits a summary of the error to a string.\nEmits a summary of the error to a string.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReverse of <code>Self::new</code>, discards span information and …\nConvert inner error using <code>From</code>.\nCheck whether <code>self</code> was defined or is a default/unknown span\nLength in code units (in bytes) of the span.\n1-based line number.\n1-based column in code units (in bytes) of the start of …\nReturn a <code>SourceLocation</code> for this span in the provided …\nReturn a <code>SourceLocation</code> for our first span, if we have one.\nCreates a new <code>Span</code> from a range of byte indices\nCreate a new <code>WithSpan</code> from an <code>Error</code>, containing no spans.\n0-based Offset in code units (in bytes) of the start of …\nIterator over stored <code>SpanContext</code>s.\nModifies <code>self</code> to contain the smallest <code>Span</code> possible that …\nConverts <code>self</code> to a range if the span is not unknown\nReturns the smallest <code>Span</code> possible that contains all the …\nReturns a new <code>Span</code> starting at <code>self</code> and ending at <code>other</code>\nAdd a <code>SpanContext</code>.\nAdd a <code>Handle</code> from either <code>Arena</code> or <code>UniqueArena</code>, borrowing …\nSee <code>WithSpan::new</code>.\nAdd a new span with description.\nSee <code>WithSpan::with_context</code>.\nSee <code>WithSpan::with_handle</code>.\nSee <code>WithSpan::with_span</code>.\nreductions, scans\nballot, broadcast\nElect, Barrier\nGroup, binding, and location attributes.\nStatements and blocks of them.\nSupport for <code>BuiltIn::ClipDistance</code>.\nConstants.\nUniformity of control flow for operations that require it.\nSupport for arrayed cube textures.\nSupport for <code>BuiltIn::CullDistance</code>.\nAllowed IR capabilities.\nSupport for generating two sources for blending from …\nSupport for <code>early_depth_test</code>.\nExpressions.\nInformation about an expression in a function body.\nFloat values with width = 8.\nIndicates how a global variable is used.\nSupport for <code>BuiltIn::SampleIndex</code> and <code>Sampling::Sample</code>.\nSupport for <code>BuiltIn::ViewIndex</code>.\nSupport for <code>BuiltIn::PrimitiveIndex</code>.\nSupport for <code>AddressSpace::PushConstant</code>.\nSupport for ray queries and acceleration structures.\nSupport for non-uniform indexing of sampled textures and …\nSupport for non-uniform indexing of samplers.\nSupport for 64-bit signed and unsigned integers.\nSupport for all atomic operations on 64-bit integers.\nSupport for <code>AtomicFunction::Min</code> and <code>AtomicFunction::Max</code> on …\nshuffle, shuffle xor\nshuffle up, down\nSupport for 16-bit normalized storage texture formats.\nHost-shareable structure layouts.\nSupport for subgroup operations. Implies support for …\nSupport for subgroup barriers.\nSupport for subgroup operations in the vertex stage.\nValidation flags.\nSupported subgroup operations\nFlags associated with <code>Type</code>s by <code>Validator</code>.\nSupport for non-uniform indexing of uniform buffers and …\nUniform control flow characteristics.\nKinds of expressions that require uniform control flow.\nAny, All\nValidation flags.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nModule analyzer.\nThe global variable into which this expression produces a …\nSet of shader stages where calling this function is valid.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIndicates that the function is using dual source blending.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nInformation about each expression in this function’s …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nValidation flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nHow this function and its callees use this module’s …\nImplementation of <code>Validator::validate_module_handles</code>.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nFunction may kill the invocation.\nA checklist of expressions that must be visited by a …\nConstruct a new validator instance.\nA child expression with non-uniform result.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nPopulates <code>self.const_expression_types</code>\nBuilds the <code>FunctionInfo</code> based on the function, and …\nThe number of statements and other expressions using this …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIf this expression requires uniform control flow, store …\nReset the validator internals\nAll (texture, sampler) pairs that may be used together in …\nAll pairs of (texture, sampler) globals that may be used …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe type of this expression.\nWhether this expression is uniform, and why.\nUniformity characteristics.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nCheck the given module to be valid.\nValidates that all handles within <code>module</code> are:\nCheck the given module to be valid.\nInformation about an expression in a function body.\nUniformity characteristics of a function.\nIndicates how a global variable is used.\nControl flow may be killed. Anything after <code>Statement::Kill</code> …\nControl flow may return from the function, which makes all …\nNo value.\nThe information about the data is queried.\nData will be read from the variable.\nSome value of type <code>T</code>.\nUniform control flow characteristics.\nDisruptor of the uniform control flow.\nKinds of expressions that require uniform control flow.\nData will be written to the variable.\nRecord a use of <code>expr</code>, and indicate which global variable it\nRecord a use of <code>expr</code> for its value.\nRecord a use of <code>expr</code> of the sort given by <code>global_use</code>.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nThe global variable into which this expression produces a …\nSet of shader stages where calling this function is valid.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIndicates that the function is using dual source blending.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nReturns a disruptor based on the stored exit flags, if any.\nInformation about each expression in this function’s …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nValidation flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nHow this function and its callees use this module’s …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nFunction may kill the invocation.\nA child expression with non-uniform result.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nAnalyzes the uniformity requirements of a block (as a …\nInherit information from a called function.\nCompute the <code>ExpressionInfo</code> for <code>handle</code>.\nThe number of statements and other expressions using this …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nIf this expression requires uniform control flow, store …\nAll (texture, sampler) pairs that may be used together in …\nAll pairs of (texture, sampler) globals that may be used …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe type of this expression.\nWhether this expression is uniform, and why.\nUniformity characteristics.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe control can break.\nThe control can continue.\nThe control can return out of this block.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis type can be passed as a function argument.\nA WGSL constructible type.\nThe data can be copied around.\nCan be used for data variables.\nContains the error value\nCan be used for host-shareable structures.\nCan be be used for user-defined IO between pipeline stages.\nContains the success value\nThe data type has a size known by pipeline creation time.\nFlags associated with <code>Type</code>s by <code>Validator</code>.\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nDetermine whether a pointer in <code>space</code> can be passed as an …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.")