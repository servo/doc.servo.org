searchState.loadedDescShard("miniz_oxide", 0, "A pure rust replacement for the miniz DEFLATE/zlib …\nNot implemented.\nBuffer-related error.\nError in inflation; see <code>inflate::stream::inflate()</code> for …\nHow compressed data is wrapped.\nContains the error value\nUnused\nAttempt to flush the remaining data and end the stream.\nSame as <code>Sync</code>, but resets the compression dictionary so …\nA list of miniz failed status codes.\nA list of flush types.\n<code>Result</code> alias for all miniz status codes both successful …\nA list of miniz successful status codes.\nUnused\nUnused\nDon’t force any flushing. Used when more input data is …\nContains the success value\nOperation succeeded.\nBad parameters.\nZlib partial flush. Currently treated as <code>Sync</code>.\nRaw DEFLATE.\nGeneral stream error.\nOperation succeeded and end of deflate stream was found.\nA structure containing the result of a call to the inflate …\nFinish compressing the currently buffered data, and output …\nUnused\nZlib wrapped but ignore and don’t compute the adler32 …\nWrapped using the zlib format.\nThe number of bytes consumed from the input slice.\nThe number of bytes written to the output slice.\nThis module contains functionality for compression.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis module contains functionality for decompression.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an MZFlush value from an integer value.\nThe return status of the call.\nSlow/high compression. Do a lot of checks to try to find …\nFast compression. Uses a special compression routine that …\nHow much processing the compressor should do to compress …\nUse the default compression level.\nDefault compromise between speed and compression.\nDon’t do any compression, only output uncompressed …\nEven more checks, can be very slow.\nBuffer wrappers implementing default so we can allocate …\nCompress the input data to a vector, using the specified …\nSimple function to compress data to a vec.\nCompress the input data to a vector, using the specified …\nStreaming compression functionality.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExtra streaming compression functionality.\nSize of the buffer of lz77 encoded data.\nSize of hash values in the hash chains.\nHow many bits to shift when updating the current hash …\nSize of the chained hash tables.\nSize of the output buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUsage error.\nCallback function and user used in <code>compress_to_output</code>.\nStrategy setting for compression.\nMain compression struct.\nTables for distances.\nDon’t use any of the special strategies.\nCompression succeeded and the deflate stream was ended.\nContains the error value\nOnly use matches that are at least 5 bytes long.\nTry to flush everything and end the deflate stream.\nOnly use static/fixed blocks. (Blocks using the default …\nSame as <code>Sync</code>, but reset the dictionary so that the …\nTables for the run-length encoded huffman lengths for …\nDon’t look for matches, only huffman encode the literals.\nA struct containing data about huffman codes and symbol …\nNumber of extra bits distances above 512.\nBase values to calculate distances above 512.\nNumber of extra bits for length values.\nLength code for length values.\nSize of hash chain for fast compression mode.\nTables used for literal/lengths in <code>HuffmanOxide</code>.\nSize of the chained hash table.\nMask used when stepping through the hash chains.\nLiteral/length codes\nDistance codes.\nHuffman length values.\nThe number of huffman tables used by the compressor. …\nThe maximum length of a match.\nThe minimum length of a match.\nThe maximum number of checks for matches in the hash table …\nNormal operation.\nContains the success value\nCompression succeeded normally.\nError putting data into output buffer.\nOnly look for matches with a distance of 1, i.e do …\nStatus of RLE encoding of huffman code lengths.\nNumber of extra bits for distances smaller than 512.\nDistance codes for distances smaller than 512.\nTry to flush all the current data and output an empty raw …\nA list of deflate flush types.\nReturn status of compression.\nGet the adler32 checksum of the currently encoded data.\nBuffer of input data. Padded with 1 byte to simplify …\nThe length of the huffman code assigned to the symbol.\nThe bits of the huffman code assigned to the symbol\nMain compression function. Tries to compress as much as …\nMain compression function. Callbacks output.\nNumber of occurrences of each symbol.\nCreate a set of compression flags using parameters used by …\nReturns whether the compressor is wrapping the data in a …\nInitialize the compressor with a level of 4, zlib wrapper …\nTry to find a match for the data at lookahead_pos in the …\nGet the raw compressor flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPut HuffmanOxide on the heap with default trick to avoid …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum number of checks in the hash chain, for the …\nCreate a new <code>CompressorOxide</code> with the given flags.\nGet the return status of the previous <code>compress</code> call with …\nDo an unaligned read of the data at <code>pos</code> in the dictionary …\nDo an unaligned read of the data at <code>pos</code> in the dictionary …\nDo an unaligned read of the data at <code>pos</code> in the dictionary …\nReset the state of the compressor, keeping the same …\nReset state, saving settings.\nSet the compression level of the compressor.\nSet the compression level of the compressor using an …\nUpdate the compression settings of the compressor.\nShould we compute the adler32 checksum.\nOnly use matches that are at least 6 bytes long.\nForce the compressor to only output raw/uncompressed …\nForce the compressor to only output static blocks. (Blocks …\nShould we use greedy parsing (as opposed to lazy parsing …\nUsed in miniz to skip zero-initializing hash and dict. We …\nOnly look for matches with a distance of 0.\nWhether to use a zlib wrapper.\nThe 16-bit value consisting of CMF and FLG must be …\nGenerate FCHECK from CMF and FLG (without FCKECH )so that …\nCreate a zlib header from the given compression flags. …\nGet the zlib header for the level using the default window …\nTry to compress from input to output with the given …\nThe decompression went fine, but the adler32 checksum did …\nThe output buffer is an invalid size; consider the <code>flags</code> …\nStruct return when decompress_to_vec functions fail.\nFinished decompression without issues.\nFailed to decompress due to invalid data.\nMore input data was expected, but the caller indicated …\nThere is still pending data that didn’t fit in the …\nThe decompressor needs more input data to continue …\nReturn status codes.\nStreaming decompression functionality.\nDecompress one or more source slices from an iterator into …\nDecompress the deflate-encoded data in <code>input</code> to a vector.\nBackend of various to-<code>Vec</code> decompressions.\nDecompress the deflate-encoded data in <code>input</code> to a vector.\nDecompress the deflate-encoded data (with a zlib wrapper) …\nDecompress the deflate-encoded data (with a zlib wrapper) …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe currently decompressed data if any.\nDecompressor status on failure. See TINFLStatus for …\nExtra streaming decompression functionality.\nThe mask used when indexing the base/extra arrays.\nBase length for each distance code.\nNumber of extra bits for each distance code.\nMain decompression struct.\nThe maximum length of a code that can be looked up in the …\nThe size of the fast lookup table.\nA struct containing huffman code lengths and the huffman …\nBase length for each length code.\nNumber of extra bits for each length code.\nThe length of the first (literal/length) huffman table.\nThe length of the second (distance) huffman table.\nThe number of huffman tables used.\nThe length of the last (huffman code length) huffman table.\nReturns the adler32 checksum of the currently decompressed …\nReturns the adler32 that was read from the zlib header if …\nPresumes that there is at least match_len bytes in output …\nBuffer of input data.\nThe type of the current block.\n1 if the adler32 value should be checked.\nLength of the code at each index.\nVariable used for match length, symbols, and a number of …\nTry to decode the next huffman code, and puts it in the …\nMain decompression function. Keeps decompressing data from …\nFast inner decompression loop which is run  while there is …\nCreate a new tinfl_decompressor with all fields set to 0.\nLast match distance.\nLook for a symbol in the fast lookup table. The symbol is …\nEnsure that there is data in the bit buffer.\n1 if the current block is the last block, 0 otherwise.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFlags to <code>decompress()</code> to control how inflation works.\nSet the current state to <code>Start</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHuffman length codes.\nFast lookup table for shorter huffman codes.\nLook up a symbol and code length from the bits in the …\nSets the value of all the elements of the slice to <code>val</code>.\nCreate a new tinfl_decompressor with all fields set to 0.\nNumber of bits in the bit buffer.\nNumber of extra bits for the last length or distance code.\nRaw block header.\nTry to read <code>amount</code> number of bits from <code>in_iter</code> and call …\nTry to read one byte from <code>in_iter</code> and call <code>f</code> with the read …\nRead an le u16 value from the slice iterator.\nRead an le u32 value from the slice iterator.\nCurrent state of the decompressor.\nNumber of entries in each huffman table.\nHuffman tables.\nFull huffman tree.\nGet the symbol and the code length from the huffman tree.\nCheck that the zlib header is correct and that there is …\nAdler32 checksum from the zlib header.\nZlib CMF\nZlib FLG\nCalculate the adler32 checksum of the output data even if …\nThere will be more input that hasn’t been given to the …\nIgnore adler32 checksum even if we are inflating a zlib …\nShould we try to parse a zlib header?\nThe output buffer should not wrap around.\nA wrapper for the output slice used when decompressing.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWrite a byte to the current position and increment\nWrite a slice to the current position and increment\nFull reset of the state, including zeroing memory.\nA struct that compbines a decompressor with extra data for …\nResets state, without performing expensive ops (e.g. …\nTag that determines reset policy of InflateState\nResets state and zero memory, continuing to use the same …\nWhether the input data is wrapped in a zlib header and …\nInner decompressor struct\nAccess the innner decompressor.\nBuffer of input bytes for matches. TODO: Could probably do …\nHow many bytes of data to be flushed is there currently in …\nWhere in the buffer are we currently at?\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to decompress from <code>input</code> to <code>output</code> with the given …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the status of the last call to <code>inflate</code> with this …\nCreate a new state.\nCreate a new state on the heap.\nCreate a new state using miniz/zlib style window bits …\nPerforms reset\nReset the decompressor without re-allocating memory, using …\nResets the state according to specified policy.")