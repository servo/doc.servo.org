searchState.loadedDescShard("selectors", 0, "A cache to speed up matching of nth-index-like selectors.\nOpaque representation of an Element, for identity …\nAdd hashes unique to this element to the given filter, …\nSets selector flags on the elemnt itself or the parent, …\nCounting and non-counting Bloom filters tuned for use as …\nHelper module to build up a selector safely and …\nThe host of the containing shadow root, if any.\nSkips non-element nodes\nEmpty string for no namespace\nReturns the mapping from the <code>exportparts</code> attribute in the …\nReturns whether this element matches <code>:empty</code>.\nReturns whether the element is an HTML  element.\nWhether this element is a <code>link</code>.\nWhether we’re matching on a pseudo-element.\nReturns whether this element matches <code>:root</code>, i.e. whether …\nWhether this element and the <code>other</code> element have the same …\nKleen logic: …\nSkips non-element nodes\nConverts self into an opaque representation.\nWhether the parent node of this element is a shadow root.\nSkips non-element nodes\nSmall helpers to abstract over different containers.\nTraits that nodes must implement. Breaks the …\nVisitor traits for selectors.\n‘i’ was specified.\nNo flags were specified and HTML says this is a …\nNo flags were specified and HTML says this is a …\n‘s’ was specified.\nThe definition of whitespace per CSS Selectors Level 3 § …\nEmpty string for no namespace\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA counting Bloom filter with 8-bit counters.\nStorage class for a CountingBloomFilter that has 1-bit …\nStorage class for a CountingBloomFilter that has 8-bit …\nA counting Bloom filter with parameterized storage to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInserts an item with a particular hash into the bloom …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck whether the filter might contain an item with the …\nCreates a new bloom filter.\nRemoves an item with a particular hash from the bloom …\nTop-level SelectorBuilder struct. This should be …\nFlags that indicate at which point of parsing a selector …\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nConsumes the builder, producing a Selector.\nBuilds with an explicit SpecificityAndFlags. This is …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe entire sequence of components. We make this large …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThere’s padding after this field due to the size of the …\nWhen you nest a pseudo-element with something like:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nReturns true if combinators have ever been pushed to this …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nCompletes the current compound selector and starts a new …\nPushes a simple selector onto the current compound …\nThe intersection of a source flags value with the …\nFinds the maximum specificity of elements in the list and …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThere are two free bits here, since we use ten bits for …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nAll links are matched as if they are unvisted.\nAll links are matched as if they are visited and unvisited …\nIgnores any stateless pseudo-element selectors in the …\nThe mode to use whether we should matching rules inside …\nLimited quirks mode.\nData associated with the matching process for a element.  …\nWhether we’re matching in the contect of invalidation.\nWhat kind of selector matching mode we should use.\nWhether we need to set selector invalidation flags on …\nAll without rules inside @starting-style. This is for the …\nNo quirks mode.\nDon’t ignore any pseudo-element selectors.\nQuirks mode.\nWhich quirks mode is this document in.\nA element’s “relevant link” is the element being …\nSet of caches (And cache-likes) that speed up expensive …\nThe mode to use when matching unvisited and visited links.\nGet the starting style. The starting style for an element …\nInput with the bloom filter used to fast-reject selectors.\nThe case-sensitivity for class and ID selectors\nThe current shadow host we’re collecting :host rules for.\nThe current element we’re anchoring on for evaluating …\nExtra implementation-dependent matching data.\nRun the given matching function for before/after …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether there are any rules inside @starting-style.\nWhether we’re matching inside a :not(..) selector.\nWhether we’re inside a negation or not.\nControls if we should match rules in @starting-style.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAre we matching for invalidation?\nWhether we’re matching a nested selector.\nWhether or not we’re matching to invalidate.\nWhether we’re matching in the contect of invalidation.\nWhether or not we’re comparing for invalidation, if we …\nThe matching-mode for this selector-matching operation.\nInput with the matching mode we should use when matching …\nWhether we need to set selector flags.\nRuns F with a deeper nesting level.\nRuns F with a deeper nesting level, and marking ourselves …\nRuns F with a deeper nesting level, with the given element …\nRuns F with a deeper nesting level, with the given element …\nRuns F with a deeper nesting level, with the given element …\nThe current nesting level of selectors that we’re …\nConstructs a new <code>MatchingContext</code>.\nConstructs a new <code>MatchingContext</code> for use in visited …\nA cache to speed up nth-index-like selectors.\nAn optional hook function for checking whether a …\nThe quirks mode of the document.\nA cache to speed up relative selector matches. See module …\nReturns the current anchor element to evaluate the …\nA map of bloom filters to fast-reject relative selector …\nThe element which is going to match :scope pseudo-class. …\nCaches to speed up expensive selector matches.\nReturns the current shadow host whose shadow root we’re …\nControls how matching for links is handled.\nRuns F with a given shadow host which is the root of the …\nRuns F with a different VisitedHandlingMode.\nFalse\nA “trilean” value based on Kleen logic.\nTrue\nEither true or false, but we’re not sure which yet.\nReturn true if any result of f() is true. Otherwise, …\nReturn false if any results of f() is false. Otherwise, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTurns this Kleene value to a bool, taking the unknown …\nThe element may anchor a relative selector.\nThe element may anchor a relative selector that is not the …\nWhether a compound selector matched, and whether it was …\nSet of flags that are set on either the element or its …\nThe selector was fully matched.\nWhen a child is added or removed from the parent, the …\nThe element has an empty selector, so when a child is …\nWhen a child is added or removed from the parent, all the …\nWhen a child is added or removed from the parent, any later\nHAS_SLOW_SELECTOR* was set by the presence of :nth (But …\nWhen a DOM mutation occurs on a child that might be …\nHolds per-compound-selector data.\nThe compound selector matched, and the next combinator …\nThe selector didn’t match.\nThe element is reached by a relative selector search in …\nThe element is reached by a relative selector search in …\nA result of selector matching, includes 3 failure types,\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nMatches a relative selector in a list of relative …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the subset of flags that apply to the parent.\nReturns the subset of flags that apply to the element.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nWhether the :hover and :active quirk applies.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nMatches a complex selector.\nMatches each selector of a list as a complex selector\nDetermines whether the given element matches the given …\nMatches a compound selector belonging to <code>selector</code>, …\nMatches a selector, fast-rejecting against a bloom filter.\nSame as matches_selector, but returns the Kleene value …\nDetermines whether the given element matches the given …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nGiven the ancestor hashes from a selector, see if the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nA cache to speed up matching of nth-index-like selectors.\nThe concrete per-pseudo-class cache.\nUse a different map of cached indices per :nth-child’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the appropriate cache for the given parameters.\nInserts an entry into the cache.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the cache is empty.\nDoes a lookup for a given element in the cache.\nWhether we’ve parsed a non-stateful pseudo-element …\nWhether we’ve parsed a ::part() pseudo-element already.\nWhether we are after any of the pseudo-like things.\nWhether we’ve parsed a pseudo-element (as in, an …\nWhether we’ve parsed a ::slotted() pseudo-element …\nAncestor hashes for the bloom filter. We precompute these …\nAn iterator over all simple selectors belonging to …\nAn attribute selector can have ‘s’ or ‘i’ as …\nComposition of combinators in a given selector, not …\nAn iterator over all combinators in a selector. Does not …\nA CSS simple selector or combinator. We store both in the …\nWhether we explicitly disallow combinators.\nWhether we explicitly disallow pseudo-element-like things.\nWhether we explicitly disallow relative selectors (i.e. …\nThis selector matches featureless shadow host via <code>:host</code>.\nThis selector matches featureless shadow host via <code>:scope</code>. …\nWhat kind of selectors potentially matching featureless …\nExpect selectors to start with a combinator, assuming …\nAllow selectors to start with a combinator, prepending a …\nAllow selectors to start with a combinator, prepending a …\nWhether or not we’re using forgiving parsing mode\nThe <code>:has</code> pseudo-class.\nThe <code>:host</code> pseudo-class:\nWhether we’ve parsed a pseudo-element which is in a …\nThe <code>SelectorImpl</code> this pseudo-element is used for.\nThe <code>SelectorImpl</code> this pseudo-element is used for.\n:scope added implicitly into scoped rules (i.e. In <code>@scope</code>) …\nWithin this element’s direct children.\nThis element’s next sibling.\nWithin this element’s next sibling’s subtree.\nWithin this element’s subsequent siblings.\nAcross this element’s subsequent siblings and their …\nWithin this element’s subtree.\nAn invalid selector inside :is() / :where().\nThe <code>:is</code> pseudo-class.\nPseudo-classes\nDiscard the entire selector list upon encountering any …\nTreat as parse error if any selector begins with a …\nA trait that represents a pseudo-class.\nnon tree-structural pseudo-classes (see: …\nThe properties that comprise an :nth- pseudoclass as of …\nThe properties that comprise an :nth- pseudoclass as of …\nAn enum for the different types of :nth- pseudoclasses\nFlag indicating if we’re parsing relative selectors.\nAnother combinator used for <code>::part()</code>, which represents the …\nThe <code>::part</code> pseudo-element. …\nA trait that represents a pseudo-element.\nA dummy combinator we use to the left of pseudo-elements.\nAn implementation-dependent pseudo-element selector.\npseudo-elements\nStorage for a relative selector.\nUsed only for relative selectors, which starts with a …\nCount of combinators in a given relative selector, not …\nFlag indicating where a given relative selector’s match …\nWhether we should avoid adding default namespaces to …\nA Selector stores a sequence of simple selectors and …\nThis trait allows to define the parser implementation in …\nUniquely identify a selector based on its components, …\nA selector list is a tagged pointer with either a single …\nFlags that indicate at which point of parsing a selector …\nAnother combinator used for ::slotted(), which represent …\nThe ::slotted() pseudo-element:\nThe <code>:where</code> pseudo-class.\nIgnore invalid selectors, potentially creating an empty …\nWhether the pseudo-element supports a given state selector …\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nGet a flags value with all known bits set.\nWhether to allow forgiving selector-list parsing.\nReturns the value as a combinator if applicable, None …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nGet the underlying bits value.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nReturns the combinator at index <code>index</code> (zero-indexed from …\nReturns the combinator at index <code>index</code> (zero-indexed from …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns selector data for :first-{child,of-type}\nReturns the fourth hash, reassembled from parts.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nGet a flags value with the bits of a flag with the given …\nCreates a SelectorList from a Vec of selectors. Used in …\nCreates a Selector from a vec of Components, specified in …\nGet the match hint based on the current combinator count.\nReturns a selector list with a single implicit <code>:scope</code> …\nAn implicit scope selector, much like :where(:scope).\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this pseudo-class is :active or :hover.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nWhether all known bits in this flags value are set.\nReturns true if this combinator is a child or descendant …\nReturns true if this is a combinator.\nReturns whether the name corresponds to a CSS2 …\nIs the match traversal direction towards the descendant of …\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether all bits in this flags value are unset.\nWhether this selector is a featureless selector matching …\nReturns true if this is a :host() selector.\nWhether this pseudo-element is in a pseudo-element tree …\nWhether the given function name is an alias for the <code>:is()</code> …\nIs the match traversal terminated at the next sibling?\nReturns true if this combinator is a pseudo-element …\nIs the compound starting at the offset the subject …\nReturns true if this combinator is a next- or …\nReturns true if this is an edge selector that is not `:*…\nDoes the match involve matching the subtree?\nWhether this selector (pseudo-element part excluded) …\nWhether this pseudo-class belongs to:\nYield a set of contained flags values.\nYield a set of contained flags values.\nReturns an iterator over this selector in matching order …\nYield a set of contained flags values.\nReturns an iterator over this selector in matching order …\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nYield a set of contained named flags values.\nReturns an iterator over the entire sequence of simple …\nReturns an iterator over the sequence of simple selectors …\nSame as <code>iter()</code>, but skips <code>RelativeSelectorAnchor</code> and its …\nDetails of this error\nReturns selector data for :last-{child,of-type}\nReturns count of simple selectors and combinators in the …\nLocation where this error occurred\nSee Arc::mark_as_intentionally_leaked\nSee Arc::mark_as_intentionally_leaked\nMatch space constraining hint.\nReturns if this component can match a featureless shadow …\nWhether this selector matches a featureless shadow host, …\nWhether a given selector (to the right of a …\nCreates an AncestorIter. The passed-in iterator is assumed …\nCreate a new key based on the given selector.\nReturns selector data for …\nCreate a new relative selector match hint based on its …\nCreate a new relative selector combinator count from a …\nPrepares this iterator to point to the next sequence to …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nReturns the An+B part of the selector\nReturns selector data for :only-{child,of-type}\nParse a comma-separated list of Selectors. …\nParse a selector, without any pseudo-element.\nsimple_selector_sequence : [ type_selector | universal ] [ …\nSame as <code>parse</code>, but disallow parsing of pseudo-elements.\nWhether to parse the :has pseudo-class.\nWhether to parse the <code>:host</code> pseudo-class.\nParses one compound selector suitable for nested stuff …\nWhether to parse <code>:is</code> and <code>:where</code> pseudo-classes.\nLevel 3: Parse <strong>one</strong> simple_selector.  (Though we might …\nThis function can return an “Err” pseudo-element in …\nWhether to parse the selector list of nth-child() or …\nParse a simple selector other than a type selector.\nWhether to parse the ‘&amp;’ delimiter as a parent …\nWhether to parse the <code>::part()</code> pseudo-element.\n<code>Err(())</code>: Invalid selector, abort<code>Ok(None(token))</code>: Not a …\nBuild up a Selector. selector : simple_selector_sequence [ …\nWhether to parse the <code>::slotted()</code> pseudo-element.\n<code>Err(())</code>: Invalid selector, abort<code>Ok(false)</code>: Not a type …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nReplaces the parent selector in all the items of the …\nReturns a selector list with a single <code>:scope</code> selector …\nThe selector. Guaranteed to contain <code>RelativeSelectorAnchor</code> …\nReturns remaining count of the simple selectors and …\nReturns the selector list part of the selector\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nWhether attribute hashes should be collected for filtering …\nSkips a sequence of simple selectors and all subsequent …\nThe count we contribute to the specificity from this …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nReturns the address on the heap of the ThinArc for memory …\nReturns the address on the heap of the ThinArc for memory …\nReturns a Cow::Borrowed if <code>s</code> is already ASCII lowercase, …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nWhether this pseudo-element is valid after a ::slotted(..) …\nTraverse selector components inside <code>self</code>.\nSerialize &lt;an+b&gt; (part of the CSS Syntax spec, but …\nWrites the beginning of the selector.\nThis selector matches this element.\nThis selector does not match this element.\nCache to speed up matching of relative selectors.\nMatch data for a given element and a selector.\nAdd a relative selector match into the cache.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if we have a cache entry for the element.\nIs the cached result a match?\nFilter lookup happened more than once, and the filter for …\nFilter lookup happened once. Construction of the filter is …\nMap of bloom filters for fast-rejecting relative selectors.\nPotentially reject the given selector for this element. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA trait to abstract over a <code>push</code> method that may be …\nPush a value into self.\nOpaque representation of an Element, for identity …\nAdd hashes unique to this element to the given filter, …\nSets selector flags on the elemnt itself or the parent, …\nReturns a const ptr to the contained reference.\nReturns the assigned  element this element is assigned to.\nReturns the assigned  element this element is assigned to.\nThe host of the containing shadow root, if any.\nSkips non-element nodes\nReturns the argument unchanged.\nEmpty string for no namespace\nReturns whether this element should ignore matching nth …\nReturns whether this element should ignore matching nth …\nReturns the mapping from the <code>exportparts</code> attribute in the …\nCalls <code>U::from(self)</code>.\nReturns whether this element matches <code>:empty</code>.\nReturns whether the element is an HTML  element.\nWhether this element is a <code>link</code>.\nWhether we’re matching on a pseudo-element.\nReturns whether this element matches <code>:root</code>, i.e. whether …\nWhether this element and the <code>other</code> element have the same …\nCreates a new OpaqueElement from an arbitrarily-typed …\nSkips non-element nodes\nConverts self into an opaque representation.\nWhether the parent node of this element is a shadow root.\nSkips non-element nodes\nThe parent of a given pseudo-element, after matching a …\nThe parent of a given pseudo-element, after matching a …\nThe visitor is inside :has(..)\nThe visitor is inside :is(..)\nThe selector implementation this visitor wants to visit.\nThe visitor is inside :not(..)\nThe visitor is inside :nth-child(.. of ) or …\nThe kinds of components the visitor is visiting the …\nA trait to visit selector properties.\nThe visitor is inside :where(..)\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nConstruct a SelectorListKind for the corresponding …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nWhether the visitor is inside :has(..)\nWhether the visitor is inside :is(..)\nWhether the visitor is inside :not(..)\nWhether the visitor is inside :nth-child(.. of ) or …\nWhether the visitor is inside :where(..)\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether this nested selector is relevant for nth-of …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nVisit an attribute selector that may match (there are …\nVisits a complex selector.\nVisit a nested relative selector list. The caller is …\nVisit a nested selector list. The caller is responsible to …\nVisit a simple selector.")