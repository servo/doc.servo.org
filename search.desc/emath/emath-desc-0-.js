searchState.loadedDescShard("emath", 0, "Opinionated 2D math library for building GUIs.\nExtension trait to provide <code>ord()</code> method.\nThis struct tracks recent values of some time series.\nIs this an integer type?\nLargest finite value\nSmallest finite value\nExtends <code>f32</code>, <code>Vec2</code> etc with <code>at_least</code> and <code>at_most</code> as aliases …\nImplemented for all builtin numeric types\nHelper trait to implement <code>lerp</code> and <code>remap</code>.\nWraps a floating-point value to add total order and hash. …\nA position on screen.\nInclusive range of floats, i.e. <code>min..=max</code>, but more …\nHelper trait to implement <code>lerp</code> and <code>remap</code>.\nA rectangular region of space.\nLinearly transforms positions from one <code>Rect</code> to another.\nRepresents a rotation in the 2D plane.\nLinearly transforms positions via a translation, then a …\nA vector has a direction and length. A <code>Vec2</code> is often used …\nTwo bools, one for each axis (X and Y).\nOne- and two-dimensional alignment (<code>Align::Center</code>, …\nReturn true when arguments are the same within some …\nMore readable version of <code>self.max(lower_limit)</code>\nMore readable version of <code>self.min(upper_limit)</code>\n<code>angle.cos()</code>\nEase in, ease out.\nEasing functions for animations.\nCalculate a lerp-factor for exponential smoothing using a …\nUse as few decimals as possible to show the value …\nIf you have a value animating over time, how much towards …\nWhere in the range is this value? Returns 0-1 if within …\nLinear interpolation.\nThe other corner, opposing <code>Self::min</code>. Usually the right …\nIn seconds.\nIn elements, i.e. of <code>values.len()</code>.\nOne of the corners of the rectangle, usually the left top …\nIn elements, i.e. of <code>values.len()</code>. The length is initially …\nWrap angle to <code>[-PI, PI]</code> range.\nType to provide total order, useful as key in sorted …\nTotal order on floating point types. Can be used for …\n<code>pos2(x, y) == Pos2::new(x, y)</code>\nLinearly remap a value from one range to another, so that …\nLike <code>remap</code>, but also clamps the value so that the returned …\nRound a value to the given number of decimal places.\n<code>angle.sin()</code>\nScaling applied first, scaled around (0, 0).\nFind “simple” numbers is some range. Used by sliders.\nTotal number of elements seen ever\nTranslation amount, applied after scaling.\n(time, value) pairs, oldest front, newest back. Time …\n<code>vec2(x, y) == Vec2::new(x, y)</code>\nHow far to the right.\nRightwards. Width.\nHow far down.\nDownwards. Height.\nleft/center/right or top/center/bottom alignment for e.g. …\nTwo-dimension alignment, e.g. <code>Align2::LEFT_TOP</code>.\nConvenience for <code>Self::Max</code>\nHorizontal or vertical center.\nConvenience for <code>Self::Min</code>\nRight or bottom.\nLeft or top.\nConvenience for <code>Self::Max</code>\nConvenience for <code>Self::Min</code>\nReturns a range of given size within a specified range.\ne.g. center a size within a given frame\nUsed e.g. to anchor a piece of text to a part of the …\nUse this anchor to position something around <code>pos</code>, e.g. …\nAllocates a rectangle of the specified <code>size</code> inside the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the point on the rect’s frame or in the center …\nConvert <code>Min =&gt; 0.0</code>, <code>Center =&gt; 0.5</code> or <code>Max =&gt; 1.0</code>.\nConvert <code>Min =&gt; -1.0</code>, <code>Center =&gt; 0.0</code> or <code>Max =&gt; 1.0</code>.\n-1, 0, or +1 for each axis\nReturns an alignment by the X (horizontal) axis\nReturns an alignment by the Y (vertical) axis\nhttps://easings.net/#easeInBack\nhttps://easings.net/#easeInOutBack\nhttps://easings.net/#easeOutBack\nhttps://easings.net/#easeInBounce\nhttps://easings.net/#easeInOutBounce\nhttps://easings.net/#easeOutBounce\nhttps://easings.net/#easeInCirc\nhttps://easings.net/#easeInOutCirc\nhttps://easings.net/#easeOutCirc\nhttps://easings.net/#easeInCubic\nhttps://easings.net/#easeInOutCubic\nhttps://easings.net/#easeOutCubic\nhttps://easings.net/#easeInExpo\nhttps://easings.net/#easeInOutExpo\nhttps://easings.net/#easeOutExpo\nNo easing, just <code>y = x</code>\nhttps://easings.net/#easeInQuad\nhttps://easings.net/#easeInOutQuad\nhttps://easings.net/#easeOutQuad\nhttps://easings.net/#easeInSine\nhttps://easings.net/#easeInOutSine\nhttps://easings.net/#easeOuSine\nThis struct tracks recent values of some time series.\nValues must be added with a monotonically increasing time, …\nAverage times rate. If you are keeping track of individual …\nAmount of time contained from start to end in this <code>History</code>.\nRemove samples that are too old.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>(time, value)</code> pairs Time difference between values can be …\nCurrent number of values kept in history\nIn seconds.\nIn elements, i.e. of <code>values.len()</code>.\nMean time difference between values in this <code>History</code>.\nIn elements, i.e. of <code>values.len()</code>. The length is initially …\nExample:\nTotal number of values seen. Includes those that have been …\nTotal number of elements seen ever\n(time, value) pairs, oldest front, newest back. Time …\nCalculate a smooth velocity (per second) over the entire …\nIs this an integer type?\nLargest finite value\nSmallest finite value\nImplemented for all builtin numeric types\nExtension trait to provide <code>ord()</code> method.\nWraps a floating-point value to add total order and hash. …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nType to provide total order, useful as key in sorted …\nA position on screen.\nThe zero position, the origin. The top left corner in a …\nTrue if any member is NaN.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrue if all members are also finite.\nLinearly interpolate towards another point, so that …\n<code>pos2(x, y) == Pos2::new(x, y)</code>\nThe vector from origin to this position. <code>p.to_vec2()</code> is …\nHow far to the right.\nHow far down.\nInfinite range that contains everything, from -∞ to …\nAn invalid <code>Rangef</code> filled with <code>f32::NAN</code>.\nThe inverse of <code>Self::EVERYTHING</code>: stretches from positive …\nInclusive range of floats, i.e. <code>min..=max</code>, but more …\nFlip <code>min</code> and <code>max</code> if needed, so that <code>min &lt;= max</code> after.\nThe center of the range\nEquivalent to <code>x.clamp(min, max)</code>\nExpand by this much on each side, keeping the center\nFlip the min and the max\nReturns the argument unchanged.\nThe overlap of two ranges, i.e. the range that is …\nDo the two ranges intersect?\nCalls <code>U::from(self)</code>.\nShrink by this much on each side, keeping the center\nThe length of the range, i.e. <code>max - min</code>.\nInfinite rectangle that contains every point.\nAn invalid <code>Rect</code> filled with <code>f32::NAN</code>.\nThe inverse of <code>Self::EVERYTHING</code>: stretches from positive …\nA rectangular region of space.\nA <code>Rect</code> filled with zeroes.\nTrue if any member is NaN.\nWidth / height\n<code>max.y</code>\n<code>max.y</code>\nReturn the given points clamped to be inside the rectangle …\nThe distance from the rect to the position, squared.\nThe distance from the rect to the position.\nA <code>Rect</code> that contains every point above a certain y …\nA <code>Rect</code> that contains every point below a certain y …\nA <code>Rect</code> that contains every point to the left of the given …\nA <code>Rect</code> that contains every point to the right of the given …\nExpand by this much in each direction, keeping the center\nExpand by this much in each direction, keeping the center\nExpand to include the given x coordinate\nExpand to include the given y coordinate\nReturns the argument unchanged.\nleft-top corner plus a size (stretching right-down).\nBounding-box around the points.\nA zero-sized rect at a specific point.\nReturns the bounding rectangle of the two points.\nThe intersection of two <code>Rect</code>, i.e. the area covered by …\nDoes this Rect intersect the given ray (where <code>d</code> is …\nCalls <code>U::from(self)</code>.\nTrue if all members are also finite.\n<code>width &lt; 0 || height &lt; 0</code>\n<code>width &gt; 0 &amp;&amp; height &gt; 0</code>\n<code>min.x</code>\n<code>min.x</code>\nLinearly interpolate so that <code>[0, 0]</code> is <code>Self::min</code> and <code>[1, 1]</code>…\nLinearly self towards other rect.\nThe other corner, opposing <code>Self::min</code>. Usually the right …\nOne of the corners of the rectangle, usually the left top …\n<code>max.x</code>\n<code>max.x</code>\nRotate the bounds (will expand the <code>Rect</code>)\nScale up by this factor in each direction, keeping the …\nScale up by this factor in each direction, keeping the …\n<code>max.y</code>\nKeep size\nkeep min\n<code>min.x</code>\n<code>max.x</code>\n<code>min.y</code>\nkeep min\nShrink by this much in each direction, keeping the center\nShrink by this much in each direction, keeping the center\nSigned distance to the edge of the box.\n<code>rect.size() == Vec2 { x: rect.width(), y: rect.height() }</code>\nSplit rectangle in left and right halves. <code>t</code> is expected to …\nSplit rectangle in left and right halves at the given <code>x</code> …\nSplit rectangle in top and bottom halves. <code>t</code> is expected to …\nSplit rectangle in top and bottom halves at the given <code>y</code> …\n<code>[2, 1]</code> for wide screen, and <code>[1, 2]</code> for portrait, etc. At …\n<code>min.y</code>\n<code>min.y</code>\nThe union of two bounding rectangle, i.e. the minimum <code>Rect</code> …\nLinearly transforms positions from one <code>Rect</code> to another.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe scale factors.\nTransforms the given coordinate in the <code>from</code> space to the <code>to</code>…\nTransforms the given coordinate in the <code>from</code> space to the <code>to</code>…\nTransforms the given rectangle in the <code>in</code>-space to a …\nThe identity rotation: nothing rotates\nRepresents a rotation in the 2D plane.\n<code>angle.cos()</code>\nIdentity rotation\nReturns the argument unchanged.\nAngle is clockwise in radians. A 𝞃/4 = 90° rotation …\nCalls <code>U::from(self)</code>.\nThe factor by which vectors will be scaled.\n<code>angle.sin()</code>\nFind the “simplest” number in a closed range [min, max]…\nFind the simplest integer in the range [min, max]\nLinearly transforms positions via a translation, then a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInverts the transform.\nApplies the right hand side transform, then the left hand …\nTransforms the given coordinate.\nTransforms the given rectangle.\nCreates a new translation that first scales points around …\nScaling applied first, scaled around (0, 0).\nTranslation amount, applied after scaling.\n+Y\n-X\n+X\n-Y\nA vector has a direction and length. A <code>Vec2</code> is often used …\nRight\nDown\nMeasures the angle of the vector.\nCreate a unit vector with the given CW angle (in radians).\nTrue if any member is NaN.\nThe dot-product of two vectors.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrue if all members are also finite.\nReturns the maximum of <code>self.x</code> and <code>self.y</code>.\nReturns the minimum of <code>self.x</code> and <code>self.y</code>.\nSafe normalize: returns zero if input is zero.\nRotates the vector by 90°, i.e positive X to positive Y …\nSet both <code>x</code> and <code>y</code> to the same value.\nTreat this vector as a position. <code>v.to_pos2()</code> is equivalent …\n<code>vec2(x, y) == Vec2::new(x, y)</code>\nRightwards. Width.\nDownwards. Height.\nSwizzle the axes.\nTwo bools, one for each axis (X and Y).\nAre both <code>x</code> and <code>y</code> true?\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")