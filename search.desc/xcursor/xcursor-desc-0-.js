searchState.loadedDescShard("xcursor", 0, "A crate to load cursor themes, and parse XCursor files.\nA cursor theme.\nDirectories where the theme is presented and corresponding …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSearch for a theme with the given name in the given search …\nThe implementation of cursor theme loading.\nTry to load an icon from the theme. If the icon is not …\nTry to load an icon from the theme, returning it with its …\nThe implementation of cursor icon loading.\nTheme name.\nParse the content of the <code>index.theme</code> and return the …\nA module implementing XCursor file parsing.\nGlobal search path for themes.\nLoad the specified index.theme file, and returns a <code>Some</code> …\nGet the list of paths where the themes have to be searched,\nA struct representing an image. Pixels are in ARGB format, …\nThe amount of time (in milliseconds) that this image …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe actual height of the image. Doesn’t need to match …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse an XCursor file into its images.\nParse an XCursor file into its images.\nA slice containing the pixels’ bytes, in ARGB format.\nA slice containing the pixels’ bytes, in RGBA format …\nConverts a RGBA slice into an ARGB vec\nThe nominal size of the image.\nParse a series of bytes, returning <code>None</code> if it doesn’t …\nTake a slice of bytes.\nParse a 32-bit little endian number.\nThe actual width of the image. Doesn’t need to match <code>size</code>…\nThe X coordinate of the hotspot pixel (the pixel where the …\nThe Y coordinate of the hotspot pixel (the pixel where the …")