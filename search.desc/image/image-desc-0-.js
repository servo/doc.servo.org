searchState.loadedDescShard("image", 0, "Overview\nPixel is 8-bit alpha\nAnimationDecoder trait\nAn Image in AVIF format.\nPixel contains 8-bit B, G and R channels\nPixel is 8-bit BGR with an alpha channel\nAn Image in BMP Format\nAn Image in BMP Format\nThe number of channels of this pixel type.\nA string that can help to interpret the meaning each …\nThis pixel has the format of one of the predefined …\nPixel is 8-bit CMYK\nAn enumeration over supported color types and bit depths\nThe maximum value for this type of primitive within the …\nThe minimum value for this type of primitive within the …\nAn Image in DDS Format\nThe delay of a frame relative to the previous one.\nA Dynamic Image\nTypes which are safe to treat as an immutable byte slice …\nAn enumeration of color types encountered in image formats.\nAn Image in farbfeld Format\nAn Image in farbfeld Format\nA single animation frame\nAn implementation dependent iterator, reading the frames …\nA trait for manipulating images.\nTrait to inspect an image.\nAn Image in GIF Format\nAn Image in GIF Format\nSendable grayscale + alpha channel image buffer\nSendable grayscale image buffer\nAn Image in Radiance HDR Format\nAn Image in ICO Format\nAn Image in ICO Format\nGeneric image buffer\nThe trait that all decoders implement\nSpecialized image decoding not be supported by all formats\nThe trait all encoders implement\nAn enumeration of supported image formats. Not all formats …\nEach pixel in this image is 16-bit Luma\nEach pixel in this image is 8-bit Luma\nEach pixel in this image is 16-bit Luma with alpha\nEach pixel in this image is 8-bit Luma with alpha\nAn enumeration of supported image formats for encoding.\nEach pixel in this image is 16-bit Rgb\nEach pixel in this image is 32-bit float Rgb\nEach pixel in this image is 8-bit Rgb\nEach pixel in this image is 16-bit Rgb with alpha\nEach pixel in this image is 32-bit float Rgb with alpha\nEach pixel in this image is 8-bit Rgb with alpha\nAn Image in JPEG Format\nAn Image in JPEG Format with specified quality, up to 100\nPixel is 1-bit luminance\nPixel is 16-bit luminance\nPixel is 16-bit luminance\nPixel is 2-bit luminance\nPixel is 4-bit luminance\nPixel is 8-bit luminance\nPixel is 8-bit luminance\nPixel is 1-bit luminance with an alpha channel\nPixel is 16-bit luminance with an alpha channel\nPixel is 16-bit luminance with an alpha channel\nPixel is 2-bit luminance with an alpha channel\nPixel is 4-bit luminance with an alpha channel\nPixel is 8-bit luminance with an alpha channel\nPixel is 8-bit luminance with an alpha channel\nGrayscale colors.\nGrayscale colors + alpha channel\nAn Image in OpenEXR Format\nAn Image in OpenEXR Format\nA generalized pixel.\nThe type of pixel.\nThe pixel with an associated <code>ColorType</code>. Not all possible …\nImmutable pixel iterator\nAn Image in PNG Format\nAn Image in PNG Format\nAn Image in general PNM Format\nAn Image in one of the PNM Formats\nThe type of each channel in a pixel. For example, this can …\nRepresents the progress of an image operation.\nAn Image in QOI format.\nAn image in QOI Format\nThe type of reader produced by <code>into_reader</code>.\nRGB colors.\nPixel contains 1-bit R, G and B channels\nPixel is 16-bit RGB\nPixel contains 16-bit R, G and B channels\nPixel contains 2-bit R, G and B channels\nPixel is 32-bit float RGB\nPixel is 32-bit float RGB\nAn image buffer for 32-bit float RGB pixels, where the …\nPixel contains 4-bit R, G and B channels\nPixel contains 8-bit R, G and B channels\nPixel contains 8-bit R, G and B channels\nSendable Rgb image buffer\nRGB colors + alpha channel\nPixel is 1-bit RGB with an alpha channel\nPixel is 16-bit RGBA\nPixel is 16-bit RGB with an alpha channel\nPixel is 2-bit RGB with an alpha channel\nPixel is 32-bit float RGBA\nPixel is 32-bit float RGBA\nAn image buffer for 32-bit float RGBA pixels, where the …\nPixel is 4-bit RGB with an alpha channel\nPixel is 8-bit RGB with an alpha channel\nPixel is 8-bit RGB with an alpha channel\nSendable Rgb + alpha channel image buffer\nA View into another image\nThe scalar type that is used to store each channel in this …\nAn Image in TGA Format\nAn Image in TGA Format\nAn Image in TIFF Format\nAn Image in TIFF Format\nPixel is of unknown color type with the specified bits per …\nA value for signalling an error: An unsupported format was …\nAn Image in WEBP Format\nAn image in WebP Format.\nApply the function <code>f</code> to each channel of this pixel.\nApply the function <code>f</code> to each channel of this pixel and …\nApply the function <code>f</code> to each channel except the alpha …\nGet the bytes of this value.\nBlend the color of a given pixel into ourself, taking into …\nPut a pixel at location (x, y), taking into account alpha …\nThe bounding rectangle of this image.\nIterators and other auxiliary structure for the <code>ImageBuffer</code>…\nContains the generic <code>ImageBuffer</code> struct.\nReturns the components as a slice.\nReturns the channels of this pixel as a 4 tuple. If the …\nReturns the components as a mutable slice\nEncoding and decoding for various image file formats.\nReturns the color type of the image data produced by this …\nDelay between the frames in milliseconds\nReturns a tuple containing the width and height of the …\nThe width and height of this image.\nContains detailed error representation.\nImage representations for ffi.\nConstruct a pixel from the 4 channels a, b, c and d. If …\nReturns a view into a slice.\nReturns mutable view into a mutable slice.\nReturns the pixel located at (x, y). Indexed from top left.\nGets a reference to the mutable pixel at location <code>(x, y)</code>. …\nGuess image format from memory block\nRead a tuple containing the (width, height) of the image …\nImage Processing Functions\nConsume the decoder producing a series of frames.\nReturns a reader that can be used to obtain the bytes of …\nInvert this pixel\nInput and output of images.\nx offset\nCreate a new image from a Reader.\nCreate a new image from a byte slice\nCreate a new image from a byte slice\nApply the function <code>f</code> to each channel of this pixel.\nApply the function <code>f</code> to each channel of this pixel and …\nApply the function <code>f</code> to each channel except the alpha …\nMathematical helper functions and types.\nOpen the image located at the path specified. The image’…\nPut a pixel at location (x, y). Indexed from top left.\nDecode a rectangular section of the image, periodically …\nSaves the supplied buffer to a file at the path specified.\nSaves the supplied buffer to a file at the path specified …\nConvert this pixel to luma\nConvert this pixel to luma with an alpha channel\nConvert this pixel to RGB\nConvert this pixel to RGB with an alpha channel\ny offset\nThis module provides useful traits that were deprecated in …\nUtilities\nWrites the supplied buffer to a writer in the specified …\nWrites all the bytes in an image to the encoder.\nThe delay of a frame relative to the previous one.\nA single animation frame\nAn implementation dependent iterator, reading the frames …\nReturns the image buffer\nReturns a mutable image buffer\nGiven some fraction, compute an approximation with …\nSteps through the iterator from the current frame until …\nDelay of this frame\nDelay between the frames in milliseconds\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a delay from a ratio of milliseconds.\nConstructs a new frame\nConvert from a duration, clamped between 0 and an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the image buffer\nReturns the x offset\nx offset\nCreates a new <code>Frames</code> from an implementation specific …\nConstructs a new frame without any delay.\nThe numerator and denominator of the delay in milliseconds.\nReturns the y offset\ny offset\nProvides color conversions for whole image buffers.\nEnumerate the pixels of an image.\nEnumerate the pixels of an image.\nEnumerate the rows of an image.\nEnumerate the rows of an image.\nIterate over pixel refs.\nIterate over mutable pixel refs.\nIterate over rows of an image\nIterate over mutable rows of an image\nConverts <code>self</code> to a buffer of type T\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct the iterator from image pixels. This is not …\nConstruct the iterator from image pixels. This is not …\nProvides color conversions for whole image buffers.\nEnumerate the pixels of an image.\nEnumerate the pixels of an image.\nEnumerate the rows of an image.\nEnumerate the rows of an image.\nSendable 16-bit grayscale image buffer\nSendable 16-bit grayscale + alpha channel image buffer\nSendable grayscale + alpha channel image buffer\nSendable grayscale image buffer\nGeneric image buffer\nIterate over pixel refs.\nIterate over mutable pixel refs.\nSendable 16-bit Rgb image buffer\nAn image buffer for 32-bit float RGB pixels, where the …\nSendable Rgb image buffer\nSendable 16-bit Rgb + alpha channel image buffer\nAn image buffer for 32-bit float RGBA pixels, where the …\nSendable Rgb + alpha channel image buffer\nIterate over rows of an image\nIterate over mutable rows of an image\nReturn a view on the raw sample buffer.\nReturn a mutable view on the raw sample buffer.\nReturns the underlying raw buffer\nPut a pixel at location (x, y), taking into account alpha …\nTest that the image fits inside the buffer.\nConverts <code>self</code> to a buffer of type T\nExamples\nThe width and height of this image.\nEnumerates over the pixels of the image. The iterator …\nEnumerates over the pixels of the image. The iterator …\nEnumerates over the rows of the image. The iterator yields …\nEnumerates over the rows of the image. The iterator yields …\nExpands a color palette by re-using the existing buffer. …\nExpands a color palette by re-using the existing buffer. …\nReturns the argument unchanged.\nConstructs a new ImageBuffer by repeated application of …\nConstructs a new ImageBuffer by copying a pixel\nConstructs a buffer from a generic container (for example …\nCreates an image buffer out of an existing buffer. Returns …\nGets a reference to the pixel at location <code>(x, y)</code>\nGets a reference to the pixel at location <code>(x, y)</code> or …\nGets a reference to the mutable pixel at location <code>(x, y)</code>\nGets a reference to the mutable pixel at location <code>(x, y)</code> …\nThe height of this image.\nCalls <code>U::from(self)</code>.\nReturn the raw sample buffer with its stride an dimension …\nReturns the underlying raw buffer\nConsumes the image buffer and returns the underlying data …\nCreates a new image buffer based on a <code>Vec&lt;P::Subpixel&gt;</code>.\nReturns an iterator over the pixels of this image. The …\nReturns an iterator over the mutable pixels of this image.\nPuts a pixel at location <code>(x, y)</code>\nReturns an iterator over the rows of this image.\nReturns an iterator over the mutable rows of this image.\nGet the format of the buffer when viewed as a matrix of …\nSaves the buffer to a file at the path specified.\nSaves the buffer to a file at the specified path in the …\nReturns the pixel located at (x, y), ignoring bounds …\nPuts a pixel at location (x, y), ignoring bounds checking.\nThe width of this image.\nWrites the buffer to a writer in the specified format.\nWrites the buffer with the given encoder.\nDecoding and Encoding of BMP Images\nDecoding of DDS images\nDecoding of DXT (S3TC) compression\nDecoding of farbfeld images\nDecoding of GIF Images\nDecoding of Radiance HDR Images\nDecoding and Encoding of ICO files\nDecoding and Encoding of JPEG Images\nDecoding of OpenEXR (.exr) Images\nDecoding and Encoding of PNG Images\nDecoding of netpbm image formats (pbm, pgm, ppm and pam).\nDecoding and encoding of QOI images\nDecoding of TGA Images\nDecoding and Encoding of TIFF Images\nDecoding and Encoding of WebP Images\nA bmp decoder\nThe representation of a BMP encoder.\nBitfield mask invalid (e.g. too long for specified type)\nBitfield (of the specified width – 16- or 32-bit) mask …\nThe bitfield mask interleaves set and unset bits\nBitfield (of the specified width – 16- or 32-bit) masks …\nBitfields (16- or 32-bit)\nA bmp decoder\nWrapper struct around a <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code>\nBMP’s “BM” signature wrong or missing\nDistinct image types whose saved channel width can be …\nAll errors that can occur when attempting to parse a BMP\nBitmap header smaller than the core header\nOne of the dimensions is larger than a soft limit\nSpecified image type is invalid for top-down BMPs (i.e. is …\nImage type not currently recognized by the decoder\nInvalid amount of bits per channel for the specified image …\nThe height is <code>i32::min_value()</code>\nThe maximum width/height the decoder will process.\nMore than the exactly one allowed plane specified by the …\nThe width is negative\nThe palette is bigger than allowed by the bit count of the …\nRGB\n4-bit run length encoding\n8-bit run length encoding\nConvenience function to check if the combination of width, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the palette that is embedded in the BMP image, if any.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new decoder that decodes from the stream <code>r</code>\nCreate a new decoder that decodes from the stream <code>r</code> …\nCalculate how many many bytes a buffer holding a decoded …\nRead image data from a reader in 32-bit formats that use …\nRead BITMAPCOREHEADER …\nRead BITMAPINFOHEADER …\nRead image data from a reader where the colours are stored …\nRead the actual data of the image. This function is …\nIf true, the palette in BMP does not apply to the image …\nCall the provided function on each row of the provided …\nThe representation of a BMP encoder.\nEncodes the image <code>image</code> that has dimensions <code>width</code> and …\nSame as <code>encode</code>, but allow a palette to be passed in. The …\nReturns the argument unchanged.\nReturns a tuple representing: (dib header size, written …\nCalls <code>U::from(self)</code>.\nCreate a new encoder that writes its output to <code>w</code>.\nExtended DX10 header used by some DDS image files\nThe representation of a DDS decoder\nDDS “DDS “ signature invalid or missing\nErrors that can occur during decoding and parsing a DDS …\nInvalid array size in DX10 header\nInvalid flags in DX10 header\nInvalid DXGI format in DX10 header\nHeader used by DDS image files\nWrong DDS header flags\nWrong DDS header size\nDDS pixel format\nWrong DDS channel width\nInvalid resource dimension\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new decoder that decodes from the stream <code>r</code>\nThe DXT1 format. 48 bytes of RGB data in a 4x4 pixel …\nThe DXT3 format. 64 bytes of RGBA data in a 4x4 pixel …\nThe DXT5 format. 64 bytes of RGBA data in a 4x4 pixel …\nDXT decoder\nDXT encoder\nDXT reader\nWhat version of DXT compression are we using? Note that …\nConstructs the DXT5 alpha lookup table from the two alpha …\nReturns the color type that is stored in this DXT variant\nDecodes a 8-byte bock of dxt5 data to a 16xRGB block\nDecode a row of DXT1 data to four rows of RGB data. …\nDecodes a 16-byte bock of dxt3 data to a 16xRGBA block\nDecode a row of DXT3 data to four rows of RGBA data. …\nDecodes a 16-byte bock of dxt5 data to a 16xRGBA block\nDecode a row of DXT5 data to four rows of RGBA data. …\ndecodes an 8-byte dxt color block into the RGB channels of …\nReturns the amount of bytes of raw image data that is …\nreturns the squared error between two RGB values\ndecodes a 5-bit R, 6-bit G, 5-bit B 16-bit packed color …\nencodes an 8-bit RGB value into a 5-bit R, 6-bit G, 5-bit …\nEncodes the image data <code>data</code> that has dimensions <code>width</code> and …\nEncodes a RGBx16 sequence of bytes into a 8 bytes DXT1 …\nDecode a row of DXT1 data to four rows of RGBA data. …\nEncodes a RGBAx16 sequence of bytes into a 16 bytes DXT3 …\nDecode a row of DXT3 data to four rows of RGBA data. …\nEncodes a buffer of 16 alpha bytes into a dxt5 alpha index …\nEncodes a RGBAx16 sequence of bytes to a 16 bytes DXT5 …\nDecode a row of DXT5 data to four rows of RGBA data. …\nTries to perform the color encoding part of dxt compression\nReturns the amount of bytes per block of encoded DXTn data\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new DXT decoder that decodes from the stream <code>r</code>. …\nCreate a new encoder that writes its output to <code>w</code>\nutility function: squares a value\nfarbfeld decoder\nfarbfeld encoder\nfarbfeld Reader\nRelative to the start of the pixel data\nEncodes the image <code>data</code> (native endian) that has dimensions …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new decoder that decodes from the stream <code>r</code>\nCreate a new encoder that writes its output to <code>w</code>. The …\nFinite number of repetitions\nGIF decoder\nGIF encoder.\nWrapper struct around a <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code>\nLooping GIF\nNumber of repetitions for a GIF animation\nEncode a single image.\nEncode one frame of animation.\nEncodes Frames. Consider using <code>try_encode_frames</code> instead …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new decoder that decodes the input steam <code>r</code>\nCreates a new GIF encoder with a speed of 1. This …\nCreate a new GIF encoder, and has the speed parameter <code>speed</code>…\nSet the repeat behaviour of the encoded GIF\nTry to encode a collection of <code>ImageResult&lt;animation::Frame&gt;</code>…\nCreates a new decoder that decodes the input steam <code>r</code>, …\nAdapter to conform to <code>ImageDecoder</code> trait\nAn Radiance HDR decoder\nRadiance HDR encoder\nScanline buffered pixel by pixel iterator\nMetadata for Radiance HDR image\nWrapper struct around a <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code>\nRefer to wikipedia\nRadiance HDR file signature\nColor components\nDivide color values by corresponding tuple member (r, g, …\nAll lines contained in image header are put here. Ordering …\nExponent\nDivide color values by exposure to get to get physical …\nHeight of decoded image. It depends on orientation too.\nOrientation matrix. For standard orientation it is …\nPixel height divided by pixel width\nHelper function for reading raw 3-channel f32 images\nCreates <code>Rgbe8Pixel</code> from components\nConverts <code>Rgb&lt;f32&gt;</code> into <code>Rgbe8Pixel</code>\nWidth of decoded image. It could be either scanline length,\nErrors that can occur during decoding and parsing of a HDR …\nDimensions line had too many elements\nDimensions line had too few elements\nCOLORCORR contains too many numbers in strict mode\nFirst pixel of a scanline is a run length marker\nAdapter to conform to <code>ImageDecoder</code> trait\nAn Radiance HDR decoder\nScanline buffered pixel by pixel iterator\nMetadata for Radiance HDR image\nWrapper struct around a <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code>\nNot enough numbers in line\nLines which contain parsable data that can fail\nHDR’s “#?RADIANCE” signature wrong or missing\nRefer to wikipedia\nRadiance HDR file signature\nEOF instead of image dimensions\nEOF before end of header\nA value couldn’t be parsed\nA value couldn’t be parsed\nThe length of a scanline (1) wasn’t a match for the …\nColor components\nDivide color values by corresponding tuple member (r, g, …\nAll lines contained in image header are put here. Ordering …\nExponent\nDivide color values by exposure to get to get physical …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHeight of decoded image. It depends on orientation too.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns file metadata. Refer to <code>HdrMetadata</code> for details.\nCreates adapter\nReads Radiance HDR image header from stream <code>r</code> if the …\nAllows reading old Radiance HDR images\nOrientation matrix. For standard orientation it is …\nPixel height divided by pixel width\nRead the actual data of the image, and store it in …\nConsumes decoder and returns a vector of <code>Rgb&lt;f32&gt;</code> pixels.\nConsumes decoder and returns a vector of <code>Rgb&lt;u8&gt;</code> pixels. …\nConsumes decoder and returns a vector of RGBE8 pixels\nConsumes decoder and returns a vector of transformed pixels\nHelper function for reading raw 3-channel f32 images\nCreates <code>Rgbe8Pixel</code> from components\nConverts <code>Rgbe8Pixel</code> into <code>Rgb&lt;f32&gt;</code> linearly\nConverts <code>Rgbe8Pixel</code> into <code>Rgb&lt;T&gt;</code> with scale=1 and gamma=2.2\nConverts <code>Rgbe8Pixel</code> into <code>Rgb&lt;T&gt;</code> using provided scale and …\nWidth of decoded image. It could be either scanline length,\nReads Radiance HDR image header from stream <code>reader</code>, if the …\nRadiance HDR encoder\nEncodes the image <code>data</code> that has dimensions <code>width</code> and <code>height</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates encoder\nConverts <code>Rgb&lt;f32&gt;</code> into <code>Rgbe8Pixel</code>\nAn ico decoder\nICO encoder\nAn ICO image entry\nBMP with optional alpha mask\nErrors that can occur during decoding and parsing an ICO …\nAn ico decoder\nThe image formats an ICO may contain\nThe bit depth (may be 0 meaning unspecified), or the …\nThe number of color planes (0 or 1), or the horizontal …\nWrapper struct around a <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code>\nThe dimensions specified by the entry does not match the …\nThe entry is in BMP format and specified a data size that …\nThe ICO directory is empty\nPNG in ARGB\nThe enclosed PNG is not in RGBA, which is invalid: …\nThe entry is in PNG format and specified a length that is …\nFind the entry with the highest (color depth, size).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new decoder that decodes from the stream <code>r</code>\nThe dimensions specified by the entry\nThe mismatched subimage’s type\nThe dimensions of the image itself\nICO encoder\nAn ICO image entry\nConstruct a new <code>IcoFrame</code> by encoding <code>buf</code> as a PNG\nEncodes the image <code>image</code> that has dimensions <code>width</code> and …\nTakes some <code>IcoFrame</code>s and encodes them into an ICO.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new encoder that writes its output to <code>w</code>.\nConstruct a new <code>IcoFrame</code> using a pre-encoded PNG or BMP\nWrite an ICO image with the specified width, height, and …\nPixels per centimeter\nPixels per inch (2.54 cm)\nJPEG decoder\nThe representation of a JPEG encoder\nRepresents the absence of a unit, the values indicate only …\nRepresents the pixel density of an image\nRepresents a unit in which the density of an image is …\nA couple of values for (Xdensity, Ydensity)\nThe unit in which the density is measured\nJPEG decoder\nWrapper struct around a <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new decoder that decodes from the stream <code>r</code>\nConfigure the decoder to scale the image during decoding.\nPixels per centimeter\nA representation of a JPEG component\nPixels per inch (2.54 cm)\nThe representation of a JPEG encoder\nRepresents the absence of a unit, the values indicate only …\nRepresents the pixel density of an image\nRepresents a unit in which the density of an image is …\nThe permutation of dct coefficients.\nThe dc prediction of the component\nIndex to the AC Huffman Table\nIndex to the Huffman DC Table\nReturns a pixel density with a pixel aspect ratio of 1\nA couple of values for (Xdensity, Ydensity)\nCreates the most common pixel density type: the horizontal …\nEncodes the image stored in the raw byte buffer <code>image</code> that …\nEncodes the given image.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHorizontal sampling factor\nThe Component’s identifier\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new encoder that writes its output to <code>w</code>\nCreate a new encoder that writes its output to <code>w</code>, and has …\nReturns the pixel at (x,y) if (x,y) is in the image, …\nSet the pixel density of the images the encoder will …\nThe quantization table selector\nThe unit in which the density is measured\nVertical sampling factor\nGiven an array containing the number of codes of each code …\nAn OpenEXR decoder. Immediately reads the meta data from …\nA thin wrapper that implements <code>ImageEncoder</code> for OpenEXR …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUse <code>read_image</code> instead if possible, as this method creates …\nCreate a decoder. Consumes the first few bytes of the …\nCreate an <code>ImageEncoder</code>. Does not write anything yet. …\nCreate a decoder. Consumes the first few bytes of the …\nWrite a raw byte buffer of pixels, returning an Error if …\nWrites the complete image.\nUses a heuristic to select one of the preceding filters …\nAn <code>AnimationDecoder</code> adapter of <code>PngDecoder</code>.\nFilters based on the average of left and right neighbor …\nHigh compression level\nCompression level of a PNG encoder. The default setting is …\nDefault compression level\nFast, minimal compression\nFilter algorithms used to process image data to improve …\nHuffman coding compression\nNo processing done, best used for low bit depth grayscale …\nAlgorithm that takes into account the left, upper left, …\nPNG decoder\nPNG encoder\nPng Reader\nRun-length encoding compression\nFilters based on previous pixel in the same scanline\nFilters based on the scanline above\nTurn this into an iterator over the animation frames.\nThe current output buffer.\nThe dispose op of the current frame.\nEncodes the image <code>data</code> that has dimensions <code>width</code> and <code>height</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the gamma value of the image or None if no gamma …\nThe next (first) image is the thumbnail.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns if the image contains an animation.\nDecode one subframe and overlay it on the canvas.\nCreates a new decoder that decodes from the stream <code>r</code>\nCreate a new encoder that writes its output to <code>w</code>\nCreate a new encoder that writes its output to <code>w</code> with …\nThe previous output buffer, used for dispose op previous.\nThe number of image still expected to be able to load.\nCreates a new decoder that decodes from the stream <code>r</code> with …\nWrite a PNG image with the specified width, height, and …\nHeader produced by a <code>pam</code> file (“Portable Arbitrary Map”…\nMagic number P7\nStandardized tuple type specifiers in the header of a <code>pam</code>.\nSamples are encoded as decimal ascii strings separated by …\nSamples are unsigned binary integers in big endian\nMagic numbers P1 and P4\nHeader produced by a <code>pbm</code> file (“Portable Bit Map”)\nPixels are either black (0) or white (1)\nPixels are either black (0) or white (1) and a second …\nAn image format which is not standardized\nMagic numbers P2 and P5\nHeader produced by a <code>pgm</code> file (“Portable Gray Map”)\nPixels represent the amount of white\nGrayscale with an additional alpha channel\nMagic numbers P3 and P6\nHeader produced by a <code>ppm</code> file (“Portable Pixel Map”)\nPNM decoder\nEncodes images to any of the <code>pnm</code> image formats.\nStores the complete header data of a file.\nDenotes the category of the magic number\nThree channels: Red, Green, Blue\nFour channels: Red, Green, Blue, Alpha\nThe kind of encoding used to store sample values\nInsert line breaks between written buffers when they would …\nNumber of color channels\nEncoding of PNM Images\nBinary or Ascii encoded file\nBinary or Ascii encoded file\nBinary or Ascii encoded file\nHeight of the image file\nHeight of the image file\nHeight of the image file\nHeight of the image file\nMaximum sample value within the image\nMaximum sample value within the image\nMaximum sample value within the image\nColor interpretation of image pixels\nWidth of the image file\nWidth of the image file\nWidth of the image file\nWidth of the image file\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAll errors that can occur when attempting to parse a PNM\n“DEPTH”\nSingle-value lines in a PNM header\nThe specified line was specified twice\nAt least one of the required lines were missing from the …\nThe line with the specified ID was not understood\n“HEIGHT”\nNot enough data was provided to the Decoder to decode the …\nThe specified tuple type supports restricted depths, those …\nThe specified tuple type supports restricted depths and …\nOne of the header lines\n“MAXVAL”, a.k.a. <code>maxwhite</code>\nThe image’s maxval exceeds 0xFFFF\nThe image’s maxval is zero\nMore than the exactly one allowed plane specified by the …\nThe PAM header contained a non-ASCII byte\nA sample string contained a non-ASCII byte\nThe byte after the P7 magic was not 0x0A NEWLINE\nOverflowed the specified value when parsing\nPNM decoder\nSingle-value lines in a PNM header\nPNM’s “P[123456]” signature wrong or missing\nWrapper struct around a <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code>\nValue in the preamble\nSample/pixel data\nSpecified sample was out of bounds (e.g. &gt;1 in B&amp;W)\nDynamic representation, represents all decodable (sample, …\nThe tuple type was not recognised by the parser\nSample raster contained unexpected byte\nThe PNM header had too few lines\nCouldn’t parse the specified string as an integer from …\n“WIDTH”\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtract the reader and header after an image has been read.\nCreate a new decoder that decodes from the stream <code>read</code>\nReads the two magic constant bytes\nReads a string as well as a single whitespace after it, …\nRepresentation size in bytes\nGet the pnm subtype, depending on the magic constant …\nEncapsulate the checking system in the type system. Non of …\nEncodes images to any of the <code>pnm</code> image formats.\nEncode an image whose samples are represented as <code>u8</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new PnmEncoder from the <code>writer</code>.\nCreate the header dynamically for each image.\nEnforce the use of a chosen header.\nEncode a specific pnm subtype image.\nChoose any valid pnm format that the image can be …\nTry to encode the image with the chosen format, give its …\nTry to encode the image with the chosen header, checking …\nHeader produced by a <code>pam</code> file (“Portable Arbitrary Map”…\nMagic number P7\nStandardized tuple type specifiers in the header of a <code>pam</code>.\nSamples are encoded as decimal ascii strings separated by …\nSamples are unsigned binary integers in big endian\nMagic numbers P1 and P4\nHeader produced by a <code>pbm</code> file (“Portable Bit Map”)\nPixels are either black (0) or white (1)\nPixels are either black (0) or white (1) and a second …\nAn image format which is not standardized\nMagic numbers P2 and P5\nHeader produced by a <code>pgm</code> file (“Portable Gray Map”)\nPixels represent the amount of white\nGrayscale with an additional alpha channel\nMagic numbers P3 and P6\nHeader produced by a <code>ppm</code> file (“Portable Pixel Map”)\nStores the complete header data of a file.\nDenotes the category of the magic number\nThree channels: Red, Green, Blue\nFour channels: Red, Green, Blue, Alpha\nThe kind of encoding used to store sample values\nRetrieve the underlying arbitrary header if any\nRetrieve the underlying bitmap header if any\nRetrieve the underlying graymap header if any\nRetrieve the underlying pixmap header if any\nNumber of color channels\nBinary or Ascii encoded file\nBinary or Ascii encoded file\nBinary or Ascii encoded file\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe height of the image this header is for.\nHeight of the image file\nHeight of the image file\nHeight of the image file\nHeight of the image file\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the two magic constant bytes corresponding to this …\nThe biggest value a sample can have. In other words, the …\nMaximum sample value within the image\nMaximum sample value within the image\nMaximum sample value within the image\nWhether samples are stored as binary or as decimal ascii\nRetrieve the format subtype from which the header was …\nColor interpretation of image pixels\nThe width of the image this header is for.\nWidth of the image file\nWidth of the image file\nWidth of the image file\nWidth of the image file\nWrite the header back into a binary stream\nQOI decoder\nQOI encoder\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new decoder that decodes from the stream <code>reader</code>\nCreates a new encoder that writes its output to <code>writer</code>\nA decoder for TGA images\nTGA encoder.\nRun-length encoding\nThe representation of a TGA decoder\nExpands indices into its mapped color\nFlip the image vertically depending on the screen origin …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet one entry from the color map\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck whether the image is vertically flipped\nCreate a new decoder that decodes from the stream <code>r</code>\nReads a run length encoded packet\nLoads the color information for the decoder\nReads a run length encoded data for given number of bytes\nReads a run length encoded line\nRead the image id field\nReverse from BGR encoding to RGB encoding\nsizes in bytes\nErrors that can occur during encoding and saving of a TGA …\nInvalid TGA height.\nTGA encoder.\nInvalid TGA width.\nDisables run-length encoding\nEncodes the image <code>buf</code> that has dimensions <code>width</code> and <code>height</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new encoder that writes its output to <code>w</code>.\nWrites the run-length encoded buffer to the writer\nRun-length encoding\nWrites a raw packet to the writer\nWrites a run-length encoded packet to the writer\nHeader used by TGA image files.\nUncompressed images.\nRun length encoded images.\nReturns the argument unchanged.\nReturns the argument unchanged.\nLoad the header with values from pixel information.\nLoad the header with values from the reader.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the image format uses colors as opposed to gray …\nDoes the image use a color map.\nIs the image run length encoded.\nCreate a new image type from a u8.\nWrite out the header values.\nDecoder for TIFF images.\nEncoder for tiff images\nWrapper struct around a <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code>\nEncodes the image <code>image</code> that has dimensions <code>width</code> and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new TiffDecoder.\nCreate a new encoder that writes its output to <code>w</code>\nWebP Image format decoder. Currently only supports lossy …\nWebP Encoder.\nWebP encoder quality.\nEncoding of WebP images.\nDoes loop filtering on webp lossy images\nDecoding of lossless WebP images\nAn implementation of the VP8 Video Codec\nChunk Header was incorrect or invalid in its usage\nAll errors that can occur when attempting to parse a WEBP …\nRIFF’s “RIFF” signature not found or invalid\nWebP Image format decoder. Currently only supports lossy …\nAll possible RIFF chunks in a WebP image file\nWrapper struct around a <code>Cursor&lt;Vec&lt;u8&gt;&gt;</code>\nWebP’s “WEBP” signature not found or invalid\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if the image as described by the bitstream is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new WebPDecoder from the Reader <code>r</code>. This function …\nReads a chunk Returns an error if the chunk header is not …\nReads a chunk header FourCC Returns None if and only if we …\nSets the background color if the image is an extended and …\nDefault lossy quality (80), providing a balance of quality …\nMaximum lossy quality value (100).\nMinimum lossy quality value (0).\nWebP Encoder.\nWebP encoder quality.\nEncode image data with the indicated color type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLossless encoding.\nLossy encoding. 0 = low quality, small size; 100 = high …\nCreate a new encoder that writes its output to <code>w</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads a chunk, but silently ignores unknown chunks at the …\nHuffman tree\nRudimentary utility for reading Canonical Huffman Codes. …\nAdds a symbol to a huffman tree\nTurns a node from empty into a branch and assigns its …\nBuilds a tree explicitly from lengths, codes and symbols\nBuilds a tree implicitly, just from code lengths\nConverts code lengths to codes\nReturns the argument unchanged.\nReturns the argument unchanged.\nInit a huffman tree\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReads a symbol using the bitstream\nSignature of 0x2f not found\nVersion Number must be 0\nAdjusts the color map since it’s subtraction coded\nReads the frame\nDecodes the image data using the huffman trees and either …\nReads Image data from the bitstream Can be in any of the 5 …\nFills a buffer with just the green values from the …\nFills a buffer by converting from argb to rgba\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet buffer size from the image\nGets the copy distance from the prefix code and bitstream\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new decoder\nGets distance to pixel\nReads color cache data from the bitstream\nDecodes and returns a single huffman tree\nReads huffman code lengths\nReads huffman codes associated with an image\nReads transforms and their data from the bitstream\nAdds green to red and blue of a pixel\nAdds 2 pixels mod 256 for each pixel\nApplies a transform to the image data\nGet average of 2 pixels\nClamp a to [0, 255]\nClamp add subtract full on 3 pixels\nClamp add subtract full on one part\nClamp add subtract half on 2 pixels\nClamp add subtract half on one part\nDoes color transform on red and blue transformed by green\nDoes color transform on 2 numbers\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a specific byte from argb pixel\nGet byte as i32 for convenience\nGet left pixel\nGet top pixel\nGet pixel to top left\nGet pixel to top right\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSelect left or top byte\nGet average of 2 bytes\nEach Y subblock is independently predicted.\nChroma prediction mode was not recognised\nAt time of writing, only the YUV colour-space encoded as <code>0</code> …\nPredict DC using row above and column to the left.\nPredict DC using row above and column to the left.\nAll errors that can occur when attempting to parse a VP8 …\nA Representation of the last decoded video frame\nPredict columns using column to the left.\nPredict columns using column to the left.\nIntra-prediction mode was not recognised\nLUMA prediction mode was not recognised\nDecoder initialisation wasn’t provided with enough data\nPropagate second differences.\nPropagate second differences.\nPredict rows using row above.\nPredict rows using row above.\nVP8 Decoder\nVP8’s <code>[0x9D, 0x01, 0x2A]</code> magic not found or invalid\nChroma plane is half the size of the Luma plane\nDecodes the current frame\nFills an rgb buffer with the image\nFills an rgba buffer by skipping the alpha values\nConversion values from …\nIndicates whether this frame is intended for display\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the buffer size\nThe height of the luma plane\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndicates whether this frame is a keyframe\nDoes loop filtering on the macroblock\nCreate a new decoder. The reader must present a raw vp8 …\nThe pixel type of the frame as defined by Section 9.2 of …\nThe blue plane of the frame\nThe red plane of the frame\nThe width of the luma plane\nThe luma plane of the frame\nPixel is 8-bit alpha\nPixel contains 8-bit B, G and R channels\nPixel is 8-bit BGR with an alpha channel\nBlends a color inter another one\nPixel is 8-bit CMYK\nAn enumeration over supported color types and bit depths\nAn enumeration of color types encountered in image formats.\nProvides color conversions for the different pixel types.\nConvert from one pixel component type to another. For …\nCopy-based conversions to target pixel types using …\nInvert a color\nPixel is 1-bit luminance\nPixel is 16-bit luminance\nPixel is 16-bit luminance\nPixel is 2-bit luminance\nPixel is 4-bit luminance\nPixel is 8-bit luminance\nPixel is 8-bit luminance\nPixel is 1-bit luminance with an alpha channel\nPixel is 16-bit luminance with an alpha channel\nPixel is 16-bit luminance with an alpha channel\nPixel is 2-bit luminance with an alpha channel\nPixel is 4-bit luminance with an alpha channel\nPixel is 8-bit luminance with an alpha channel\nPixel is 8-bit luminance with an alpha channel\nGrayscale colors.\nGrayscale colors + alpha channel\nRGB colors.\nPixel contains 1-bit R, G and B channels\nPixel is 16-bit RGB\nPixel contains 16-bit R, G and B channels\nPixel contains 2-bit R, G and B channels\nPixel is 32-bit float RGB\nPixel is 32-bit float RGB\nPixel contains 4-bit R, G and B channels\nPixel contains 8-bit R, G and B channels\nPixel contains 8-bit R, G and B channels\nRGB colors + alpha channel\nPixel is 1-bit RGB with an alpha channel\nPixel is 16-bit RGBA\nPixel is 16-bit RGB with an alpha channel\nPixel is 2-bit RGB with an alpha channel\nPixel is 32-bit float RGBA\nPixel is 32-bit float RGBA\nPixel is 4-bit RGB with an alpha channel\nPixel is 8-bit RGB with an alpha channel\nPixel is 8-bit RGB with an alpha channel\nCoefficients to transform from sRGB to a CIE Y (luminance) …\nPixel is of unknown color type with the specified bits per …\nReturns the number of bits contained in a pixel of …\nBlends a color in-place.\nReturns the number of bytes contained in a pixel of …\nReturns the number of color channels that make up this …\nGet the number of channels for colors of this type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nChanges <code>self</code> to represent <code>Other</code> in the color space of <code>Self</code>\nConverts from any pixel component type to this type.\nReturns if there is an alpha channel.\nReturns false if the color scheme is grayscale, true …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a pixel of the target type and converts this …\nInverts a color in-place.\nA Dynamic Image\nEach pixel in this image is 16-bit Luma\nEach pixel in this image is 8-bit Luma\nEach pixel in this image is 16-bit Luma with alpha\nEach pixel in this image is 8-bit Luma with alpha\nEach pixel in this image is 16-bit Rgb\nEach pixel in this image is 32-bit float Rgb\nEach pixel in this image is 8-bit Rgb\nEach pixel in this image is 16-bit Rgb with alpha\nEach pixel in this image is 32-bit float Rgb with alpha\nEach pixel in this image is 8-bit Rgb with alpha\nAdjust the contrast of this image. <code>contrast</code> is the amount …\nReturn this image’s pixels as a native endian byte slice.\nReturn a view on the raw sample buffer for 32bit per …\nReturn a view on the raw sample buffer for 16 bit per …\nReturn a view on the raw sample buffer for 8 bit per …\nReturn a reference to an 16bit Grayscale image\nReturn a reference to an 8bit Grayscale image\nReturn a reference to an 16bit Grayscale image with an …\nReturn a reference to an 8bit Grayscale image with an …\nReturn a mutable reference to an 16bit Grayscale image\nReturn a mutable reference to an 8bit Grayscale image\nReturn a mutable reference to an 16bit Grayscale image …\nReturn a mutable reference to an 8bit Grayscale image with …\nReturn a mutable reference to an 16bit RGB image\nReturn a mutable reference to an 32bit RGB image\nReturn a mutable reference to an 8bit RGB image\nReturn a mutable reference to an 16bit RGBA image\nReturn a mutable reference to an 16bit RGBA image\nReturn a mutable reference to an 8bit RGBA image\nReturn a reference to an 16bit RGB image\nReturn a reference to an 32bit RGB image\nReturn a reference to an 8bit RGB image\nReturn a reference to an 16bit RGBA image\nReturn a reference to an 32bit RGBA image\nReturn a reference to an 8bit RGBA image\nPerforms a Gaussian blur on this image. <code>sigma</code> is a measure …\nBrighten the pixels of this image. <code>value</code> is the amount to …\nReturn this image’s color type.\nReturn a cut-out of this image delimited by the bounding …\nReturn a cut-out of this image delimited by the bounding …\nDecodes an image and stores it into a dynamic image\nFilters this image with the specified 3x3 kernel.\nFlip this image horizontally\nFlip this image vertically\nReturns the argument unchanged.\nDecodes an encoded image into a dynamic image.\nDo not use is function: It is unimplemented!\nReturn a grayscale version of this image. Returns <code>Luma</code> …\nReturns the height of the underlying image\nHue rotate the supplied image. <code>value</code> is the degrees to …\nRead a tuple containing the (width, height) of the image …\nCalls <code>U::from(self)</code>.\nReturn this image’s pixels as a byte vector. If the …\nConsume the image and returns a Luma image.\nConsume the image and returns a Luma image.\nConsume the image and returns a LumaA image.\nConsume the image and returns a LumaA image.\nConsume the image and returns a RGB image.\nConsume the image and returns a RGB image.\nConsume the image and returns a RGB image.\nConsume the image and returns a RGBA image.\nConsume the image and returns a RGBA image.\nConsume the image and returns a RGBA image.\nInvert the colors of this image. This method operates …\nCreate a new image from a byte slice\nCreate a new image from a byte slice\nCreates a dynamic image backed by a buffer depending on …\nCreates a dynamic image backed by a buffer of gray pixels.\nCreates a dynamic image backed by a buffer of gray pixels.\nCreates a dynamic image backed by a buffer of gray pixels …\nCreates a dynamic image backed by a buffer of gray pixels …\nCreates a dynamic image backed by a buffer of RGB pixels.\nCreates a dynamic image backed by a buffer of RGB pixels.\nCreates a dynamic image backed by a buffer of RGB pixels.\nCreates a dynamic image backed by a buffer of RGBA pixels.\nCreates a dynamic image backed by a buffer of RGBA pixels.\nCreates a dynamic image backed by a buffer of RGBA pixels.\nOpen the image located at the path specified. The image’…\nResize this image using the specified filter algorithm. …\nResize this image using the specified filter algorithm. …\nResize this image using the specified filter algorithm. …\nRotate this image 180 degrees clockwise.\nRotate this image 270 degrees clockwise.\nRotate this image 90 degrees clockwise.\nSaves the buffer to a file at the path specified.\nSaves the supplied buffer to a file at the path specified.\nSaves the supplied buffer to a file at the path specified …\nSaves the buffer to a file at the specified path in the …\nScale this image down to fit within a specific size. …\nScale this image down to a specific size. Returns a new …\nReturn a copy of this image’s pixels as a byte vector. …\nReturns a copy of this image as a Luma image.\nReturns a copy of this image as a Luma image.\nReturns a copy of this image as a Luma image.\nReturns a copy of this image as a LumaA image.\nReturns a copy of this image as a LumaA image.\nReturns a copy of this image as a LumaA image.\nReturns a copy of this image as an RGB image.\nReturns a copy of this image as an RGB image.\nReturns a copy of this image as an RGB image.\nReturns a copy of this image as an RGBA image.\nReturns a copy of this image as an RGBA image.\nReturns a copy of this image as an RGBA image.\nPerforms an unsharpen mask on this image. <code>sigma</code> is the …\nReturns the width of the underlying image\nWrites the supplied buffer to a writer in the specified …\nEncode this image and write it to <code>w</code>.\nEncode this image with the provided encoder.\nThe required color type can not be handled.\nAn error was encountered while decoding.\nAn error was encountered while decoding an image.\nThe resulting image exceed dimension limits in either …\nThe dimensions passed are wrong.\nAn error was encountered while encoding.\nAn error was encountered while encoding an image.\nContains the error value\nThe format is known exactly.\nRepeated an operation for which error that could not be …\nAn image format is not supported.\nA string describing the parameter. This is discouraged and …\nSome feature specified by string. This is discouraged and …\nThe generic error type for image operations.\nA best effort representation for image formats.\nResult of an image decoding/encoding process\nThe operation would have performed an allocation larger …\nAn error occurred while interacting with the environment.\nCompleting the operation would have required more …\nIndicates the limit that prevented an operation from …\nCompleting the operation would have required more …\nThe format can be identified by a name.\nThe end of the image has been reached.\nContains the success value\nAn error was encountered in input arguments.\nAn error was encountered in inputs arguments.\nDetails how a parameter is malformed.\nA common path extension for the format is known.\nThe format is not known or could not be determined.\nAn operation can not be completed by the chosen …\nThe specified strict limits are not supported for this …\nThe implementation for an operation was not provided.\nDetails what feature is not supported.\nReturns the image format associated with this error.\nReturn the image format associated with this error.\nReturns the image format associated with this error.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an <code>UnsupportedError</code> for an image with details on …\nCreate an <code>EncodingError</code> for an image format.\nCreate a <code>DecodingError</code> for an image format.\nConstruct a <code>ParameterError</code> directly from a corresponding …\nConstruct a generic <code>LimitError</code> directly from a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the corresponding <code>UnsupportedErrorKind</code> of the …\nReturns the corresponding <code>ParameterErrorKind</code> of the error.\nReturns the corresponding <code>LimitErrorKind</code> of the error.\nCreate an <code>EncodingError</code> that stems from an arbitrary error …\nCreate a <code>DecodingError</code> that stems from an arbitrary error …\nThe given limits\nThe supported strict limits\nThe color format did not match the channel count.\nThe samples are in column-major form and all samples are …\nHelper struct for an unnamed (stride, length) pair.\nDenotes invalid flat sample buffers when trying to convert …\nA flat buffer over a (multi channel) image.\nAll samples are packed.\nDifferent normal forms of buffers.\nThe represented image can not use this representation.\nAt least pixels are packed.\nThe samples are in row-major form and all samples are …\nA ffi compatible description of a sample buffer.\nThe represented image was too large.\nNo pixel aliases another.\nA flat buffer that can be used as an image view.\nA mutable owning version of a flat buffer.\nDeprecated - ChannelCountMismatch is used instead\nGet a mutable reference based version.\nView the samples as a slice.\nGet a reference based version.\nView the samples as a slice.\nView this buffer as an image over some type of pixel.\nInterpret this buffer as a mutable image.\nView this buffer but keep mutability at a sample level.\nTuple of bounds in the order of coordinate inputs.\nTuple of bounds in the order of coordinate inputs.\nAdd this to an index to get to the sample in the next …\nThe number of channels in the color representation of the …\nLength of this dimension in memory.\nSupplementary color information.\nDescribe a column-major image packed in all directions.\nGet the dimensions <code>(channels, width, height)</code>.\nGet the dimensions <code>(channels, width, height)</code>.\nCheck if a buffer of length <code>len</code> is large enough.\nCheck if a buffer of length <code>len</code> is large enough.\nGet a reference on the inner sample descriptor.\nGet a reference on the sample buffer descriptor.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a mutable reference to a single sample.\nGet a mutable reference to a selected subpixel if it is …\nGet a mutable reference to a selected sample.\nGet a reference to a single sample.\nGet a reference to a selected subpixel if it is in-bounds.\nGet a reference to a selected subpixel.\nIf there are any samples aliasing each other.\nIf there are any samples aliasing each other.\nThe height of the represented image.\nAdd this to an index to get to the next sample in …\nMutable portion of the buffer that holds sample values.\nReturn the mutable portion of the buffer that holds sample …\nReturn the mutable buffer that holds sample values.\nReturn the portion of the buffer that holds sample values.\nReturn the portion of the buffer that holds sample values.\nReturn the portion of the buffer that holds sample values.\nCheck that the pixel and the channel index are in bounds.\nCheck that the pixel and the channel index are in bounds.\nGet an index provided it is inbouds.\nGet an index provided it is inbouds.\nThe extents of this array, in order of increasing strides.\nReturn a reference to a single sample at specified …\nResolve the index of a particular sample.\nResolve the index of a particular sample.\nGet the theoretical position of sample (x, y, channel).\nGet the theoretical position of sample (channel, x, y).\nReturn a mutable reference to a single sample at specified …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake out the sample buffer.\nTake out the sample buffer.\nCheck if a buffer fulfills the requirements of a normal …\nCheck if a buffer fulfills the requirements of a normal …\nA <code>repr(C)</code> description of the layout of buffer samples.\nGet the minimum length of a buffer such that all in-bounds …\nGet the minimum length of a buffer such that all in-bounds …\nGet the minimum length of a buffer such that all in-bounds …\nGet the minimum length of a buffer such that all in-bounds …\nCompares the logical preconditions.\nDescribe a row-major image packed in all directions.\nGet a reference on the inner buffer.\nGet a reference on the inner buffer.\nUnderlying linear container holding sample values.\nShrink the image to the minimum of current and given …\nShrink the image to the minimum of current and given …\nShrink the inner image.\nShrink the inner image.\nGet the strides for indexing matrix-like <code>[(c, w, h)]</code>.\nGet the strides for indexing matrix-like <code>[(c, w, h)]</code>.\nCopy the data into an owned vector.\nMove the data into an image buffer.\nTry to convert this into an image with mutable pixels.\nThe width of the represented image.\nAdd this to an index to get to the next sample in …\nCreate a monocolor image from a single pixel.\nAnimationDecoder trait\nAn Image in AVIF format.\nAn Image in BMP Format\nAn Image in BMP Format\nAn Image in DDS Format\nAlias to access Pixel behind a reference\nAlias to access Subpixel behind a reference\nAn Image in farbfeld Format\nAn Image in farbfeld Format\nA trait for manipulating images.\nTrait to inspect an image.\nAn Image in GIF Format\nAn Image in GIF Format\nAn Image in Radiance HDR Format\nAn Image in ICO Format\nAn Image in ICO Format\nThe trait that all decoders implement\nSpecialized image decoding not be supported by all formats\nThe trait all encoders implement\nAn enumeration of supported image formats. Not all formats …\nAn enumeration of supported image formats for encoding.\nAn Image in JPEG Format\nAn Image in JPEG Format with specified quality, up to 100\nAn Image in OpenEXR Format\nAn Image in OpenEXR Format\nThe type of pixel.\nImmutable pixel iterator\nAn Image in PNG Format\nAn Image in PNG Format\nAn Image in general PNM Format\nAn Image in one of the PNM Formats\nRepresents the progress of an image operation.\nAn Image in QOI format.\nAn image in QOI Format\nThe type of reader produced by <code>into_reader</code>.\nA View into another image\nThe inner type of <code>SubImage</code> that implements …\nAn Image in TGA Format\nAn Image in TGA Format\nAn Image in TIFF Format\nAn Image in TIFF Format\nA value for signalling an error: An unsupported format was …\nAn Image in WEBP Format\nAn image in WebP Format.\nReturn all ImageFormats\nPut a pixel at location (x, y), taking into account alpha …\nDEPRECATED: This method will be removed. Blend the pixel …\nThe bounding rectangle of this image.\nReturn if the ImageFormat can be decoded by the lib.\nReturn if the ImageFormat can be encoded by the lib.\nChange the coordinates of this subimage.\nReturns the color type of the image data produced by this …\nCopies all of the pixels from another image into this …\nCopies all of the pixels from another image into this …\nCopies all of the pixels from one part of this image to …\nCopies all of the pixels from one part of this image to …\nA measure of completed decoding.\nReads all of the bytes of a decoder into a Vec. No …\nReturns a tuple containing the width and height of the …\nThe width and height of this image.\nReturn a list of applicable extensions for this format.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the image format specified by a path’s file …\nReturn the image format specified by a MIME type.\nReturn the image format specified by the path’s file …\nReturns the pixel located at (x, y). Indexed from top left.\nGets a reference to the mutable pixel at location <code>(x, y)</code>. …\nThe height of this image.\nThe height of this image.\nReturns the ICC color profile embedded in the image\nReturns the ICC color profile embedded in the image\nReturns true if this x, y coordinate is contained inside …\nReturns true if this x, y coordinate is contained inside …\nGet a reference to the underlying image.\nGet a mutable reference to the underlying image.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsume the decoder producing a series of frames.\nReturns a reader that can be used to obtain the bytes of …\nDecodes a specific region of the image, represented by the …\nCreate a new ImageReadBuffer.\nCreate Progress. Result in invalid progress if you provide …\nConstruct a new subimage The coordinates set the position …\nThe offsets of this subimage relative to the underlying …\nReturns the color type of the image file before decoding\nReturns the color type of the image file before decoding\nReturns an Iterator over the pixels of this image. The …\nReturns an Iterator over the pixels of this image. The …\nPut a pixel at location (x, y). Indexed from top left.\nReturns all the bytes in the image.\nReturns all the bytes in the image.\nSame as <code>read_image</code> but periodically calls the provided …\nSame as <code>read_image</code> but periodically calls the provided …\nDecode a rectangular section of the image; see …\nDecode a rectangular section of the image; see …\nDecode a rectangular section of the image, periodically …\nReturn the ImageFormats which are enabled for reading.\nCalculate a measure for remaining decoding work.\nReturns the minimum number of bytes that can be …\nReturns the minimum number of bytes that can be …\nSet decoding limits for this decoder. See <code>Limits</code> for the …\nSet decoding limits for this decoder. See <code>Limits</code> for the …\nReturns a mutable subimage that is a view into this image. …\nReturns a mutable subimage that is a view into this image. …\nCreate a mutable sub-view of the image.\nConvert this subimage to an ImageBuffer\nReturn the MIME type for this image format or “…\nA measure of all necessary decoding work.\nReturns the total number of bytes in the decoded image.\nReturns the total number of bytes in the decoded image.\nReturns the pixel located at (x, y). Indexed from top left.\nReturns the pixel located at (x, y). Indexed from top left.\nPuts a pixel at location (x, y). Indexed from top left.\nPuts a pixel at location (x, y). Indexed from top left.\nReturns a subimage that is an immutable view into this …\nReturns a subimage that is an immutable view into this …\nCreate a sub-view of the image.\nThe width of this image.\nThe width of this image.\nWrites all the bytes in an image to the encoder.\nReturn the ImageFormats which are enabled for writing.\nColor operations\nCubic Filter\nColor operations\nAvailable Sampling Filters.\nGaussian Filter\nLanczos with window 3\nNearest Neighbor\nLinear Filter\nFunctions for performing affine transformations.\nImage sampling Performs a Gaussian blur on the supplied …\nColor operations\nFunctions for altering and converting the color of …\nColor operations\nReturn a mutable view into an image The coordinates set …\nReturn an immutable view into an image The coordinates set …\nColor operations\nImage sampling Perform a 3x3 box filter on the supplied …\nAffine transformations Flip an image horizontally\nAffine transformations Flip an image horizontally and put …\nAffine transformations Flip an image horizontally in place.\nAffine transformations Flip an image vertically\nAffine transformations Flip an image vertically and put …\nAffine transformations Flip an image vertically in place.\nColor operations\nColor operations\nColor operations\nColor operations\nFill the image with a linear horizontal gradient\nColor operations\nColor operations\nImage sampling Linearly sample from an image using …\nImage sampling Sample from an image using coordinates in […\nColor operations\nOverlay an image at a given coordinate (x, y)\nCalculate the region that can be copied from top to bottom.\nCalculate the region that can be copied from top to bottom.\nReplace the contents of an image at a given coordinate (x, …\nImage sampling Resize the supplied image to the specified …\nAffine transformations Rotate an image 180 degrees …\nAffine transformations Rotate an image 180 degrees …\nAffine transformations Rotate an image 180 degrees …\nAffine transformations Rotate an image 270 degrees …\nAffine transformations Rotate an image 270 degrees …\nAffine transformations Rotate an image 90 degrees …\nAffine transformations Rotate an image 90 degrees …\nFunctions and filters for the sampling of pixels.\nImage sampling Linearly sample from an image using …\nImage sampling Sample from an image using coordinates in […\nImage sampling Resize the supplied image to the specific …\nTile an image by repeating it multiple times\nImage sampling Performs an unsharpen mask on the supplied …\nFill the image with a linear vertical gradient\nFlip an image horizontally\nFlip an image horizontally and put the result into the …\nFlip an image horizontally in place.\nFlip an image vertically\nFlip an image vertically and put the result into the …\nFlip an image vertically in place.\nRotate an image 180 degrees clockwise.\nRotate an image 180 degrees clockwise and put the result …\nRotate an image 180 degrees clockwise in place.\nRotate an image 270 degrees clockwise.\nRotate an image 270 degrees clockwise and put the result …\nRotate an image 90 degrees clockwise.\nRotate an image 90 degrees clockwise and put the result …\nA bi-level color map\nThe color type on which the map operates on\nA color map\nBrighten the supplied image. <code>value</code> is the amount to …\nBrighten the supplied image in place. <code>value</code> is the amount …\nAdjust the contrast of the supplied image. <code>contrast</code> is the …\nAdjust the contrast of the supplied image in place. …\nFloyd-Steinberg error diffusion\nReduces the colors of the image using the supplied …\nReturns the argument unchanged.\nConvert the supplied image to grayscale. Alpha channel is …\nConvert the supplied image to grayscale. Alpha channel is …\nConvert the supplied image to a grayscale image with the …\nConvert the supplied image to a grayscale image with the …\nDetermine if this implementation of ColorMap overrides the …\nIndicate NeuQuant implements <code>lookup</code>.\nHue rotate the supplied image. <code>value</code> is the degrees to …\nHue rotate the supplied image in place. <code>value</code> is the …\nReduces the colors using the supplied <code>color_map</code> and …\nReturns the index of the closest match of <code>color</code> in the …\nCalls <code>U::from(self)</code>.\nInvert each pixel within the supplied image. This function …\nLooks up color by index in the color map.  If <code>idx</code> is out …\nMaps <code>color</code> to the closest color in the color map.\nCubic Filter\nA Representation of a separable filter.\nAvailable Sampling Filters.\nGaussian Filter\nLanczos with window 3\nNearest Neighbor\nLocal struct for keeping track of pixel sums for fast …\nLinear Filter\nPerforms a Gaussian blur on the supplied image. <code>sigma</code> is a …\nCalculate the box kernel. Only pixels inside the box …\nCalculate the Catmull-Rom cubic spline. Also known as a …\nPerform a 3x3 box filter on the supplied image. <code>kernel</code> is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe Gaussian Function. <code>r</code> is the standard deviation.\nCalculate the gaussian function with a standard deviation …\nLinearly sample from an image using coordinates in [0, w-1]…\nSample from an image using coordinates in [0, w-1] and [0, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe filter’s filter function.\nCalculate the lanczos kernel with a window of 3\nResize the supplied image to the specified dimensions. …\nLinearly sample from an image using coordinates in [0, 1].\nSample from an image using coordinates in [0, 1], taking …\nThe window on which this filter operates.\nResize the supplied image to the specific dimensions.\nGet a pixel for a thumbnail where the input window …\nGet a single pixel for a thumbnail where the input window …\nGet a thumbnail pixel where the input window encloses at …\nGet a thumbnail pixel where the input window encloses at …\nCalculate the triangle function. Also known as <code>BiLinear</code> …\nPerforms an unsharpen mask on the supplied image. <code>sigma</code> is …\nSet of supported strict limits for a decoder.\nResource limits for decoding.\nA multi-format image reader.\nThis function checks the <code>max_image_width</code> and …\nThis function checks that all currently set strict limits …\nThe format, if one has been set or deduced.\nThis function increases the <code>max_alloc</code> limit with amount. …\nThis function acts identically to [<code>free</code>], but takes a <code>usize</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe reader. Should be buffered.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDecoding limits\nThe maximum allowed sum of allocations allocated by the …\nThe maximum allowed image height. This limit is strict. …\nThe maximum allowed image width. This limit is strict. The …\nDisable all limits.\nThis function checks that the current limit allows for …\nThis function acts identically to [<code>reserve</code>], but accepts …\nThis function acts identically to [<code>reserve</code>], but takes a …\nGuess image format from memory block\nCreate a new image from a Reader.\nA multi-format image reader.\nRemove the current information on the image format.\nRead the image (replaces <code>load</code>).\nGet the currently determined format.\nThe format, if one has been set or deduced.\nReturns the argument unchanged.\nThe reader. Should be buffered.\nCalls <code>U::from(self)</code>.\nRead the image dimensions.\nUnwrap the reader.\nSet a custom set of decoding limits.\nDecoding limits\nCreate a new image reader without a preset format.\nDisable all decoding limits.\nOpen a file to read, format will be guessed from path.\nSupply the format as which to interpret the read image.\nConstruct a reader with specified format.\nMake a format guess based on the content, replacing it on …\nA Rectangle defined by its top left corner, width and …\nThe rectangle’s height.\nShared mathematical utility functions.\nThe rectangle’s width.\nThe x coordinate of the top left corner.\nThe y coordinate of the top left corner.\nA Rectangle defined by its top left corner, width and …\nReturns the argument unchanged.\nThe rectangle’s height.\nCalls <code>U::from(self)</code>.\nThe rectangle’s width.\nThe x coordinate of the top left corner.\nThe y coordinate of the top left corner.\nCalculates the width and height an image should be resized …\nThe number of channels of this pixel type.\nA string that can help to interpret the meaning each …\nThis pixel has the format of one of the predefined …\nThe maximum value for this type of primitive within the …\nThe minimum value for this type of primitive within the …\nTypes which are safe to treat as an immutable byte slice …\nAn Enlargable::Larger value should be enough to calculate …\nLinear interpolation without involving floating numbers.\nA generalized pixel.\nThe pixel with an associated <code>ColorType</code>. Not all possible …\nThe type of each channel in a pixel. For example, this can …\nThe scalar type that is used to store each channel in this …\nApply the function <code>f</code> to each channel of this pixel.\nApply the function <code>f</code> to each channel of this pixel and …\nApply the function <code>f</code> to each channel except the alpha …\nApply the function <code>f</code> to each channel except the alpha …\nApply the function <code>f</code> to each channel except the alpha …\nGet the bytes of this value.\nBlend the color of a given pixel into ourself, taking into …\nReturns the components as a slice.\nReturns the channels of this pixel as a 4 tuple. If the …\nReturns the components as a mutable slice\nConstruct a pixel from the 4 channels a, b, c and d. If …\nReturns a view into a slice.\nReturns mutable view into a mutable slice.\nInvert this pixel\nApply the function <code>f</code> to each channel of this pixel.\nApply the function <code>f</code> to each channel of this pixel and …\nApply the function <code>f</code> to each channel except the alpha …\nApply the function <code>f</code> to each channel except the alpha …\nApply the function <code>f</code> to each channel except the alpha …\nPrevents down-stream users from implementing the <code>Primitive</code> …\nPrivate module for supertraits of sealed traits.\nConvert this pixel to luma\nConvert this pixel to luma with an alpha channel\nConvert this pixel to RGB\nConvert this pixel to RGB with an alpha channel\nChecks if the provided dimensions would cause an overflow.\nExpand a buffer of packed 1, 2, or 4 bits integers into u8…")