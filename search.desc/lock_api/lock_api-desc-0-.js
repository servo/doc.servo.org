searchState.loadedDescShard("lock_api", 0, "This library provides type-safe and fully-featured <code>Mutex</code> …\nDuration type used for <code>try_lock_for</code>.\nDuration type used for <code>try_lock_for</code>.\nHelper trait which returns a non-zero thread ID.\nMarker type which determines whether a lock guard should …\nMarker type which determines whether a lock guard should …\nMarker type which indicates that the Guard type for a lock …\nMarker type which indicates that the Guard type for a lock …\nInitial value for an unlocked mutex.\nInitial value.\nInitial value for an unlocked <code>RwLock</code>.\nInstant type used for <code>try_lock_until</code>.\nInstant type used for <code>try_lock_until</code>.\nAn RAII mutex guard returned by <code>MutexGuard::map</code>, which can …\nAn RAII mutex guard returned by <code>ReentrantMutexGuard::map</code>, …\nAn RAII read lock guard returned by <code>RwLockReadGuard::map</code>, …\nAn RAII write lock guard returned by <code>RwLockWriteGuard::map</code>…\nA mutual exclusion primitive useful for protecting shared …\nAn RAII implementation of a “scoped lock” of a mutex. …\nBasic operations for a mutex.\nAdditional methods for mutexes which support fair …\nAdditional methods for mutexes which support locking with …\nA raw mutex type that wraps another raw mutex to provide …\nBasic operations for a reader-writer lock.\nAdditional methods for <code>RwLock</code>s which support atomically …\nAdditional methods for <code>RwLock</code>s which support fair …\nAdditional methods for <code>RwLock</code>s which support recursive …\nAdditional methods for <code>RwLock</code>s which support recursive …\nAdditional methods for <code>RwLock</code>s which support locking with …\nAdditional methods for <code>RwLock</code>s which support atomically …\nAdditional methods for <code>RwLock</code>s which support upgradable …\nAdditional methods for <code>RwLock</code>s which support upgradable …\nAdditional methods for <code>RwLock</code>s which support upgradable …\nA mutex which can be recursively locked by a single thread.\nAn RAII implementation of a “scoped lock” of a …\nA reader-writer lock\nRAII structure used to release the shared read access of a …\nRAII structure used to release the upgradable read access …\nRAII structure used to release the exclusive write access …\nAtomically downgrades an exclusive lock into a shared lock …\nDowngrades an exclusive lock to an upgradable lock.\nDowngrades an upgradable lock to a shared lock.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAcquires this mutex, blocking the current thread until it …\nAcquires an exclusive lock, blocking the current thread …\nAcquires a shared lock, blocking the current thread until …\nAcquires a shared lock without deadlocking in case of a …\nAcquires an upgradable lock, blocking the current thread …\nReturns a non-zero thread ID which identifies the current …\nAttempts to acquire this mutex without blocking. Returns …\nAttempts to acquire an exclusive lock without blocking.\nAttempts to acquire an exclusive lock until a timeout is …\nAttempts to acquire an exclusive lock until a timeout is …\nAttempts to acquire this lock until a timeout is reached.\nAttempts to acquire a shared lock without blocking.\nAttempts to acquire a shared lock until a timeout is …\nAttempts to acquire a shared lock without deadlocking in …\nAttempts to acquire a shared lock until a timeout is …\nAttempts to acquire a shared lock until a timeout is …\nAttempts to acquire a shared lock until a timeout is …\nAttempts to acquire this lock until a timeout is reached.\nAttempts to acquire an upgradable lock without blocking.\nAttempts to acquire an upgradable lock until a timeout is …\nAttempts to acquire an upgradable lock until a timeout is …\nAttempts to upgrade an upgradable lock to an exclusive …\nAttempts to upgrade an upgradable lock to an exclusive …\nAttempts to upgrade an upgradable lock to an exclusive …\nUnlocks this mutex.\nReleases an exclusive lock.\nReleases an exclusive lock using a fair unlock protocol.\nUnlocks this mutex using a fair unlock protocol.\nReleases a shared lock.\nReleases a shared lock using a fair unlock protocol.\nReleases an upgradable lock.\nReleases an upgradable lock using a fair unlock protocol.\nUpgrades an upgradable lock to an exclusive lock.\nDuration type used for <code>try_lock_for</code>.\nMarker type which determines whether a lock guard should …\nInitial value for an unlocked mutex.\nInstant type used for <code>try_lock_until</code>.\nAn RAII mutex guard returned by <code>MutexGuard::map</code>, which can …\nA mutual exclusion primitive useful for protecting shared …\nAn RAII implementation of a “scoped lock” of a mutex. …\nBasic operations for a mutex.\nAdditional methods for mutexes which support fair …\nAdditional methods for mutexes which support locking with …\nTemporarily yields the mutex to a waiting thread if there …\nTemporarily yields the mutex to a waiting thread if there …\nTemporarily yields the mutex to a waiting thread if there …\nCreates a new mutex based on a pre-existing raw mutex.\nReturns a raw pointer to the underlying data.\nForcibly unlocks the mutex.\nForcibly unlocks the mutex using a fair unlock protocol.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new mutex based on a pre-existing raw mutex.\nReturns a mutable reference to the underlying data.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this mutex, returning the underlying data.\nChecks whether the mutex is currently locked.\nChecks whether the mutex is currently locked.\nChecks whether the mutex is currently locked.\nLeaks the mutex guard and returns a mutable reference to …\nAcquires this mutex, blocking the current thread until it …\nAcquires a mutex, blocking the current thread until it is …\nCreates a new <code>MutexGuard</code> without checking if the mutex is …\nMakes a new <code>MappedMutexGuard</code> for a component of the locked …\nMakes a new <code>MappedMutexGuard</code> for a component of the locked …\nReturns a reference to the original <code>Mutex</code> object.\nCreates a new mutex in an unlocked state ready for use.\nReturns the underlying raw mutex object.\nAttempts to acquire this mutex without blocking. Returns …\nAttempts to acquire this lock.\nAttempts to acquire this lock until a timeout is reached.\nAttempts to acquire this lock until a timeout is reached.\nAttempts to acquire this lock until a timeout is reached.\nAttempts to acquire this lock until a timeout is reached.\nAttempts to make a new <code>MappedMutexGuard</code> for a component of …\nAttempts to make a new <code>MappedMutexGuard</code> for a component of …\nUnlocks this mutex.\nUnlocks this mutex using a fair unlock protocol.\nUnlocks the mutex using a fair unlock protocol.\nUnlocks the mutex using a fair unlock protocol.\nTemporarily unlocks the mutex to execute the given …\nTemporarily unlocks the mutex to execute the given …\nHelper trait which returns a non-zero thread ID.\nInitial value.\nInitial value for an unlocked mutex.\nAn RAII mutex guard returned by <code>ReentrantMutexGuard::map</code>, …\nA raw mutex type that wraps another raw mutex to provide …\nA mutex which can be recursively locked by a single thread.\nAn RAII implementation of a “scoped lock” of a …\nTemporarily yields the mutex to a waiting thread if there …\nTemporarily yields the mutex to a waiting thread if there …\nCreates a new reentrant mutex based on a pre-existing raw …\nReturns a raw pointer to the underlying data.\nForcibly unlocks the mutex.\nForcibly unlocks the mutex using a fair unlock protocol.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new reentrant mutex based on a pre-existing raw …\nReturns a mutable reference to the underlying data.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this mutex, returning the underlying data.\nChecks whether the mutex is currently locked.\nChecks whether the mutex is currently locked.\nChecks whether the mutex is currently held by the current …\nChecks whether the mutex is currently held by the current …\nAcquires this mutex, blocking if it’s held by another …\nAcquires a reentrant mutex, blocking the current thread …\nCreates a new <code>ReentrantMutexGuard</code> without checking if the …\nMakes a new <code>MappedReentrantMutexGuard</code> for a component of …\nMakes a new <code>MappedReentrantMutexGuard</code> for a component of …\nCreates a new reentrant mutex in an unlocked state ready …\nReturns a non-zero thread ID which identifies the current …\nReturns the underlying raw mutex object.\nReturns a reference to the original <code>ReentrantMutex</code> object.\nAttempts to acquire this mutex without blocking. Returns …\nAttempts to acquire this lock.\nAttempts to acquire this lock until a timeout is reached.\nAttempts to acquire this lock until a timeout is reached.\nAttempts to acquire this lock until a timeout is reached.\nAttempts to acquire this lock until a timeout is reached.\nAttempts to make  a new <code>MappedReentrantMutexGuard</code> for a …\nAttempts to make  a new <code>MappedReentrantMutexGuard</code> for a …\nUnlocks this mutex. The inner mutex may not be unlocked if …\nUnlocks this mutex using a fair unlock protocol. The inner …\nUnlocks the mutex using a fair unlock protocol.\nUnlocks the mutex using a fair unlock protocol.\nTemporarily unlocks the mutex to execute the given …\nTemporarily unlocks the mutex to execute the given …\nDuration type used for <code>try_lock_for</code>.\nMarker type which determines whether a lock guard should …\nInitial value for an unlocked <code>RwLock</code>.\nInstant type used for <code>try_lock_until</code>.\nAn RAII read lock guard returned by <code>RwLockReadGuard::map</code>, …\nAn RAII write lock guard returned by <code>RwLockWriteGuard::map</code>…\nBasic operations for a reader-writer lock.\nAdditional methods for <code>RwLock</code>s which support atomically …\nAdditional methods for <code>RwLock</code>s which support fair …\nAdditional methods for <code>RwLock</code>s which support recursive …\nAdditional methods for <code>RwLock</code>s which support recursive …\nAdditional methods for <code>RwLock</code>s which support locking with …\nAdditional methods for <code>RwLock</code>s which support atomically …\nAdditional methods for <code>RwLock</code>s which support upgradable …\nAdditional methods for <code>RwLock</code>s which support upgradable …\nAdditional methods for <code>RwLock</code>s which support upgradable …\nA reader-writer lock\nRAII structure used to release the shared read access of a …\nRAII structure used to release the upgradable read access …\nRAII structure used to release the exclusive write access …\nTemporarily yields the <code>RwLock</code> to a waiting thread if there …\nTemporarily yields the <code>RwLock</code> to a waiting thread if there …\nTemporarily yields the <code>RwLock</code> to a waiting thread if there …\nTemporarily yields an exclusive lock to a waiting thread …\nTemporarily yields an exclusive lock to a waiting thread …\nTemporarily yields a shared lock to a waiting thread if …\nTemporarily yields a shared lock to a waiting thread if …\nTemporarily yields an upgradable lock to a waiting thread …\nTemporarily yields an upgradable lock to a waiting thread …\nCreates a new new instance of an <code>RwLock&lt;T&gt;</code> based on a …\nReturns a raw pointer to the underlying data.\nAtomically downgrades an exclusive lock into a shared lock …\nAtomically downgrades a write lock into a read lock …\nAtomically downgrades an upgradable read lock lock into a …\nDowngrades an exclusive lock to an upgradable lock.\nAtomically downgrades a write lock into an upgradable read …\nDowngrades an upgradable lock to a shared lock.\nForcibly unlocks a read lock.\nForcibly unlocks a read lock using a fair unlock protocol.\nForcibly unlocks a write lock.\nForcibly unlocks a write lock using a fair unlock protocol.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new new instance of an <code>RwLock&lt;T&gt;</code> based on a …\nReturns a mutable reference to the underlying data.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this <code>RwLock</code>, returning the underlying data.\nChecks if this <code>RwLock</code> is currently locked in any way.\nChecks if this <code>RwLock</code> is currently locked in any way.\nChecks whether this <code>RwLock</code> is currently locked in any way.\nCheck if this <code>RwLock</code> is currently exclusively locked.\nCheck if this <code>RwLock</code> is currently exclusively locked.\nCheck if this <code>RwLock</code> is currently exclusively locked.\nAcquires an exclusive lock, blocking the current thread …\nAcquires a shared lock, blocking the current thread until …\nAcquires a shared lock without deadlocking in case of a …\nAcquires an upgradable lock, blocking the current thread …\nCreates a new <code>RwLockReadGuard</code> without checking if the lock …\nCreates a new <code>RwLockUpgradableReadGuard</code> without checking …\nCreates a new <code>RwLockReadGuard</code> without checking if the lock …\nMake a new <code>MappedRwLockReadGuard</code> for a component of the …\nMake a new <code>MappedRwLockWriteGuard</code> for a component of the …\nMake a new <code>MappedRwLockReadGuard</code> for a component of the …\nMake a new <code>MappedRwLockWriteGuard</code> for a component of the …\nCreates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked.\nReturns the underlying raw reader-writer lock object.\nLocks this <code>RwLock</code> with shared read access, blocking the …\nLocks this <code>RwLock</code> with shared read access, blocking the …\nReturns a reference to the original reader-writer lock …\nReturns a reference to the original reader-writer lock …\nReturns a reference to the original reader-writer lock …\nAttempts to acquire an exclusive lock without blocking.\nAttempts to acquire an exclusive lock until a timeout is …\nAttempts to acquire an exclusive lock until a timeout is …\nAttempts to acquire a shared lock without blocking.\nAttempts to acquire a shared lock until a timeout is …\nAttempts to acquire a shared lock without deadlocking in …\nAttempts to acquire a shared lock until a timeout is …\nAttempts to acquire a shared lock until a timeout is …\nAttempts to acquire a shared lock until a timeout is …\nAttempts to acquire an upgradable lock without blocking.\nAttempts to acquire an upgradable lock until a timeout is …\nAttempts to acquire an upgradable lock until a timeout is …\nAttempts to make  a new <code>MappedRwLockReadGuard</code> for a …\nAttempts to make  a new <code>MappedRwLockWriteGuard</code> for a …\nAttempts to make  a new <code>MappedRwLockReadGuard</code> for a …\nAttempts to make  a new <code>MappedRwLockWriteGuard</code> for a …\nAttempts to acquire this <code>RwLock</code> with shared read access.\nAttempts to acquire this <code>RwLock</code> with shared read access …\nAttempts to acquire this <code>RwLock</code> with shared read access.\nAttempts to acquire this <code>RwLock</code> with shared read access …\nAttempts to acquire this <code>RwLock</code> with shared read access …\nAttempts to acquire this <code>RwLock</code> with shared read access …\nAttempts to acquire this <code>RwLock</code> with upgradable read …\nAttempts to acquire this <code>RwLock</code> with upgradable read …\nAttempts to acquire this <code>RwLock</code> with upgradable read …\nAttempts to upgrade an upgradable lock to an exclusive …\nTries to atomically upgrade an upgradable read lock into …\nAttempts to upgrade an upgradable lock to an exclusive …\nTries to atomically upgrade an upgradable read lock into …\nAttempts to upgrade an upgradable lock to an exclusive …\nTries to atomically upgrade an upgradable read lock into …\nFirst, tries to atomically upgrade an upgradable read lock …\nTries to atomically upgrade an upgradable read lock into …\nTries to atomically upgrade an upgradable read lock into …\nAttempts to lock this <code>RwLock</code> with exclusive write access.\nAttempts to acquire this <code>RwLock</code> with exclusive write …\nAttempts to acquire this <code>RwLock</code> with exclusive write …\nReleases an exclusive lock.\nReleases an exclusive lock using a fair unlock protocol.\nUnlocks the <code>RwLock</code> using a fair unlock protocol.\nUnlocks the <code>RwLock</code> using a fair unlock protocol.\nUnlocks the <code>RwLock</code> using a fair unlock protocol.\nUnlocks the <code>RwLock</code> using a fair unlock protocol.\nUnlocks the <code>RwLock</code> using a fair unlock protocol.\nReleases a shared lock.\nReleases a shared lock using a fair unlock protocol.\nReleases an upgradable lock.\nReleases an upgradable lock using a fair unlock protocol.\nTemporarily unlocks the <code>RwLock</code> to execute the given …\nTemporarily unlocks the <code>RwLock</code> to execute the given …\nTemporarily unlocks the <code>RwLock</code> to execute the given …\nTemporarily unlocks the <code>RwLock</code> to execute the given …\nTemporarily unlocks the <code>RwLock</code> to execute the given …\nTemporarily unlocks the <code>RwLock</code> to execute the given …\nLocks this <code>RwLock</code> with upgradable read access, blocking …\nUpgrades an upgradable lock to an exclusive lock.\nAtomically upgrades an upgradable read lock lock into an …\nFirst, atomically upgrades an upgradable read lock lock …\nLocks this <code>RwLock</code> with exclusive write access, blocking …")