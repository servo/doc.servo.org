searchState.loadedDescShard("rayon_core", 0, "Rayon-core houses the core stable APIs of Rayon.\nProvides context to a closure called by <code>broadcast</code>.\nContains the rayon thread pool configuration. Use …\nWork was found and executed.\nThe type for a closure that gets invoked when a thread …\nProvides the calling context to a closure called by …\nNo available work was found.\nThe type for a panic handling closure. Note that this same …\nRepresents a fork-join scope which can be used to spawn …\nRepresents a fork-join scope which can be used to spawn …\nThe type for a closure that gets invoked when a thread …\nThread builder used for customization via …\nRepresents a user created thread-pool.\nError when initializing a thread pool.\nUsed to create a new <code>ThreadPool</code> or to configure the global …\nResult of <code>yield_now()</code> or <code>yield_local()</code>.\nMake sure to prevent auto-traits like <code>Send</code> and <code>Sync</code>.\ndisable <code>Send</code> and <code>Sync</code>, just for a little future-proofing.\n<strong>(DEPRECATED)</strong> Suggest to worker threads that they execute …\nDeprecated in favor of <code>ThreadPoolBuilder::breadth_first</code>.\nIf false, worker threads will execute spawned jobs in a “…\nExecutes <code>op</code> within every thread in the current threadpool. …\nCreates a new <code>ThreadPool</code> initialized using this …\nDeprecated in favor of <code>ThreadPoolBuilder::build</code>.\nInitializes the global thread pool. This initialization is …\nCreates a scoped <code>ThreadPool</code> initialized using this …\nReturns the number of threads in the current registry. If …\nIf called from a Rayon worker thread, indicates whether …\nIf called from a Rayon worker thread, returns the index of …\nSets a callback to be invoked on thread exit.\nDeprecated in favor of <code>ThreadPoolBuilder::exit_handler</code>.\nClosure invoked on worker thread exit.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the number of threads that will be used for the thread …\nReturns a reference to the current spawn handler.\nGet the stack size of the worker threads\nGet the thread name for the thread with the given index.\nClosure to compute the name of a thread.\nCreates a “fork-join” scope <code>s</code> and invokes the closure …\nCreates a “fork-join” scope <code>s</code> with FIFO order, and …\nDeprecated in favor of <code>ThreadPoolBuilder::build_global</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a ThreadPoolBuilder with identical parameters.\nTakes two closures and <em>potentially</em> runs them in parallel. …\nIdentical to <code>join</code>, except that the closures have a …\nReturns the maximum number of threads that Rayon supports …\nReturns <code>true</code> if the closure was called from a different …\nCreates and returns a valid rayon thread pool builder, but …\nCreates and return a valid rayon thread pool …\nSets the number of threads to be used in the rayon …\nDeprecated in favor of <code>ThreadPoolBuilder::num_threads</code>.\nThe number of threads in the rayon thread pool. If zero …\nNormally, whenever Rayon catches a panic, it tries to …\nDeprecated in favor of <code>ThreadPoolBuilder::panic_handler</code>.\nCustom closure, if any, to handle a panic that we cannot …\nThe public parts of this private module are used to create …\nMethods for custom fork-join scopes, created by the <code>scope()</code>\nCreates a “fork-join” scope <code>s</code> and invokes the closure …\nCreates a “fork-join” scope <code>s</code> with FIFO order, and …\nCode that decides when workers should go to sleep. See …\nPuts the task into the Rayon threadpool’s job queue in …\nSpawns an asynchronous task on every thread in this …\nFires off a task into the Rayon threadpool in the “static…\nSets a custom function for spawning threads.\nClosure invoked to spawn threads.\nSets the stack size of the worker threads\nDeprecated in favor of <code>ThreadPoolBuilder::stack_size</code>.\nThe stack size for the created worker threads\nSets a callback to be invoked on thread start.\nDeprecated in favor of <code>ThreadPoolBuilder::start_handler</code>.\nClosure invoked on worker thread start.\nReturns a current thread exit callback, leaving <code>None</code>.\nReturns a copy of the current panic handler.\nTakes the current thread start callback, leaving <code>None</code>.\nSets a closure which takes a thread index and returns the …\nDeprecated in favor of <code>ThreadPoolBuilder::thread_name</code>.\nContains support for user-managed thread pools, …\nPackage up unwind recovery. Note that if you are in some …\nUse the current thread as one of the threads in the pool.\nThe thread we’re building <em>from</em> will also be part of the …\nCooperatively yields execution to local Rayon work.\nCooperatively yields execution to Rayon.\nProvides context to a closure called by <code>broadcast</code>.\nMake sure to prevent auto-traits like <code>Send</code> and <code>Sync</code>.\nExecutes <code>op</code> within every thread in the current threadpool. …\nExecute <code>op</code> on every thread in the pool. It will be …\nReturns the argument unchanged.\nOur index amongst the broadcast threads (ranges from …\nCalls <code>U::from(self)</code>.\nThe number of threads receiving the broadcast in the …\nSpawns an asynchronous task on every thread in this …\nExecute <code>op</code> on every thread in the pool. It will be …\nRepresents a job stored in an <code>Arc</code> – like <code>HeapJob</code>, but may\nRepresents a job stored in the heap. Used to implement …\nA <code>Job</code> is used to advertise work for other threads that …\nIndirect queue to provide FIFO job priority.\nEffectively a Job trait object. Each JobRef <strong>must</strong> be …\nA job that will be owned by a stack slot. This means that …\nCreates a <code>JobRef</code> from this job – note that this hides all\nCreates a static <code>JobRef</code> from this job.\nUnsafe: this may be called from a different thread than …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns an opaque handle that can be saved and compared, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a <code>JobRef</code> from this job – note that this hides all\nConvert the <code>JobResult</code> for a job that has finished (and …\nCreates a static <code>JobRef</code> from this job.\nUnsafe: caller asserts that <code>data</code> will remain valid until …\nTakes two closures and <em>potentially</em> runs them in parallel. …\nIdentical to <code>join</code>, except that the closures have a …\nIf job A panics, we still cannot return until we are sure …\nA latch for scopes created on a non-rayon thread which …\nSpin latches are the simplest, most efficient kind, but …\nCounting latches are used to implement scopes. They track a\nWe define various kinds of latches, which are all a …\n<code>&amp;L</code> without any implication of <code>dereferenceable</code> for …\nA Latch starts as false and eventually becomes true. You …\nOnce latches are used to implement one-time blocking, …\nLatch is set.\nLatch is not set, owning thread is asleep on this latch and\nLatch is not set, owning thread is going to sleep on this …\nSpin latches are the simplest, most efficient kind, but …\nA latch for scopes created on a rayon thread which will …\nLatch is not set, owning thread is awake\nCreates a new spin latch for cross-threadpool blocking.  …\nInvoked by owning thread as it falls asleep sleep. Returns …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInvoked by owning thread as it prepares to sleep. Returns …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new spin latch that is owned by <code>thread</code>. This …\nTest if this latch has been set.\nSet the latch, signalling others.\nSet the latch. If this returns true, the owning thread was …\nSet the latch, then tickle the specific worker thread, …\nBlock until latch is set.\nBlock until latch is set, then resets this lock latch so …\nInvoked by owning thread as it falls asleep sleep. Returns …\nIf a worker thread in registry A calls <code>in_place_scope</code> on a …\nThe index of the worker to wake in <code>registry</code>\nIf this type is pub but not publicly reachable, third …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSpawns a thread with a user’s custom callback.\nSpawns a thread in the “normal” way with …\n…\nThread builder used for customization via …\nGeneralized trait for spawning a thread in the <code>Registry</code>.\n…\nxorshift* is a fast pseudorandom number generator which …\nGets the <code>WorkerThread</code> index for the current thread; returns\nReturns the number of threads in the current registry.  …\nReturns the current <code>WorkerThread</code> if it’s part of this …\nlocal queue used for <code>spawn_fifo</code> indirection\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nStarts the worker threads (if that has not already …\nReturns an opaque identifier for this registry.\nIf already in a worker-thread, just execute <code>op</code>.  Otherwise,\nIf already in a worker-thread of this registry, just …\nIncrements the terminate counter. This increment should be …\nGets the index of this thread in the pool, within …\nOur index amongst the worker threads (ranges from …\nStarts the worker threads (if that has not already …\nPush a job into the “external jobs” queue; it will be …\nPush a job into each thread’s own “external jobs” …\n…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n…\nGets the string that was specified by …\nReturn a value from <code>0..n</code>.\nNotify the worker that the latch they are sleeping on has …\nLatch set once thread has started and we are entering into …\nReturns the registry that owns this worker thread.\nA weak random number generator.\nExecutes the main loop for this thread. This will not …\nSets <code>self</code> as the worker thread index for the current …\nStarts the worker threads (if that has not already …\nSpawn a thread with the <code>ThreadBuilder</code> parameters, and then …\nGets the value that was specified by …\nTry to steal a single job and return it.\nthe “stealer” half of the worker’s deque\nthe “stealer” half of the worker’s broadcast deque\nLatch is set once worker thread has completed. Used to wait\nAttempts to obtain a “local” job – typically this …\nSignals that the thread-pool which owns this registry has …\nThe latch used to signal that terminated has been …\nWait until the latch is set. Try to keep busy by popping …\nWaits for the worker threads to get up and running.  This …\nthe “worker” half of our local deque\nRepresents a fork-join scope which can be used to spawn …\nRepresents a fork-join scope which can be used to spawn …\nUsed to capture a scope <code>&amp;Self</code> pointer in jobs, without …\nExecutes <code>func</code> as a job, either aborting or executing as …\nExecutes <code>func</code> as a job, either aborting or executing as …\nExecutes <code>func</code> as a job in scope. Adjusts the “job …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a “fork-join” scope <code>s</code> and invokes the closure …\nCreates a “fork-join” scope <code>s</code> with FIFO order, and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nlatch to track job counts\nYou can think of a scope as containing a list of closures …\nCreates the base of a new scope for the given registry\nif some job panicked, the error is stored here; it will be …\nthread registry where <code>scope()</code> was executed or where …\nCreates a “fork-join” scope <code>s</code> and invokes the closure …\nCreates a “fork-join” scope <code>s</code> with FIFO order, and …\nSpawns a job into the fork-join scope <code>self</code>. This job will …\nSpawns a job into every thread of the fork-join scope <code>self</code>…\nSpawns a job into every thread of the fork-join scope <code>self</code>…\nSpawns a job into the fork-join scope <code>self</code>. This job will …\nAn instance of this struct is created when a thread …\nThe <code>Sleep</code> struct is embedded into each registry. It …\nThe “sleep state” for an individual worker.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet to true when the worker goes to sleep; set to false …\nOnce we become sleepy, what was the sleepy counter value? …\nSignals that <code>num_jobs</code> new jobs were injected into the …\nSignals that <code>num_jobs</code> new jobs were pushed onto a thread’…\nCommon helper for <code>new_injected_jobs</code> and <code>new_internal_jobs</code>.\nNotify the given thread that it should wake up (if it is …\nHow many rounds have we been circling without sleeping?\nWhat is worker index of the idle thread?\nOne “sleep state” per worker. Used to track if a …\nBits to shift to select the inactive threads (used with …\nBits to shift to select the JEC (use JOBS_BITS).\nA value read from the <strong>Jobs Event Counter</strong>. See the <code>README.md</code>…\nConstant that can be added to add one inactive thread. An …\nConstant that can be added to add one to the JEC.\nConstant that can be added to add one sleeping thread.\nBits to shift to select the sleeping threads (used with …\nNumber of bits used for the thread counters.\nMax value for the thread counters.\nAdds an inactive thread. This cannot fail.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe number of threads that are not actively executing …\nIncrements the jobs event counter if <code>increment_when</code>, when …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe JEC “is active” if the last thread to increment it …\nThe JEC “is sleepy” if the last thread to increment it …\nLoad and return the current value of the various counters. …\nSubtracts an inactive thread. This cannot fail. It is …\nSubtracts a sleeping thread. This cannot fail, but it is …\nPacks together a number of counters. The counters are …\nPuts the task into the Rayon threadpool’s job queue in …\nFires off a task into the Rayon threadpool in the “static…\nSpawns an asynchronous FIFO job in <code>registry.</code>\nSpawns an asynchronous job in <code>registry.</code>\nWork was found and executed.\nNo available work was found.\nRepresents a user created thread-pool.\nResult of <code>yield_now()</code> or <code>yield_local()</code>.\nExecutes <code>op</code> within every thread in the threadpool. Any …\nReturns the (current) number of threads in the thread pool.\nIf called from a Rayon worker thread, indicates whether …\nReturns true if the current worker thread currently has “…\nIf called from a Rayon worker thread, returns the index of …\nIf called from a Rayon worker thread in this thread-pool, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a scope that spawns work into this thread-pool.\nCreates a scope that spawns work into this thread-pool in …\nExecutes <code>op</code> within the threadpool. Any attempts to use <code>join</code>…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExecute <code>oper_a</code> and <code>oper_b</code> in the thread-pool and return …\nDeprecated in favor of <code>ThreadPoolBuilder::build</code>.\nCreates a scope that executes within this thread-pool. …\nCreates a scope that executes within this thread-pool. …\nSpawns an asynchronous task in this thread-pool. This task …\nSpawns an asynchronous task on every thread in this …\nSpawns an asynchronous task in this thread-pool. This task …\nCooperatively yields execution to local Rayon work.\nCooperatively yields execution to local Rayon work.\nCooperatively yields execution to Rayon.\nCooperatively yields execution to Rayon.\nReturns the argument unchanged.\nExecutes <code>f</code> and captures any panic, translating that panic …\nCalls <code>U::from(self)</code>.")