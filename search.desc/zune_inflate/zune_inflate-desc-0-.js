searchState.loadedDescShard("zune_inflate", 0, "An incredibly spiffy deflate decoder.\nA deflate decoder instance.\nA simple Deflate Encoder.\nOptions that can influence decompression in …\n<code>BitStreamReader</code> API\nErrors possible when decoding deflate/zlib/gzip streams\nReturns the argument unchanged.\nGet number of bits left in the bit buffer.\nGet position the stream is in this buffer Or …\nReturn true if the bit buffer can satisfy <code>bits</code> read …\nCalls <code>U::from(self)</code>.\nCreate a new <code>BitStreamReader</code> instance\nRefill the bitstream ensuring the buffer has bits between …\nReturn the remaining bytes in this stream.\nReset buffer and bits left to zero.\nMaximum codeword length across all codes.\nMaximum length of a deflate match\nMaximum number of symbols across all codes\nMaximum codeword length in bits for each precode\nNumber of symbols in each Huffman code.  Note: for the …\nOrder which precode lengths are stored\nMaximum possible overrun when decoding codeword lengths\nNumber of bytes copied per every loop\nWorst case maximum number of output bytes writtern during …\nEnd of block entry in litlen decode table\nPresence of HUFFDEC_SUITABLE_POINTER or …\nPresence of a literal entry\nPointer entry in the litlen or offset decode table\nNote, default libdeflate value is 402, but with 512, we …\nMaximum bits found in the lookup table for offsets offsets …\nFormat for precode decode table entries, Bits not …\nA deflate decoder instance.\nOptions that can influence decompression in …\nBuild decode tables for static and dynamic huffman blocks.\nBuild the decode table for the precode\nDecode a deflate stream returning the data as <code>Vec&lt;u8&gt;</code> or …\nDecode zlib-encoded data returning the uncompressed in a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet whether the decoder will confirm a checksum after …\nGet deflate/zlib limit option\nGet the default set size hint for the decompressor\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new decompressor that will read compressed data …\nCreate new decoder with specified options\nResize vector if its current space wont be able to store a …\nSet whether the decoder should confirm a checksum after …\nSet a limit to the internal vector used to store decoded …\nSet the size hint for the decompressor\nMain inner loop for decompressing deflate data\nA simple Deflate Encoder.\nEncode a deflate stream\nEncode a deflate data block with no compression\nFast match finder\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new deflate encoder.\nInput data was malformed.\nAnything that isn’t significant\nAnything that isn’t significant but we need to pass back …\nA struct returned when decompression fails\nInput data is not enough to construct a full output\nOutput Adler does not match stored adler\nOutput CRC does not match stored CRC.\nLimit set by the user was exceeded by decompressed output\nDecoded data up until that decompression error\nreason why decompression fails\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new decode wrapper with data being how many bytes …\nCreate a new decode wrapper with an empty vector\nCalculate the adler hash of a piece of data.\nReturn the minimum of two usizes in a const context\nA safe version of src.copy_within that helps me because I …\nmake_decode_table_entry() creates a decode table entry for …")