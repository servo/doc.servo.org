searchState.loadedDescShard("rustls", 0, "Rustls - a modern TLS library\nA list of all the cipher suites supported by rustls.\nA list of all the key exchange groups supported by rustls.\nA list of all the protocol versions supported by rustls.\nAES with 128-bit keys in Galois counter mode.\nAES with 256-bit keys in Galois counter mode.\nThe <code>AlertDescription</code> TLS protocol enum.  Values in this …\nWe received a fatal alert.  This means the peer is unhappy.\nThe certificate is valid, but the handshake is rejected …\nThe certificate is not correctly encoded.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nA certificate is not correctly signed by the key of its …\nThe CRL had a bad, or unsupported signature from its …\nBulk symmetric encryption scheme used by a cipher suite.\nThe ways in which a certificate revocation list (CRL) can …\nThis type contains a single certificate by value.\nThe ways in which certificate validators can express …\nChacha20 for confidentiality with poly1305 for …\nThe <code>CipherSuite</code> TLS protocol enum.  Values in this enum …\nA client initiates the connection.\nA client connection\nConnection state common to both client and server …\nBuilding a <code>ServerConfig</code> or <code>ClientConfig</code> in a …\nHelper trait to abstract <code>ConfigBuilder</code> over building a …\nA client or server connection.\nInterface shared by client and server connections.\nThe <code>ContentType</code> TLS protocol enum.  Values in this enum …\nThe cipher suite configuration that an application should …\nThe version configuration that an application should use …\nWe couldn’t decrypt a message.  This is invariably fatal.\nThis type combines a <code>SignatureScheme</code> and a signature …\nA <code>DistinguishedName</code> is a <code>Vec&lt;u8&gt;</code> wrapped in internal types.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nThe current time is after the <code>notAfter</code> time in the …\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nThis function doesn’t work until the TLS handshake is …\nAn advertised message was larger then expected.\nThe <code>HandshakeType</code> TLS protocol enum.  Values in this enum …\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nThe peer sent us a syntactically incorrect …\nContext was incorrectly attached to a certificate request …\nA provided certificate revocation list (CRL) was invalid.\nWe saw an invalid certificate.\nA peer sent an invalid certificate status type\nAn unknown content type was encountered during message …\nThe CRL contained an invalid CRL number.\nA peer’s DH params could not be decoded\nA message was zero-length when its record kind forbids it.\nA peer sent an unexpected key update request.\nA corrupt TLS message payload that resulted in an error.\nThe peer sent us a TLS message with invalid contents.\nThe certificate is being used for a different purpose than …\nThe CRL contained a revoked certificate with an invalid …\nThe presented SCT(s) were invalid.\nA peer’s server name could not be decoded\nValues of this structure are returned from …\nThe CRL issuer does not specify the cRLSign key usage.\nThis trait represents the ability to do something useful …\n<code>KeyLog</code> implementation that opens a file whose name is …\nA TLS message payload was larger then allowed by the …\nMessage is shorter than the expected length\nMissing data for the named handshake payload value\nA peer did not advertise its supported key exchange groups.\nThe <code>NamedGroup</code> TLS protocol enum.  Values in this enum are …\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nKeyLog that does exactly nothing.\nA peer sent an empty list of signature schemes\nThe subject names in an end-entity certificate do not …\nThe current time is before the <code>notBefore</code> time in the …\nAny other error.\nThe CRL is invalid for some other reason.\nA trust anchor, commonly known as a “Root Certificate.”\nThe CRL is not correctly encoded.\nThe set of cases where we failed to make a connection …\nThe peer doesn’t support a protocol version/feature we …\nThe set of cases where we failed to make a connection …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nThis type contains a private key by value.\nThe <code>ProtocolVersion</code> TLS protocol enum.  Values in this …\nA structure that implements <code>std::io::Read</code> for reading …\nThe certificate has been revoked.\nA container for root certificates able to provide a …\nA server waits for a client to connect.\nA server connection\nSide of the connection.\nData specific to the peer’s side (client or server).\nThe <code>SignatureAlgorithm</code> TLS protocol enum.  Values in this …\nThe <code>SignatureScheme</code> TLS protocol enum.  Values in this …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nA cipher suite supported by rustls.\nA key-exchange group supported by rustls.\nA TLS protocol version supported by rustls.\nA concrete, safe ticket creation mechanism.\nA TLS 1.2 cipher suite\nA TLS 1.2 cipher suite supported by rustls.\nA TLS 1.3 cipher suite\nA TLS 1.3 cipher suite supported by rustls.\nTrailing data found for the named handshake payload value\nA peer sent an unexpected message type.\nThe certificate contains an extension marked critical, but …\nThe certificate chain is not issued by a known root …\nAn unknown TLS protocol was encountered during message …\nA peer sent a non-null compression method.\nThe CRL, or a revoked certificate in the CRL, contained an …\nThe CRL is not a v2 X.509 CRL.\nA peer sent an unknown elliptic curve type.\nThe CRL is an unsupported delta CRL, containing only …\nThe CRL is an unsupported indirect CRL, containing revoked …\nA peer sent an unsupported key exchange algorithm.\nThe certificate verifier doesn’t support the given type …\nThe CRL contained a revoked certificate with an …\nConfig builder state where the caller must supply cipher …\nConfig builder state where the caller must supply key …\nConfig builder state where the caller must supply a …\nConfig builder state where the caller must supply TLS …\nA structure that implements <code>std::io::Write</code> for writing …\nThe corresponding ring agreement::Algorithm\nAll defined ciphersuites appear in this module.\nItems for use in a client.\nCommon cipher suite fields.\nCommon cipher suite fields.\nOur TLS connection\nOur connection\nThis is a non-standard extension which extends the key …\nHow long the fixed part of the ‘IV’ is.\nIf the peer has signaled end of stream.\nInternal classes which may be useful outside the library. …\nHow to exchange/agree keys.\nAll defined key exchange groups appear in this module.\nLog the given <code>secret</code>.  <code>client_random</code> is provided for …\nThis is the rustls manual.\nThe IANA “TLS Supported Groups” name of the group\nProtocol whose key schedule should be used. Unused for TLS …\nThe single place where we generate random material for our …\nThe list of roots.\nThe <code>SignatureScheme</code> used to produce the signature.\nItems for use in a server.\nMessage signing interfaces and implementations.\nHow to sign messages for authentication.\nThe underlying transport, like a socket\nThe underlying transport, like a socket\nAll defined protocol versions appear in this module.\nThe TLS enumeration naming this version.\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received\nA trust anchor, commonly known as a “Root Certificate.”\nA container for root certificates able to provide a …\nAdd a single DER-encoded certificate to the store.\nParse the given DER-encoded certificates and add all that …\nAdds all the given TrustAnchors <code>anchors</code>.  This does not …\nAdds all the given TrustAnchors <code>anchors</code>.  This does not …\nMake a new, empty <code>RootCertStore</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs an <code>OwnedTrustAnchor</code> from its components.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if there are no certificates.\nSay how many certificates are in the container.\nThe list of roots.\nReturn the subject field including its outer SEQUENCE …\nGet a <code>webpki::TrustAnchor</code> by borrowing the owned elements.\nAlternative implementation of <code>fmt::Debug</code> for byte slice.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBuilding a <code>ServerConfig</code> or <code>ClientConfig</code> in a …\nHelper trait to abstract <code>ConfigBuilder</code> over building a …\nConfig builder state where the caller must supply cipher …\nConfig builder state where the caller must supply key …\nConfig builder state where the caller must supply a …\nConfig builder state where the caller must supply TLS …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSets a custom <code>ResolvesServerCert</code>.\nSet Certificate Transparency logs to use for server …\nChoose a specific set of cipher suites.\nSets a single certificate chain and matching private key …\nSets a single certificate chain and matching private key …\nSets a custom <code>ResolvesClientCert</code>.\nSets a custom <code>ResolvesClientCert</code>.\nChoose how to verify client certificates.\nSet a custom certificate verifier.\nChoose a specific set of key exchange groups.\nDo not support client auth.\nDo not support client auth.\nDisable client authentication.\nUse a specific set of protocol versions.\nChoose how to verify server certificates.\nChoose the default set of cipher suites (…\nChoose the default set of key exchange groups (…\nAccept the default protocol versions: both TLS1.2 and …\nStart side-specific config with defaults for underlying …\nSets a single certificate chain and matching private key …\nSets a single certificate chain and matching private key …\nSets a single certificate chain and matching private key.  …\nSets a single certificate chain, matching private key, OCSP\nFor a Message $m, and a HandshakePayload enum member …\nLike require_handshake_msg, but moves the payload out of …\nA <code>MessageDecrypter</code> which doesn’t work.\nA <code>MessageEncrypter</code> which doesn’t work.\nA write or read IV.\nObjects with this trait can decrypt TLS messages.\nObjects with this trait can encrypt TLS messages.\nPerform the decryption over the concerned TLS message.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCommon state for cipher suites (both for TLS 1.2 and TLS …\nThe TLS1.3 ciphersuite TLS_AES_128_GCM_SHA256\nThe TLS1.3 ciphersuite TLS_AES_256_GCM_SHA384\nThe TLS1.3 ciphersuite TLS_CHACHA20_POLY1305_SHA256\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nHow to do bulk encryption.\nThe TLS enumeration naming this cipher suite.\nPolicy for enforcing Certificate Transparency.\nCommon configuration for (typically) all connections made …\nThis represents a single TLS client connection.\nState associated with a client connection.\nAn implementer of <code>ClientSessionStore</code> that stores everything\nA trait for the ability to store client session data, so …\nAccessor for dangerous configuration options.\nDisable 1.2 resumption.\nThe server is identified by a DNS name.  The name is sent …\nZero-sized marker type representing verification of a …\nThe provided input could not be parsed because it is not a …\nThe server is identified by an IP address. SNI is not done.\nA trait for the ability to choose a certificate chain and …\nConfiguration for how/when a client is allowed to resume a …\nZero-sized marker type representing verification of a …\nSomething that can verify a server certificate chain, and …\nEncodes ways a client can know the expected name of the …\nSupport 1.2 resumption using session ids only.\nSupport 1.2 resumption using session ids or RFC 5077 …\nWhat mechanisms to support for resuming a TLS 1.2 session.\nA config builder state where the caller needs to supply …\nA config builder state where the caller needs to supply a …\nDefault <code>ServerCertVerifier</code>, see the trait impl for more …\nStub that implements io::Write and dispatches to …\nWhich ALPN protocols we include in our client hello. If …\nThe underlying ClientConfig\nList of ciphersuites, in preference order.\nHow to decide what client auth certificate/keys to use.\nWhether to send data on the first flight (“early data”…\nWhether to send the Server Name Indication (SNI) extension …\nReturn true if any certificates at all are available.\nRemember a TLS1.3 ticket that might be retrieved later …\nHow to output key material for debugging.  The default …\nList of supported key exchange algorithms, in preference …\nThis should return the value most recently passed to …\nThe maximum size of TLS message we’ll emit.  If None, we …\nRemove and forget any saved TLS1.2 session for <code>server_name</code>.\nWith the server-supplied acceptable issuers in …\nHow and when the client can resume a previous session.\nRemember what <code>NamedGroup</code> the given server chose.\nRemember a TLS1.2 session.\nHow we store session data or tickets. The default is to …\nReturn a TLS1.3 ticket previously provided to …\nWhat mechanism is used for resuming a TLS 1.2 session.\nGet the most recently saved TLS1.2 session for <code>server_name</code> …\nHow to verify the server certificate chain.\nVerify the end-entity certificate <code>end_entity</code> is valid for …\nVerify that the end-entity certificate <code>end_entity</code> is a …\nVerify that the <code>end_entity</code> has a name or alternative name …\nSupported versions, in no particular order.  The default …\nA config builder state where the caller needs to supply …\nA config builder state where the caller needs to supply a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCommon configuration for (typically) all connections made …\nThis represents a single TLS client connection.\nState associated with a client connection.\nA trait for the ability to store client session data, so …\nDisable 1.2 resumption.\nThe server is identified by a DNS name.  The name is sent …\nThe server is identified by an IP address. SNI is not done.\nA trait for the ability to choose a certificate chain and …\nConfiguration for how/when a client is allowed to resume a …\nEncodes ways a client can know the expected name of the …\nSupport 1.2 resumption using session ids only.\nSupport 1.2 resumption using session ids or RFC 5077 …\nWhat mechanisms to support for resuming a TLS 1.2 session.\nStub that implements io::Write and dispatches to …\nWhich ALPN protocols we include in our client hello. If …\nCreate a builder to build up the client configuration.\nHow many bytes you may send.  Writes will become short …\nList of ciphersuites, in preference order.\nHow to decide what client auth certificate/keys to use.\nContainer for unsafe APIs\nAccess configuration options whose use is dangerous and …\nCreate an in-memory session store resumption with up to …\nDisable all use of session resumption.\nReturns an <code>io::Write</code> implementer you can write bytes to to …\nWhether to send data on the first flight (“early data”…\nWhether to send the Server Name Indication (SNI) extension …\nReturn the name that should go in the SNI extension. If …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn true if any certificates at all are available.\nCreate a new <code>Resumption</code> that stores data for the given …\nRemember a TLS1.3 ticket that might be retrieved later …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns True if the server signalled it will process early …\nHow to output key material for debugging.  The default …\nList of supported key exchange algorithms, in preference …\nThis should return the value most recently passed to …\nThe maximum size of TLS message we’ll emit.  If None, we …\nMake a new ClientConnection.  <code>config</code> controls how we …\nRemove and forget any saved TLS1.2 session for <code>server_name</code>.\nWith the server-supplied acceptable issuers in …\nHow and when the client can resume a previous session.\nRemember what <code>NamedGroup</code> the given server chose.\nRemember a TLS1.2 session.\nUse a custom <code>ClientSessionStore</code> implementation to store …\nHow we store session data or tickets. The default is to …\nWe support a given TLS version if it’s quoted in the …\nReturn a TLS1.3 ticket previously provided to …\nConfigure whether TLS 1.2 sessions may be resumed, and by …\nWhat mechanism is used for resuming a TLS 1.2 session.\nGet the most recently saved TLS1.2 session for <code>server_name</code> …\nHow to verify the server certificate chain.\nSupported versions, in no particular order.  The default …\nAccessor for dangerous configuration options.\nThe underlying ClientConfig\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOverrides the default <code>ServerCertVerifier</code> with something …\nSend an empty <code>Certificate</code> and no <code>CertificateVerify</code>.\nSend a non-empty <code>Certificate</code> and a <code>CertificateVerify</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn implementer of <code>ClientSessionStore</code> that stores everything\nAn implementer of <code>ClientSessionStore</code> which does nothing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a new ClientSessionMemoryCache.  <code>size</code> is the maximum …\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrepare resumption with the session state retrieved from …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis implements the horrifying TLS1.3 hack where PSK …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA client initiates the connection.\nConnection state common to both client and server …\nValues of this structure are returned from …\nA server waits for a client to connect.\nSide of the connection.\nRetrieves the protocol agreed with the peer via ALPN.\nSend any buffered plaintext.  Plaintext is buffered if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the peer has signaled end of stream.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the connection is currently performing the …\nRetrieves the ciphersuite agreed with the peer.\nRetrieves the certificate chain used by the peer to …\nTrue if the peer has sent us a close_notify alert.  This is\nHow many plaintext bytes could be obtained via …\nProtocol whose key schedule should be used. Unused for TLS …\nRetrieves the protocol version agreed with the peer.\nLike send_msg_encrypt, but operate on an appdata directly.\nQueues a close_notify warning alert to be sent in the next …\nSend a raw TLS message, fragmenting it if needed.\nFragment <code>m</code>, encrypt the fragments, and then queue the …\nEncrypt and send some plaintext <code>data</code>.  <code>limit</code> controls …\nSend plaintext application data, fragmenting and …\nSets a limit on the internal buffers used to buffer unsent …\nHow many bytes could be written by <code>Connection::write_tls</code> …\nReturns true if the caller should call <code>Connection::read_tls</code>…\nReturns true if the caller should call …\nA client connection\nA client or server connection.\nInterface shared by client and server connections.\nInternal trait implemented by the [<code>ServerConnection</code>]/[…\nA structure that implements <code>std::io::Read</code> for reading …\nA server connection\nData specific to the peer’s side (client or server).\nHow many ChangeCipherSpec messages we accept and drop in …\nA structure that implements <code>std::io::Write</code> for writing …\nThis function uses <code>io</code> to complete any outstanding IO for …\nThis function uses <code>io</code> to complete any outstanding IO for …\nPull a message out of the deframer and send any messages …\nDerives key material from the agreed connection secrets.\nDerives key material from the agreed connection secrets.\nExtract the first handshake message.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new Writer.\nProcesses any new packets read by a previous call to …\nProcesses any new packets read by a previous call to …\nObtain plaintext data received from the peer over this TLS …\nRead TLS content from <code>rd</code> into the internal buffer.\nRead TLS content from <code>rd</code>.\nReturns an object that allows reading plaintext.\nReturns an object that allows reading plaintext.\nSend the plaintext <code>buf</code> to the peer, encrypting and …\nWrites TLS messages to <code>wr</code>.\nWrites TLS messages to <code>wr</code>.\nReturns an object that allows writing plaintext.\nReturns an object that allows writing plaintext.\nA type which encapsulates an owned string that is a …\nA type which encapsulates a borrowed string that is a …\nThe provided input could not be parsed because it is not a …\nProduce a borrowed <code>DnsNameRef</code> from this owned <code>DnsName</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCopy this object to produce an owned <code>DnsName</code>, smashing the …\nCopy this object to produce an owned <code>DnsName</code>.\nValidate the given bytes are a DNS name if they are viewed …\nThe <code>AlertDescription</code> TLS protocol enum.  Values in this …\nThe <code>CipherSuite</code> TLS protocol enum.  Values in this enum …\nThe <code>ContentType</code> TLS protocol enum.  Values in this enum …\nThe <code>HandshakeType</code> TLS protocol enum.  Values in this enum …\nThe <code>ProtocolVersion</code> TLS protocol enum.  Values in this …\nThe <code>SignatureAlgorithm</code> TLS protocol enum.  Values in this …\nThe <code>SignatureScheme</code> TLS protocol enum.  Values in this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWe received a fatal alert.  This means the peer is unhappy.\nThe certificate is valid, but the handshake is rejected …\nThe certificate is not correctly encoded.\nThe <code>max_fragment_size</code> value supplied in configuration was …\nA certificate is not correctly signed by the key of its …\nThe CRL had a bad, or unsupported signature from its …\nThe ways in which a certificate revocation list (CRL) can …\nThe ways in which certificate validators can express …\nWe couldn’t decrypt a message.  This is invariably fatal.\nWe couldn’t encrypt a message because it was larger than …\nrustls reports protocol errors using this type.\nThe current time is after the <code>notAfter</code> time in the …\nWe failed to figure out what time it currently is.\nWe failed to acquire random bytes from the system.\nA catch-all error for unlikely errors.\nThis function doesn’t work until the TLS handshake is …\nAn advertised message was larger then expected.\nWe received a TLS handshake message that isn’t valid …\nWe received a TLS message that isn’t valid right now. …\nThe peer sent us a syntactically incorrect …\nContext was incorrectly attached to a certificate request …\nA provided certificate revocation list (CRL) was invalid.\nWe saw an invalid certificate.\nA peer sent an invalid certificate status type\nAn unknown content type was encountered during message …\nThe CRL contained an invalid CRL number.\nA peer’s DH params could not be decoded\nA message was zero-length when its record kind forbids it.\nA peer sent an unexpected key update request.\nA corrupt TLS message payload that resulted in an error.\nThe peer sent us a TLS message with invalid contents.\nThe certificate is being used for a different purpose than …\nThe CRL contained a revoked certificate with an invalid …\nThe presented SCT(s) were invalid.\nA peer’s server name could not be decoded\nThe CRL issuer does not specify the cRLSign key usage.\nA TLS message payload was larger then allowed by the …\nMessage is shorter than the expected length\nMissing data for the named handshake payload value\nA peer did not advertise its supported key exchange groups.\nAn incoming connection did not support any known …\nThe peer didn’t give us any certificates.\nA peer sent an empty list of signature schemes\nThe subject names in an end-entity certificate do not …\nThe current time is before the <code>notBefore</code> time in the …\nAny other error.\nThe CRL is invalid for some other reason.\nThe CRL is not correctly encoded.\nThe set of cases where we failed to make a connection …\nThe peer doesn’t support a protocol version/feature we …\nThe set of cases where we failed to make a connection …\nThe peer deviated from the standard TLS protocol. The …\nThe peer sent an oversized record/fragment.\nThe certificate has been revoked.\nTrailing data found for the named handshake payload value\nA peer sent an unexpected message type.\nThe certificate contains an extension marked critical, but …\nThe certificate chain is not issued by a known root …\nAn unknown TLS protocol was encountered during message …\nA peer sent a non-null compression method.\nThe CRL, or a revoked certificate in the CRL, contained an …\nThe CRL is not a v2 X.509 CRL.\nA peer sent an unknown elliptic curve type.\nThe CRL is an unsupported delta CRL, containing only …\nThe CRL is an unsupported indirect CRL, containing revoked …\nA peer sent an unsupported key exchange algorithm.\nThe certificate verifier doesn’t support the given type …\nThe CRL contained a revoked certificate with an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhich types we expected\nWhich handshake type we expected\nWhat type we received\nWhat handshake type we received\nThis deals with keeping a running hash of the handshake …\nEarly stage buffering of handshake payloads.\nWe decided not to do client auth after all, so discard the …\nHash/buffer a handshake message.\nHash/buffer a handshake message.\nThe digest algorithm\nbuffer for client-auth.\nNone before we know what hash function we’re using\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the current hash value.\nGet the hash value if we were to hash <code>extra</code> too.\nGet the hash value if we were to hash <code>extra</code> too, using …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake the current hash value, and encapsulate it in a ‘…\nWe might be doing client auth, so need to keep a full log …\nWe now know what hash function the verify_data will use.\nTakes this object’s buffer containing all handshake …\nHash or buffer a byte slice.\nLow-level TLS message decryption functions.\nLow-level TLS message parsing and encoding functions.\nLow-level TLS record layer functions.\nObjects with this trait can decrypt TLS messages.\nPerform the decryption over the concerned TLS message.\nAn externally length’d payload\nAn arbitrary, unknown-content, u16-length-prefixed payload\nAn arbitrary, unknown-content, u24-length-prefixed payload\nAn arbitrary, unknown-content, u8-length-prefixed payload\nTrait for implementing encoding and decoding functionality …\nThe length of the length prefix for a list.\nWrapper over a slice of bytes that allows reading chunks …\nA trait for types that can be encoded and decoded in a …\nThe underlying buffer storing the readers content\nStores the current reading position for the buffer\nFunction for encoding itself by appending itself to the …\nFunction for decoding itself from the provided reader will …\nThis deframer works to reconstruct TLS messages from a …\nBuffer of data read from the socket, in the process of …\nIf we’re in the middle of joining a handshake payload, …\nSet if the peer is not talking TLS, but some other …\nWhat size prefix of <code>buf</code> is used.\nThe <code>AlertLevel</code> TLS protocol enum.  Values in this enum are …\nThe <code>CertificateStatusType</code> TLS protocol enum.  Values in …\nThe <code>ClientCertificateType</code> TLS protocol enum.  Values in …\nThe <code>Compression</code> TLS protocol enum.  Values in this enum …\nThe <code>ECCurveType</code> TLS protocol enum.  Values in this enum …\nThe <code>ECPointFormat</code> TLS protocol enum.  Values in this enum …\nThe <code>ExtensionType</code> TLS protocol enum.  Values in this enum …\nThe <code>HashAlgorithm</code> TLS protocol enum.  Values in this enum …\nThe <code>HeartbeatMessageType</code> TLS protocol enum.  Values in …\nThe <code>HeartbeatMode</code> TLS protocol enum.  Values in this enum …\nThe <code>KeyUpdateRequest</code> TLS protocol enum.  Values in this …\nThe <code>NamedCurve</code> TLS protocol enum.  Values in this enum are …\nThe <code>NamedGroup</code> TLS protocol enum.  Values in this enum are …\nThe <code>PSKKeyExchangeMode</code> TLS protocol enum.  Values in this …\nThe <code>ServerNameType</code> TLS protocol enum.  Values in this enum …\nOnly supports OCSP\nA <code>DistinguishedName</code> is a <code>Vec&lt;u8&gt;</code> wrapped in internal types.\nA TLS frame, named TLSPlaintext in the standard.\nA message with decoded payload\nA TLS frame, named TLSPlaintext in the standard.\nA decrypted TLS frame\nResult of decryption.\nRecord layer that tracks decryption and encryption keys.\nThe decrypted message.\nWhether the peer appears to be getting close to encrypting …\nThis type contains a single certificate by value.\nwrapper around internal representation of a parsed …\nThis type contains a private key by value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis trait represents the ability to do something useful …\nKeyLog that does exactly nothing.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLog the given <code>secret</code>.  <code>client_random</code> is provided for …\nIndicates whether the secret with label <code>label</code> will be …\nIndicates whether the secret with label <code>label</code> will be …\n<code>KeyLog</code> implementation that opens a file whose name is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMakes a new <code>KeyLogFile</code>.  The environment variable is …\nA list of all the key exchange groups supported by rustls.\nAn in-progress key exchange.  This has the algorithm, our …\nEphemeral ECDH on secp256r1 (aka NIST-P256)\nEphemeral ECDH on secp384r1 (aka NIST-P384)\nA key-exchange group supported by rustls.\nEphemeral ECDH on curve25519 (see RFC7748)\nThe corresponding ring agreement::Algorithm\nChoose a SupportedKxGroup by name, from a list of …\nCompletes the key exchange, given the peer’s public key.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the group being used.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe IANA “TLS Supported Groups” name of the group\nStart a key exchange, using the given SupportedKxGroup.\nEphemeral ECDH on secp256r1 (aka NIST-P256)\nEphemeral ECDH on secp384r1 (aka NIST-P384)\nEphemeral ECDH on curve25519 (see RFC7748)\nA HashMap-alike, which never gets larger than a specified …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new LimitedCache with the given rough capacity.\nThis section discusses vulnerabilities in other TLS …\nThis section discusses vulnerabilities and design errors …\nThis section collects together goal-oriented documentation.\nThis section documents rustls itself: what protocol …\nThis section provides rationale for the defaults in rustls.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn externally length’d payload\nAn arbitrary, unknown-content, u16-length-prefixed payload\nAn arbitrary, unknown-content, u24-length-prefixed payload\nAn arbitrary, unknown-content, u8-length-prefixed payload\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrait for implementing encoding and decoding functionality …\nThe length of the length prefix for a list.\nWrapper over a slice of bytes that allows reading chunks …\nA trait for types that can be encoded and decoded in a …\nUsed to check whether the reader has any content left …\nThe underlying buffer storing the readers content\nStores the current reading position for the buffer\nFunction for encoding itself by appending itself to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvenience function for encoding the implementation into …\nConvenience function for encoding the implementation into …\nCreates a new Reader of the provided <code>bytes</code> slice with the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the number of bytes that are still able to be read …\nFunction for decoding itself from the provided reader will …\nFunction for wrapping a call to the read function in a …\nFunction for wrapping a call to the read function in a …\nBorrows a slice of all the remaining bytes that appear …\nAttempts to create a new Reader on a sub section of this …\nAttempts to borrow a slice of bytes from the current …\nReturns the cursor position which is also the number of …\nWaiting for more data.\nWe have a complete handshake message.\nMore records available for processing.\nTLS allows for handshake messages of up to 16MB.  We …\nThis deframer works to reconstruct TLS messages from a …\nWrite the handshake message contents into the buffer and …\nBuffer of data read from the socket, in the process of …\nDiscard <code>taken</code> bytes from the start of our buffer.\nThe expected size of the handshake payload, if available.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if we have messages for the caller to …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf we’re in the middle of joining a handshake payload, …\nSet if the peer is not talking TLS, but some other …\nThe range of bytes from the deframer buffer that contains …\nThe range of bytes from the deframer buffer that contains …\nDetermine the expected length of the payload as advertised …\nReturn any decrypted messages that the deframer has been …\nResize the internal <code>buf</code> if necessary for reading more …\nTrue if this is a QUIC handshake message.\nRead some bytes from <code>rd</code>, and add them to our internal …\nFuses this deframer’s error and returns the set value.\nWhat size prefix of <code>buf</code> is used.\nThe protocol version as found in the decrypted handshake …\nThe <code>AlertLevel</code> TLS protocol enum.  Values in this enum are …\nThe <code>CertificateStatusType</code> TLS protocol enum.  Values in …\nThe <code>ClientCertificateType</code> TLS protocol enum.  Values in …\nThe <code>Compression</code> TLS protocol enum.  Values in this enum …\nThe <code>ECCurveType</code> TLS protocol enum.  Values in this enum …\nThe <code>ECPointFormat</code> TLS protocol enum.  Values in this enum …\nThe <code>ExtensionType</code> TLS protocol enum.  Values in this enum …\nThe <code>HashAlgorithm</code> TLS protocol enum.  Values in this enum …\nThe <code>HeartbeatMessageType</code> TLS protocol enum.  Values in …\nThe <code>HeartbeatMode</code> TLS protocol enum.  Values in this enum …\nThe <code>KeyUpdateRequest</code> TLS protocol enum.  Values in this …\nThe <code>NamedCurve</code> TLS protocol enum.  Values in this enum are …\nThe <code>NamedGroup</code> TLS protocol enum.  Values in this enum are …\nThe <code>PSKKeyExchangeMode</code> TLS protocol enum.  Values in this …\nThe <code>ServerNameType</code> TLS protocol enum.  Values in this enum …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake the Message <code>msg</code> and re-fragment it into new messages …\nEnqueue borrowed fragments of (version, typ, payload) which\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSet the maximum fragment size that will be produced.\nOnly supports OCSP\nA <code>DistinguishedName</code> is a <code>Vec&lt;u8&gt;</code> wrapped in internal types.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nReturns true if there is more than one extension of a given\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a basic SNI ServerNameRequest quoting <code>hostname</code>.\nMake a new one with one entry.\nCreate a newtype wrapper around a given type.\nA macro which defines an enum type.\nA TLS frame, named TLSPlaintext in the standard.\nContent type, version and size.\nThis is the maximum on-the-wire size of a TLSCiphertext. …\nMaximum on-wire message size.\nA message with decoded payload\nA TLS frame, named TLSPlaintext in the standard.\nA decrypted TLS frame\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForce conversion into a plaintext message.\n<code>MessageError</code> allows callers to distinguish between valid …\nThis is the maximum allowed skew between server and client …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFill the whole slice with random material.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn a uniformly random u32.\nMake a Vec of the given size containing random material.\nKeying material in use.\nResult of decryption.\nNo keying material.\nKeying material present, but not yet in use.\nRecord layer that tracks decryption and encryption keys.\nDecrypt a TLS message.\nReturn true if we outright refuse to do anything with the …\nEncrypt a TLS message.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new record layer with no keys.\nThe decrypted message.\nPrepare to use the given <code>MessageDecrypter</code> for future …\nPrepare to use the given <code>MessageEncrypter</code> for future …\nSet and start using the given <code>MessageDecrypter</code> for future …\nSet and start using the given <code>MessageDecrypter</code> for future …\nSet and start using the given <code>MessageEncrypter</code> for future …\nStart using the <code>MessageDecrypter</code> previously provided to …\nStart using the <code>MessageEncrypter</code> previously provided to …\nWhether the peer appears to be getting close to encrypting …\nReturn true if we are getting close to encrypting too many …\nRepresents a <code>ClientHello</code> message received through the …\nHandle on a server-side connection before configuration is …\nA <code>ClientCertVerifier</code> that will allow both anonymous and …\nA <code>ClientCertVerifier</code> that will ensure that every client …\nZero-sized marker type representing verification of a …\nSomething that can verify a client certificate chain\nA struct representing the received Client Hello\nA type which encapsulates an owned string that is a …\nTurns off client authentication.\nSomething which never stores sessions.\nwrapper around internal representation of a parsed …\nA trait for the ability to encrypt and decrypt tickets.\nAllows reading of early data in resumed TLS1.3 connections.\nHow to choose a certificate chain and signing key for use …\nSomething that resolves do different cert chains/keys based\nCommon configuration for a set of server sessions.\nThis represents a single TLS server connection.\nState associated with a server connection.\nAn implementer of <code>StoresServerSessions</code> that stores …\nA trait for the ability to store server session data.\nAn unparsed DER encoded Certificate Revocation List (CRL).\nA config builder state where the caller must supply how to …\nProtocol names we support, most preferred first. If empty …\nWhether the store can cache another session. This is used …\nHow to choose a server cert and key.\nList of ciphersuites, in preference order.\nReturns the Subjects of the client authentication trust …\nDecrypt <code>cipher</code>, validating its authenticity protection and …\nReturns true if this implementation will encrypt/decrypt …\nEncrypt and authenticate <code>plain</code>, returning the resulting …\nFind a value with the given <code>key</code>.  Return it, or None if it …\nIgnore the client’s ciphersuite order. Instead, choose …\nHow to output key material for debugging.  The default …\nList of supported key exchange groups.\nReturns the lifetime in seconds of tickets produced now. …\nAmount of early data to accept for sessions created by …\nThe maximum size of TLS message we’ll emit.  If None, we …\nStore session secrets encoded in <code>value</code> against <code>key</code>, …\nChoose a certificate chain and matching key given …\nWhether the server should send “0.5RTT” data.  This …\nHow many TLS1.3 tickets to send immediately after a …\nHow to store client sessions.\nFind a value with the given <code>key</code>.  Return it and delete it; …\nHow to produce tickets.\nHow to verify client certificates.\nVerify the end-entity certificate <code>end_entity</code> is valid, …\nSupported protocol versions, in no particular order. The …\nA config builder state where the caller must supply how to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nActiveCertifiedKey wraps CertifiedKey and tracks OSCP and …\nReturns the argument unchanged.\nGet the certificate chain\nGet the signing key\nCalls <code>U::from(self)</code>.\nSomething which always resolves to the same cert chain.\nSomething which never produces tickets.\nSomething which never stores sessions.\nSomething that resolves do different cert chains/keys based\nAn implementer of <code>StoresServerSessions</code> that stores …\nAdd a new <code>sign::CertifiedKey</code> to be used for the given SNI …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a new ServerSessionMemoryCache.  <code>size</code> is the maximum …\nCreates an <code>AlwaysResolvesChain</code>, auto-detecting the …\nCreate a new and empty (i.e., knows no certificates) …\nCreates an <code>AlwaysResolvesChain</code>, auto-detecting the …\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConfiguration-independent validation of a <code>ClientHello</code> …\nContinues handling of a <code>ClientHello</code> message once config …\nRepresents a <code>ClientHello</code> message received through the …\nHandle on a server-side connection before configuration is …\nA struct representing the received Client Hello\nA trait for the ability to encrypt and decrypt tickets.\nAllows reading of early data in resumed TLS1.3 connections.\nHow to choose a certificate chain and signing key for use …\nCommon configuration for a set of server sessions.\nThis represents a single TLS server connection.\nState associated with a server connection.\nA trait for the ability to store server session data.\nCheck if a <code>ClientHello</code> message has been received.\nGet the ALPN protocol identifiers submitted by the client.\nProtocol names we support, most preferred first. If empty …\nCreate builder to build up the server configuration.\nWhether the store can cache another session. This is used …\nHow to choose a server cert and key.\nGet cipher suites.\nList of ciphersuites, in preference order.\nGet the <code>ClientHello</code> for this connection.\nDecrypt <code>cipher</code>, validating its authenticity protection and …\nReturn an empty Acceptor, ready to receive bytes from a …\nReturns an <code>io::Read</code> implementer you can read bytes from …\nReturns true if this implementation will encrypt/decrypt …\nEncrypt and authenticate <code>plain</code>, returning the resulting …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFind a value with the given <code>key</code>.  Return it, or None if it …\nIgnore the client’s ciphersuite order. Instead, choose …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the <code>Accepted</code> into a <code>ServerConnection</code>.\nHow to output key material for debugging.  The default …\nList of supported key exchange groups.\nReturns the lifetime in seconds of tickets produced now. …\nAmount of early data to accept for sessions created by …\nThe maximum size of TLS message we’ll emit.  If None, we …\nCreates a new ClientHello\nMake a new ServerConnection.  <code>config</code> controls how we …\nStore session secrets encoded in <code>value</code> against <code>key</code>, …\nRead TLS content from <code>rd</code>.\nApplication-controlled portion of the resumption ticket …\nExplicitly discard early data, notifying the client\nChoose a certificate chain and matching key given …\nWhether the server should send “0.5RTT” data.  This …\nHow many TLS1.3 tickets to send immediately after a …\nGet the server name indicator.\nRetrieves the server name, if any, used to select the …\nHow to store client sessions.\nSet the resumption data to embed in future resumption …\nGet the compatible signature schemes.\nWe support a given TLS version if it’s quoted in the …\nFind a value with the given <code>key</code>.  Return it and delete it; …\nHow to produce tickets.\nHow to verify client certificates.\nSupported protocol versions, in no particular order. The …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA packaged-together certificate chain, matching <code>SigningKey</code> …\nA SigningKey that uses exactly one TLS-level …\nA SigningKey that uses exactly one TLS-level …\nErrors while signing\nA thing that can sign a message.\nAn abstract signing key.\nWhat kind of key we have.\nParse <code>der</code> as any ECDSA key type, returning the first which …\nParse <code>der</code> as any EdDSA key type, returning the first which …\nParse <code>der</code> as any supported key encoding/type, returning …\nThe certificate chain.\nChoose a <code>SignatureScheme</code> from those offered.\nConvert a SEC1 encoding to PKCS8, and ask ring to parse …\nThe end-entity certificate.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe certified key.\nMake a new <code>ECDSASigningKey</code> from a DER encoding in PKCS#8 …\nMake a new <code>Ed25519SigningKey</code> from a DER encoding in PKCS#8 …\nMake a new CertifiedKey, with the given chain and key.\nAn optional OCSP response from the certificate issuer, …\nReveals which scheme will be used when you call <code>sign()</code>.\nAn optional collection of SCTs from CT logs, proving the …\nSigns <code>message</code> using the selected scheme.\nThe set of schemes we support for signatures and that are …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nThis type implements <code>io::Read</code> and <code>io::Write</code>, encapsulating …\nIf we’re handshaking, complete all the IO for that. If …\nOur TLS connection\nOur connection\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a mutable reference to the underlying socket\nGet a reference to the underlying socket\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMake a new Stream using the Connection <code>conn</code> and …\nMake a new StreamOwned taking the Connection <code>conn</code> and …\nThe underlying transport, like a socket\nThe underlying transport, like a socket\nA list of all the cipher suites supported by rustls.\nAES with 128-bit keys in Galois counter mode.\nAES with 256-bit keys in Galois counter mode.\nBulk symmetric encryption scheme used by a cipher suite.\nChacha20 for confidentiality with poly1305 for …\nCommon state for cipher suites (both for TLS 1.2 and TLS …\nThe cipher suite configuration that an application should …\nA cipher suite supported by rustls.\nA TLS 1.2 cipher suite\nA TLS 1.3 cipher suite\nHow to do bulk encryption.\nReturn true if <code>sigscheme</code> is usable by any of the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhich hash function to use with this suite.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn a list of the ciphersuites in <code>all</code> with the suites …\nReturn a list of the ciphersuites in <code>all</code> with the suites …\nThe cipher suite’s identifier\nThe TLS enumeration naming this cipher suite.\nReturn true if this suite is usable for a key only …\nReturn supported protocol version for the cipher suite.\nThis is a <code>ProducesTickets</code> implementation which uses any …\nA ticketer that has a ‘current’ sub-ticketer and a …\nA concrete, safe ticket creation mechanism.\nThe timebase for expiring and rolling tickets and ticketing\nDecrypt <code>ciphertext</code> and recover the original message.\nEncrypt <code>message</code> and return the ciphertext.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf it’s time, demote the <code>current</code> ticketer to <code>previous</code> …\nMake a ticketer with recommended configuration and a …\n<code>lifetime</code> is in seconds, and is how long the current …\nMake the recommended Ticketer.  This produces tickets with …\nTLS1.2 per-connection keying material\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nThe TLS1.2 ciphersuite …\nA TLS 1.2 cipher suite supported by rustls.\nCommon cipher suite fields.\nThis is a non-standard extension which extends the key …\nHow long the fixed part of the ‘IV’ is.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhich hash function to use with this suite.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHow to exchange/agree keys.\nMake a <code>MessageCipherPair</code> based on the given supported …\nResolve the set of supported <code>SignatureScheme</code>s from the …\nHow to sign messages for authentication.\nThe RFC7905/RFC7539 ChaCha20Poly1305 construction. This …\nThe RFC7905/RFC7539 ChaCha20Poly1305 construction. This …\nA <code>MessageDecrypter</code> for AES-GCM AEAD ciphersuites.  TLS1.2 …\nA <code>MessageEncrypter</code> for AES-GCM AEAD ciphersuites. TLS 1.2 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe TLS1.3 ciphersuite TLS_AES_128_GCM_SHA256\nThe TLS1.3 ciphersuite TLS_AES_256_GCM_SHA384\nThe TLS1.3 ciphersuite TLS_CHACHA20_POLY1305_SHA256\nA TLS 1.3 cipher suite supported by rustls.\nCan a session using suite self resume from suite prev?\nCommon cipher suite fields.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhich hash function to use with this suite.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is the TLS1.3 key schedule.  It stores the current …\nKeySchedule for early data stage.\nKeySchedule during handshake.\nPre-handshake key schedule\nKeySchedule during traffic stage.  All traffic &amp; exporter …\nKeySchedule during traffic stage, retaining the ability to …\nThe kinds of secret we can extract from <code>KeySchedule</code>.\nDerive a secret of given <code>kind</code>, using current handshake …\nDerive a secret of given <code>kind</code> using the hash of the empty …\nDerive the next application traffic secret, returning it.\nDerive the PSK to use given a resumption_master_secret and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInput the empty secret.\nInput the given secret.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSign the finished message consisting of <code>hs_hash</code> using a …\nSign the finished message consisting of <code>hs_hash</code> using the …\nThis is a byte buffer that is built from a vector of byte …\nTake and append the given <code>bytes</code>.\nAppend a copy of <code>bytes</code>, perhaps a prefix if we’re near …\nFor a proposed append of <code>len</code> bytes, how many bytes should …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf we’re empty\nHow many bytes we’re storing\nTake one of the chunks from this object.  This function …\nRead data out of this object, writing it into <code>buf</code> and …\nSets the upper limit on how many bytes this object can …\nRead data out of this object, passing it <code>wr</code>\nA <code>ClientCertVerifier</code> that will allow both anonymous and …\nA <code>ClientCertVerifier</code> that will ensure that every client …\nPolicy for enforcing Certificate Transparency.\nZero-sized marker type representing verification of a …\nSomething that can verify a client certificate chain\nThis type combines a <code>SignatureScheme</code> and a signature …\nZero-sized marker type representing verification of a …\nTurns off client authentication.\nWhich signature verification mechanisms we support.  No …\nZero-sized marker type representing verification of a …\nSomething that can verify a server certificate chain, and …\nAn unparsed DER encoded Certificate Revocation List (CRL).\nDefault <code>ServerCertVerifier</code>, see the trait impl for more …\nMake a <code>HandshakeSignatureValid</code>\nMake a <code>ServerCertVerified</code>\nMake a <code>ClientCertVerified</code>\nWrap this verifier in an <code>Arc</code> and coerce it to …\nWrap this verifier in an <code>Arc</code> and coerce it to …\nConstruct a <code>NoClientAuth</code>, wrap it in an <code>Arc</code> and coerce it …\nReturn <code>true</code> to require a client certificate and <code>false</code> to …\nReturn <code>true</code> to require a client certificate and <code>false</code> to …\nReturns the Subjects of the client authentication trust …\nConstructs the signature message specified in section …\nConstructs the signature message specified in section …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a new <code>WebPkiVerifier</code>.\nCreate a new policy.\nConstruct a new <code>AllowAnyAuthenticatedClient</code>.\nConstruct a new <code>AllowAnyAnonymousOrAuthenticatedClient</code>.\nReturns <code>true</code> to enable the server to request a client …\nReturns <code>true</code> to enable the server to request a client …\nParse the CRL DER, yielding a <code>webpki::CertRevocationList</code> …\nReturns <code>true</code> if Rustls should ask the server to send SCTs.\nReturns <code>true</code> if Rustls should ask the server to send SCTs.\nThe <code>SignatureScheme</code> used to produce the signature.\nGet the signature.\nReturn the list of SignatureSchemes that this verifier …\nReturn the list of SignatureSchemes that this verifier …\nReturn the list of SignatureSchemes that this verifier …\nReturn the list of SignatureSchemes that this verifier …\nReturns the signature verification methods supported by …\nVerify the end-entity certificate <code>end_entity</code> is valid, …\nVerify the end-entity certificate <code>end_entity</code> is valid for …\nWill verify the certificate is valid in the following ways:\nVerify that the end-entity certificate <code>end_entity</code> is a …\nVerify that the <code>end_entity</code> has a name or alternative name …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given client …\nVerify a signature allegedly by the given client …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given server …\nVerify a signature allegedly by the given client …\nVerify a signature allegedly by the given client …\nUpdate the verifier to validate client certificates …\nUpdate the verifier to validate client certificates …\nTLS1.2\nTLS1.3\nA list of all the protocol versions supported by rustls.\nThe version configuration that an application should use …\nA TLS protocol version supported by rustls.\nTLS1.2\nTLS1.3\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe TLS enumeration naming this version.\nPrepend stuff to <code>bytes</code> to put it in a DER SEQUENCE.")