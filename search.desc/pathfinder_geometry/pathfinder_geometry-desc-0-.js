searchState.loadedDescShard("pathfinder_geometry", 0, "Basic geometry and linear algebra primitives, optimized …\nAngle utilities.\nLine segment types, optimized with SIMD.\n2D axis-aligned rectangles, optimized with SIMD.\n2D affine transforms.\n3D transforms that can be applied to paths.\nA utility module that allows unit vectors to be treated …\nVarious utilities.\nA SIMD-optimized point type.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNB: The origin is inclusive, while the lower right point …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRounds all points to the nearest integer.\nA 2x2 matrix, optimized with SIMD, in column-major order.\nAn affine transform, optimized with SIMD.\nExtracts the scale from this matrix.\nExtracts the scale from this matrix.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the rotation angle of this matrix.\nReturns the scale factor of this matrix.\nReturns the translation part of this matrix.\nAn transform, optimized with SIMD.\nReturns the argument unchanged.\nReturns the argument unchanged.\nJust like <code>glOrtho()</code>.\nJust like <code>gluPerspective()</code>.\nCreates a rotation matrix from the given quaternion.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLinearly interpolate between transforms\nJust like <code>gluLookAt()</code>.\nReturns the argument unchanged.\nHalf angle formula.\nCalls <code>U::from(self)</code>.\nAngle subtraction formula.\nAngle addition formula.\nDivides <code>a</code> by <code>b</code>, rounding up.\nApproximate equality.\nClamping.\nLinear interpolation.\nEither a scalar or a <code>Vector2F</code>.\n2D points with 32-bit floating point coordinates.\n2D points with 32-bit signed integer coordinates.\n3D points.\n3D homogeneous points.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks to see whether this <em>homogeneous</em> coordinate equals …\nTreats this point as a vector and calculates its length.\nNB: This does not negate w, because that is rarely what …\nTreats this point as a vector and normalizes it.\nReturns the coefficient when the given vector <code>a</code> is …\nRounds both coordinates to the nearest integer.\nTreats this point as a vector and calculates its squared …\nTruncates this vector to 2D.\nPerforms perspective division to convert this vector to 3D.\nConverts this vector to an equivalent 3D homogeneous one …\nA convenience alias for <code>Vector2F::new()</code>.\nA convenience alias for <code>Vector2I::new()</code>.\nSwaps y and x.")