searchState.loadedDescShard("aho_corasick", 0, "A library for finding occurrences of many patterns at …\nAn automaton for searching multiple strings in linear time.\nA builder for configuring an Aho-Corasick automaton.\nThe type of Aho-Corasick implementation to use in an …\nThe type of anchored search to perform.\nSupport only anchored searches. Requesting an unanchored …\nSupport both anchored and unanchored searches.\nAn error that occurred during the construction of an …\nUse a contiguous NFA.\nUse a DFA. Warning: DFAs typically use a large amount of …\nAn iterator of non-overlapping matches in a particular …\nAn iterator of overlapping matches in a particular …\nThe configuration and the haystack to use for an …\nAn error indicating that an anchored search was requested, …\nAn error indicating that an unanchored search was …\nUse leftmost-first match semantics, which reports leftmost …\nUse leftmost-longest match semantics, which reports …\nA representation of a match reported by an Aho-Corasick …\nAn error that occurred during an Aho-Corasick search.\nThe underlying kind of a <code>MatchError</code>.\nA knob for controlling the match semantics of an …\nRun an unanchored search. This means a match may occur …\nUse a noncontiguous NFA.\nThe identifier of a pattern in an Aho-Corasick automaton.\nThis error occurs when an ID could not be constructed.\nA representation of a range in a haystack.\nUse standard match semantics, which support overlapping …\nThe kind of anchored starting configurations to support in …\nAn iterator that reports Aho-Corasick matches in a stream.\nSupport only unanchored searches. Requesting an anchored …\nAn error indicating that the operation requested doesn’t …\nAn error indicating that an overlapping search was …\nAn error indicating that a stream search was attempted on …\nRun an anchored search. This means that a match must begin …\nThe underlying Aho-Corasick automaton. It’s one of …\nProvides <code>Automaton</code> trait for abstracting over Aho-Corasick …\nProvides direct access to a DFA implementation of …\nThe end offset of the span, exclusive.\nThe specific Aho-Corasick kind chosen. This makes it …\nProvides direct access to NFA implementations of …\nProvides packed multiple substring search, principally for …\nThe pattern ID.\nThe underlying match span.\nThe start offset of the span, inclusive.\nThe start kind of this automaton as configured by the …\nThe match semantics for the automaton that was used.\nThe match semantics for the automaton that was used.\nA trait that effectively gives us practical dynamic …\nAn automaton for searching multiple strings in linear time.\nA builder for configuring an Aho-Corasick automaton.\nThe type of Aho-Corasick implementation to use in an …\nUse a contiguous NFA.\nUse a DFA. Warning: DFAs typically use a large amount of …\nAn iterator of non-overlapping matches in a particular …\nAn iterator of overlapping matches in a particular …\nUse a noncontiguous NFA.\nAn iterator that reports Aho-Corasick matches in a stream.\nEnable ASCII-aware case insensitive matching.\nThe underlying Aho-Corasick automaton. It’s one of …\nBuild an Aho-Corasick automaton using the configuration …\nImplements the automatic selection logic for the …\nA convenience method for returning a new Aho-Corasick …\nA debug settting for whether to attempt to shrink the size …\nSet the limit on how many states use a dense …\nReturns an error if the start state configuration does not …\nReturns the location of the first match according to the …\nReturns an iterator of non-overlapping matches, using the …\nReturns the location of the first overlapping match in the …\nReturns an iterator of overlapping matches. Stated …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this automaton matches the …\nReturns the kind of the Aho-Corasick automaton used by …\nChoose the type of underlying automaton to use.\nThe specific Aho-Corasick kind chosen. This makes it …\nReturns the match kind used by this automaton.\nSet the desired match semantics.\nReturns the length of the longest pattern matched by this …\nReturns the approximate total amount of heap used by this …\nReturns the length of the shortest pattern matched by this …\nCreate a new Aho-Corasick automaton using the default …\nCreate a new builder for configuring an Aho-Corasick …\nReturn the total number of patterns matched by this …\nEnable heuristic prefilter optimizations.\nReplace all matches with a corresponding value in the …\nReplace all matches using raw bytes with a corresponding …\nReplace all matches using a closure called on each match. …\nReplace all matches using raw bytes with a closure called …\nReturns the type of starting search configuration …\nSets the starting state configuration for the automaton.\nThe start kind of this automaton as configured by the …\nReturns an iterator of non-overlapping matches in the given\nReturns the location of the first match according to the …\nReturns an iterator of non-overlapping matches, using the …\nReturns the location of the first overlapping match in the …\nReturns an iterator of overlapping matches.\nReplace all matches with a corresponding value in the …\nReplace all matches using raw bytes with a corresponding …\nReplace all matches using a closure called on each match. …\nReplace all matches using raw bytes with a closure called …\nReturns an iterator of non-overlapping matches in the given\nSearch for and replace all matches of this automaton in …\nSearch the given reader and replace all matches of this …\nA trait that abstracts over Aho-Corasick automata.\nA candidate is the result of running a prefilter on a …\nAn iterator of non-overlapping matches in a particular …\nAn iterator of overlapping matches in a particular …\nThe total number of values that can be represented.\nThe maximum value.\nA chunk that precisely contains a match.\nA confirmed match was found. Callers do not need to …\nA chunk that does not contain any matches.\nNo match was found. Since false negatives are not …\nRepresents the current state of an overlapping search.\nThe start of a possible match was found. Callers must …\nA prefilter for accelerating a search.\nThe number of bytes that a single value uses in memory.\nThe identifier of a finite automaton state.\nThis error occurs when an ID could not be constructed.\nA single chunk yielded by the stream chunk iterator.\nAn iterator that reports matches in a stream.\nAn iterator that reports matches in a stream.\nThe zero value.\nThe absolute position over the entire stream.\nReturn the internal value as a <code>i32</code>. This is guaranteed to …\nReturn the internal value as a <code>u32</code>. This is guaranteed to …\nReturn the internal value as a <code>u64</code>. This is guaranteed to …\nReturn the internal value as a <code>usize</code>. This is guaranteed to\nThe position of the search.\nReturns the value that could not be converted to an ID.\nThe automaton used to drive the search.\nThe underlying automaton to do the search.\nA roll buffer for managing bytes from <code>rdr</code>. Basically, this …\nThe position we’re currently at within <code>buf</code>.\nThe buffer position of the end of the bytes that we last …\nExecute a search in the haystack within the span given. If …\nWrite a prefix “state” indicator for fmt::Debug impls. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode this value from the bytes given using the native …\nDecode this value from the bytes given using the native …\nCreate a new value from a <code>u32</code> without checking whether the …\nReturn any unreported bytes as a non-match up to the end …\nReturn the match result of the most recent search to …\nReturn the match at the current position for the current …\nReturn a match chunk for the given match. It is assumed …\nReturn a non-match chunk, if necessary, just before …\nLook for any bytes that should be reported as a non-match …\nHandles the special case of an empty match by ensuring …\nThe state ID of the state at which the search was in when …\nThe input parameters to give to each search call.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this candidate into an option. This is useful when …\nReturns true if the given ID represents a dead state.\nReturns true if the given ID represents a match state.\nReturns true if the given ID represents a “special” …\nReturns true if the given ID represents a start state.\nReturns an iterator over all values from 0 up to and not …\nRecords the end offset of the most recent match. This is …\nThe match reported by the most recent overlapping search …\nReturns the match semantics that this automaton was built …\nReturns the total number of matches for the given state ID.\nReturns the pattern ID for the match state given by <code>sid</code> at …\nReturns the length, in bytes, of the longest pattern in …\nReturns the heap memory usage, in bytes, used by this …\nReturns the length, in bytes, of the shortest pattern in …\nLike <code>new</code>, but panics if the given value is not valid.\nCreates a new non-overlapping iterator. If the given …\nCreate a new value that is represented by a “small index.…\nCreate a new value without checking whether the given …\nThe index into the matching patterns of the next match to …\nPerforms a state transition from <code>sid</code> for <code>byte</code> and returns …\nReturns one more than this value as a usize.\nReturns the length of the pattern for the given ID.\nReturns the total number of patterns compiled into this …\nReturns a prefilter, if available, that can be used to …\nWe seal the <code>Automaton</code> trait for now. It’s a big trait, …\nThe source of bytes we read from.\nExecutes a search and returns a match if one is found.\nThe state of the automaton.\nReturn an iterator of transitions in a sparse format given …\nCreate a new overlapping state that begins at the start …\nThe unanchored starting state of this automaton.\nReturns the starting state for the given anchor mode.\nReturn the underlying integer as raw bytes in native endian\nExecutes a non-overlapping search with this automaton …\nReturns an iterator of non-overlapping matches with this …\nExecutes a overlapping search with this automaton using …\nReturns an iterator of overlapping matches with this …\nReplaces all non-overlapping matches in <code>haystack</code> with …\nReplaces all non-overlapping matches in <code>haystack</code> with …\nReplaces all non-overlapping matches in <code>haystack</code> by …\nReplaces all non-overlapping matches in <code>haystack</code> by …\nReturns an iterator of non-overlapping matches with this …\nReplaces all non-overlapping matches in <code>rdr</code> with strings …\nReplaces all non-overlapping matches in <code>rdr</code> by calling the …\nA builder for configuring an Aho-Corasick DFA.\nA sentinel state ID indicating that a search should stop …\nA DFA implementation of Aho-Corasick.\nThe alphabet size, or total number of equivalence classes, …\nEnable ASCII-aware case insensitive matching.\nBuild an Aho-Corasick DFA from the given iterator of …\nBuild an Aho-Corasick DFA from the given noncontiguous NFA.\nA convenience method for returning a new Aho-Corasick DFA …\nA debug setting for whether to attempt to shrink the size …\nThe equivalence classes for this DFA. All transitions are …\nFinishes building a DFA that supports BOTH unanchored and …\nFinishes building a DFA for either unanchored or anchored …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the desired match semantics.\nThe match semantics built into this DFA.\nThe matches for every match state in this DFA. This is …\nThe amount of heap memory used, in bytes, by the inner …\nThe length of the longest pattern in this automaton.\nThe length of the shortest pattern in this automaton.\nCreate a new Aho-Corasick DFA using the default …\nCreate a new builder for configuring an Aho-Corasick DFA.\nThe length of each pattern. This is used to compute the …\nEnable heuristic prefilter optimizations.\nA prefilter for accelerating searches, if one exists.\nAdds the given pattern IDs as matches to the given state …\nIterate over all possible equivalence class transitions in …\nThe information required to deduce which states are “…\nSets the starting state configuration for the automaton.\nThe total number of states in this DFA.\nThe exponent with a base 2, such that stride=2^stride2. …\nThe DFA transition table. IDs in this table are …\nProvides a contiguous NFA implementation of Aho-Corasick.\nProvides a noncontiguous NFA implementation of …\nA builder for configuring an Aho-Corasick contiguous NFA.\nA sentinel state ID indicating that a search should stop …\nA dense representation of transitions for a state, where …\nAnother sentinel state ID indicating that a search should …\nThe offset of where the “kind” of a state is stored. …\nA sentinel value indicating that the state uses a dense …\nA sentinel value indicating that the state uses a special …\nThe maximum number of transitions to encode as a sparse …\nA contiguous NFA implementation of Aho-Corasick.\nA “one transition” state that is never a match state.\nA sparse representation of transitions for a state, where …\nThe “in memory” representation a single dense or …\nThe underlying representation of sparse or dense …\nThe alphabet size, or total number of equivalence classes, …\nEnable ASCII-aware case insensitive matching.\nBuild an Aho-Corasick contiguous NFA from the given …\nBuild an Aho-Corasick contiguous NFA from the given …\nA convenience method for returning a new Aho-Corasick …\nA debug setting for whether to attempt to shrink the size …\nThe equivalence classes for this NFA. All transitions, …\nSet the limit on how many states use a dense …\nThe state to transition to when ‘class_to_next’ yields …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the kind of this state.\nReturns the length, in number of u32s, of this state.\nSet the desired match semantics.\nThe match semantics built into this NFA.\nReturns the total number of matching pattern IDs in this …\nThe number of pattern IDs in this state. For a non-match …\nReturns the pattern ID corresponding to the given index …\nThe length of the longest pattern in this automaton.\nThe length of the shortest pattern in this automaton.\nCreate a new Aho-Corasick contiguous NFA using the default …\nCreate a new builder for configuring an Aho-Corasick …\nThe length of each pattern. This is used to compute the …\nEnable heuristic prefilter optimizations.\nA prefilter for accelerating searches, if one exists.\nRead a state’s binary encoding to its in-memory …\nRemap state IDs in-place.\nThe raw NFA representation. Each state is packed with a …\nGet the number of sparse transitions in this state. This …\nThe information required to deduce which states are “…\nThe total number of states in this NFA.\nThe sparse or dense representation of the transitions for …\nReturn an iterator over every explicitly defined …\nComputes the number of u32 values needed to represent one …\nEncode the “old” state from a noncontiguous NFA to its …\nEncode the “old” state transitions from a …\nEncode the “old” state transitions from a …\nThe element of this NFA’s alphabet that this transition …\nA dense set of transitions to other states. The …\nThe state this should transition to if the current symbol …\nThe transitions for this state, where each transition is …\nA builder for configuring an Aho-Corasick noncontiguous …\nA compiler uses a builder configuration and builds up the …\nThe DEAD state is a sentinel state like the FAIL state. …\nThe FAIL state mostly just corresponds to the ID of any …\nA single match in a non-contiguous NFA.\nA noncontiguous NFA implementation of Aho-Corasick.\nA set of state identifiers used to avoid revisiting the …\nA representation of a sparse NFA state for an Aho-Corasick …\nA single transition in a non-contiguous NFA.\nReturn an active set that tracks state ID membership.\nSets all transitions on the dead state to point back to …\nAdd a match for the given pattern ID to the state for the …\nSet the transition for the given byte to the state ID …\nSet the failure transitions on the start state to loop …\nCreate a new set of <code>N</code> transitions in this NFA’s dense …\nCreate a new entry in <code>NFA::matches</code>, if there’s room, and …\nAllocate and add a fresh state to the underlying NFA and …\nCreate a new entry in <code>NFA::trans</code>, if there’s room, and …\nEnable ASCII-aware case insensitive matching.\nBuild an Aho-Corasick noncontiguous NFA from the given …\nThis sets up the initial prefix trie that makes up the …\nA convenience method for returning a new Aho-Corasick …\nReturn the byte for which this transition is defined.\nReturns the equivalence classes of bytes found while …\nA set of equivalence classes in terms of bytes. We compute …\nRemove the start state loop by rewriting any transitions …\nReturns true if and only if the given state ID is in this …\nCopy matches from the <code>src</code> state to the <code>dst</code> state. This is …\nTransitions stored in a dense representation.\nA pointer to a row of <code>N</code> transitions in <code>NFA::dense</code>. These …\nSet the limit on how many states use a dense …\nAttempts to convert the transition representation of a …\nReturns the depth of this state. That is, the number of …\nThe depth of this state. Specifically, this is the …\nReturns the failure transition for this state.\nThe state that should be transitioned to if the current …\nThis routine creates failure transitions according to the …\nFollow the transition for the given byte in the given …\nLike <code>follow_transition</code>, but always uses the sparse …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn an inert set that returns <code>false</code> for every state ID …\nThis sets every possible transition (all 255 of them) for …\nInitializes the unanchored start state by making it dense. …\nInserts the given state ID into this set. (If the set is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if and only if this state is a match state.\nIterate over all of the matches for the given state ID.\nIterate over all of the transitions for the given state ID.\nReturn the ID of the next transition.\nReturn the ID of the next match.\nSet the desired match semantics.\nThe match semantics built into this NFA.\nMatches stored in linked list for each state.\nA pointer to <code>NFA::matches</code> corresponding to the head of a …\nThe length, in bytes, of the longest pattern in this …\nThe length, in bytes, of the shortest pattern in this …\nCreate a new Aho-Corasick noncontiguous NFA using the …\nCreate a new builder for configuring an Aho-Corasick …\nReturn the ID of the state that this transition points to.\nReturn the link following the one given. If the one given …\nReturn the pattern ID for this match.\nThe length, in bytes, of each pattern in this NFA. This …\nReturns a slice containing the length of each pattern in …\nEnable heuristic prefilter optimizations.\nA prefilter for quickly skipping to candidate matches, if …\nReturns a set that tracked queued states.\nRe-maps all state IDs in this NFA according to the <code>map</code> …\nSetup the anchored start state by copying all of the …\nShuffle the states so that they appear in this sequence:\nTransitions stored in a sparse representation via a linked …\nA pointer to <code>NFA::trans</code> corresponding to the head of a …\nReturns the underlying “special” state information for …\nThe information required to deduce which states are “…\nReturns a slice of all states in this non-contiguous NFA.\nA set of states. Each state defines its own transitions, a …\nSwaps the states at <code>id1</code> and <code>id2</code>.\nA builder for constructing a packed searcher from a …\nThe configuration for a packed multiple pattern searcher.\nAn iterator over non-overlapping matches from a packed …\nUse leftmost-first match semantics, which reports leftmost …\nUse leftmost-longest match semantics, which reports …\nA knob for controlling the match semantics of a packed …\nA packed searcher for quickly finding occurrences of …\nThe configuration of this builder and subsequent matcher.\nSet to true if the builder detects that a matcher cannot …\nThe patterns provided by the caller.\nA builder for constructing a packed searcher from a …\nThe configuration for a packed multiple pattern searcher.\nAn iterator over non-overlapping matches from a packed …\nAn internal option for forcing the use of a particular …\nUse leftmost-first match semantics, which reports leftmost …\nUse leftmost-longest match semantics, which reports …\nA knob for controlling the match semantics of a packed …\nThis is a limit placed on the total number of patterns we…\nA packed searcher for quickly finding occurrences of …\nAdd the given pattern to this set to match.\nBuild a searcher from the patterns added to this builder …\nCreate a packed builder from this configuration. The …\nA convenience function for calling <code>Builder::new()</code>.\nA convenience function for calling <code>Config::new()</code>.\nThe configuration of this builder and subsequent matcher.\nAdd the given iterator of patterns to this set to match.\nReturn the first occurrence of any of the patterns in this …\nReturn the first occurrence of any of the patterns in this …\nUse a slow (non-packed) searcher.\nReturn an iterator of non-overlapping occurrences of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRequest that heuristic limitations on the number of …\nSet to true if the builder detects that a matcher cannot …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the number of patterns added to this builder.\nSet the match semantics for this configuration.\nReturns the match kind used by this packed searcher.\nReturns the approximate total amount of heap used by this …\nReturns the length, in bytes, of the shortest pattern …\nReturns the minimum length of a haystack that is required …\nCreate a new default configuration. A default …\nCreate a new builder for constructing a multi-pattern …\nA convenience function for constructing a searcher from an …\nThe patterns provided by the caller.\nA trait for adding some helper routines to pointers.\nCasts this pointer to <code>usize</code>.\nReturns the distance, in units of <code>T</code>, between <code>self</code> and …\nA pattern that is used in packed searching.\nAn iterator over the patterns in the <code>Patterns</code> collection.\nA non-empty collection of non-empty patterns to search for.\nAdd a pattern to this collection.\nThe collection of patterns, indexed by their identifier.\nReturns the bytes of this pattern.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the pattern with the given identifier. If such a …\nReturn the pattern with the given identifier without …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this collection of patterns is …\nCompare <code>n</code> bytes at the given pointers for equality.\nReturns true if and only if <code>needle</code> is a prefix of <code>haystack</code>.\nReturns true if this pattern is a prefix of the given …\nReturns true if this pattern is a prefix of the haystack …\nReturn an iterator over all the patterns in this …\nThe match semantics supported by this collection of …\nReturn the number of patterns in this collection.\nReturns the length of this pattern, in bytes.\nReturns the first <code>len</code> low nybbles from this pattern. If …\nReturns the match semantics used by these patterns.\nReturns the approximate total amount of heap used by these …\nReturns the length, in bytes, of the smallest pattern.\nThe length of the smallest pattern, in bytes.\nCreate a new collection of patterns for the given match …\nThe order of patterns defined for iteration, given by …\nClears all heap memory associated with this collection of …\nSet the match kind semantics for this collection of …\nThe total number of pattern bytes across the entire …\nThe type of the rolling hash used in the Rabin-Karp …\nThe number of buckets to store our patterns in. We don’t …\nAn implementation of the Rabin-Karp algorithm. The main …\nThe order of patterns in each bucket is significant. …\nReturn the first matching pattern in the given haystack, …\nReturns the argument unchanged.\nHash the given bytes.\nThe factor to subtract out of a hash before updating it …\nThe length of the hashing window. Generally, this …\nCalls <code>U::from(self)</code>.\nReturns the approximate total amount of heap used by this …\nCompile a new Rabin-Karp matcher from the patterns given.\nThe patterns we’re searching for.\nUpdate the hash given based on removing <code>old_byte</code> at the …\nVerify whether the pattern with the given id matches at …\nA builder for constructing a Teddy matcher.\nA searcher that dispatches to one of several possible …\nA trait that provides dynamic dispatch over the different …\nBuild a matcher for the set of patterns given. If a …\nExecute a search on the given haystack (identified by <code>start</code>…\nLook for the leftmost occurrence of any pattern in this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nRequest that heuristic limitations on the number of …\nWhen true (the default), the number of patterns will be …\nThe Teddy variant we use. We use dynamic dispatch under …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the approximate total amount of heap used by this …\nTotal heap memory used by the Teddy variant.\nReturns the minimum length, in bytes, that a haystack must …\nThe minimum haystack length this searcher can handle. It …\nCreate a new builder for configuring a Teddy matcher.\nRequest the use of 256-bit vectors (true) or 128-bit …\nWhen none, this is automatically determined. Otherwise, …\nRequire the use of Fat (true) or Slim (false) Teddy. Fat …\nWhen none, this is automatically determined. Otherwise, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new searcher using “slim” Teddy with 128-bit …\nCreates a new searcher using “slim” Teddy with 128-bit …\nCreates a new searcher using “slim” Teddy with 128-bit …\nCreates a new searcher using “slim” Teddy with 128-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nCreates a new searcher using “slim” Teddy with 256-bit …\nA “fat” Teddy implementation that is generic over both …\nRepresents the low and high nybble masks that will be used …\nA vector generic mask for the low and high nybbles in a …\nA match type specialized to the Teddy implementations …\nA “slim” Teddy implementation that is generic over …\nRepresents the low and high nybble masks that will be used …\nThe common elements of all “slim” and “fat” Teddy …\nUpdate this mask by adding the given byte to the given …\nUpdate this mask by adding the given byte to the given …\nThe allocation of patterns in buckets. This only contains …\nTurn this builder into a vector mask.\nTurn this builder into a vector mask.\nSee Slim&lt;V, 1&gt;::candidate.\nLook for a candidate match (represented as a vector) …\nSee Slim&lt;V, 1&gt;::candidate.\nSee Slim&lt;V, 1&gt;::candidate.\nSee <code>Fat&lt;V, 1&gt;::candidate</code>.\nSee <code>Fat&lt;V, 1&gt;::candidate</code>.\nSee <code>Fat&lt;V, 1&gt;::candidate</code>.\nLook for a candidate match (represented as a vector) …\nReturns a pointer into the haystack at which the match …\nSee Slim&lt;V, 1&gt;::find.\nSee Slim&lt;V, 1&gt;::find.\nLook for an occurrences of the patterns in this finder in …\nSee Slim&lt;V, 1&gt;::find.\nLook for an occurrences of the patterns in this finder in …\nSee <code>Fat&lt;V, 1&gt;::find</code>.\nSee <code>Fat&lt;V, 1&gt;::find</code>.\nSee <code>Fat&lt;V, 1&gt;::find</code>.\nSee Slim&lt;V, 1&gt;::find_one.\nSee Slim&lt;V, 1&gt;::find_one.\nLook for a match starting at the <code>V::BYTES</code> at and after <code>cur</code>…\nSee Slim&lt;V, 1&gt;::find_one.\nSee <code>Fat&lt;V, 1&gt;::find_one</code>.\nSee <code>Fat&lt;V, 1&gt;::find_one</code>.\nLook for a match starting at the <code>V::BYTES</code> at and after <code>cur</code>…\nSee <code>Fat&lt;V, 1&gt;::find_one</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA convenience function for building <code>N</code> vector masks from a …\nA convenience function for building <code>N</code> vector masks from a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the total number of masks required by the patterns …\nThe masks used as inputs to the shuffle operation to …\nThe masks used as inputs to the shuffle operation to …\nReturn a candidate for Teddy (fat or slim) that is …\nReturn a candidate for Teddy (fat or slim) that is …\nReturn a candidate for Teddy (fat or slim) that is …\nReturn a candidate for Teddy (fat or slim) that is …\nReturns the approximate total amount of heap used by this …\nReturns the approximate total amount of heap used by this …\nReturns the approximate total amount of heap used by this …\nReturns the minimum length, in bytes, that a haystack must …\nReturns the minimum length, in bytes, that a haystack must …\nCreate a new “slim” Teddy searcher for the given …\nCreate a new “fat” Teddy searcher for the given …\nCreate a new generic data structure for Teddy verification.\nReturns the ID of the pattern that matched.\nThe patterns we are searching for.\nReturns a pointer into the haystack at which the match …\nA generic data structure for doing “slim” Teddy …\nA generic data structure for doing “fat” Teddy …\nRuns the verification routine for “fat” Teddy.\nRuns the verification routine for “slim” Teddy.\nVerify whether there are any matches starting at or after …\nVerify whether there are any matches starting at <code>at</code> in the …\nThe number of bits in the vector.\nThe number of bytes in the vector. That is, this is the …\nThis trait extends the <code>Vector</code> trait with additional …\nA trait for describing vector operations used by …\nPerform a bitwise ‘and’ of this vector and the one …\nDo an 8-bit pairwise equality check. If lane <code>i</code> is equal in …\nCall the provided function for each 64-bit lane in this …\nCall the provided function for each 64-bit lane in the …\nLike <code>Vector::shift_in_one_byte</code>, except this is done for …\nLike <code>Vector::shift_in_two_bytes</code>, except this is done for …\nLike <code>Vector::shift_in_two_bytes</code>, except this is done for …\nUnpack and interleave the 8-bit lanes from the high 128 …\nUnpack and interleave the 8-bit lanes from the low 128 …\nReturns true if and only if this vector has zero in all of …\nRead a half-vector-size number of bytes from the given …\nRead a vector-size number of bytes from the given pointer. …\nPerform a bitwise ‘or’ of this vector and the one …\nShift each 8-bit lane in this vector to the right by the …\nShift this vector to the left by one byte and shift the …\nShift this vector to the left by three bytes and shift the …\nShift this vector to the left by two bytes and shift the …\nShuffles the bytes in this vector according to the indices …\nCreate a vector with 8-bit lanes with the given byte …\nSwap the 128-bit lanes in this vector.\nThis module provides several integer oriented traits for …\nLower level primitive types that are useful in a variety …\nThe representation of a byte set. Split out so that we can …\nAn iterator over all elements in an equivalence class …\nAn iterator over all elements in a specific equivalence …\nAn iterator over each equivalence class.\nA partitioning of bytes into equivalence classes.\nA representation of byte oriented equivalence classes.\nA simple set of bytes that is reasonably cheap to copy and …\nAdd a byte to this set.\nReturn the total number of elements in the alphabet …\nConvert this boolean set to a map that maps all byte …\nReturn true if and only if the given byte is in this set.\nReturns an iterator of byte ranges in the given …\nReturns an iterator of the bytes in the given equivalence …\nCreates a new set of equivalence classes where all bytes …\nCreate a new set of byte classes where all bytes are part …\nCreate an empty set of bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the equivalence class for the given byte.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if every byte in this class maps …\nReturns an iterator over all equivalence classes in this …\nSet the equivalence class for the given byte.\nIndicate the the range of byte given (inclusive) can …\nCreates a new set of equivalence classes where each byte …\nReturns the stride for these equivalence classes, which …\nReturns the stride, as a base-2 exponent, required for …\nA fairly simple roll buffer for supporting stream searches.\nThe default buffer capacity that we use for the stream …\nThe raw buffer contents. This has a fixed size and never …\nReturn the contents of this buffer.\nThe end of the contents of this buffer.\nRefill the contents of this buffer by reading as much as …\nReturn all free capacity in this buffer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe minimum size of the buffer, which is equivalent to the …\nReturn the minimum size of the buffer. The only way a …\nCreate a new buffer for stream searching. The minimum …\nRoll the contents of the buffer so that the suffix of this …\nA type that wraps a single byte with a convenient …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn error that occurred during the construction of an …\nThe kind of error that occurred.\nAn error indicating that an anchored search was requested, …\nAn error indicating that an unanchored search was …\nAn error that occurred during an Aho-Corasick search.\nThe underlying kind of a <code>MatchError</code>.\nAn error that occurs when adding a pattern to an …\nOccurs when a pattern string is given to the Aho-Corasick …\nAn error that occurs when allocating a new state would …\nAn error indicating that the operation requested doesn’t …\nAn error indicating that an overlapping search was …\nAn error indicating that a stream search was attempted on …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new “invalid anchored search” error. This …\nCreate a new “invalid unanchored search” error. This …\nReturns a reference to the underlying error kind.\nCreate a new error value with the given kind.\nCreate a new “unsupported empty pattern” error. This …\nCreate a new “unsupported overlapping search” error. …\nCreate a new “unsupported stream search” error. This …\nThe length that was too long.\nThe maximum possible id.\nThe maximum possible id.\nThe ID of the pattern that was too long.\nThe maximum ID requested.\nThe maximum ID requested.\nThe match semantics for the automaton that was used.\nThe match semantics for the automaton that was used.\nA builder for constructing the best possible prefilter. …\nA candidate is the result of running a prefilter on a …\nA confirmed match was found. Callers do not need to …\nA type that wraps a SIMD accelerated single substring …\nA builder for constructing a prefilter that uses memmem.\nNo match was found. Since false negatives are not …\nA type that wraps a packed searcher and implements the …\nThe start of a possible match was found. Callers must …\nA prefilter for accelerating a search.\nA prefilter describes the behavior of fast literal …\nOffsets associated with an occurrence of a “rare” byte …\nA set of byte offsets, keyed by byte.\nA builder for constructing a rare byte prefilter.\nA prefilter for scanning for a single “rare” byte.\nA prefilter for scanning for three “rare” bytes.\nA prefilter for scanning for two “rare” bytes.\nA builder for constructing a starting byte prefilter.\nA prefilter for scanning for a single starting byte.\nA prefilter for scanning for three starting bytes.\nA prefilter for scanning for two starting bytes.\nAdd a literal string to this prefilter builder.\nAdd a byte string to this builder.\nAdd a byte string to this builder.\nEnable ASCII case insensitivity. When set, byte strings …\nEnable ASCII case insensitivity. When set, byte strings …\nEnable ASCII case insensitivity. When set, byte strings …\nWhether this prefilter should account for ASCII case …\nWhether this prefilter should account for ASCII case …\nWhether this is available as a prefilter or not. This can …\nReturn a prefilter suitable for quickly finding potential …\nBuild the rare bytes prefilter.\nBuild the starting bytes prefilter.\nA set of byte offsets associated with bytes in a pattern. …\nThe set of starting bytes observed.\nThe number of patterns that have been added.\nThe number of bytes set to an active value in <code>byte_offsets</code>.\nThe number of bytes set to true in <code>byteset</code>.\nCreate a new empty set of rare byte offsets.\nReturns the next possible match candidate. This may yield …\nReturn the frequency rank of the given byte. The higher …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum offset at which a particular byte occurs from …\nCreate a new builder for constructing the best possible …\nCreate a new builder for constructing a rare byte …\nCreate a new rare byte offset. If the given offset is too …\nCreate a new builder for constructing a start byte …\nThe singular pattern to search for. This is only set when …\nIf the given byte is an ASCII letter, then return it in …\nThe sum of frequency ranks for the rare bytes detected. …\nThe sum of frequency ranks for the rare bytes detected. …\nA set of rare bytes, indexed by byte value.\nAdd the given offset for the given byte to this set. If …\nEach entry corresponds to the maximum offset of the …\nA utility trait that defines a couple of adapters for …\nThe total number of values that can be represented as a …\nThe total number of values that can be represented.\nThe maximum index value.\nThe maximum value.\nThe identifier of a pattern in an Aho-Corasick automaton.\nThis error occurs when an ID could not be constructed.\nThe number of bytes that a single small index uses in …\nThe number of bytes that a single value uses in memory.\nA type that represents a “small” index.\nThis error occurs when a small index could not be …\nThe identifier of a finite automaton state.\nThis error occurs when an ID could not be constructed.\nAn iterator adapter that is like std::iter::Enumerate, but …\nAn iterator adapter that is like std::iter::Enumerate, but …\nThe zero index value.\nThe zero value.\nReturn the internal <code>u32</code> of this small index represented as …\nReturn the internal value as a <code>i32</code>. This is guaranteed to …\nReturn the internal <code>u32</code> of this small index. This is …\nReturn the internal value as a <code>u32</code>. This is guaranteed to …\nReturn this small index as a <code>u64</code>. This is guaranteed to …\nReturn the internal value as a <code>u64</code>. This is guaranteed to …\nReturn this small index as a <code>usize</code>. This is guaranteed to …\nReturn the internal value as a <code>usize</code>. This is guaranteed to\nReturns the value that could not be converted to a small …\nReturns the value that could not be converted to an ID.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecode this small index from the bytes given using the …\nDecode this value from the bytes given using the native …\nDecode this small index from the bytes given using the …\nDecode this value from the bytes given using the native …\nCreate a new small index from a <code>u32</code> without checking …\nCreate a new value from a <code>u32</code> without checking whether the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns an iterator over all values from 0 up to and not …\nLike <code>SmallIndex::new</code>, but panics if the given index is not …\nLike <code>new</code>, but panics if the given value is not valid.\nCreate a new small index.\nCreate a new value that is represented by a “small index.…\nCreate a new small index without checking whether the …\nCreate a new value without checking whether the given …\nReturns one more than this small index as a usize.\nReturns one more than this value as a usize.\nReturn the underlying small index integer as raw bytes in …\nReturn the underlying integer as raw bytes in native endian\nA simple type for mapping between state indices and state …\nRemappable is a tightly coupled abstraction that …\nRemapper is an abstraction the manages the remapping of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nA way to map indices to state IDs (and back).\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA map from the index of a state to its pre-multiplied …\nCreate a new remapper from the given remappable …\nThis must remap every single state ID in the underlying …\nComplete the remapping process by rewriting all state IDs …\nReturn the total number of states.\nThe power of 2 corresponding to the stride of the …\nSwap two states. Once this is called, callers must follow …\nSwap the states pointed to by the given IDs. The …\nConvert a state ID to a state index.\nConvert a state index to a state ID.\nThe type of anchored search to perform.\nSupport only anchored searches. Requesting an unanchored …\nSupport both anchored and unanchored searches.\nThe configuration and the haystack to use for an …\nUse leftmost-first match semantics, which reports leftmost …\nUse leftmost-longest match semantics, which reports …\nA representation of a match reported by an Aho-Corasick …\nA knob for controlling the match semantics of an …\nRun an unanchored search. This means a match may occur …\nA representation of a range in a haystack.\nUse standard match semantics, which support overlapping …\nThe kind of anchored starting configurations to support in …\nSupport only unanchored searches. Requesting an anchored …\nRun an anchored search. This means that a match must begin …\nSets the anchor mode of a search.\nConvert this match kind into a packed match kind. If this …\nReturns true when the given offset is contained within …\nWhether to execute an “earliest” search or not.\nReturn the end position of this search.\nThe ending position of the match.\nThe end offset of the span, exclusive.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn the anchored mode for this search configuration.\nReturn whether this search should execute in “earliest”…\nReturn the span as a range for this search configuration.\nReturn the span for this search configuration.\nReturn a borrow of the underlying haystack as a slice of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if and only if this anchor mode corresponds …\nReturn true if this input has been exhausted, which in …\nReturns true when this span is empty. That is, when …\nReturns true when the span in this match is empty.\nReturns the length of this span.\nReturns the length of this match.\nCreate a new match from a pattern ID and a byte offset …\nCreate a new search configuration for the given haystack.\nCreate a new match from a pattern ID and a span.\nReturns a new span with <code>offset</code> added to this span’s <code>start</code>…\nReturns a new match with <code>offset</code> added to its span’s <code>start</code>…\nReturns the ID of the pattern that matched.\nThe pattern ID.\nLike <code>Input::span</code>, but accepts any range instead.\nReturns this span as a range.\nReturns the match span as a range.\nSet the anchor mode of a search.\nSet whether the search should execute in “earliest” …\nSet the ending offset for the span for this search …\nSet the span for this search configuration given any range.\nSet the span for this search configuration.\nSet the starting offset for the span for this search …\nSet the span for this search.\nReturns the span for this match.\nThe underlying match span.\nReturn the start position of this search.\nThe starting position of the match.\nThe start offset of the span, inclusive.\nA collection of sentinel state IDs for Aho-Corasick …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe maximum ID of all the match states. Any state ID …\nThe maximum ID of all the “special” states. This …\nThe state ID of the start state used for anchored …\nThe state ID of the start state used for unanchored …\nCreate a new set of “special” state IDs with all IDs …")