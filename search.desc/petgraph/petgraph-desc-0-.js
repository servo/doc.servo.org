searchState.loadedDescShard("petgraph", 0, "<strong>petgraph</strong> is a graph data structure library.\nMarker type for a directed graph.\nEdge direction.\nA graph’s edge type determines whether is has directed …\nAn <code>Incoming</code> edge is an inbound edge <em>to</em> the current node.\nConvert an element like <code>(i, j)</code> or <code>(i, j, w)</code> into a triple …\nAn <code>Outgoing</code> edge is an outward edge <em>from</em> the current node.\nMarker type for an undirected graph.\nGraph algorithms.\nCompressed Sparse Row (CSR) is a sparse adjacency matrix …\nGraph traits for associated data and graph construction.\nSimple graphviz dot file format output.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>Graph&lt;N, E, Ty, Ix&gt;</code> is a graph datastructure using an …\n<code>GraphMap&lt;N, E, Ty&gt;</code> is a graph datastructure where node …\nReturn <code>0</code> for <code>Outgoing</code> and <code>1</code> for <code>Incoming</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFormatting utils\nReturn the opposite <code>Direction</code>.\nCommonly used items.\n<code>StableGraph</code> keeps indices stable across removals.\n<code>UnionFind&lt;K&gt;</code> is a disjoint-set data structure.\nGraph traits and graph traversals.\nAn algorithm error: a cycle was found in the graph.\nWorkspace for a graph traversal.\nA floating-point measure.\nAssociated data that can be used for measures (such as …\nAn iterator producing a minimum spanning forest of a graph.\nAn algorithm error: a cycle of negative weights was found …\n[Generic] A* shortest path algorithm.\n[Generic] Compute shortest paths from node <code>source</code> to all …\nGraph Condense every strongly connected component into a …\n[Generic] Return the number of connected components of the …\n[Generic] Dijkstra’s shortest path algorithm.\nCompute dominators of a control-flow graph.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n[Generic] Check if there exists a path starting at <code>from</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n[Generic] Return <code>true</code> if the input directed graph contains …\n[Generic] Return <code>true</code> if the input graph contains a cycle.\nGraph Return <code>true</code> if the graphs <code>g0</code> and <code>g1</code> are isomorphic.\nGraph Return <code>true</code> if the graphs <code>g0</code> and <code>g1</code> are isomorphic.\n[Generic] Compute the <em>strongly connected components</em> using …\n[Generic] Compute a <em>minimum spanning tree</em> of a graph.\nReturn a node id that participates in the cycle\nRenamed to <code>kosaraju_scc</code>.\n[Generic] Compute the <em>strongly connected components</em> using …\n[Generic] Perform a topological sort of a directed graph.\nCreate a Dfs if it’s needed\nThe dominance relation for some graph and root.\nIterator for a node’s dominators.\nThe undefined dominator sentinel, for when we have not yet …\nIterate over all of the given node’s dominators …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the immediate dominator of the given node.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the root node used to construct these dominance …\nThis is an implementation of the engineered “Simple, …\nIterate over the given node’s that strict dominators.\n[Generic] A* shortest path algorithm.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompressed Sparse Row ([<code>CSR</code>]) is a sparse adjacency matrix …\nCsr edge index type, a plain integer.\nCsr creation error: edges were not in sorted order.\nCsr node index type, a plain integer.\nReturn <code>true</code> if the edge was added\nAdds a new node with the given weight, returning the …\nRemove all edges\nColumn of next edge\nComputes in <strong>O(log |V|)</strong> time.\nReturn an iterator of all edges of <code>a</code>.\nweight of each edge; lock step with column\nComputes in <strong>O(1)</strong> time.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>Csr</code> from a sorted sequence of edges\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn an iterator of all neighbors of <code>a</code>.\nComputes in <strong>O(1)</strong> time.\nCreate an empty <code>Csr</code>.\nComputes in <strong>O(1)</strong> time.\nIndex of start of row Always node_count + 1 long. Last …\nAccess the edge’s weight.\nCreate a new <code>Csr</code> with <code>n</code> nodes. <code>N</code> must implement <code>Default</code> …\nA graph that can be extended with further nodes and edges\nA graph that can be created\nAccess node and edge weights (associated data).\nAccess node and edge weights mutably.\nA graph edge.\nA graph element.\nIterator adaptors for iterators of <code>Element</code>.\nAn iterator that filters graph elements.\nCreate a graph from an iterator of elements.\nA graph node.\nAdd a new edge. If parallel edges (duplicate) are not …\nCreate an iterator adaptor that filters graph elements.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdd or update the edge from <code>a</code> to <code>b</code>. Return the id of the …\n[Generic] Dijkstra’s shortest path algorithm.\n<code>Dot</code> configuration.\nPass Debug formatting to Display\n<code>Dot</code> implements output to graphviz .dot format for a graph.\nUse indices for edge labels.\nUse no edge labels.\nPass Display formatting through a simple escaping filter\nEscape for Graphviz\nUse indices for node labels.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a <code>Dot</code> formatting wrapper with default configuration.\nCreate a <code>Dot</code> formatting wrapper with custom configuration.\nThe default integer type for graph indices. <code>u32</code> is the …\nA <code>Graph</code> with directed edges.\nThe graph’s edge type.\nEdge identifier.\nIterator over the edge indices of a graph.\nReference to a <code>Graph</code> edge.\nIterator over all edges of a graph.\nIterator yielding mutable access to all edge weights.\nIterator over the edges of from or to a node\nAn iterator over either the nodes without edges to them or …\n<code>Frozen</code> is a graph wrapper.\n<code>Graph&lt;N, E, Ty, Ix&gt;</code> is a graph datastructure using an …\nA  <code>GraphIndex</code> is a node or edge index.\nTrait for the unsigned integer type used for node and edge …\nIterator over the neighbors of a node.\nThe graph’s node type.\nNode identifier.\nIterator over the node indices of a graph.\nIterator over all nodes of a graph.\nIterator yielding mutable access to all node weights.\nA <code>Graph</code> with undirected edges.\nA “walker” object that can be used to step through the …\nWhich direction to follow None: Both, Some(d): d if …\nShort version of <code>EdgeIndex::new</code>\nNext edge to visit. If we are only following one …\nNext edge in outgoing and incoming edge lists.\nNext edge in outgoing and incoming edge lists.\nStart and End node index\nShort version of <code>NodeIndex::new</code>\nstarting node to skip over\nstarting node to skip over\nAssociated node data.\nAssociated edge data.\nThe default integer type for graph indices. <code>u32</code> is the …\nA <code>Graph</code> with directed edges.\nThe graph’s edge type.\nEdge identifier.\nIterator over the edge indices of a graph.\nReference to a <code>Graph</code> edge.\nIterator over all edges of a graph.\nIterator yielding mutable access to all edge weights.\nIterator over the edges of from or to a node\nAn iterator over either the nodes without edges to them or …\n<code>Frozen</code> is a graph wrapper.\n<code>Graph&lt;N, E, Ty, Ix&gt;</code> is a graph datastructure using an …\nA  <code>GraphIndex</code> is a node or edge index.\nTrait for the unsigned integer type used for node and edge …\nIterator over the neighbors of a node.\nThe graph’s node type.\nNode identifier.\nIterator over the node indices of a graph.\nIterator over all nodes of a graph.\nIterator yielding mutable access to all node weights.\nA <code>Graph</code> with undirected edges.\nA “walker” object that can be used to step through the …\nAdd an edge from <code>a</code> to <code>b</code> to the graph, with its associated …\nAdd a node (also called vertex) with associated data <code>weight</code>…\nReturn the current node and edge capacity of the graph.\nFor edge <code>e</code> with endpoints <code>edge_node</code>, replace links to it, …\nRemove all nodes and edges\nRemove all edges\nLookup if there is an edge from <code>a</code> to <code>b</code>.\nReturn a “walker” object that can be used to step …\nWhich direction to follow None: Both, Some(d): d if …\nReturn the number of edges in the graph.\nAccess the source and target nodes for <code>e</code>.\nShort version of <code>EdgeIndex::new</code>\nReturn an iterator over the edge indices of the graph\nCreate an iterator over all edges, in indexed order.\nAccess the weight for edge <code>e</code>.\nAccess the weight for edge <code>e</code>, mutably.\nReturn an iterator yielding mutable access to all edge …\nReturn an iterator of all edges of <code>a</code>.\nReturn an iterator of all edges of <code>a</code>, in the specified …\nReturn an iterator over all edges connected to <code>a</code>.\nAn invalid <code>EdgeIndex</code> used to denote absence of an edge, …\nExtend the graph from an iterable of edges.\nReturn an iterator over either the nodes without edges to …\nCreate a new <code>Graph</code> by mapping nodes and edges. A node or …\nLookup an edge from <code>a</code> to <code>b</code>.\nLookup an edge between <code>a</code> and <code>b</code>, in either direction.\nAccessor for data structure internals: the first edge in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>Graph</code> from an iterable of edges.\nGet mutable references at index <code>a</code> and <code>b</code>.\nIndex the <code>Graph</code> by two indices, any combination of node or …\nIndex the <code>Graph</code> by two indices, any combination of node or …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the graph into either undirected or directed. No …\nConvert the graph into a vector of Nodes and a vector of …\nWhether the graph has directed edges or not.\nCreate a new <code>Graph</code> by mapping node and edge weights to new …\nReturn an iterator of all nodes with an edge starting from …\nReturn an iterator of all neighbors that have an edge …\nReturn an iterator of all neighbors that have an edge …\nCreate a new <code>Graph</code> with directed edges.\nCreate a new <code>Frozen</code> from a mutable reference to a graph.\nCreate a new <code>Graph</code> with undirected edges.\nStep to the next edge and its endpoint node in the walk …\nNext edge to visit. If we are only following one …\nNext edge in outgoing and incoming edge lists.\nNext edge in outgoing and incoming edge lists.\nAccessor for data structure internals: the next edge for …\nAccessor for data structure internals: the first edge in …\nAccessor for data structure internals: the next edge for …\nStart and End node index\nReturn the number of nodes (vertices) in the graph.\nShort version of <code>NodeIndex::new</code>\nReturn an iterator over the node indices of the graph\nAccess the weight for node <code>a</code>.\nAccess the weight for node <code>a</code>, mutably.\nReturn an iterator yielding mutable access to all node …\nAccess the internal edge array.\nAccess the internal node array.\nRemove an edge and return its edge weight, or <code>None</code> if it …\nRemove <code>a</code> from the graph if it exists, and return its …\nReserves capacity for at least <code>additional</code> more edges to be …\nReserves the minimum capacity for exactly <code>additional</code> more …\nReserves the minimum capacity for exactly <code>additional</code> more …\nReserves capacity for at least <code>additional</code> more nodes to be …\nKeep all edges that return <code>true</code> from the <code>visit</code> closure, …\nKeep all nodes that return <code>true</code> from the <code>visit</code> closure, …\nReverse the direction of all edges\nShrinks the capacity of the graph as much as possible.\nShrinks the capacity of the underlying edges collection as …\nShrinks the capacity of the underlying nodes collection as …\nstarting node to skip over\nstarting node to skip over\nReturn the source node index.\n<code>StableGraph</code> keeps indices stable across removals.\nReturn the target node index.\nAdd or update an edge from <code>a</code> to <code>b</code>. If the edge already …\nAccess the edge’s weight.\nAssociated node data.\nAssociated edge data.\nCreate a new <code>Graph</code> with estimated capacity.\nIterator over the edge indices of a graph.\nReference to a <code>StableGraph</code> edge.\nIterator over all edges of a graph.\nIterator over the edges of from or to a node\nIterator over the neighbors of a node.\nIterator over the node indices of a graph.\nIterator over all nodes of a graph.\nA <code>StableGraph</code> with directed edges.\n<code>StableGraph&lt;N, E, Ty, Ix&gt;</code> is a graph datastructure using …\nA <code>StableGraph</code> with undirected edges.\nA “walker” object that can be used to step through the …\nAdd an edge from <code>a</code> to <code>b</code> to the graph, with its associated …\nAdd a node (also called vertex) with associated data <code>weight</code>…\nfree_edge: Which free list to update for the vacancy\nfree_node: Which free list to update for the vacancy\nReturn the current node and edge capacity of the graph.\nRemove all nodes and edges\nRemove all edges\nReturn a “walker” object that can be used to step …\nWhich direction to follow None: Both, Some(d): d if …\nReturn the number of edges in the graph.\nAccess the source and target nodes for <code>e</code>.\nReturn an iterator over the node indices of the graph\nCreate an iterator over all edges in the graph, in indexed …\nAccess the weight for edge <code>e</code>.\nAccess the weight for edge <code>e</code>, mutably\nReturn an iterator of all edges of <code>a</code>.\nReturn an iterator of all edges of <code>a</code>, in the specified …\nReturn an iterator over all edges connected to <code>a</code>.\nExtend the graph from an iterable of edges.\nCreate a new <code>StableGraph</code> by mapping nodes and edges. A …\nLookup an edge from <code>a</code> to <code>b</code>.\nLookup an edge between <code>a</code> and <code>b</code>, in either direction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>StableGraph</code> from an iterable of edges.\nIndex the <code>StableGraph</code> by two indices, any combination of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the graph has directed edges or not.\nCreate a new <code>StableGraph</code> by mapping node and edge weights …\nReturn an iterator of all nodes with an edge starting from …\nReturn an iterator of all neighbors that have an edge …\nReturn an iterator of all neighbors that have an edge …\nCreate a new <code>StableGraph</code> with directed edges.\nStep to the next edge and its endpoint node in the walk …\nNext edge to visit. If we are only following one …\nReturn an upper bound of the node indices in the graph\nReturn the number of nodes (vertices) in the graph.\nReturn an iterator over the node indices of the graph\nAccess the weight for node <code>a</code>.\nAccess the weight for node <code>a</code>, mutably.\nRemove an edge and return its edge weight, or <code>None</code> if it …\nRemove <code>a</code> from the graph if it exists, and return its …\nKeep all edges that return <code>true</code> from the <code>visit</code> closure, …\nKeep all nodes that return <code>true</code> from the <code>visit</code> closure, …\nstarting node to skip over\nstarting node to skip over\nAdd or update an edge from <code>a</code> to <code>b</code>. If the edge already …\nAccess the edge’s weight.\nCreate a new <code>StableGraph</code> with estimated capacity.\nA <code>GraphMap</code> with directed edges.\n<code>GraphMap&lt;N, E, Ty&gt;</code> is a graph datastructure using an …\nA trait group for <code>GraphMap</code>’s node identifier.\nA reference that is hashed and compared by its pointer …\nA <code>GraphMap</code> with undirected edges.\nAdd an edge connecting <code>a</code> and <code>b</code> to the graph, with …\nAdd node <code>n</code> to the graph.\nReturn an iterator over all edges of the graph with their …\nReturn an iterator over all edges of the graph in …\nReturn the current node and edge capacity of the graph.\nRemove all nodes and edges\nPtr is ordered by pointer value, i.e. an arbitrary but …\nReturn <code>true</code> if the edge connecting <code>a</code> with <code>b</code> is contained …\nReturn <code>true</code> if the node is contained in the graph.\nReturn the number of edges in the graph.\nUse their natual order to map the node pair (a, b) to a …\nReturn a reference to the edge weight connecting <code>a</code> with <code>b</code>, …\nReturn a mutable reference to the edge weight connecting <code>a</code> …\nReturn an iterator of target nodes with an edge starting …\nPtr compares by pointer equality, i.e if they point to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>GraphMap</code> from an iterable of edges.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn a <code>Graph</code> that corresponds to this <code>GraphMap</code>.\nWhether the graph has directed edges.\nReturn an iterator of all nodes with an edge starting from …\nReturn an iterator of all neighbors that have an edge …\nCreate a new <code>GraphMap</code>\nReturn the number of nodes in the graph.\nReturn an iterator over the nodes of the graph.\nRemove edge from <code>a</code> to <code>b</code> from the graph and return the edge …\nReturn <code>true</code> if node <code>n</code> was removed.\nRemove edge relation from a to b\nCreate a new <code>GraphMap</code> with estimated capacity.\nReturns the argument unchanged.\nReturns the argument unchanged.\nins[i] is non-zero if i is in either M_0(s) or Tin_0(s) …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn <strong>true</strong> if we have a complete mapping\nGraph Return <code>true</code> if the graphs <code>g0</code> and <code>g1</code> are isomorphic.\nGraph Return <code>true</code> if the graphs <code>g0</code> and <code>g1</code> are isomorphic.\nThe current mapping M(s) of nodes from G0 → G1 and G1 …\nFind the next (least) node in the Tin set.\nFind the next (least) node in the Tout set.\nFind the next (least) node in the N - M set.\nout[i] is non-zero if i is in either M_0(s) or Tout_0(s) …\nRestore the state to before the last added mapping\nAdd mapping <strong>from</strong> &lt;-&gt; <strong>to</strong> to the state.\nReturn Some(bool) if isomorphism is decided, else None.\nFormat the iterator like a map\nFormat all iterator elements lazily, separated by <code>sep</code>.\nAvoid “pretty” debug\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFormat uses interior mutability because Display::fmt takes …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the first element that maps to <code>Some(_)</code>, or None if …\nReturn the last element from the back that maps to <code>Some(_)</code>…\n<code>MinScored&lt;K, T&gt;</code> holds a score <code>K</code> and a scored object <code>T</code> in a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIterator over the edge indices of a graph.\nReference to a <code>StableGraph</code> edge.\nIterator over all edges of a graph.\nIterator over the edges of from or to a node\nIterator over the neighbors of a node.\nIterator over the node indices of a graph.\nIterator over all nodes of a graph.\nA <code>StableGraph</code> with directed edges.\n<code>StableGraph&lt;N, E, Ty, Ix&gt;</code> is a graph datastructure using …\nA <code>StableGraph</code> with undirected edges.\nA “walker” object that can be used to step through the …\nWhich direction to follow None: Both, Some(d): d if …\nNext edge to visit. If we are only following one …\nstarting node to skip over\nstarting node to skip over\n<code>UnionFind&lt;K&gt;</code> is a disjoint-set data structure. It tracks …\nReturn the representative for <code>x</code>.\nReturn the representative for <code>x</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturn a vector mapping each element to its representative.\nCreate a new <code>UnionFind</code> of <code>n</code> disjoint sets.\nUnify the two sets containing <code>x</code> and <code>y</code>.\nThe associated adjacency matrix type\nAn edge to an already visited node.\nA breadth first search (BFS) of a graph.\nControl flow for callbacks.\nControl flow for callbacks.\nA cross or forward edge.\nDefine associated data for nodes and edges\nVisit nodes of a graph in a depth-first-search (DFS) …\nA depth first search (DFS) visitor event.\nVisit nodes in a depth-first-search (DFS) emitting nodes …\nAn edge-filtering graph adaptor.\nA filtered edges iterator.\nA filtered neighbors iterator.\nedge identifier\nAn edge reference.\nThe kind edges in the graph.\nA graph filter for edges\nA graph filter for nodes.\nCreate or access the adjacency matrix of a graph.\nBase graph trait: defines the associated node identifier …\nEdge kind property (directed or undirected edges)\nA copyable reference to a graph.\nAccess to the sequence of the graph’s edges\nAccess to the edges of each node.\nAccess to all edges of each node, in the specified …\nAccess to the neighbors of each node\nAccess to the neighbors of each node, through incoming or …\nAccess to the sequence of the graph’s <code>NodeId</code>s.\nAccess to the sequence of the graph’s nodes\nThe associated map type\nThe graph’s <code>NodeId</code>s map to indices, in a range without …\nA graph with a known node count.\nA node-filtering graph adaptor.\nA filtered edges iterator.\nA filtered edges iterator.\nA filtered neighbors iterator.\nA filtered node references iterator.\nnode identifier\nThe graph’s <code>NodeId</code>s map to indices\nA node reference.\nAn edge-reversing graph adaptor.\nA reversed edge reference\nA reversed edge references iterator.\nStrictly monotonically increasing event time for a depth …\nA topological order traversal for a graph.\nAn edge of the tree formed by the traversal.\nA mapping for storing the visited status for NodeId <code>N</code>.\nA graph that can create a map that tracks the visited …\nA walker is a traversal state, but where part of the …\nA walker and its context wrapped into an iterator.\nCreate the adjacency matrix\nA recursive depth first search.\nThe map of discovered nodes\nThe map of discovered nodes\nThe map of discovered nodes\nThe map of finished nodes\nConvert <code>i</code> to a node index\nThe edge’s identifier.\nReturn true to have the edge be part of the graph\nReturn true to have the node be part of the graph\nReturn true if there is an edge from <code>a</code> to <code>b</code>, false …\nReturn whether <code>a</code> has been visited before.\nReturn an iterator of the neighbors of node <code>a</code>.\nReturn an upper bound of the node indices in the graph …\nReset the visitor map (and resize to new size of graph if …\nThe source node of the edge.\nThe stack of nodes to visit\nThe stack of nodes to visit\nThe queue of nodes to visit\nThe target node of the edge.\nConvert <code>a</code> to an integer index.\nMark <code>a</code> as visited.\nCreate a new visitor map\nAdvance to the next item\nA reference to the weight of the edge.\nAn edge to an already visited node.\nControl flow for callbacks.\nControl flow for callbacks.\nA cross or forward edge.\nA depth first search (DFS) visitor event.\nStrictly monotonically increasing event time for a depth …\nAn edge of the tree formed by the traversal.\nGet the value in <code>Control::Break(_)</code>, if present.\nA recursive depth first search.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn if the expression is a break value.\nAn edge-filtering graph adaptor.\nA filtered edges iterator.\nA filtered neighbors iterator.\nA graph filter for edges\nA graph filter for nodes.\nA node-filtering graph adaptor.\nA filtered edges iterator.\nA filtered edges iterator.\nA filtered neighbors iterator.\nA filtered node references iterator.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an <code>NodeFiltered</code> adaptor from the closure <code>filter</code>.\nCreate an <code>EdgeFiltered</code> adaptor from the closure <code>filter</code>.\nReturn true to have the edge be part of the graph\nReturn true to have the node be part of the graph\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImplement a trait by delegation. By default as if we are …\nDefine a trait as usual, and a macro that can be used to …\nAn edge-reversing graph adaptor.\nA reversed edge reference\nA reversed edge references iterator.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA breadth first search (BFS) of a graph.\nVisit nodes of a graph in a depth-first-search (DFS) …\nVisit nodes in a depth-first-search (DFS) emitting nodes …\nA topological order traversal for a graph.\nA walker is a traversal state, but where part of the …\nA walker and its context wrapped into an iterator.\nThe map of discovered nodes\nThe map of discovered nodes\nThe map of discovered nodes\nCreate a new <strong>Dfs</strong> using the graph’s visitor map, and no …\nCreate a new <code>DfsPostOrder</code> using the graph’s visitor map, …\nCreate a new <code>Topo</code>, using the graph’s visitor map with <em>no</em> …\nThe map of finished nodes\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Dfs</code> from a vector and a visit map\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an iterator out of the walker and given <code>context</code>.\nCreate an iterator out of the walker and given <code>context</code>.\nKeep the discovered map, but clear the visit stack and …\nKeep the discovered and finished map, but clear the visit …\nCreate a new <strong>Dfs</strong>, using the graph’s visitor map, and put …\nCreate a new <code>DfsPostOrder</code> using the graph’s visitor map, …\nCreate a new <strong>Bfs</strong>, using the graph’s visitor map, and put …\nCreate a new <code>Topo</code>, using the graph’s visitor map, and …\nReturn the next node in the dfs, or <strong>None</strong> if the traversal …\nReturn the next node in the traversal, or <code>None</code> if the …\nReturn the next node in the bfs, or <strong>None</strong> if the traversal …\nReturn the next node in the current topological order …\nClear the visit state\nClear the visit state\nClear visited state, and put all initial nodes in the to …\nThe stack of nodes to visit\nThe stack of nodes to visit\nThe queue of nodes to visit\nAdvance to the next item")