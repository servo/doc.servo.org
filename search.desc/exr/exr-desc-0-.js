searchState.loadedDescShard("exr", 0, "Read and write OpenEXR images. This library uses no …\nThis is the low-level interface for the raw blocks of an …\nContains the compression attribute definition and methods …\nError type definitions.\nData structures that represent a complete exr image. …\nSimple math utilities.\nDescribes all meta data possible in an exr file. Contains …\nExport the most important items from <code>exrs</code>. <em>Note: This </em>…\nSpecifies where a block of pixel data should be placed in …\nContains a block of pixel data and where that data should …\nRead and write already compressed pixel data blocks. Does …\nCreate an uncompressed block byte vector by requesting one …\nConsume this block by compressing it, returning a <code>Chunk</code>.\nUncompressed pixel values of the whole block. One or more …\nDecompress the possibly compressed chunk and returns an …\nThis iterator tells you the block indices of all blocks …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an uncompressed block by requesting one line of …\nLocation of the data inside the image.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndex of the layer.\nIndex of the mip or rip level in the image.\nExtract lines from a block of pixel bytes.\nIterate all the lines in this block. Each line contains …\nIndex of the top left pixel from the block within the data …\nNumber of pixels in this block, extending to the right and …\nImmediately reads the meta data from the file. Then, …\nComposable structures to handle reading an image.\nExtract pixel samples from a block of pixel bytes.\nImmediately writes the meta data to the file. Then, calls …\nComposable structures to handle writing an image.\nA generic block of pixel information. Contains pixel data …\nThe raw, possibly compressed pixel data of a file. Each …\nThis <code>Block</code> consists of one or more deep scan lines. …\nThis <code>Block</code> is a tile of deep data. Corresponds to type …\nA <code>Block</code> of possibly compressed flat scan lines. …\nThis <code>Block</code> is a tile of flat (non-deep) data. Corresponds …\nScan line blocks of deep data.\nTiles of deep data.\nScan line blocks of flat data.\nTiles of flat data.\nIndicates the position and resolution level of a <code>TileBlock</code> …\nThe compressed pixel contents.\nThe pixel offset table is a list of integers, one for each …\nThe pixel offset table is a list of integers, one for each …\nOne or more scan lines may be stored together as a scan …\nOne or more scan lines may be stored together as a scan …\nOne or more scan lines may be stored together as a scan …\nOne or more scan lines may be stored together as a scan …\nThe tile location.\nThe tile location.\nCount of samples.\nCount of samples.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns if this is the original resolution or a smaller …\nThe index of the layer that the block belongs to. This is …\nIndex of the Mip/Rip level.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nIndex of the tile, not pixel position.\nAbsolute coordinates inside the global 2D space of a file, …\nThe indices which can be used to index into the arrays of …\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nThe block’s y coordinate is the pixel space y coordinate …\nThe block’s y coordinate is the pixel space y coordinate …\nSpecifies where a row of pixels lies inside an image. This …\nAn reference to a single line of pixels. May go across the …\nA reference to a single mutable line of pixels. May go …\nA single line of pixels. Use LineRef or LineRefMut for …\nThe channel index of the layer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndex of the layer.\nIndex of the mip or rip level in the image.\nIterates the lines of this block index in interleaved …\nWhere this line is located inside the image.\nWhere this line is located inside the image.\nWhere this line is located inside the image.\nPosition of the most left pixel of the row.\nIterate over all samples in this line, from left to right. …\nIterate over all samples in this line, from left to right. …\nRead the samples (f16, f32, u32 values) from this line …\nRead the samples (f16, f32, u32 values) from this line …\nThe width of the line; the number of samples in this row, …\nThe raw bytes of the pixel line, either <code>&amp;[u8]</code> or <code>&amp;mut [u8]</code>.\nThe raw bytes of the pixel line, either <code>&amp;[u8]</code> or <code>&amp;mut [u8]</code>.\nThe raw bytes of the pixel line, either <code>&amp;[u8]</code> or <code>&amp;mut [u8]</code>.\nIterate over all samples in this line, from left to right. …\nIterate over all samples in this line, from left to right. …\nWrites the samples (f16, f32, u32 values) into this line …\nWrites the samples (f16, f32, u32 values) into this line …\nDecode all chunks in the file without seeking. The decoded …\nDecode chunks in the file. The decoded chunks can be …\nDecode the desired chunks and skip the unimportant chunks …\nDecode chunks in the file without seeking. Calls the …\nDecompress the chunks in a file in parallel. The first …\nDecode the meta data from a byte source, keeping the …\nRead all chunks from the file, decompressing each chunk …\nPrepare to read all the chunks from the file. Does not …\nRead and then decompress a single block of pixels from the …\nFill the pool with decompression jobs. Returns the first …\nDecompress all blocks in the file, using multiple cpu …\nReturn an iterator that decompresses the chunks in this …\nThe number of chunks that this reader will return in total.\nPrepare to read some the chunks from the file. Does not …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe decoded exr headers from the file.\nThe decoded exr meta data from the file.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nObtain the meta data ownership.\nThe decoded exr meta data from the file.\nThe decoded exr meta data from the file.\nThe extracted meta data from the image file.\nThe extracted meta data of the image file.\nCreate a new decompressor. Does not immediately spawn any …\nCreate a new decompressor. Does not immediately spawn any …\nCreate a new reader that calls the provided progress …\nReturn an iterator that decompresses the chunks with …\nStart the reading process. Immediately decodes the meta …\nRead the next compressed chunk from the file. Equivalent …\nPrepare reading the chunks sequentially, only a single …\nA 16-bit float sample.\nA 32-bit float sample.\nCreate an arbitrary sample type from one of the defined …\nConvert any type into one of the supported sample types. …\nA single red, green, blue, or alpha value.\nAn unsigned integer sample.\nCreate a sample containing a 16-bit float.\nCreate a sample containing a 32-bit float.\nReturns the argument unchanged.\nCreate this sample from a f16, trying to represent the …\nConvert all values from the slice into this type. This …\nCreate this sample from a f32, trying to represent the …\nConvert all values from the slice into this type. This …\nCreate this sample from a u32, trying to represent the …\nConvert all values from the slice into this type. This …\nCalls <code>U::from(self)</code>.\nIs this value not a number?\nIs this value zero or negative zero?\nConvert this sample to an f16, trying to represent the …\nConvert the sample to an f16 value. This has lower …\nConvert this sample to an f32, trying to represent the …\nConvert the sample to an f32 value. Note: An f32 can only …\nConvert this sample to an u16, trying to represent the …\nConvert the sample to a u32. Rounds floats to integers the …\nCreate a sample containing a 32-bit integer.\nCan consume compressed pixel chunks, writing them a file. …\nWrite chunks to a byte destination. Then write each chunk …\nA new writer that triggers a callback for each block …\nCompress blocks to a chunk writer with multiple threads.\nCompress blocks to a chunk writer in this thread.\nWrite blocks that appear in any order and reorder them …\nAdd a single block to the compressor queue. The index of …\nSeek back to the meta data, write offset tables, and flush …\nCompresses all blocks to the file. The index of the block …\nCompresses all blocks to the file. The index of the block …\nCompress a single block immediately. The index of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhere the chunks will be written to.\nThis is where the compressed blocks are written to.\nThis is where the compressed blocks are written to.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNew sorting writer. Returns <code>None</code> if sorting is not …\nNew blocks writer.\nNew blocks writer. Returns none if sequential compression …\nWrites the meta data and zeroed offset tables as a …\nNew blocks writer. Returns none if sequential compression …\nObtain a new writer that calls the specified closure for …\nObtain a new writer that can compress blocks to chunks on …\nObtain a new writer that can compress blocks to chunks, …\nThe total number of chunks that the complete file will …\nThe total number of chunks that the complete file will …\nWait until all currently compressing chunks in the …\nAny more calls will result in an error and have no effect. …\nAny more calls will result in an error and have no effect. …\nWrite an exr file by writing one chunk after another in a …\nWrite the chunk or stash it. In the closure, write all …\nThis is a lossy compression method for f16 images. It’s …\nThis is a lossy compression method for f16 images. All f32 …\nA byte vector.\nA byte slice.\nSpecifies which compression method to use. Use …\n<strong>This lossy compression is not yet supported by this </strong>…\n<strong>This lossy compression is not yet supported by this </strong>…\nPIZ compression works well for noisy and natural images. …\nLike <code>ZIP1</code>, but reduces precision of <code>f32</code> images to <code>f24</code>. …\nProduces slightly smaller files that can still be read and …\nStore uncompressed values. Produces large files that can …\nUses ZIP compression to compress each line. Slowly …\nUses ZIP compression to compress blocks of 16 lines. …\nNumber of bytes this would consume in an exr file.\nCompress the image section of bytes.\nDecompress the image section of bytes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMost compression methods will reconstruct the exact pixel …\nMost compression methods will reconstruct the exact pixel …\nA collection of functions used to prepare data for …\nThe PIZ compression method is a wavelet compression, based …\nLossy compression for F32 data, but lossless compression …\nRead the value without validating.\nFor scan line images and deep scan line images, one or …\nDeep data can only be compressed using RLE or ZIP …\nMost compression methods will reconstruct the exact pixel …\nWithout validation, write this instance to the byte stream.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPack a block of 4 by 4 16-bit pixels (32 bytes, the array <code>s</code>…\nIntegrate over all differences to the previous value in …\nInterleave the bytes such that the second half of the …\nDerive over all values in order to produce differences to …\nSeparate the bytes such that the second half contains …\nReturns the argument unchanged.\n16-bit Huffman compression and decompression. Huffman …\nCalls <code>U::from(self)</code>.\nWavelet encoding and decoding.\nBuild a “canonical” Huffman code table:\nBuild a decoding hash table based on the encoding table …\nCompute Huffman codes (based on frq input) and store them …\nDecode (uncompress) n bits based on encoding &amp; decoding …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPack an encoding table:\nRun-length-decompresses all zero runs from the packed …\nUntransformed data values should be less than (1 &lt;&lt; 14).\nConversion from 32-bit to 24-bit floating-point numbers. …\nReading or Writing the file has been aborted by the caller.\nContains the error value\nContains the error value\nContains the error value\nAn error that may happen while reading or writing an exr …\nThe contents of the image are contradicting or …\nThe underlying byte stream could not be read successfully, …\nThe error type for I/O operations of the <code>Read</code>, <code>Write</code>, <code>Seek</code>…\nA specialized <code>Result</code> type for I/O operations.\nThe contents of the file are not supported by this …\nContains the success value\nContains the success value\nContains the success value\nA result that may contain an exr error.\nA result that, if ok, contains nothing, and otherwise …\nAttempt to downcast the custom boxed error to <code>E</code>.\nConverts an <code>ErrorKind</code> into an <code>Error</code>.\nConverts <code>TryReserveError</code> to an error with …\nConverts a <code>alloc::ffi::NulError</code> into a <code>Error</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new instance of an <code>Error</code> from a particular OS …\nReturns a mutable reference to the inner error wrapped by …\nReturns a reference to the inner error wrapped by this …\nReturn error on invalid range.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the <code>Error</code>, returning its inner error (if any).\nCreate an error of the variant <code>Invalid</code>.\nReturns the corresponding <code>ErrorKind</code> for this error.\nReturns an error representing the last OS error which …\nCreates a new I/O error from a known kind of error as well …\nCreates a new I/O error from an arbitrary error payload.\nReturns the OS error that this error represents (if any).\nPanic on overflow.\nPanic on overflow.\nCreate an error of the variant <code>NotSupported</code>.\nPanic on overflow.\nReturn error on invalid range.\nPanic on overflow.\nA single arbitrary channel. <code>Samples</code> can currently only be …\nA dynamic list of arbitrary channels. <code>Samples</code> can …\nThis image type contains all supported exr features and …\nHow the image pixels are split up into separate blocks.\nThis check can be executed at compile time if the channel …\nHow the pixels are split up and compressed.\nA vector of non-deep <code>f16</code> values.\nA vector of non-deep <code>f32</code> values.\nRun-length encoding with tiles of 64x64 pixels. This is …\nThis image type contains the most common exr features and …\nIterate over all channels of a single pixel in the image\nA vector of non-deep values (one value per pixel per …\nA list of samples representing a single pixel. Does not …\nThe complete exr image. <code>Layers</code> can be either a single <code>Layer</code>…\nConvert this type into one of the known sample types. Also …\nA single Layer, including fancy attributes and compression …\nA list of layers. <code>Channels</code> can be <code>SpecificChannels</code> or …\nA list of resolution levels. <code>Samples</code> can currently only be …\nOne or multiple resolution levels of the same image. …\nContains uniformly scaled smaller versions of the original.\nThe native sample types that this type should be converted …\nThis image type contains a single layer containing a …\nThis image type contains multiple layers, with each layer …\nContains information about the channels in an rgb image, …\nContains information about the channels in an rgba image, …\nThis image type contains a single layer containing a …\nThis image type contains multiple layers, with each layer …\nContains any possible combination of smaller versions of …\nIn addition to the full resolution image, this layer also …\nPIZ compression with tiles of 256x256 pixels. Small …\nZIP compression with blocks of 16 lines. Slow, but …\nThe image is divided into scan line blocks. The number of …\nA single image without smaller versions of itself. If you …\nA grid of pixels. The pixels are written to your custom …\nUsed to construct a <code>SpecificChannels</code>. Call …\nThe image is divided into tile blocks. Also specifies the …\nA vector of non-deep <code>u32</code> values.\nNo compression. Massive space requirements. Fast, because …\nSometimes called “data window”\nCheck for duplicate channel names.\nAttributes that apply to the whole image file. These …\nAttributes that apply to the whole image file. These …\nAttributes that apply to the whole image file. These …\nAttributes that apply to the whole image file. These …\nAttributes that apply to the whole image file. These …\nAttributes that apply to the whole image file. These …\nAttributes that apply to the whole image file. These …\nAttributes that apply to this layer. May still contain …\nDescribes how the pixels of this layer are divided into …\nStart building some specific channels. On the result of …\nThe actual pixel data. Either <code>SpecificChannels</code> or …\nA description of the channels in the file, as opposed to …\nHow the pixel data of all channels in this layer is …\nCrop away unwanted pixels. Includes automatic detection of …\nCreate an empty image, to be filled with layers later on. …\nHow the pixels are split up and compressed.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nUses empty attributes and fast compression.\nUses empty attributes.\nUses the display position and size to the channel position …\nCreate an image with multiple layers. The layer can be a …\nReturn a level by level index. Level <code>0</code> has the largest …\nReturn a mutable level reference by level index. Level <code>0</code> …\nGet a resolution level by index, sorted by size, …\nFlatten the 2D level index to a one dimensional index.\nGet a resolution level by index, sorted by size, …\nDon’t do anything\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe layers contained in the image file. Can be either a …\nThe layers contained in the image file. Can be either a …\nThe layers contained in the image file. Can be either a …\nThe layers contained in the image file. Can be either a …\nThe layers contained in the image file. Can be either a …\nThe layers contained in the image file. Can be either a …\nThe layers contained in the image file. Can be either a …\nThe number of samples in the image. Should be the width …\nThe number of levels that were generated along the x-axis …\nWhether this stores multiple resolution levels.\nGet a slice of all resolution levels, sorted by size, …\nGet a mutable slice of all resolution levels, sorted by …\nPanics for images with Scanline encoding.\nIn what order the tiles of this header occur in the file. …\nThis list must be sorted alphabetically, by channel name. …\nA flattened list containing the individual levels\nOne of “R”, “G”, or “B” most of the time.\nCreate an image with one or multiple layers. The layer can …\nCreate a layer with the specified size, attributes, …\nCreate some pixels with channel information. The <code>Channels</code> …\nCreate a new channel without subsampling.\nProvides a predefined pixel storage. Currently only …\nYour custom pixel storage\nThis attribute only tells lossy compression methods …\nRead an exr image.\nA generic wrapper which can be used to represent recursive …\nCreate an image with red, green, and blue channels. You …\nCreate an image with red, green, blue, and alpha channels. …\nThe actual pixel data. Can be <code>FlatSamples</code> or …\nUse <code>samples_at</code> if you can borrow from this layer\nLookup all channels of a single pixel in the image\nHow many of the samples are skipped compared to the other …\nThe pixel resolution of this layer. See <code>layer.attributes</code> …\nA new list of arbitrary channels. Sorts the list to make …\nThis does an approximate comparison for all channels, even …\nCompare the result of a round trip test with the original …\nLookup a single value, by flat index. The flat index can …\nAll samples in this storage as iterator. Matches the …\nViews all samples in this storage as f32. Matches the …\nAdd another channel to this image. Does not add the actual …\nAdd another channel to this image. Does not add the actual …\nAdd another layer to this image. The layer type does not …\nSpecify the contents of the image. The pixel type must be …\nSpecify the actual pixel contents of the image. You can …\nWrite an exr image to a file.\nThe smaller versions of the original.\nThe smaller versions of the original.\nWhether to round up or down when calculating Mip/Rip …\nWhether to round up or down when calculating Mip/Rip …\nRealize a cropped view of the original data, by actually …\nCrop some pixels ways when specifying a smaller rectangle\nCropping an image fails if the image is fully transparent. …\nCrop away unwanted pixels from the border if they match …\nThe image contained some pixels and has been cropped or …\nThe type of  this image after cropping (probably the same …\nThe type of the cropped image (probably the same as the …\nA smaller window into an existing pixel storage\nA writer for the cropped view layer\nAll pixels in the image would be discarded, removing the …\nSomething that has a two-dimensional rectangular shape\nInspect the pixels in this image to determine where to …\nThe simpler type after cropping is realized\nThe type of pixel in this pixel grid.\nThe bounding rectangle of this pixel grid.\nCrop the image to exclude unwanted pixels. Panics for …\nWrap a layer in a cropped view with adjusted bounds, but …\nConvert this data to cropped data without discarding any …\nCrop away unwanted pixels from the border if they match …\nCrop away unwanted pixels from the border if they match …\nThe cropped pixel storage bounds\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe uncropped pixel storage bounds\nThe uncropped pixel storage\nIndex is not in world coordinates, but within the data …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf the image was fully empty, crop to one single pixel of …\nIf the image was fully empty, return <code>None</code>, otherwise …\nMake the cropping real by reallocating the underlying …\nReduce your image to a smaller part, usually to save …\nReturn the smallest bounding rectangle including all …\nThe fully discarded image which caused the cropping to fail\nStore all samples in a single array. All samples will be …\nCompute the flat index of a specific pixel. Returns a …\nCreate a new flattened pixel storage, filled with default …\nReturns the argument unchanged.\nExamine a pixel of a <code>PixelVec&lt;T&gt;</code> image. Can usually be …\nCalls <code>U::from(self)</code>.\nCreate a new flattened pixel storage, checking the length …\nThe flattened vector contains all rows one after another. …\nThe resolution of this layer.\nUpdate a pixel of a <code>PixelVec&lt;T&gt;</code> image. Can usually be used …\nUtilizes the builder pattern to configure an image reader. …\nHow to read arbitrary channels.\nReturns the argument unchanged.\nThe last wrapper of image readers, finally containing the […\nCalls <code>U::from(self)</code>.\nHow to read either a single or a list of layers.\nHow to read a set of resolution levels.\nSpecify to handle only one sample per channel, disabling …\nCreate a reader which can be used to load an exr image. …\nAll resolution levels, all channels, all layers. Does not …\nNo deep data, no resolution levels, all channels, all …\nNo deep data, no resolution levels, rgba channels, all …\nNo deep data, no resolution levels, all channels, first …\nNo deep data, no resolution levels, rgba channels, …\nHow to read samples (a grid of <code>f32</code>, <code>f16</code> or <code>u32</code> values).\nHow to read arbitrary but specific selection of arbitrary …\nProcesses pixel blocks from a file and accumulates them …\nProcesses pixel blocks from a file and accumulates them …\nA template that creates an AnyChannelsReader for each …\nA template that creates a new [<code>SampleReader</code>] for each …\nThe type of the temporary samples reader\nThe type of resulting sample storage\nProcesses pixel blocks from a file and accumulates them …\nCreate a single reader for a single channel of a layer\nSpecify whether a single block of pixels should be loaded …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDeliver the final accumulated sample storage for the image\nTemporarily accumulated meta data.\nTemporarily accumulated meta data.\nLoad a single pixel line, which has not been filtered, …\nThe sample reading specification\nStores a separate sample reader per channel in the layer\nThe custom reader that accumulates the pixel data for a …\nTemporarily accumulated meta data.\nProcesses blocks from a file and collects them into a …\nThe type of the resulting Layers\nThe type of resulting layers\nProcesses pixel blocks from a file and accumulates them …\nSpecify whether to read the image in parallel, whether to …\nA template that creates a <code>LayerReader</code> for each layer in …\nThe type of the temporary layer reader\nSpecify that all attributes should be read from an image. …\nCreate a single reader for a single layer\nSpecify whether a single block of pixels should be loaded …\nSpecify whether a single block of pixels should be loaded …\nReturns the argument unchanged.\nReturns the argument unchanged.\nRead the exr image from a buffered reader. Use […\nRead the exr image from an initialized chunks reader that …\nRead the exr image from a file. Use […\nBuffer the reader and then read the exr image from it. Use …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDeliver the complete accumulated image\nDeliver the final accumulated layers for the image\nUses relaxed error handling and parallel decompression.\nA new image reader with image attributes.\nSpecify that multiple pixel blocks should never be …\nSpecify a function to be called regularly throughout the …\nSpecify that any missing or unusual information should …\nLoad a single pixel block, which has not been filtered, …\nLoad a single pixel block, which has not been filtered, …\nProcesses pixel blocks from a file and accumulates them …\nThe type of the resulting channel collection\nProcesses pixel blocks from a file and accumulates them …\nProcesses pixel blocks from a file and accumulates them …\nProcesses pixel blocks from a file and accumulates them …\nSpecify to read all channels, aborting if any one is …\nA template that creates a <code>ChannelsReader</code> once for all …\nSpecify to read only the first layer which meets the …\nThe type of the temporary channels reader\nReads all layers, including an empty list. Aborts if any …\nCreate a single reader for all channels of a specific layer\nSpecify whether a single block of pixels should be loaded …\nRead only the first layer which meets the previously …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDeliver the final accumulated channel collection for the …\nLoad a single pixel block, which has not been filtered, …\nThe channel reading specification\nThe channel reading specification\nProcesses pixel blocks from a file and accumulates them …\nSpecify to read all contained resolution levels from the …\nSpecify to read only the highest resolution level, …\nA template that creates a <code>SamplesReader</code> once for each …\nThe type of the temporary level reader\nRead all arbitrary channels in each layer.\nRead all arbitrary channels in each layer.\nCreate a single reader for a single resolution level\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe sample reading specification\nThe sample reading specification\nRead only layers that contain rgb channels. Skips any …\nRead only layers that contain rgba channels. Skips any …\nRead only layers that contain the specified channels, …\nProcesses pixel blocks from a file and accumulates them …\nSpecify to read only flat samples and no “deep data”\nSpecify to read all contained resolution levels from the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSpecify to read only the highest resolution level, …\nSpecifies how to collect all the specified channels into a …\nReader for a single channel. Generic over the concrete …\nUsed to read another specific channel from an image. …\nUsed to read another specific channel from an image. …\nCan be attached one more channel reader. Call <code>required</code> or …\nRead zero channels from an image. Call <code>with_named_channel</code> …\nThe channel descriptions from the image. Will be converted …\nThe pixel type. Will be converted to a tuple at the end of …\nA reader containing sub-readers for reading the pixel …\nA separate internal reader for the pixels. Will be of type …\nReader for a single channel. Generic over the concrete …\nThe reader that holds the temporary data that is required …\nto be multiplied with line width!\nUsing two closures, define how to store the pixels. The …\nCreate a separate internal reader for the pixels of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the channel descriptions based on the channels in …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPlan to read an additional channel from the image, with …\nDoes the same as …\nRead the line of pixels.\nPlan to read an additional channel from the image, with …\nConvert this recursive type into a tuple. This is nice as …\nCreate a recursive type from this tuple.\nConvert this recursive type into a tuple. This is nice as …\nThe resulting tuple type.\nNo more recursion. Can be used within any …\nA recursive type-level linked list of <code>Value</code> entries. …\nThe recursive type resulting from this tuple.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates the recursive type corresponding to this tuple:\nGenerates the recursive value corresponding to the given …\nGenerates the into_tuple value corresponding to the given …\nGenerate the trait implementations given a sequence of …\nThe remaining values of this linked list, probably either …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this recursive type to a nice tuple.\nCreate a recursive type from this tuple.\nConvert this recursive type to a nice tuple.\nCreate a new recursive type. Equivalent to the manual …\nThe next item in this linked list.\nContains the error value\nContains the success value\nCompare two objects, but with a few special quirks. …\nWhether to do accurate or approximate comparison.\nIf invalid, contains the error message.\nCompare self with the other. Panics if not equal.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompare self with the other. Exceptional behaviour:\nEnables an image to be written to a file. Call …\nA temporary writer which can be configured and used to …\nHow to read arbitrary channels and rgb channels.\nReturns the argument unchanged.\nGenerate file meta data for this image. The meta data …\nCalls <code>U::from(self)</code>.\nHow to write either a single or a list of layers.\nDo not compress multiple pixel blocks on multiple threads …\nSpecify a function to be called regularly throughout the …\nHow to write samples (a grid of <code>f32</code>, <code>f16</code> or <code>u32</code> values).\nSkip some checks that ensure a file can be opened by other …\nWrite the exr image to a writer. Use <code>to_file</code> instead, if …\nWrite the exr image to a file. Use <code>to_unbuffered</code> instead, …\nBuffer the writer and then write the exr image to it. Use …\nCreate a temporary writer which can be configured and used …\nAn oversimplified function for “just write the damn file …\nAn oversimplified function for “just write the damn file …\nA temporary writer for an arbitrary list of channels\nA temporary writer for a list of channels\nDefine how to get a pixel from your custom pixel storage. …\nThe pixel tuple containing <code>f32</code>, <code>f16</code>, <code>u32</code> and <code>Sample</code> values.\nWrite pixels to a slice of bytes. The top level writer …\nA type that has a recursive entry for each channel in the …\nWrite the pixels of a single channel, unconditionally. …\nA temporary writer for a layer of channels, alpha being …\nEnables an image containing this list of channels to be …\nA tuple containing either <code>ChannelsDescription</code> or …\nThe type of temporary writer\nReturn all the channels that should actually end up in the …\nCreate the temporary writer, accepting the sorted list of …\nCreate a temporary writer for this list of channels\nDeliver a block of pixels, containing all channel data, to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInspect a single pixel at the requested position. Will be …\nGenerate the file meta data for this list of channel\nGenerate the file meta data of whether and how resolution …\nThe remaining values of this linked list, probably either …\nThe remaining values of this linked list, probably either …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe next item in this linked list.\nThe next item in this linked list.\nWrite pixels to a slice of bytes. Recursively do this for …\nA temporary writer for an arbitrary list of layers\nA temporary writer for a single layer\nA temporary writer for a list of channels\nEnables an image containing this list of layers to be …\nThe type of temporary writer\nCreate a temporary writer for this list of layers\nDeliver a block of pixels from a single layer to be stored …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate the file meta data for this list of layers\nThe remaining values of this linked list, probably either …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe next item in this linked list.\nA temporary writer for a predefined non-deep sample storage\nA temporary writer for multiple resolution levels\nA temporary writer for one or more resolution levels …\nEnable an image with this single level sample grid to be …\nEnable an image with this sample grid to be written to a …\nThe type of the temporary writer for this sample storage\nThe type of the temporary writer for this single level of …\nCreate a temporary writer for this single level of samples\nCreate a temporary writer for this sample storage\nDeliver a single short horizontal list of samples for a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate the file meta data regarding resolution levels\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerate the file meta data regarding the number type of …\nGenerate the file meta data regarding the number type of …\nRound down.\nRound up or down in specific calculations.\nRound up.\nSimple two-dimensional vector of any numerical type. …\nSeeing this vector as a dimension or size (width and …\nComputes <code>ceil(log(x)/log(2))</code>. Returns 0 where argument is …\nOnly works for positive numbers.\nConvert this two-dimensional coordinate to an index suited …\nComputes <code>floor(log(x)/log(2))</code>. Returns 0 where argument is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe second component of this 2D vector.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the vector with the maximum of either coordinates.\nReturns the vector with the minimum of either coordinates.\nPanics for too large values\nTry to convert to <code>Vec2&lt;usize&gt;</code>, returning an error on …\nTry to convert all components of this vector to a new type,\nThe first component of this 2D vector.\nThe first component of this 2D vector.\nThe second component of this 2D vector.\nHow the image pixels are split up into separate blocks.\nList of <code>Header</code>s.\nContains the complete meta data of an exr image. Defines …\nThe offset table is an ordered list of indices referencing …\nList of <code>OffsetTable</code>s.\nA summary of requirements that must be met to read this …\nThe image is divided into scan line blocks. The number of …\nLocates a rectangular section of pixels in an image.\nThe image is divided into tile blocks. Also specifies the …\nContains all meta data attributes. Each layer can have any …\nCompute the start position and size of a block inside a …\nCalculate the size of a single block. If this is the last …\nGo through all the block indices in the correct order and …\nGo through all the block indices in the correct order and …\nCompute the number of tiles required to contain all values.\nCompute the number of chunks that an image is divided …\nCalculate number of mip levels in a given resolution.\nCalculate the size of a single mip level by index.\nThis iterator tells you the block indices of all blocks …\nThis library supports reading version 1 and 2, and writing …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis image contains at least one layer with deep data.\nWhether this file has strings with a length greater than …\nWhether this file contains multiple layers.\nWhether this image is tiled. If false, this image is …\nContains collections of common attributes. Defines some …\nOne header to describe each layer in this file.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this file declared to contain multiple layers?\nIf true, this image has tiled blocks and contains only a …\nIndex of the tile.\nThe first four bytes of each exr file. Used to abort …\nIterates over all mip map level indices of a given size. …\nIterates over all mip map level resolutions of a given …\nRead the value without validating.\nRead the exr meta data from a reader. Use <code>read_from_file</code> …\nRead the exr meta data from a file. Use …\nBuffer the reader and then read the exr meta data from it. …\nRead one offset table from the reader for each header.\nDoes <strong>not validate</strong> the meta data completely.\nValidates the meta data.\nSome flags summarizing the features that must be supported …\nIterates over all rip map level indices of a given size. …\nIterates over all rip map level resolutions of a given …\nA <code>0_u8</code> at the end of a sequence.\nPixel size of the tile.\nSkip the offset tables by advancing the reader by the …\nValidates this meta data. Returns the minimal possible …\nValidate this instance.\nWithout validation, write this instance to the byte stream.\nValidates the meta data and writes it to the stream. If …\nContains one of all possible attributes. Includes a …\nNumber of bytes this would consume in an exr file.\nlayer type, specifies block type and deepness.\nDeep or flat and tiled or scan line.\nA single channel in an layer. Does not contain the actual …\nA List of channels. Channels must be sorted alphabetically.\nChannel meta data.\nThe color space of the pixels.\nColor space definition.\nCompression method of this layer.\nThis image contains the six sides of a cube.\nA custom attribute. Contains the type name of this value.\nThe integer rectangle describing where an layer is placed …\nThe blocks in the file are ordered in ascending rows from …\nCorresponds to the string value <code>deepscanline</code>.\nCorresponds to the string value <code>deeptile</code>.\nThe integer rectangle limiting which part of the infinite …\nIf this attribute is present, it describes how this …\nThis image is an environment map.\nThis channel contains 16-bit float values.\n32-bit float\nThis channel contains 32-bit float values.\n64-bit float\nA rectangular section anywhere in 2D float space.\n2D float rectangle.\n2D float vector.\n3D float vector.\n32-bit signed integer\nThe blocks in the file are ordered in descending rows from …\n2D integer vector.\n3D integer vector.\nA rectangular section anywhere in 2D integer space. Valid …\n2D integer rectangle.\nUniquely identifies a motion picture film frame.\nFilm roll information.\nThis image is an environment map projected like a world …\nWhether to also store increasingly smaller versions of the …\nIn what order the <code>Block</code>s of pixel data appear in a file.\nOrder of the bocks in the file.\nA float matrix with three rows and three columns.\nA 3x3 matrix of floats.\nA float matrix with four rows and four columns.\nA 4x4 matrix of floats.\nLevels with a similar aspect ratio.\nA small <code>rgba</code> image of <code>i8</code> values that approximates the real …\n8-bit rgba Preview of the image.\nAn integer dividend and divisor, together forming a ratio.\nAn integer dividend and divisor.\nLevels with all possible aspect ratios.\nThe type of samples in this channel.\nCorresponds to the string value <code>scanlineimage</code>.\nOnly a single level.\nThe corresponding attribute type name literal\nA byte array with each byte being a char. This is not UTF …\nA string of byte-chars.\nThe raw bytes that make up a string in an exr file. Each <code>u8</code>…\nA byte slice, interpreted as text\nList of texts.\nCorresponds to the string value <code>tiledimage</code>.\nDescribes how the layer is divided into tiles. Specifies …\nHow to tile up the image.\nContains time information for this frame within a sequence.\nTimepoint and more.\nThis channel contains 32-bit unsigned int values.\nThe blocks are not ordered in a specific way inside the …\nThe internal ASCII bytes this text is made of.\nFlags for <code>TimeCode.binary_groups</code>.\nThe user-defined control codes. Every entry in this array …\nThe string literals used to represent a <code>BlockType</code> in a …\n“Blue” location on the CIE XY chromaticity diagram.\nNumber of bytes this attribute would consume in an exr …\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nNumber of bytes this would consume in an exr file.\nThe underlying bytes that represent this text.\nThe number of bytes that one pixel in this image needs.\nHow many bytes a single sample takes up.\nIterate over the channels, and adds to each channel the …\nIterate over the individual chars in this text, similar to …\nWhether this is a color frame.\nReturns whether the specified rectangle is equal to or …\nSpecifies the film count.\nWhether this is a drop frame.\nReturns the top-right coordinate of the rectangle. The row …\nCompare this <code>exr::Text</code> with a plain <code>&amp;str</code>.\nCompare this <code>exr::Text</code> with a plain <code>&amp;str</code> ignoring …\nField Phase.\nIdentifies a film manufacturer.\nSpecifies the film roll prefix.\nIdentifies a film type.\nReturn the index of the channel with the exact name, case …\nFrame Indices 0 - 29 are valid.\nReturns the argument unchanged.\nPanics if the string contains an unsupported character\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>Text</code> from the specified bytes object, without …\nCreate a box with a size starting at zero.\nUnpack a time code from one TV60 encoded u32 value and the …\nCreate a <code>Text</code> from a slice of bytes, without checking any …\nUnpack a time code from one TV50 encoded u32 value and the …\nUnpack a time code from one TV60 encoded u32 value and the …\n“Green” location on the CIE XY chromaticity diagram.\nChoose whether to compress samples linearly or not, based …\nHours 0 - 23 are valid.\nThe byte count this string would occupy if it were encoded …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn <code>Ok(Text)</code> if this attribute is a text.\nThe exr name string of the type that an attribute can have.\nWhether to also store smaller versions of the image.\nThe channels in this list.\nReturns the maximum coordinate that a value in this …\nThe bottom right corner location of the rectangle …\nThe top left corner location of the rectangle (inclusive)\nMinutes 0 - 59 are valid.\nOne of “R”, “G”, or “B” most of the time.\nCreate a new channel with the specified properties and a …\nCreate a box with a size and an origin point.\nDoes not validate channel order.\nCreate a new channel with the specified properties and a …\nCreate a <code>Text</code> from an <code>str</code> reference. Returns <code>None</code> if this …\nCreate a <code>Text</code> from an <code>str</code> reference. Panics if this string …\nThe byte count this string would occupy if it were encoded …\nPack the SMPTE time code into a u32 value, according to …\nPack the SMPTE time code into a u32 value, according to …\nPack the SMPTE time code into a u32 value, according to …\nPack the user data <code>u8</code> array into one u32. User data values …\nReturn a <code>BlockType</code> object from the specified attribute …\nSpecifies the perforation offset.\nSpecifies the perforation count of each single film.\nSpecifies the perforation count of each single frame.\nAn array with a length of 4 × width × height. The pixels …\nThe top left corner of this rectangle. The <code>Box2I32</code> …\nThe top left corner of this rectangle. The <code>Box2I32</code> …\nThe top left corner of this rectangle. The <code>Box2I32</code> …\nThis attribute only tells lossy compression methods …\nRead the attribute without validating. The result may be <code>Ok</code>…\nRead the value without validating. Returns …\nRead the time code, without validating, extracting from …\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the value without validating.\nRead the length of a string and then the contents with …\nRead a string until the null-terminator is found. Then …\nRead the contents with that length.\nAllows any text length since it is only used for attribute …\n“Red” location on the CIE XY chromaticity diagram.\nWhether to round up or down when calculating Mip/Rip …\nU32, F16 or F32.\nHow many of the samples are skipped compared to the other …\nSeconds 0 - 59 are valid.\nHow many pixels to include in this <code>Box2I32</code>. Extends to the …\nHow many pixels to include in this <code>Box2I32</code>. Extends to the …\nHow many pixels to include in this <code>Box2I32</code>. Extends to the …\nThe dimensions of the preview image.\nThe count of pixels this channel contains, respecting …\nThe resolution pf this channel, respecting subsampling.\nThe size of each tile. Stays the same number of pixels …\nReturn <code>Ok(Chromaticities)</code> if this attribute is a …\nReturn <code>Ok(f32)</code> if this attribute is an f32.\nReturn <code>Ok(i32)</code> if this attribute is an i32.\nReturn <code>Ok(Text)</code> if this attribute is a text.\nReturns the raw attribute text value this type is …\nReturn <code>Ok(TimeCode)</code> if this attribute is a time code.\nContains string literals identifying the type of an …\nThe sample type of all channels, if all channels have the …\nValidate this attribute.\nValidate this instance.\nCheck whether this string is valid, adjusting <code>long_names</code> …\nReturns an error if this time code is considered invalid.\nValidate this instance.\nCheck if channels are valid and sorted.\nValidate this instance.\nValidate this instance.\nValidate this instance.\nCheck whether some bytes are valid, adjusting <code>long_names</code> …\n“White” location on the CIE XY chromaticity diagram.\nCreate a new rectangle which is offset by the specified …\nWithout validation, write this attribute to the byte …\nWithout validation, write this instance to the byte stream.\nWrite this time code to the byte stream, encoded as TV60 …\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWithout validation, write this instance to the byte stream.\nWrite the length of a string and then the contents with …\nWrite the string contents and a null-terminator.\nWrite the string contents and a null-terminator.\nWithout validation, write this instance to the byte stream.\nAllows any text length since it is only used for attribute …\nCreate a box with no size located at (0,0).\nThe value, stored in little-endian byte order, of the …\nThe name of the type this attribute is an instance of.\nType attribute text value of deep scan lines\nType attribute text value of deep tiles\nType attribute text value of flat scan lines\nType attribute text value of flat tiles\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nThe byte-string name of this attribute type as it appears …\nDescribes a single layer in a file. A file can have any …\nIncludes mandatory fields like pixel aspect or display …\nDoes not include the attributes required for reading the …\nThe adopted neutral of the colors. Specifies the CIE (x,y) …\nGeographical image location.\nCamera aperture measured in f-stops. Equals the focal …\nDescribes how the pixels of this layer are divided into …\nIterate over all tile indices in this header in …\nThe date of image creation, in <code>YYYY:MM:DD hh:mm:ss</code> format.\nList of channels in this layer.\nThe chromaticities attribute of the image. See the …\nNumber of chunks, that is, scan line blocks or tiles, that …\nAdditional textual information.\nHow the pixel data of all channels in this layer is …\nThe rectangle describing the bounding box of this layer …\nWhether this layer contains deep data.\nThis library supports only deep data version 1.\nSpecifies whether the pixels in a deep image are sorted …\nThe rectangle anywhere in the global infinite 2D space …\nIterate over all blocks, in the order specified by the …\nIf this is an environment map, specifies how to interpret …\nExposure time in seconds.\nThe far clip plane of the virtual camera projection.\nIdentifies film manufacturer, film type, film roll and …\nCamera focus in meters.\nFrames per second if this is a frame in a sequence.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalculate the pixel index rectangle inside this header. Is …\nReturn the tile index, converting scan line block …\nCalculate the position of a block in the global infinite …\nComputes the absolute tile coordinate data indices, which …\nThe horizontal density, in pixels per inch. The image’s …\nThe field of view angle, along the horizontal axis, in …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIso-speed of the camera sensor.\nGeographical image location.\nThe name of this layer. Required if this file contains …\nThe top left corner of the rectangle that positions this …\nThe resolution of this layer. Equivalent to the size of …\nIn what order the tiles of this header occur in the file.\nGeographical image location.\nName of the color transform function that computes the …\nMaximum byte length of an uncompressed or compressed …\nThe default pixel resolution of a single block (tile or …\nApproximates the maximum number of bytes that the pixels …\nMaximum number of samples in a single pixel in a deep …\nSpecifies the view names for multi-view, for example …\nCreate default layer attributes with a data position of …\nThe near clip plane of the virtual camera projection.\nCreate a new Header with the specified name, display …\nSet the display position and size of this image.\nIf the image was cropped, contains the original data …\nContains custom attributes. Does not contain the …\nContains custom attributes. Does not contain the …\nDoes not include the attributes required for reading the …\nName of the owner.\nAspect ratio of each pixel in this header.\nAn 8-bit rgba image representing the rendered image.\nRead the value without validating.\nRead the headers without validating them.\nName of the color transform function that is applied for …\nPart of the perspective projection. Default should be …\nPart of the perspective projection. Default should be <code>1</code>.\nIncludes mandatory fields like pixel aspect or display …\nThe name of the software that produced this image.\nCollection of required attribute names.\nThe time code of the image.\nReturns the number of bytes that the pixels of this header …\nTime offset from UTC.\nValidate this instance.\nThe field of view angle, along the horizontal axis, in …\nName of the view, which is typically either <code>&quot;right&quot;</code> or …\nThe white luminance of the colors. Defines the luminance …\nSet <strong>all</strong> attributes of the header that are not shared with …\nSet all common camera projection attributes at once.\nSet the display window, that is, the global clipping …\nSet compression, tiling, and line order. Automatically …\nSet the offset of this layer.\nSet the data position of this layer.\nSet <strong>all</strong> attributes of the header that are shared with all …\nSet the display position to zero and use the specified …\nThe matrix that transforms 3D points from the world to the …\nThe matrix that transforms 3D points from the world to the …\nSpecifies how texture map images are extrapolated. Values …\nWithout validation, write this instance to the byte stream.\nWithout validation, write the headers to the byte stream.\nThe byte-string name of this required attribute as it …\nA list containing all reserved names.\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe byte-string name of this required attribute as it …\nThe first four bytes of each exr file.\nConsumes four bytes from the reader and returns whether …\nValidate this image. If it is an exr file, return <code>Ok(())</code>.\nWithout validation, write this instance to the byte stream.\nNumber of bytes this would consume in an exr file.\nPeeks the next byte. If it is zero, consumes the byte and …\nWithout validation, write this instance to the byte stream.\nApproximate number of [<code>f16</code>] significant digits in base 10\n[<code>f16</code>] Euler’s number (ℯ)\n[<code>f16</code>] machine epsilon value\n[<code>f16</code>] 1/π\n[<code>f16</code>] 1/√2\n[<code>f16</code>] 2/π\n[<code>f16</code>] 2/√π\n[<code>f16</code>] π/2\n[<code>f16</code>] π/3\n[<code>f16</code>] π/4\n[<code>f16</code>] π/6\n[<code>f16</code>] π/8\n[<code>f16</code>] positive Infinity (+∞)\n[<code>f16</code>] 𝗅𝗇 10\n[<code>f16</code>] 𝗅𝗇 2\n[<code>f16</code>] 𝗅𝗈𝗀₁₀2\n[<code>f16</code>] 𝗅𝗈𝗀₁₀ℯ\n[<code>f16</code>] 𝗅𝗈𝗀₂10\n[<code>f16</code>] 𝗅𝗈𝗀₂ℯ\nNumber of [<code>f16</code>] significant digits in base 2\nLargest finite [<code>f16</code>] value\nMaximum possible [<code>f16</code>] power of 10 exponent\nMaximum possible [<code>f16</code>] power of 2 exponent\nMaximum subnormal [<code>f16</code>] value\nSmallest finite [<code>f16</code>] value\nMinimum possible normal [<code>f16</code>] power of 10 exponent\nOne greater than the minimum possible normal [<code>f16</code>] power …\nSmallest positive normal [<code>f16</code>] value\nMinimum positive subnormal [<code>f16</code>] value\n[<code>f16</code>] Not a Number (NaN)\n[<code>f16</code>] negative infinity (-∞)\n[<code>f16</code>] -1\n[<code>f16</code>] -0\n[<code>f16</code>] 1\n[<code>f16</code>] Archimedes’ constant (π)\nThe radix or base of the internal representation of [<code>f16</code>]\n[<code>f16</code>] √2\nA <code>Vec</code>-like container that can store a small number of …\n[<code>f16</code>] 0\nMoves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> …\nReturns a raw mutable pointer to the vector’s buffer.\nExtracts a mutable slice of the entire vector.\nReturns a raw pointer to the vector’s buffer.\nExtracts a slice containing the entire vector.\nThe number of items the vector can hold without …\nRestrict a value to a certain interval unless it is NaN.\nReturns the floating point category of the number.\nRemove all elements from the vector.\nReturns a number composed of the magnitude of <code>self</code> and the …\nRemoves consecutive duplicate elements.\nRemoves consecutive duplicate elements using the given …\nRemoves consecutive elements that map to the same key.\nCreates a draining iterator that removes the specified …\nCopy elements from a slice and append them to the vector.\nA 16-bit floating point type implementing the IEEE …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a floating point value from its representation as …\nConstructs a 16-bit floating point value from the raw bits.\nConstructs a new <code>SmallVec</code> on the stack from an <code>A</code> without …\nConstructs a new <code>SmallVec</code> on the stack from an <code>A</code> without …\nConstructs a new <code>SmallVec</code> on the stack from an <code>A</code> without …\nThe array passed as an argument is moved to be an inline …\nConstructs a new <code>SmallVec</code> on the stack from an array …\nCreates a <code>SmallVec</code> with <code>n</code> copies of <code>elem</code>.\nConstructs a 16-bit floating point value from a 32-bit …\nConstructs a 16-bit floating point value from a 32-bit …\nConstructs a 16-bit floating point value from a 64-bit …\nConstructs a 16-bit floating point value from a 64-bit …\nCreates a floating point value from its representation as …\nCreates a floating point value from its representation as …\nCreates a <code>SmallVec</code> directly from the raw components of …\nCopy the elements from a slice into a new <code>SmallVec</code>.\nConstruct a new <code>SmallVec</code> from a <code>Vec&lt;A::Item&gt;</code>.\nRe-allocate to set the capacity to …\nThe maximum number of elements this vector can hold inline\nInsert an element at position <code>index</code>, shifting all elements …\nCopy elements from a slice into the vector at position …\nInsert multiple elements at position <code>index</code>, shifting all …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts a <code>SmallVec</code> into a <code>Box&lt;[T]&gt;</code> without reallocating …\nConvert the <code>SmallVec</code> into an <code>A</code> if possible. Otherwise …\nConvert a <code>SmallVec</code> to a <code>Vec</code>, without reallocating if the …\nReturns <code>true</code> if the vector is empty\nReturns <code>true</code> if this number is neither infinite nor <code>NaN</code>.\nReturns <code>true</code> if this value is ±∞ and <code>false</code>. otherwise.\nReturns <code>true</code> if this value is <code>NaN</code> and <code>false</code> otherwise.\nReturns <code>true</code> if the number is neither zero, infinite, …\nReturns <code>true</code> if and only if <code>self</code> has a negative sign, …\nReturns <code>true</code> if and only if <code>self</code> has a positive sign, …\nThe number of elements stored in the vector\nReturns the maximum of the two numbers.\nReturns the minimum of the two numbers.\nConstruct an empty vector\nConstruct an empty vector.\nRemove an item from the end of the vector and return it, …\nAppend an item to the vector.\nRemove and return the element at position <code>index</code>, shifting …\nReserve capacity for <code>additional</code> more elements to be …\nReserve the minimum capacity for <code>additional</code> more elements …\nResizes the vector so that its length is equal to <code>len</code>.\nResizes the <code>SmallVec</code> in-place so that <code>len</code> is equal to …\nRetains only the elements specified by the predicate.\nRetains only the elements specified by the predicate.\nSets the length of a vector.\nShrink the capacity of the vector as much as possible.\nReturns a number that represents the sign of <code>self</code>.\nReturns <code>true</code> if the data has spilled into a separate …\nRemove the element at position <code>index</code>, replacing it with …\nReturns the memory representation of the underlying bit …\nConverts a [<code>f16</code>] into the underlying bit representation.\nConverts a [<code>f16</code>] value into a <code>f32</code> value.\nConverts a [<code>f16</code>] value into a <code>f32</code> value.\nConverts a [<code>f16</code>] value into a <code>f64</code> value.\nConverts a [<code>f16</code>] value into a <code>f64</code> value.\nReturns the memory representation of the underlying bit …\nReturns the memory representation of the underlying bit …\nReturns the ordering between <code>self</code> and <code>other</code>.\nImport this specifically if you want to be explicit but …\nShorten the vector, keeping the first <code>len</code> elements and …\nRe-allocate to set the capacity to …\nReserve capacity for <code>additional</code> more elements to be …\nReserve the minimum capacity for <code>additional</code> more elements …\nConstruct an empty vector with enough capacity …")