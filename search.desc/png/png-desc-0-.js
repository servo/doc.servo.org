searchState.loadedDescShard("png", 0, "PNG encoder and decoder\nFor images requiring preservation of absolute colorimetry, …\nThe <code>Adam7</code> algorithm derives its name from doing 7 passes …\nDescribes which stage of the Adam7 algorithm applies to a …\nAdaptive filtering tries every possible filter for each …\nAnimation control information\nClear buffer with the background color.\nHigher compression level\nBit depth of the PNG file. Specifies the number of bits …\nHow pixels are written into the buffer.\nDescribes how a pixel is encoded.\nThe type and strength of applied compression.\nDecoder configuration options\nResult of the decoding process\nPNG Decoder\nAny kind of error during PNG decoding.\nDefault level\nHow to reset buffer of an animated png (APNG) at the end …\nPNG Encoder.\nFast minimal compression\nThe byte level filter applied to scanlines to prepare them …\nThe input image was not a valid PNG.\nFrame control information\n1 grayscale sample.\n1 grayscale sample, then 1 alpha sample.\nDecoded raw image data.\nThe last of a consecutive chunk of IDAT was done. This is …\n1 sample for the palette index.\nPNG info struct\nDescribes which interlacing algorithm applies to a decoded …\nA row of data with interlace information attached.\nAn error in IO of the underlying reader.\nLimits on the resources the <code>Decoder</code> is allowed too use\nThe image would have required exceeding the limits …\nLeave the buffer unchanged.\nNothing decoded yet\nThe <code>null</code> method means no interlacing.\nOutput info.\nThe new pixels are blended into the current state based on …\nAn interface was used incorrectly.\nFor images preferring good adaptation to the output device …\nPixel dimensions information\nReset the buffer to the state before the current frame.\nPNG reader (mostly high-level interface)\nFor images requiring colour appearance matching (relative …\n1 red sample, 1 green sample, 1 blue sample.\n1 red sample, 1 green sample, 1 blue sample, and finally, …\nFor images preferring preservation of saturation at the …\nAn unsigned integer scaled version of a floating point …\nPixels overwrite the value at their position.\nChromaticities of the color space primaries\nThe rendering intent for an sRGB image.\nStreaming PNG writer\nPNG StreamingDecoder (low-level interface)\nOutput transformations\nPhysical unit of the pixel dimensions\nPNG writer\nUtility functions related to handling of the Adam7 …\nThe total number of animation frames, that is equivalent …\nThe chosen output bit depth.\nType of frame area rendering for this frame\nmaximum number of bytes the decoder is allowed to …\nThe contents of the image’s <code>cHRM</code> chunk, if present. …\nChunk types and functions\nHow colors are stored in the image.\nThe chosen output color type.\nCommon types shared between the encoder and decoder\nzTXt field\nThe animation chunk sequence number.\nIndex in <code>data_stream</code> where the current row starts.\nVec containing the uncompressed image data currently being …\nFrame delay fraction denominator\nFrame delay fraction numerator\nType of frame area disposal to be done after rendering …\nCopies pixels from <code>interlaced_row</code> into the right location …\nNumber of frame control chunks read. By the APNG …\nThe contents of the image’s gAMA chunk, if present. …\nWhether we have already seen an iCCP chunk. Used to …\nWhether we have already seen a start of an IDAT chunk.  …\nHeight of the following frame\nThe pixel height of this frame.\nThe ICC profile for the image.\nA flag to note when the IEND chunk was already added. This …\nThe total number of image frames, counting all consecutive …\nAmount of data already written\nThe inflater state handling consecutive <code>IDAT</code> and <code>fdAT</code> …\nThe complete image info read from all prior chunks.\nThe local version of the <code>Info</code> struct.\nlength of the current scanline\nThe byte count of each scan line in the image.\nNumber of frames\nNumber of times to loop this APNG.  0 indicates infinite …\nGlobal encoding options.\nThe image’s <code>PLTE</code> chunk, if present; contains the RGB …\nIndex in <code>data_stream</code> where the previous row starts.\nWhether we are ready for a start of an <code>fdAT</code> chunk …\nWhether we are ready for a start of an <code>IDAT</code> chunk …\nThis buffer is only used so that <code>next_row</code> and …\nSequence number of the animation chunk, starting from 0\nChromaticities of the source system. Set by both <code>cHRM</code> as …\nGamma of the source system. Set by both <code>gAMA</code> as well as to …\nThe rendering intent of an SRGB image.\nText chunks (tEXt/zTXt/iTXt) structs and functions\nsize of the frame (width * height * sample_size)\nOutput transformations\nOutput transformations\nFunction that can transform decompressed, unfiltered rows …\nThe image’s <code>tRNS</code> chunk, if present; contains the alpha …\ntEXt field\nEither <em>Meter</em> or <em>Unspecified</em>\niTXt field\nThe underlying writer.\nWidth of the following frame\nThe pixel width of this frame.\nThe option here is needed in order to access the inner …\nX position at which to render the following frame\nPixels per unit, X axis\nY position at which to render the following frame\nPixels per unit, Y axis\nDescribes which stage of the Adam7 algorithm applies to a …\nThis iterator iterates over the different passes of an …\nGiven <code>row_stride</code>, interlace <code>info</code>, and bits-per-pixel, …\nCopies pixels from <code>interlaced_row</code> into the right location …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalculates the bounds of the current pass\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new <code>Adam7Info</code>.  May panic if the arguments are …\nImage data\nImage trailer\nImage header\nPalette\nAnimation control\nBackground colour\nSource system’s pixel chromaticities\nFrame control\nFrame data\nReturns the argument unchanged.\nSource system’s gamma value\nICC profile chunk\nUTF-8 textual data\nCalls <code>U::from(self)</code>.\nReturns true if the chunk is critical.\nReturns true if the chunk is private.\nPhysical pixel dimensions\nChecks whether the reserved bit of the chunk name is set. …\nsRGB color space chunk\nReturns true if the chunk is safe to copy if unknown.\nLatin-1 uncompressed textual data\nImage last-modification time\nTransparency\nLatin-1 compressed textual data\nExpand paletted images to include an alpha channel. …\nFor images requiring preservation of absolute colorimetry, …\nAnimation control information\nClear buffer with the background color.\nHigher compression level\nBit depth of the PNG file. Specifies the number of bits …\nHow pixels are written into the buffer.\nInternal count of bytes per pixel. This is used for …\nDescribes how a pixel is encoded.\nThe type and strength of applied compression.\nDefault level\nHow to reset buffer of an animated png (APNG) at the end …\nExpand paletted images to RGB; expand grayscale images of …\nFast minimal compression\nFrame control information\n1 grayscale sample.\n1 grayscale sample, then 1 alpha sample.\nNo transformation\nA provided buffer must be have the exact size to hold the …\n1 sample for the palette index.\nPNG info struct\nLeave the buffer unchanged.\nThe new pixels are blended into the current state based on …\nFor images preferring good adaptation to the output device …\nPixel dimensions information\nA bit like return <code>None</code> from an iterator. We use it to …\nReset the buffer to the state before the current frame.\nFor images requiring colour appearance matching (relative …\n1 red sample, 1 green sample, 1 blue sample.\n1 red sample, 1 green sample, 1 blue sample, and finally, …\nStrip 16-bit samples to 8 bits\nFor images preferring preservation of saturation at the …\nAn unsigned integer scaled version of a floating point …\nPixels overwrite the value at their position.\nChromaticities of the color space primaries\nThe rendering intent for an sRGB image.\nOutput transformations\nPhysical unit of the pixel dimensions\nReturns the set containing all flags.\nReturns the frame control information of the image.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the number of bits per pixel.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nType of frame area rendering for this frame\nReturn the number of bytes for this pixel used in …\nReturns the number of bytes per pixel.\nThe contents of the image’s <code>cHRM</code> chunk, if present. …\nHow colors are stored in the image.\nReturns the complement of this set of flags.\nzTXt field\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nFrame delay fraction denominator\nFrame delay fraction numerator\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nType of frame area disposal to be done after rendering …\nReturns an empty set of flags.\nEncode this header to the writer.\nGets whether the value can be exactly converted in …\nReturns the frame control information of the current frame\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nFully accurate construction from a value scaled as per …\nu8 -&gt; Self. Temporary solution until Rust provides a …\nu8 -&gt; Self. Temporary solution until Rust provides a …\nu8 -&gt; Self. Temporary solution until Rust provides a …\nu8 -&gt; Self. Using enum_primitive or transmute is probably …\nu8 -&gt; Self. Using enum_primitive or transmute is probably …\nThe contents of the image’s gAMA chunk, if present. …\nHeight of the following frame\nThe ICC profile for the image.\nGets whether the value is within the clamped range of this …\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the accurate encoded value.\nGet the unscaled value as a floating point.\nReturns <code>true</code> if all flags are currently set.\nReturns true if the image is an APNG image.\nReturns <code>true</code> if no flags are currently stored.\nSlightly inaccurate scaling and quantization. Clamps the …\nTransform every input to 8bit grayscale or color.\nReturns the complement of this set of flags.\nNumber of frames\nNumber of times to loop this APNG.  0 indicates infinite …\nThe image’s <code>PLTE</code> chunk, if present; contains the RGB …\nReturns the number of bytes needed for one deinterlaced …\nReturns the number of bytes needed for one deinterlaced …\nReturns the number of bytes needed for one deinterlaced …\nRemoves the specified flags in-place.\nReturns the number of samples used per pixel encoded in …\nSequence number of the animation chunk, starting from 0\nInserts or removes the specified flags depending on the …\nSize of the image, width then height.\nChromaticities of the source system. Set by both <code>cHRM</code> as …\nGamma of the source system. Set by both <code>gAMA</code> as well as to …\nThe rendering intent of an SRGB image.\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nThe image’s <code>tRNS</code> chunk, if present; contains the alpha …\ntEXt field\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nEither <em>Meter</em> or <em>Unspecified</em>\niTXt field\nWidth of the following frame\nA utility constructor for a default info with width and …\nX position at which to render the following frame\nPixels per unit, X axis\nY position at which to render the following frame\nPixels per unit, Y axis\nPNG Decoder\nThe past-the-end index.\nThe initial frame in an IDAT chunk without fcTL chunk …\nA row of data with interlace information attached.\nLimits on the resources the <code>Decoder</code> is allowed too use\nOutput info.\nPNG reader (mostly high-level interface)\nA row of data without interlace information.\nAn IDAT frame with fcTL or an fdAT frame.\nDenote a frame as given by sequence numbers.\nThe subframe specific information.\nThe chosen output bit depth.\nReturns the size needed to hold a decoded frame If the …\nmaximum number of bytes the decoder is allowed to …\nThe chosen output color type.\nIndex in <code>data_stream</code> where the current row starts.\nVec containing the uncompressed image data currently being …\nReturns the next decoded chunk. If the chunk is an …\nNumber of frame control chunks read. By the APNG …\nRead the rest of the image and chunks and finish up, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe pixel height of this frame.\nSet the decoder to ignore and not verify the Adler-32 …\nGet information on the image.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe byte count of each scan line in the image.\nCreate a new decoder configuration with default limits.\nCreate a new decoder configuration with custom limits.\nCreate a new decoder configuration with custom …\nDecodes the next frame into <code>buf</code>.\nReturns the next processed row of the image\nFetch the next interlaced row and filter it according to …\nWrite the next raw interlaced row into <code>self.prev</code>.\nReturns the next processed row of the image\nReturns the number of bytes required to hold a …\nReturns the color type and the number of bits per sample …\nReturns the number of bytes required to hold a …\nIndex in <code>data_stream</code> where the previous row starts.\nRead the PNG header and return the information contained …\nReads all meta data until the first IDAT chunk\nReads all meta data until the next frame data starts. …\nThis buffer is only used so that <code>next_row</code> and …\nSet the decoder to ignore iccp chunks while parsing.\nSet the decoder to ignore all text chunks while parsing.\nLimit resource usage.\nSet the allowed and performed transformations.\nTransforming a decompressed, unfiltered row into the final …\nOutput transformations\nOutput transformations\nFunction that can transform decompressed, unfiltered rows …\nThe pixel width of this frame.\nThe <code>Adam7</code> algorithm derives its name from doing 7 passes …\nDescribes which interlacing algorithm applies to a decoded …\nThe <code>null</code> method means no interlacing.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n4.3., some chunks must be before IDAT.\n4.3., some chunks must be before PLTE.\nSpecifically for fdat there is an embedded sequence number …\nSequence number from an <code>fdAT</code> chunk - see …\nThe subframe is not in bounds of the image. TODO: fields …\nBad text encoding\nDetermines if checksum checks should be disabled globally.\nTODO check if these size are reasonable\n4.3., Must be first.\nFailure to parse a chunk, because the chunk didn’t …\nThe compression of the data stream was faulty.\nChunk checksum - see …\nBad framing.\nDecoder configuration options\nResult of the decoding process\nAny kind of error during PNG decoding.\n4.3., some chunks must be unique.\nfdAT shorter than 4 bytes\nThe input image was not a valid PNG.\nIn this state we are reading image data from external …\nDecoded raw image data.\nThe last of a consecutive chunk of IDAT was done. This is …\nThe color-depth combination is not valid according to …\nThe image width or height is zero.\nNot a PNG, the magic signature is missing.\nThe rendering intent of the sRGB chunk is invalid.\nAn error in IO of the underlying reader.\nChunk length - see …\nThe image would have required exceeding the limits …\nFctl must occur if an animated chunk occurs.\nIhdr must occur.\nImage data that was indicated in IHDR or acTL is missing.\nThe image data chunk was too short for the expected pixel …\nNothing decoded yet\n4.3., some chunks must be between PLTE and IDAT.\nA palletized image did not have a palette.\nAn interface was used incorrectly.\nIn this state we check if all chunk data has been already …\nIn this state we are reading chunk data from external …\nThe palette did not even contain a single pixel data.\nFirst 4 bytes of the PNG signature - see …\nSecond 4 bytes of the PNG signature - see …\nPNG StreamingDecoder (low-level interface)\nChunk type - see …\nIn this state we are reading a u32 value from external …\nKind of <code>u32</code> value that is being read via <code>State::U32</code>.\n“11.2.4 IDAT Image data” section of the PNG spec says: …\nPartial crc until now.\nThe animation chunk sequence number.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether we have already seen an iCCP chunk. Used to …\nWhether we have already seen a start of an IDAT chunk.  …\nReturn whether the decoder is set to ignore the Adler-32 …\nThe inflater state handling consecutive <code>IDAT</code> and <code>fdAT</code> …\nProvides access to the inner <code>info</code> field\nThe complete image info read from all prior chunks.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a new StreamingDecoder\nNon-decoded bytes in the chunk.\nWhether we are ready for a start of an <code>fdAT</code> chunk …\nWhether we are ready for a start of an <code>IDAT</code> chunk …\nRemaining bytes to be read.\nResets the StreamingDecoder\nSet whether to compute and verify the Adler-32 checksum …\nWhen set, the decoder will not compute and verify the …\nFlag to ignore computing and verifying the Adler-32 …\nSet whether to compute and verify the Adler-32 checksum …\nWhen set, the decoder will not compute and verify the CRC …\nIgnore ICCP chunks while decoding.\nIgnore text chunks while decoding.\nIgnore ancillary chunks if CRC fails\nIgnore ancillary chunks if CRC fails\nThe type of the current chunk. Relevant for <code>IDAT</code> and <code>fdAT</code> …\nLow level StreamingDecoder interface.\nThe chunk type that has the CRC mismatch.\nCalculated CRC32 sum\nStored CRC32 value\nThe one that should have been present.\nThe sequence number in the chunk.\nType of a function that can transform a decompressed, …\nReturns a transformation function that should be applied …\nHelpers for taking a slice of indices (indices into <code>PLTE</code> …\nErgonomics wrapper around <code>miniz_oxide::inflate::stream</code> for …\nFill the decoded buffer as far as possible from <code>data</code>. On …\nCalled after all consecutive IDAT chunks were handled.\nReturns the argument unchanged.\nReturn the <code>ignore_adler32</code> flag.\nIgnore and do not calculate the Adler-32 checksum. …\nCalls <code>U::from(self)</code>.\nLimit on how many bytes can be decompressed in total.  …\nRemaining buffered decoded bytes. The decoder sometimes …\nThe first index of <code>out_buffer</code> where new data can be …\nResize the vector to allow allocation of more data.\nThe first index of <code>out_buffer</code> that hasn’t yet been …\nSet the <code>ignore_adler32</code> flag and return <code>true</code> if the flag was\nIf there has been a call to decompress already.\nCurrent decoding state.\nThis writer is used between the actual writer and the …\nPNG Encoder.\nContains the error value\nThis is used in-between, should never be matched\nContains the success value\nDecoding options, internal type, forwarded to the Writer.\nContains the subset of attributes of Info needed for Writer…\nStreaming PNG writer\nThis enum is used to be allow the <code>StreamWriter</code> to keep its …\nPNG writer\nConvenience function to add iTXt chunks to <code>Info</code> struct\nConvenience function to add tEXt chunks to <code>Info</code> struct\nConvenience function to add zTXt chunks to <code>Info</code> struct\nThe total number of animation frames, that is equivalent …\nConsume the stream writer with validation.\nConsume the stream writer with validation.\nFlushes the current chunk\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA flag to note when the IEND chunk was already added. This …\nThe total number of image frames, counting all consecutive …\nkeeps track of where the last byte was written\nAmount of data already written\nThe local version of the <code>Info</code> struct.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurn this into a stream writer for image data.\nTurn this into a stream writer with custom buffer size.\nlength of the current scanline\nFlushes the buffered chunk, checks if it was the last …\nReturns the size of each scanline for the next frame …\nGlobal encoding options.\nSet the frame dimension to occupy all the image, starting …\nSet the frame dimension to occupy all the image, starting …\nSet the frame position to (0, 0).\nSet the frame position to (0, 0).\nSet the adaptive filter type.\nSet the adaptive filter type for the following frames.\nSet the adaptive filter type for the next frame.\nSpecify that the image is animated.\nSet the blend operation for every frame.\nSet the blend operation for the following frames.\nSet the blend operation for the following frames.\nSet the color of the encoded image.\nSet compression parameters.\nSet the indicated depth of the image data.\nSet the dispose operation for every frame.\nSet the dispose operation for the following frames.\nSet the dispose operation for the following frames.\nSet the <code>FrameControl</code> for the following frame\nSet the used filter type.\nSet the used filter type for the following frames.\nSet the used filter type for the next frame.\nSet the fraction of time every frame is going to be …\nSet the fraction of time the following frames are going to …\nSet the fraction of time the following frames are going to …\nSet the dimension of the following frames.\nSet the dimension of the following frames.\nSet the position of the following frames.\nSet the position of the following frames.\nSets the raw byte contents of the PLTE chunk. This method …\nMark the first animated frame as a ‘separate default …\nSet the chromaticities for the source system’s display …\nSet the display gamma of the source system on which the …\nMark the image data as conforming to the SRGB color space …\nSets the raw byte contents of the tRNS chunk. This method …\nCreate a stream writer.\nCreate a stream writer with custom buffer size.\nLike <code>Option::take</code> this returns the <code>Wrapper</code> contained in …\nConverts this partial info to an owned Info struct, …\nsize of the frame (width * height * sample_size)\nCheck if we should allow writing another image.\nValidate the written image sequence.\nThe underlying writer.\nWrite a raw chunk of PNG data.\nStart encoding by writing the header data.\nNOTE: this bypasses the internal buffer so the flush …\nWrites the next image data.\nThe option here is needed in order to access the inner …\nAdaptive filtering tries every possible filter for each …\nThe byte level filter applied to scanlines to prepare them …\nReturns the argument unchanged.\nReturns the argument unchanged.\nu8 -&gt; Self. Temporary solution until Rust provides a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the chromaticities that should be substituted for …\nGet the gamma that should be substituted for images …\nCompressed version of text field. Can be at most 2GB.\nError encountered while compressing text\nDefault decompression limit for compressed text chunks.\nA generalized text chunk trait\nStruct encoding an iTXt chunk\nCompressed text cannot be uncompressed\nUsing a byte that is not 0 or 255 as compression flag in …\nUsing an unspecified value for the compression method\nKeyword longer than 79 bytes or empty\nKeyword longer than 79 bytes or empty\nMissing the compression flag\nMissing null separator\nPrivate enum encoding the compressed and uncompressed …\nNeeds more space to decompress\nStruct representing a tEXt chunk\nText decoding error that is wrapped by the standard …\nText encoding errors that is wrapped by the standard …\nUncompressed text field.\nUnrepresentable characters in string\nUnrepresentable characters in string\nStruct representing a zTXt chunk\nCompresses the inner text, mutating its own state.\nCompresses the inner text, mutating its own state.\nIndicates whether the text will be (or was) compressed in …\nDecodes a slice of bytes to a String using Latin-1 …\nDecompresses the inner text, mutating its own state. Can …\nDecompresses the inner text, mutating its own state. Can …\nDecompresses the inner text, mutating its own state. Can …\nDecompresses the inner text, mutating its own state. Can …\nEncode text chunk as <code>Vec&lt;u8&gt;</code> to a <code>Write</code>\nEncodes TEXtChunk to a Writer. The keyword and text are …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDecompresses the inner text, and returns it as a <code>String</code>. …\nDecompresses the inner text, and returns it as a <code>String</code>. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKeyword field of the tEXt chunk. Needs to be between 1-79 …\nKeyword field of the tEXt chunk. Needs to be between 1-79 …\nThe keyword field. This needs to be between 1-79 bytes …\nA hyphen separated list of languages that the keyword is …\nConstructs a new TEXtChunk. Not sure whether it should …\nCreates a new ZTXt chunk.\nConstructs a new iTXt chunk. Leaves all but keyword and …\nText field of tEXt chunk. Can be at most 2GB.\nText field of zTXt chunk. It is compressed by default, but …\nText field of iTXt chunk. It is compressed by default, but …\nTranslated keyword. This is UTF-8 encoded.\nRead extension to read big endian data\nWrite extension to write big endian data\nRead <code>T</code> from a bytes stream. Most significant byte first.\nWrites <code>T</code> to a bytes stream. Most significant byte first.")