searchState.loadedDescShard("bytemuck_derive", 0, "Derive macros for bytemuck traits.\nDerive the <code>AnyBitPattern</code> trait for a struct\nDerive the <code>PartialEq</code> and <code>Eq</code> trait for a type\nDerive the <code>Hash</code> trait for a type\nDerive the <code>CheckedBitPattern</code> trait for a struct or enum.\nDerive the <code>Contiguous</code> trait for an enum\nDerive the <code>NoUninit</code> trait for a struct or enum\nDerive the <code>Pod</code> trait for a struct\nDerive the <code>TransparentWrapper</code> trait for a struct\nDerive the <code>Zeroable</code> trait for a type.\nAdd a trait marker to the generics if it is not already …\nBasic wrapper for error handling\nFind <code>#[name(key = &quot;value&quot;)]</code> helper attributes on the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck that a struct has no padding by asserting that the …\nCheck that all fields implement a given trait\nExtract the <code>Fields</code> off a <code>DeriveInput</code>, or, in the <code>enum</code> …\nget a simple #[foo(bar)] attribute, returning “bar”\nHelper function to get the variant with discriminant zero …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf this trait has a custom meaning for “perfect derive”…")