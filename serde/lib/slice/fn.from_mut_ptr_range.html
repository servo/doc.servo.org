<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Forms a mutable slice from a pointer range."><title>from_mut_ptr_range in serde::lib::slice - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="serde" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../serde/index.html">serde</a><span class="version">1.0.213</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In serde::lib::slice</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="../../index.html">serde</a>::<wbr><a href="../index.html">lib</a>::<wbr><a href="index.html">slice</a>::<wbr><a class="fn" href="#">from_mut_ptr_range</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/slice/raw.rs.html#312">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub const unsafe fn from_mut_ptr_range&lt;'a, T&gt;(
    range: <a class="struct" href="../struct.Range.html" title="struct serde::lib::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.pointer.html">*mut T</a>&gt;,
) -&gt; &amp;'a mut <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.slice.html">[T]</a></code></pre><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>slice_from_ptr_range</code>)</span></div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Forms a mutable slice from a pointer range.</p>
<p>This is the same functionality as <a href="fn.from_ptr_range.html" title="fn serde::lib::slice::from_ptr_range"><code>from_ptr_range</code></a>, except that a
mutable slice is returned.</p>
<p>This function is useful for interacting with foreign interfaces which
use two pointers to refer to a range of elements in memory, as is
common in C++.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>Behavior is undefined if any of the following conditions are violated:</p>
<ul>
<li>
<p>The <code>start</code> pointer of the range must be a <a href="../ptr/index.html#safety" title="mod serde::lib::ptr">valid</a> and properly aligned pointer
to the first element of a slice.</p>
</li>
<li>
<p>The <code>end</code> pointer must be a <a href="../ptr/index.html#safety" title="mod serde::lib::ptr">valid</a> and properly aligned pointer to <em>one past</em>
the last element, such that the offset from the end to the start pointer is
the length of the slice.</p>
</li>
<li>
<p>The entire memory range of this slice must be contained within a single allocated object!
Slices can never span across multiple allocated objects.</p>
</li>
<li>
<p>The range must contain <code>N</code> consecutive properly initialized values of type <code>T</code>.</p>
</li>
<li>
<p>The memory referenced by the returned slice must not be accessed through any other pointer
(not derived from the return value) for the duration of lifetime <code>'a</code>.
Both read and write accesses are forbidden.</p>
</li>
<li>
<p>The total length of the range must be no larger than <code>isize::MAX</code>,
and adding that size to <code>data</code> must not “wrap around” the address space.
See the safety documentation of <a href="https://doc.rust-lang.org/1.80.1/std/primitive.pointer.html#method.offset" title="method pointer::offset"><code>pointer::offset</code></a>.</p>
</li>
</ul>
<p>Note that a range created from <a href="https://doc.rust-lang.org/1.80.1/std/primitive.slice.html#method.as_mut_ptr_range" title="method slice::as_mut_ptr_range"><code>slice::as_mut_ptr_range</code></a> fulfills these requirements.</p>
<h2 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h2>
<p>This function panics if <code>T</code> is a Zero-Sized Type (“ZST”).</p>
<h2 id="caveat"><a class="doc-anchor" href="#caveat">§</a>Caveat</h2>
<p>The lifetime for the returned slice is inferred from its usage. To
prevent accidental misuse, it’s suggested to tie the lifetime to whichever
source lifetime is safe in the context, such as by providing a helper
function taking the lifetime of a host value for the slice, or by explicit
annotation.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(slice_from_ptr_range)]

</span><span class="kw">use </span>core::slice;

<span class="kw">let </span><span class="kw-2">mut </span>x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let </span>range = x.as_mut_ptr_range();

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(slice::from_mut_ptr_range(range), <span class="kw-2">&amp;mut </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
}</code></pre></div>
</div></details></section></div></main></body></html>