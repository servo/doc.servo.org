initSidebarItems({"enum":[["BigEndian","Defines big-endian serialization."],["LittleEndian","Defines little-endian serialization."]],"fn":[["extend_sign",""],["extend_sign128",""],["pack_size",""],["pack_size128",""],["unextend_sign",""],["unextend_sign128",""]],"macro":[["unsafe_read_slice","Copies a &[u8] $src into a &mut [] $dst for the endianness given by $which (must be either to_be or to_le)."],["unsafe_write_num_bytes","Copies $size bytes from a number $n to a &mut [u8] $dst. $ty represents the numeric type of $n and $which must be either to_be or to_le, depending on which endianness one wants to use when writing to $dst."],["unsafe_write_slice_native","Copies a &[$ty] $src into a &mut [u8] $dst, where $ty must be a numeric type. This panics if size_of::<$ty>() * $src.len() != $dst.len()."],["write_slice",""]],"mod":[["io",""],["private",""]],"trait":[["ByteOrder","`ByteOrder` describes types that can serialize integers as bytes."],["ReadBytesExt","Extends `Read` with methods for reading numbers. (For `std::io`.)"],["WriteBytesExt","Extends `Write` with methods for writing numbers. (For `std::io`.)"]],"type":[["BE","A type alias for `BigEndian`."],["LE","A type alias for `LittleEndian`."],["NativeEndian","Defines system native-endian serialization."],["NetworkEndian","Defines network byte order serialization."]]});